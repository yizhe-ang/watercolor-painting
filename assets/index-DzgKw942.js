var g_=Object.defineProperty;var __=(et,_,_e)=>_ in et?g_(et,_,{enumerable:!0,configurable:!0,writable:!0,value:_e}):et[_]=_e;var jn=(et,_,_e)=>__(et,typeof _!="symbol"?_+"":_,_e);function _mergeNamespaces(et,_){for(var _e=0;_e<_.length;_e++){const tt=_[_e];if(typeof tt!="string"&&!Array.isArray(tt)){for(const nt in tt)if(nt!=="default"&&!(nt in et)){const rt=Object.getOwnPropertyDescriptor(tt,nt);rt&&Object.defineProperty(et,nt,rt.get?rt:{enumerable:!0,get:()=>tt[nt]})}}}return Object.freeze(Object.defineProperty(et,Symbol.toStringTag,{value:"Module"}))}(function(){const _=document.createElement("link").relList;if(_&&_.supports&&_.supports("modulepreload"))return;for(const nt of document.querySelectorAll('link[rel="modulepreload"]'))tt(nt);new MutationObserver(nt=>{for(const rt of nt)if(rt.type==="childList")for(const ot of rt.addedNodes)ot.tagName==="LINK"&&ot.rel==="modulepreload"&&tt(ot)}).observe(document,{childList:!0,subtree:!0});function _e(nt){const rt={};return nt.integrity&&(rt.integrity=nt.integrity),nt.referrerPolicy&&(rt.referrerPolicy=nt.referrerPolicy),nt.crossOrigin==="use-credentials"?rt.credentials="include":nt.crossOrigin==="anonymous"?rt.credentials="omit":rt.credentials="same-origin",rt}function tt(nt){if(nt.ep)return;nt.ep=!0;const rt=_e(nt);fetch(nt.href,rt)}})();function getDefaultExportFromCjs(et){return et&&et.__esModule&&Object.prototype.hasOwnProperty.call(et,"default")?et.default:et}function getAugmentedNamespace(et){if(et.__esModule)return et;var _=et.default;if(typeof _=="function"){var _e=function tt(){return this instanceof tt?Reflect.construct(_,arguments,this.constructor):_.apply(this,arguments)};_e.prototype=_.prototype}else _e={};return Object.defineProperty(_e,"__esModule",{value:!0}),Object.keys(et).forEach(function(tt){var nt=Object.getOwnPropertyDescriptor(et,tt);Object.defineProperty(_e,tt,nt.get?nt:{enumerable:!0,get:function(){return et[tt]}})}),_e}var jsxRuntime={exports:{}},reactJsxRuntime_production_min={},react={exports:{}},react_production_min={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var l$3=Symbol.for("react.element"),n$3=Symbol.for("react.portal"),p$6=Symbol.for("react.fragment"),q$3=Symbol.for("react.strict_mode"),r$2=Symbol.for("react.profiler"),t$2=Symbol.for("react.provider"),u$3=Symbol.for("react.context"),v$4=Symbol.for("react.forward_ref"),w$2=Symbol.for("react.suspense"),x$2=Symbol.for("react.memo"),y$3=Symbol.for("react.lazy"),z$2=Symbol.iterator;function A$2(et){return et===null||typeof et!="object"?null:(et=z$2&&et[z$2]||et["@@iterator"],typeof et=="function"?et:null)}var B$2={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C$2=Object.assign,D$2={};function E$2(et,_,_e){this.props=et,this.context=_,this.refs=D$2,this.updater=_e||B$2}E$2.prototype.isReactComponent={};E$2.prototype.setState=function(et,_){if(typeof et!="object"&&typeof et!="function"&&et!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,et,_,"setState")};E$2.prototype.forceUpdate=function(et){this.updater.enqueueForceUpdate(this,et,"forceUpdate")};function F$2(){}F$2.prototype=E$2.prototype;function G$2(et,_,_e){this.props=et,this.context=_,this.refs=D$2,this.updater=_e||B$2}var H$3=G$2.prototype=new F$2;H$3.constructor=G$2;C$2(H$3,E$2.prototype);H$3.isPureReactComponent=!0;var I$4=Array.isArray,J$2=Object.prototype.hasOwnProperty,K$1={current:null},L$3={key:!0,ref:!0,__self:!0,__source:!0};function M$3(et,_,_e){var tt,nt={},rt=null,ot=null;if(_!=null)for(tt in _.ref!==void 0&&(ot=_.ref),_.key!==void 0&&(rt=""+_.key),_)J$2.call(_,tt)&&!L$3.hasOwnProperty(tt)&&(nt[tt]=_[tt]);var at=arguments.length-2;if(at===1)nt.children=_e;else if(1<at){for(var lt=Array(at),ut=0;ut<at;ut++)lt[ut]=arguments[ut+2];nt.children=lt}if(et&&et.defaultProps)for(tt in at=et.defaultProps,at)nt[tt]===void 0&&(nt[tt]=at[tt]);return{$$typeof:l$3,type:et,key:rt,ref:ot,props:nt,_owner:K$1.current}}function N$3(et,_){return{$$typeof:l$3,type:et.type,key:_,ref:et.ref,props:et.props,_owner:et._owner}}function O$2(et){return typeof et=="object"&&et!==null&&et.$$typeof===l$3}function escape$1(et){var _={"=":"=0",":":"=2"};return"$"+et.replace(/[=:]/g,function(_e){return _[_e]})}var P$2=/\/+/g;function Q$2(et,_){return typeof et=="object"&&et!==null&&et.key!=null?escape$1(""+et.key):_.toString(36)}function R$2(et,_,_e,tt,nt){var rt=typeof et;(rt==="undefined"||rt==="boolean")&&(et=null);var ot=!1;if(et===null)ot=!0;else switch(rt){case"string":case"number":ot=!0;break;case"object":switch(et.$$typeof){case l$3:case n$3:ot=!0}}if(ot)return ot=et,nt=nt(ot),et=tt===""?"."+Q$2(ot,0):tt,I$4(nt)?(_e="",et!=null&&(_e=et.replace(P$2,"$&/")+"/"),R$2(nt,_,_e,"",function(ut){return ut})):nt!=null&&(O$2(nt)&&(nt=N$3(nt,_e+(!nt.key||ot&&ot.key===nt.key?"":(""+nt.key).replace(P$2,"$&/")+"/")+et)),_.push(nt)),1;if(ot=0,tt=tt===""?".":tt+":",I$4(et))for(var at=0;at<et.length;at++){rt=et[at];var lt=tt+Q$2(rt,at);ot+=R$2(rt,_,_e,lt,nt)}else if(lt=A$2(et),typeof lt=="function")for(et=lt.call(et),at=0;!(rt=et.next()).done;)rt=rt.value,lt=tt+Q$2(rt,at++),ot+=R$2(rt,_,_e,lt,nt);else if(rt==="object")throw _=String(et),Error("Objects are not valid as a React child (found: "+(_==="[object Object]"?"object with keys {"+Object.keys(et).join(", ")+"}":_)+"). If you meant to render a collection of children, use an array instead.");return ot}function S$4(et,_,_e){if(et==null)return et;var tt=[],nt=0;return R$2(et,tt,"","",function(rt){return _.call(_e,rt,nt++)}),tt}function T$3(et){if(et._status===-1){var _=et._result;_=_(),_.then(function(_e){(et._status===0||et._status===-1)&&(et._status=1,et._result=_e)},function(_e){(et._status===0||et._status===-1)&&(et._status=2,et._result=_e)}),et._status===-1&&(et._status=0,et._result=_)}if(et._status===1)return et._result.default;throw et._result}var U$3={current:null},V$4={transition:null},W$2={ReactCurrentDispatcher:U$3,ReactCurrentBatchConfig:V$4,ReactCurrentOwner:K$1};function X$1(){throw Error("act(...) is not supported in production builds of React.")}react_production_min.Children={map:S$4,forEach:function(et,_,_e){S$4(et,function(){_.apply(this,arguments)},_e)},count:function(et){var _=0;return S$4(et,function(){_++}),_},toArray:function(et){return S$4(et,function(_){return _})||[]},only:function(et){if(!O$2(et))throw Error("React.Children.only expected to receive a single React element child.");return et}};react_production_min.Component=E$2;react_production_min.Fragment=p$6;react_production_min.Profiler=r$2;react_production_min.PureComponent=G$2;react_production_min.StrictMode=q$3;react_production_min.Suspense=w$2;react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W$2;react_production_min.act=X$1;react_production_min.cloneElement=function(et,_,_e){if(et==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+et+".");var tt=C$2({},et.props),nt=et.key,rt=et.ref,ot=et._owner;if(_!=null){if(_.ref!==void 0&&(rt=_.ref,ot=K$1.current),_.key!==void 0&&(nt=""+_.key),et.type&&et.type.defaultProps)var at=et.type.defaultProps;for(lt in _)J$2.call(_,lt)&&!L$3.hasOwnProperty(lt)&&(tt[lt]=_[lt]===void 0&&at!==void 0?at[lt]:_[lt])}var lt=arguments.length-2;if(lt===1)tt.children=_e;else if(1<lt){at=Array(lt);for(var ut=0;ut<lt;ut++)at[ut]=arguments[ut+2];tt.children=at}return{$$typeof:l$3,type:et.type,key:nt,ref:rt,props:tt,_owner:ot}};react_production_min.createContext=function(et){return et={$$typeof:u$3,_currentValue:et,_currentValue2:et,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},et.Provider={$$typeof:t$2,_context:et},et.Consumer=et};react_production_min.createElement=M$3;react_production_min.createFactory=function(et){var _=M$3.bind(null,et);return _.type=et,_};react_production_min.createRef=function(){return{current:null}};react_production_min.forwardRef=function(et){return{$$typeof:v$4,render:et}};react_production_min.isValidElement=O$2;react_production_min.lazy=function(et){return{$$typeof:y$3,_payload:{_status:-1,_result:et},_init:T$3}};react_production_min.memo=function(et,_){return{$$typeof:x$2,type:et,compare:_===void 0?null:_}};react_production_min.startTransition=function(et){var _=V$4.transition;V$4.transition={};try{et()}finally{V$4.transition=_}};react_production_min.unstable_act=X$1;react_production_min.useCallback=function(et,_){return U$3.current.useCallback(et,_)};react_production_min.useContext=function(et){return U$3.current.useContext(et)};react_production_min.useDebugValue=function(){};react_production_min.useDeferredValue=function(et){return U$3.current.useDeferredValue(et)};react_production_min.useEffect=function(et,_){return U$3.current.useEffect(et,_)};react_production_min.useId=function(){return U$3.current.useId()};react_production_min.useImperativeHandle=function(et,_,_e){return U$3.current.useImperativeHandle(et,_,_e)};react_production_min.useInsertionEffect=function(et,_){return U$3.current.useInsertionEffect(et,_)};react_production_min.useLayoutEffect=function(et,_){return U$3.current.useLayoutEffect(et,_)};react_production_min.useMemo=function(et,_){return U$3.current.useMemo(et,_)};react_production_min.useReducer=function(et,_,_e){return U$3.current.useReducer(et,_,_e)};react_production_min.useRef=function(et){return U$3.current.useRef(et)};react_production_min.useState=function(et){return U$3.current.useState(et)};react_production_min.useSyncExternalStore=function(et,_,_e){return U$3.current.useSyncExternalStore(et,_,_e)};react_production_min.useTransition=function(){return U$3.current.useTransition()};react_production_min.version="18.3.1";react.exports=react_production_min;var reactExports=react.exports;const React=getDefaultExportFromCjs(reactExports),React$1=_mergeNamespaces({__proto__:null,default:React},[reactExports]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var f$3=reactExports,k$3=Symbol.for("react.element"),l$2=Symbol.for("react.fragment"),m$4=Object.prototype.hasOwnProperty,n$2=f$3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p$5={key:!0,ref:!0,__self:!0,__source:!0};function q$2(et,_,_e){var tt,nt={},rt=null,ot=null;_e!==void 0&&(rt=""+_e),_.key!==void 0&&(rt=""+_.key),_.ref!==void 0&&(ot=_.ref);for(tt in _)m$4.call(_,tt)&&!p$5.hasOwnProperty(tt)&&(nt[tt]=_[tt]);if(et&&et.defaultProps)for(tt in _=et.defaultProps,_)nt[tt]===void 0&&(nt[tt]=_[tt]);return{$$typeof:k$3,type:et,key:rt,ref:ot,props:nt,_owner:n$2.current}}reactJsxRuntime_production_min.Fragment=l$2;reactJsxRuntime_production_min.jsx=q$2;reactJsxRuntime_production_min.jsxs=q$2;jsxRuntime.exports=reactJsxRuntime_production_min;var jsxRuntimeExports=jsxRuntime.exports,client={},reactDom={exports:{}},reactDom_production_min={},scheduler$2={exports:{}},scheduler_production_min$2={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(et){function _(Lt,zt){var Yt=Lt.length;Lt.push(zt);e:for(;0<Yt;){var en=Yt-1>>>1,bn=Lt[en];if(0<nt(bn,zt))Lt[en]=zt,Lt[Yt]=bn,Yt=en;else break e}}function _e(Lt){return Lt.length===0?null:Lt[0]}function tt(Lt){if(Lt.length===0)return null;var zt=Lt[0],Yt=Lt.pop();if(Yt!==zt){Lt[0]=Yt;e:for(var en=0,bn=Lt.length,Un=bn>>>1;en<Un;){var mn=2*(en+1)-1,vn=Lt[mn],In=mn+1,Cn=Lt[In];if(0>nt(vn,Yt))In<bn&&0>nt(Cn,vn)?(Lt[en]=Cn,Lt[In]=Yt,en=In):(Lt[en]=vn,Lt[mn]=Yt,en=mn);else if(In<bn&&0>nt(Cn,Yt))Lt[en]=Cn,Lt[In]=Yt,en=In;else break e}}return zt}function nt(Lt,zt){var Yt=Lt.sortIndex-zt.sortIndex;return Yt!==0?Yt:Lt.id-zt.id}if(typeof performance=="object"&&typeof performance.now=="function"){var rt=performance;et.unstable_now=function(){return rt.now()}}else{var ot=Date,at=ot.now();et.unstable_now=function(){return ot.now()-at}}var lt=[],ut=[],dt=1,st=null,it=3,ct=!1,ft=!1,ht=!1,mt=typeof setTimeout=="function"?setTimeout:null,pt=typeof clearTimeout=="function"?clearTimeout:null,_t=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function vt(Lt){for(var zt=_e(ut);zt!==null;){if(zt.callback===null)tt(ut);else if(zt.startTime<=Lt)tt(ut),zt.sortIndex=zt.expirationTime,_(lt,zt);else break;zt=_e(ut)}}function bt(Lt){if(ht=!1,vt(Lt),!ft)if(_e(lt)!==null)ft=!0,Ot(wt);else{var zt=_e(ut);zt!==null&&Ut(bt,zt.startTime-Lt)}}function wt(Lt,zt){ft=!1,ht&&(ht=!1,pt(At),At=-1),ct=!0;var Yt=it;try{for(vt(zt),st=_e(lt);st!==null&&(!(st.expirationTime>zt)||Lt&&!Ct());){var en=st.callback;if(typeof en=="function"){st.callback=null,it=st.priorityLevel;var bn=en(st.expirationTime<=zt);zt=et.unstable_now(),typeof bn=="function"?st.callback=bn:st===_e(lt)&&tt(lt),vt(zt)}else tt(lt);st=_e(lt)}if(st!==null)var Un=!0;else{var mn=_e(ut);mn!==null&&Ut(bt,mn.startTime-zt),Un=!1}return Un}finally{st=null,it=Yt,ct=!1}}var xt=!1,Mt=null,At=-1,St=5,Tt=-1;function Ct(){return!(et.unstable_now()-Tt<St)}function It(){if(Mt!==null){var Lt=et.unstable_now();Tt=Lt;var zt=!0;try{zt=Mt(!0,Lt)}finally{zt?$t():(xt=!1,Mt=null)}}else xt=!1}var $t;if(typeof _t=="function")$t=function(){_t(It)};else if(typeof MessageChannel<"u"){var Nt=new MessageChannel,Bt=Nt.port2;Nt.port1.onmessage=It,$t=function(){Bt.postMessage(null)}}else $t=function(){mt(It,0)};function Ot(Lt){Mt=Lt,xt||(xt=!0,$t())}function Ut(Lt,zt){At=mt(function(){Lt(et.unstable_now())},zt)}et.unstable_IdlePriority=5,et.unstable_ImmediatePriority=1,et.unstable_LowPriority=4,et.unstable_NormalPriority=3,et.unstable_Profiling=null,et.unstable_UserBlockingPriority=2,et.unstable_cancelCallback=function(Lt){Lt.callback=null},et.unstable_continueExecution=function(){ft||ct||(ft=!0,Ot(wt))},et.unstable_forceFrameRate=function(Lt){0>Lt||125<Lt?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):St=0<Lt?Math.floor(1e3/Lt):5},et.unstable_getCurrentPriorityLevel=function(){return it},et.unstable_getFirstCallbackNode=function(){return _e(lt)},et.unstable_next=function(Lt){switch(it){case 1:case 2:case 3:var zt=3;break;default:zt=it}var Yt=it;it=zt;try{return Lt()}finally{it=Yt}},et.unstable_pauseExecution=function(){},et.unstable_requestPaint=function(){},et.unstable_runWithPriority=function(Lt,zt){switch(Lt){case 1:case 2:case 3:case 4:case 5:break;default:Lt=3}var Yt=it;it=Lt;try{return zt()}finally{it=Yt}},et.unstable_scheduleCallback=function(Lt,zt,Yt){var en=et.unstable_now();switch(typeof Yt=="object"&&Yt!==null?(Yt=Yt.delay,Yt=typeof Yt=="number"&&0<Yt?en+Yt:en):Yt=en,Lt){case 1:var bn=-1;break;case 2:bn=250;break;case 5:bn=1073741823;break;case 4:bn=1e4;break;default:bn=5e3}return bn=Yt+bn,Lt={id:dt++,callback:zt,priorityLevel:Lt,startTime:Yt,expirationTime:bn,sortIndex:-1},Yt>en?(Lt.sortIndex=Yt,_(ut,Lt),_e(lt)===null&&Lt===_e(ut)&&(ht?(pt(At),At=-1):ht=!0,Ut(bt,Yt-en))):(Lt.sortIndex=bn,_(lt,Lt),ft||ct||(ft=!0,Ot(wt))),Lt},et.unstable_shouldYield=Ct,et.unstable_wrapCallback=function(Lt){var zt=it;return function(){var Yt=it;it=zt;try{return Lt.apply(this,arguments)}finally{it=Yt}}}})(scheduler_production_min$2);scheduler$2.exports=scheduler_production_min$2;var schedulerExports$1=scheduler$2.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var aa=reactExports,ca=schedulerExports$1;function p$4(et){for(var _="https://reactjs.org/docs/error-decoder.html?invariant="+et,_e=1;_e<arguments.length;_e++)_+="&args[]="+encodeURIComponent(arguments[_e]);return"Minified React error #"+et+"; visit "+_+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var da=new Set,ea={};function fa(et,_){ha(et,_),ha(et+"Capture",_)}function ha(et,_){for(ea[et]=_,et=0;et<_.length;et++)da.add(_[et])}var ia=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),ja=Object.prototype.hasOwnProperty,ka=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,la={},ma={};function oa(et){return ja.call(ma,et)?!0:ja.call(la,et)?!1:ka.test(et)?ma[et]=!0:(la[et]=!0,!1)}function pa(et,_,_e,tt){if(_e!==null&&_e.type===0)return!1;switch(typeof _){case"function":case"symbol":return!0;case"boolean":return tt?!1:_e!==null?!_e.acceptsBooleans:(et=et.toLowerCase().slice(0,5),et!=="data-"&&et!=="aria-");default:return!1}}function qa(et,_,_e,tt){if(_===null||typeof _>"u"||pa(et,_,_e,tt))return!0;if(tt)return!1;if(_e!==null)switch(_e.type){case 3:return!_;case 4:return _===!1;case 5:return isNaN(_);case 6:return isNaN(_)||1>_}return!1}function v$3(et,_,_e,tt,nt,rt,ot){this.acceptsBooleans=_===2||_===3||_===4,this.attributeName=tt,this.attributeNamespace=nt,this.mustUseProperty=_e,this.propertyName=et,this.type=_,this.sanitizeURL=rt,this.removeEmptyString=ot}var z$1={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(et){z$1[et]=new v$3(et,0,!1,et,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(et){var _=et[0];z$1[_]=new v$3(_,1,!1,et[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(et){z$1[et]=new v$3(et,2,!1,et.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(et){z$1[et]=new v$3(et,2,!1,et,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(et){z$1[et]=new v$3(et,3,!1,et.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(et){z$1[et]=new v$3(et,3,!0,et,null,!1,!1)});["capture","download"].forEach(function(et){z$1[et]=new v$3(et,4,!1,et,null,!1,!1)});["cols","rows","size","span"].forEach(function(et){z$1[et]=new v$3(et,6,!1,et,null,!1,!1)});["rowSpan","start"].forEach(function(et){z$1[et]=new v$3(et,5,!1,et.toLowerCase(),null,!1,!1)});var ra=/[\-:]([a-z])/g;function sa(et){return et[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(et){var _=et.replace(ra,sa);z$1[_]=new v$3(_,1,!1,et,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(et){var _=et.replace(ra,sa);z$1[_]=new v$3(_,1,!1,et,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(et){var _=et.replace(ra,sa);z$1[_]=new v$3(_,1,!1,et,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(et){z$1[et]=new v$3(et,1,!1,et.toLowerCase(),null,!1,!1)});z$1.xlinkHref=new v$3("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(et){z$1[et]=new v$3(et,1,!1,et.toLowerCase(),null,!0,!0)});function ta(et,_,_e,tt){var nt=z$1.hasOwnProperty(_)?z$1[_]:null;(nt!==null?nt.type!==0:tt||!(2<_.length)||_[0]!=="o"&&_[0]!=="O"||_[1]!=="n"&&_[1]!=="N")&&(qa(_,_e,nt,tt)&&(_e=null),tt||nt===null?oa(_)&&(_e===null?et.removeAttribute(_):et.setAttribute(_,""+_e)):nt.mustUseProperty?et[nt.propertyName]=_e===null?nt.type===3?!1:"":_e:(_=nt.attributeName,tt=nt.attributeNamespace,_e===null?et.removeAttribute(_):(nt=nt.type,_e=nt===3||nt===4&&_e===!0?"":""+_e,tt?et.setAttributeNS(tt,_,_e):et.setAttribute(_,_e))))}var ua=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,va=Symbol.for("react.element"),wa=Symbol.for("react.portal"),ya=Symbol.for("react.fragment"),za=Symbol.for("react.strict_mode"),Aa=Symbol.for("react.profiler"),Ba=Symbol.for("react.provider"),Ca=Symbol.for("react.context"),Da=Symbol.for("react.forward_ref"),Ea=Symbol.for("react.suspense"),Fa=Symbol.for("react.suspense_list"),Ga=Symbol.for("react.memo"),Ha=Symbol.for("react.lazy"),Ia=Symbol.for("react.offscreen"),Ja=Symbol.iterator;function Ka(et){return et===null||typeof et!="object"?null:(et=Ja&&et[Ja]||et["@@iterator"],typeof et=="function"?et:null)}var A$1=Object.assign,La;function Ma(et){if(La===void 0)try{throw Error()}catch(_e){var _=_e.stack.trim().match(/\n( *(at )?)/);La=_&&_[1]||""}return`
`+La+et}var Na=!1;function Oa(et,_){if(!et||Na)return"";Na=!0;var _e=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(_)if(_=function(){throw Error()},Object.defineProperty(_.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(_,[])}catch(ut){var tt=ut}Reflect.construct(et,[],_)}else{try{_.call()}catch(ut){tt=ut}et.call(_.prototype)}else{try{throw Error()}catch(ut){tt=ut}et()}}catch(ut){if(ut&&tt&&typeof ut.stack=="string"){for(var nt=ut.stack.split(`
`),rt=tt.stack.split(`
`),ot=nt.length-1,at=rt.length-1;1<=ot&&0<=at&&nt[ot]!==rt[at];)at--;for(;1<=ot&&0<=at;ot--,at--)if(nt[ot]!==rt[at]){if(ot!==1||at!==1)do if(ot--,at--,0>at||nt[ot]!==rt[at]){var lt=`
`+nt[ot].replace(" at new "," at ");return et.displayName&&lt.includes("<anonymous>")&&(lt=lt.replace("<anonymous>",et.displayName)),lt}while(1<=ot&&0<=at);break}}}finally{Na=!1,Error.prepareStackTrace=_e}return(et=et?et.displayName||et.name:"")?Ma(et):""}function Pa(et){switch(et.tag){case 5:return Ma(et.type);case 16:return Ma("Lazy");case 13:return Ma("Suspense");case 19:return Ma("SuspenseList");case 0:case 2:case 15:return et=Oa(et.type,!1),et;case 11:return et=Oa(et.type.render,!1),et;case 1:return et=Oa(et.type,!0),et;default:return""}}function Qa(et){if(et==null)return null;if(typeof et=="function")return et.displayName||et.name||null;if(typeof et=="string")return et;switch(et){case ya:return"Fragment";case wa:return"Portal";case Aa:return"Profiler";case za:return"StrictMode";case Ea:return"Suspense";case Fa:return"SuspenseList"}if(typeof et=="object")switch(et.$$typeof){case Ca:return(et.displayName||"Context")+".Consumer";case Ba:return(et._context.displayName||"Context")+".Provider";case Da:var _=et.render;return et=et.displayName,et||(et=_.displayName||_.name||"",et=et!==""?"ForwardRef("+et+")":"ForwardRef"),et;case Ga:return _=et.displayName||null,_!==null?_:Qa(et.type)||"Memo";case Ha:_=et._payload,et=et._init;try{return Qa(et(_))}catch{}}return null}function Ra(et){var _=et.type;switch(et.tag){case 24:return"Cache";case 9:return(_.displayName||"Context")+".Consumer";case 10:return(_._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return et=_.render,et=et.displayName||et.name||"",_.displayName||(et!==""?"ForwardRef("+et+")":"ForwardRef");case 7:return"Fragment";case 5:return _;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Qa(_);case 8:return _===za?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof _=="function")return _.displayName||_.name||null;if(typeof _=="string")return _}return null}function Sa(et){switch(typeof et){case"boolean":case"number":case"string":case"undefined":return et;case"object":return et;default:return""}}function Ta(et){var _=et.type;return(et=et.nodeName)&&et.toLowerCase()==="input"&&(_==="checkbox"||_==="radio")}function Ua(et){var _=Ta(et)?"checked":"value",_e=Object.getOwnPropertyDescriptor(et.constructor.prototype,_),tt=""+et[_];if(!et.hasOwnProperty(_)&&typeof _e<"u"&&typeof _e.get=="function"&&typeof _e.set=="function"){var nt=_e.get,rt=_e.set;return Object.defineProperty(et,_,{configurable:!0,get:function(){return nt.call(this)},set:function(ot){tt=""+ot,rt.call(this,ot)}}),Object.defineProperty(et,_,{enumerable:_e.enumerable}),{getValue:function(){return tt},setValue:function(ot){tt=""+ot},stopTracking:function(){et._valueTracker=null,delete et[_]}}}}function Va(et){et._valueTracker||(et._valueTracker=Ua(et))}function Wa(et){if(!et)return!1;var _=et._valueTracker;if(!_)return!0;var _e=_.getValue(),tt="";return et&&(tt=Ta(et)?et.checked?"true":"false":et.value),et=tt,et!==_e?(_.setValue(et),!0):!1}function Xa(et){if(et=et||(typeof document<"u"?document:void 0),typeof et>"u")return null;try{return et.activeElement||et.body}catch{return et.body}}function Ya(et,_){var _e=_.checked;return A$1({},_,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:_e??et._wrapperState.initialChecked})}function Za(et,_){var _e=_.defaultValue==null?"":_.defaultValue,tt=_.checked!=null?_.checked:_.defaultChecked;_e=Sa(_.value!=null?_.value:_e),et._wrapperState={initialChecked:tt,initialValue:_e,controlled:_.type==="checkbox"||_.type==="radio"?_.checked!=null:_.value!=null}}function ab(et,_){_=_.checked,_!=null&&ta(et,"checked",_,!1)}function bb(et,_){ab(et,_);var _e=Sa(_.value),tt=_.type;if(_e!=null)tt==="number"?(_e===0&&et.value===""||et.value!=_e)&&(et.value=""+_e):et.value!==""+_e&&(et.value=""+_e);else if(tt==="submit"||tt==="reset"){et.removeAttribute("value");return}_.hasOwnProperty("value")?cb(et,_.type,_e):_.hasOwnProperty("defaultValue")&&cb(et,_.type,Sa(_.defaultValue)),_.checked==null&&_.defaultChecked!=null&&(et.defaultChecked=!!_.defaultChecked)}function db(et,_,_e){if(_.hasOwnProperty("value")||_.hasOwnProperty("defaultValue")){var tt=_.type;if(!(tt!=="submit"&&tt!=="reset"||_.value!==void 0&&_.value!==null))return;_=""+et._wrapperState.initialValue,_e||_===et.value||(et.value=_),et.defaultValue=_}_e=et.name,_e!==""&&(et.name=""),et.defaultChecked=!!et._wrapperState.initialChecked,_e!==""&&(et.name=_e)}function cb(et,_,_e){(_!=="number"||Xa(et.ownerDocument)!==et)&&(_e==null?et.defaultValue=""+et._wrapperState.initialValue:et.defaultValue!==""+_e&&(et.defaultValue=""+_e))}var eb=Array.isArray;function fb(et,_,_e,tt){if(et=et.options,_){_={};for(var nt=0;nt<_e.length;nt++)_["$"+_e[nt]]=!0;for(_e=0;_e<et.length;_e++)nt=_.hasOwnProperty("$"+et[_e].value),et[_e].selected!==nt&&(et[_e].selected=nt),nt&&tt&&(et[_e].defaultSelected=!0)}else{for(_e=""+Sa(_e),_=null,nt=0;nt<et.length;nt++){if(et[nt].value===_e){et[nt].selected=!0,tt&&(et[nt].defaultSelected=!0);return}_!==null||et[nt].disabled||(_=et[nt])}_!==null&&(_.selected=!0)}}function gb(et,_){if(_.dangerouslySetInnerHTML!=null)throw Error(p$4(91));return A$1({},_,{value:void 0,defaultValue:void 0,children:""+et._wrapperState.initialValue})}function hb(et,_){var _e=_.value;if(_e==null){if(_e=_.children,_=_.defaultValue,_e!=null){if(_!=null)throw Error(p$4(92));if(eb(_e)){if(1<_e.length)throw Error(p$4(93));_e=_e[0]}_=_e}_==null&&(_=""),_e=_}et._wrapperState={initialValue:Sa(_e)}}function ib(et,_){var _e=Sa(_.value),tt=Sa(_.defaultValue);_e!=null&&(_e=""+_e,_e!==et.value&&(et.value=_e),_.defaultValue==null&&et.defaultValue!==_e&&(et.defaultValue=_e)),tt!=null&&(et.defaultValue=""+tt)}function jb(et){var _=et.textContent;_===et._wrapperState.initialValue&&_!==""&&_!==null&&(et.value=_)}function kb(et){switch(et){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function lb(et,_){return et==null||et==="http://www.w3.org/1999/xhtml"?kb(_):et==="http://www.w3.org/2000/svg"&&_==="foreignObject"?"http://www.w3.org/1999/xhtml":et}var mb,nb=function(et){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(_,_e,tt,nt){MSApp.execUnsafeLocalFunction(function(){return et(_,_e,tt,nt)})}:et}(function(et,_){if(et.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in et)et.innerHTML=_;else{for(mb=mb||document.createElement("div"),mb.innerHTML="<svg>"+_.valueOf().toString()+"</svg>",_=mb.firstChild;et.firstChild;)et.removeChild(et.firstChild);for(;_.firstChild;)et.appendChild(_.firstChild)}});function ob(et,_){if(_){var _e=et.firstChild;if(_e&&_e===et.lastChild&&_e.nodeType===3){_e.nodeValue=_;return}}et.textContent=_}var pb={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},qb=["Webkit","ms","Moz","O"];Object.keys(pb).forEach(function(et){qb.forEach(function(_){_=_+et.charAt(0).toUpperCase()+et.substring(1),pb[_]=pb[et]})});function rb(et,_,_e){return _==null||typeof _=="boolean"||_===""?"":_e||typeof _!="number"||_===0||pb.hasOwnProperty(et)&&pb[et]?(""+_).trim():_+"px"}function sb(et,_){et=et.style;for(var _e in _)if(_.hasOwnProperty(_e)){var tt=_e.indexOf("--")===0,nt=rb(_e,_[_e],tt);_e==="float"&&(_e="cssFloat"),tt?et.setProperty(_e,nt):et[_e]=nt}}var tb=A$1({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function ub(et,_){if(_){if(tb[et]&&(_.children!=null||_.dangerouslySetInnerHTML!=null))throw Error(p$4(137,et));if(_.dangerouslySetInnerHTML!=null){if(_.children!=null)throw Error(p$4(60));if(typeof _.dangerouslySetInnerHTML!="object"||!("__html"in _.dangerouslySetInnerHTML))throw Error(p$4(61))}if(_.style!=null&&typeof _.style!="object")throw Error(p$4(62))}}function vb(et,_){if(et.indexOf("-")===-1)return typeof _.is=="string";switch(et){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var wb=null;function xb(et){return et=et.target||et.srcElement||window,et.correspondingUseElement&&(et=et.correspondingUseElement),et.nodeType===3?et.parentNode:et}var yb=null,zb=null,Ab=null;function Bb(et){if(et=Cb(et)){if(typeof yb!="function")throw Error(p$4(280));var _=et.stateNode;_&&(_=Db(_),yb(et.stateNode,et.type,_))}}function Eb(et){zb?Ab?Ab.push(et):Ab=[et]:zb=et}function Fb(){if(zb){var et=zb,_=Ab;if(Ab=zb=null,Bb(et),_)for(et=0;et<_.length;et++)Bb(_[et])}}function Gb(et,_){return et(_)}function Hb(){}var Ib=!1;function Jb(et,_,_e){if(Ib)return et(_,_e);Ib=!0;try{return Gb(et,_,_e)}finally{Ib=!1,(zb!==null||Ab!==null)&&(Hb(),Fb())}}function Kb(et,_){var _e=et.stateNode;if(_e===null)return null;var tt=Db(_e);if(tt===null)return null;_e=tt[_];e:switch(_){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(tt=!tt.disabled)||(et=et.type,tt=!(et==="button"||et==="input"||et==="select"||et==="textarea")),et=!tt;break e;default:et=!1}if(et)return null;if(_e&&typeof _e!="function")throw Error(p$4(231,_,typeof _e));return _e}var Lb=!1;if(ia)try{var Mb={};Object.defineProperty(Mb,"passive",{get:function(){Lb=!0}}),window.addEventListener("test",Mb,Mb),window.removeEventListener("test",Mb,Mb)}catch{Lb=!1}function Nb(et,_,_e,tt,nt,rt,ot,at,lt){var ut=Array.prototype.slice.call(arguments,3);try{_.apply(_e,ut)}catch(dt){this.onError(dt)}}var Ob=!1,Pb=null,Qb=!1,Rb=null,Sb={onError:function(et){Ob=!0,Pb=et}};function Tb(et,_,_e,tt,nt,rt,ot,at,lt){Ob=!1,Pb=null,Nb.apply(Sb,arguments)}function Ub(et,_,_e,tt,nt,rt,ot,at,lt){if(Tb.apply(this,arguments),Ob){if(Ob){var ut=Pb;Ob=!1,Pb=null}else throw Error(p$4(198));Qb||(Qb=!0,Rb=ut)}}function Vb(et){var _=et,_e=et;if(et.alternate)for(;_.return;)_=_.return;else{et=_;do _=et,_.flags&4098&&(_e=_.return),et=_.return;while(et)}return _.tag===3?_e:null}function Wb(et){if(et.tag===13){var _=et.memoizedState;if(_===null&&(et=et.alternate,et!==null&&(_=et.memoizedState)),_!==null)return _.dehydrated}return null}function Xb(et){if(Vb(et)!==et)throw Error(p$4(188))}function Yb(et){var _=et.alternate;if(!_){if(_=Vb(et),_===null)throw Error(p$4(188));return _!==et?null:et}for(var _e=et,tt=_;;){var nt=_e.return;if(nt===null)break;var rt=nt.alternate;if(rt===null){if(tt=nt.return,tt!==null){_e=tt;continue}break}if(nt.child===rt.child){for(rt=nt.child;rt;){if(rt===_e)return Xb(nt),et;if(rt===tt)return Xb(nt),_;rt=rt.sibling}throw Error(p$4(188))}if(_e.return!==tt.return)_e=nt,tt=rt;else{for(var ot=!1,at=nt.child;at;){if(at===_e){ot=!0,_e=nt,tt=rt;break}if(at===tt){ot=!0,tt=nt,_e=rt;break}at=at.sibling}if(!ot){for(at=rt.child;at;){if(at===_e){ot=!0,_e=rt,tt=nt;break}if(at===tt){ot=!0,tt=rt,_e=nt;break}at=at.sibling}if(!ot)throw Error(p$4(189))}}if(_e.alternate!==tt)throw Error(p$4(190))}if(_e.tag!==3)throw Error(p$4(188));return _e.stateNode.current===_e?et:_}function Zb(et){return et=Yb(et),et!==null?$b(et):null}function $b(et){if(et.tag===5||et.tag===6)return et;for(et=et.child;et!==null;){var _=$b(et);if(_!==null)return _;et=et.sibling}return null}var ac=ca.unstable_scheduleCallback,bc=ca.unstable_cancelCallback,cc=ca.unstable_shouldYield,dc=ca.unstable_requestPaint,B$1=ca.unstable_now,ec=ca.unstable_getCurrentPriorityLevel,fc=ca.unstable_ImmediatePriority,gc=ca.unstable_UserBlockingPriority,hc=ca.unstable_NormalPriority,ic=ca.unstable_LowPriority,jc=ca.unstable_IdlePriority,kc=null,lc=null;function mc(et){if(lc&&typeof lc.onCommitFiberRoot=="function")try{lc.onCommitFiberRoot(kc,et,void 0,(et.current.flags&128)===128)}catch{}}var oc=Math.clz32?Math.clz32:nc,pc=Math.log,qc=Math.LN2;function nc(et){return et>>>=0,et===0?32:31-(pc(et)/qc|0)|0}var rc=64,sc=4194304;function tc(et){switch(et&-et){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return et&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return et&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return et}}function uc(et,_){var _e=et.pendingLanes;if(_e===0)return 0;var tt=0,nt=et.suspendedLanes,rt=et.pingedLanes,ot=_e&268435455;if(ot!==0){var at=ot&~nt;at!==0?tt=tc(at):(rt&=ot,rt!==0&&(tt=tc(rt)))}else ot=_e&~nt,ot!==0?tt=tc(ot):rt!==0&&(tt=tc(rt));if(tt===0)return 0;if(_!==0&&_!==tt&&!(_&nt)&&(nt=tt&-tt,rt=_&-_,nt>=rt||nt===16&&(rt&4194240)!==0))return _;if(tt&4&&(tt|=_e&16),_=et.entangledLanes,_!==0)for(et=et.entanglements,_&=tt;0<_;)_e=31-oc(_),nt=1<<_e,tt|=et[_e],_&=~nt;return tt}function vc(et,_){switch(et){case 1:case 2:case 4:return _+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return _+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function wc(et,_){for(var _e=et.suspendedLanes,tt=et.pingedLanes,nt=et.expirationTimes,rt=et.pendingLanes;0<rt;){var ot=31-oc(rt),at=1<<ot,lt=nt[ot];lt===-1?(!(at&_e)||at&tt)&&(nt[ot]=vc(at,_)):lt<=_&&(et.expiredLanes|=at),rt&=~at}}function xc(et){return et=et.pendingLanes&-1073741825,et!==0?et:et&1073741824?1073741824:0}function yc(){var et=rc;return rc<<=1,!(rc&4194240)&&(rc=64),et}function zc(et){for(var _=[],_e=0;31>_e;_e++)_.push(et);return _}function Ac(et,_,_e){et.pendingLanes|=_,_!==536870912&&(et.suspendedLanes=0,et.pingedLanes=0),et=et.eventTimes,_=31-oc(_),et[_]=_e}function Bc(et,_){var _e=et.pendingLanes&~_;et.pendingLanes=_,et.suspendedLanes=0,et.pingedLanes=0,et.expiredLanes&=_,et.mutableReadLanes&=_,et.entangledLanes&=_,_=et.entanglements;var tt=et.eventTimes;for(et=et.expirationTimes;0<_e;){var nt=31-oc(_e),rt=1<<nt;_[nt]=0,tt[nt]=-1,et[nt]=-1,_e&=~rt}}function Cc(et,_){var _e=et.entangledLanes|=_;for(et=et.entanglements;_e;){var tt=31-oc(_e),nt=1<<tt;nt&_|et[tt]&_&&(et[tt]|=_),_e&=~nt}}var C$1=0;function Dc(et){return et&=-et,1<et?4<et?et&268435455?16:536870912:4:1}var Ec,Fc,Gc,Hc,Ic,Jc=!1,Kc=[],Lc=null,Mc=null,Nc=null,Oc=new Map,Pc=new Map,Qc=[],Rc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Sc(et,_){switch(et){case"focusin":case"focusout":Lc=null;break;case"dragenter":case"dragleave":Mc=null;break;case"mouseover":case"mouseout":Nc=null;break;case"pointerover":case"pointerout":Oc.delete(_.pointerId);break;case"gotpointercapture":case"lostpointercapture":Pc.delete(_.pointerId)}}function Tc(et,_,_e,tt,nt,rt){return et===null||et.nativeEvent!==rt?(et={blockedOn:_,domEventName:_e,eventSystemFlags:tt,nativeEvent:rt,targetContainers:[nt]},_!==null&&(_=Cb(_),_!==null&&Fc(_)),et):(et.eventSystemFlags|=tt,_=et.targetContainers,nt!==null&&_.indexOf(nt)===-1&&_.push(nt),et)}function Uc(et,_,_e,tt,nt){switch(_){case"focusin":return Lc=Tc(Lc,et,_,_e,tt,nt),!0;case"dragenter":return Mc=Tc(Mc,et,_,_e,tt,nt),!0;case"mouseover":return Nc=Tc(Nc,et,_,_e,tt,nt),!0;case"pointerover":var rt=nt.pointerId;return Oc.set(rt,Tc(Oc.get(rt)||null,et,_,_e,tt,nt)),!0;case"gotpointercapture":return rt=nt.pointerId,Pc.set(rt,Tc(Pc.get(rt)||null,et,_,_e,tt,nt)),!0}return!1}function Vc(et){var _=Wc(et.target);if(_!==null){var _e=Vb(_);if(_e!==null){if(_=_e.tag,_===13){if(_=Wb(_e),_!==null){et.blockedOn=_,Ic(et.priority,function(){Gc(_e)});return}}else if(_===3&&_e.stateNode.current.memoizedState.isDehydrated){et.blockedOn=_e.tag===3?_e.stateNode.containerInfo:null;return}}}et.blockedOn=null}function Xc(et){if(et.blockedOn!==null)return!1;for(var _=et.targetContainers;0<_.length;){var _e=Yc(et.domEventName,et.eventSystemFlags,_[0],et.nativeEvent);if(_e===null){_e=et.nativeEvent;var tt=new _e.constructor(_e.type,_e);wb=tt,_e.target.dispatchEvent(tt),wb=null}else return _=Cb(_e),_!==null&&Fc(_),et.blockedOn=_e,!1;_.shift()}return!0}function Zc(et,_,_e){Xc(et)&&_e.delete(_)}function $c(){Jc=!1,Lc!==null&&Xc(Lc)&&(Lc=null),Mc!==null&&Xc(Mc)&&(Mc=null),Nc!==null&&Xc(Nc)&&(Nc=null),Oc.forEach(Zc),Pc.forEach(Zc)}function ad(et,_){et.blockedOn===_&&(et.blockedOn=null,Jc||(Jc=!0,ca.unstable_scheduleCallback(ca.unstable_NormalPriority,$c)))}function bd(et){function _(nt){return ad(nt,et)}if(0<Kc.length){ad(Kc[0],et);for(var _e=1;_e<Kc.length;_e++){var tt=Kc[_e];tt.blockedOn===et&&(tt.blockedOn=null)}}for(Lc!==null&&ad(Lc,et),Mc!==null&&ad(Mc,et),Nc!==null&&ad(Nc,et),Oc.forEach(_),Pc.forEach(_),_e=0;_e<Qc.length;_e++)tt=Qc[_e],tt.blockedOn===et&&(tt.blockedOn=null);for(;0<Qc.length&&(_e=Qc[0],_e.blockedOn===null);)Vc(_e),_e.blockedOn===null&&Qc.shift()}var cd=ua.ReactCurrentBatchConfig,dd=!0;function ed(et,_,_e,tt){var nt=C$1,rt=cd.transition;cd.transition=null;try{C$1=1,fd(et,_,_e,tt)}finally{C$1=nt,cd.transition=rt}}function gd(et,_,_e,tt){var nt=C$1,rt=cd.transition;cd.transition=null;try{C$1=4,fd(et,_,_e,tt)}finally{C$1=nt,cd.transition=rt}}function fd(et,_,_e,tt){if(dd){var nt=Yc(et,_,_e,tt);if(nt===null)hd(et,_,tt,id,_e),Sc(et,tt);else if(Uc(nt,et,_,_e,tt))tt.stopPropagation();else if(Sc(et,tt),_&4&&-1<Rc.indexOf(et)){for(;nt!==null;){var rt=Cb(nt);if(rt!==null&&Ec(rt),rt=Yc(et,_,_e,tt),rt===null&&hd(et,_,tt,id,_e),rt===nt)break;nt=rt}nt!==null&&tt.stopPropagation()}else hd(et,_,tt,null,_e)}}var id=null;function Yc(et,_,_e,tt){if(id=null,et=xb(tt),et=Wc(et),et!==null)if(_=Vb(et),_===null)et=null;else if(_e=_.tag,_e===13){if(et=Wb(_),et!==null)return et;et=null}else if(_e===3){if(_.stateNode.current.memoizedState.isDehydrated)return _.tag===3?_.stateNode.containerInfo:null;et=null}else _!==et&&(et=null);return id=et,null}function jd(et){switch(et){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(ec()){case fc:return 1;case gc:return 4;case hc:case ic:return 16;case jc:return 536870912;default:return 16}default:return 16}}var kd=null,ld=null,md=null;function nd(){if(md)return md;var et,_=ld,_e=_.length,tt,nt="value"in kd?kd.value:kd.textContent,rt=nt.length;for(et=0;et<_e&&_[et]===nt[et];et++);var ot=_e-et;for(tt=1;tt<=ot&&_[_e-tt]===nt[rt-tt];tt++);return md=nt.slice(et,1<tt?1-tt:void 0)}function od(et){var _=et.keyCode;return"charCode"in et?(et=et.charCode,et===0&&_===13&&(et=13)):et=_,et===10&&(et=13),32<=et||et===13?et:0}function pd(){return!0}function qd(){return!1}function rd(et){function _(_e,tt,nt,rt,ot){this._reactName=_e,this._targetInst=nt,this.type=tt,this.nativeEvent=rt,this.target=ot,this.currentTarget=null;for(var at in et)et.hasOwnProperty(at)&&(_e=et[at],this[at]=_e?_e(rt):rt[at]);return this.isDefaultPrevented=(rt.defaultPrevented!=null?rt.defaultPrevented:rt.returnValue===!1)?pd:qd,this.isPropagationStopped=qd,this}return A$1(_.prototype,{preventDefault:function(){this.defaultPrevented=!0;var _e=this.nativeEvent;_e&&(_e.preventDefault?_e.preventDefault():typeof _e.returnValue!="unknown"&&(_e.returnValue=!1),this.isDefaultPrevented=pd)},stopPropagation:function(){var _e=this.nativeEvent;_e&&(_e.stopPropagation?_e.stopPropagation():typeof _e.cancelBubble!="unknown"&&(_e.cancelBubble=!0),this.isPropagationStopped=pd)},persist:function(){},isPersistent:pd}),_}var sd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(et){return et.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td=rd(sd),ud=A$1({},sd,{view:0,detail:0}),vd=rd(ud),wd,xd,yd,Ad=A$1({},ud,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd,button:0,buttons:0,relatedTarget:function(et){return et.relatedTarget===void 0?et.fromElement===et.srcElement?et.toElement:et.fromElement:et.relatedTarget},movementX:function(et){return"movementX"in et?et.movementX:(et!==yd&&(yd&&et.type==="mousemove"?(wd=et.screenX-yd.screenX,xd=et.screenY-yd.screenY):xd=wd=0,yd=et),wd)},movementY:function(et){return"movementY"in et?et.movementY:xd}}),Bd=rd(Ad),Cd=A$1({},Ad,{dataTransfer:0}),Dd=rd(Cd),Ed=A$1({},ud,{relatedTarget:0}),Fd=rd(Ed),Gd=A$1({},sd,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd=rd(Gd),Id=A$1({},sd,{clipboardData:function(et){return"clipboardData"in et?et.clipboardData:window.clipboardData}}),Jd=rd(Id),Kd=A$1({},sd,{data:0}),Ld=rd(Kd),Md={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Nd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Od={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pd(et){var _=this.nativeEvent;return _.getModifierState?_.getModifierState(et):(et=Od[et])?!!_[et]:!1}function zd(){return Pd}var Qd=A$1({},ud,{key:function(et){if(et.key){var _=Md[et.key]||et.key;if(_!=="Unidentified")return _}return et.type==="keypress"?(et=od(et),et===13?"Enter":String.fromCharCode(et)):et.type==="keydown"||et.type==="keyup"?Nd[et.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd,charCode:function(et){return et.type==="keypress"?od(et):0},keyCode:function(et){return et.type==="keydown"||et.type==="keyup"?et.keyCode:0},which:function(et){return et.type==="keypress"?od(et):et.type==="keydown"||et.type==="keyup"?et.keyCode:0}}),Rd=rd(Qd),Sd=A$1({},Ad,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td=rd(Sd),Ud=A$1({},ud,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd}),Vd=rd(Ud),Wd=A$1({},sd,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd=rd(Wd),Yd=A$1({},Ad,{deltaX:function(et){return"deltaX"in et?et.deltaX:"wheelDeltaX"in et?-et.wheelDeltaX:0},deltaY:function(et){return"deltaY"in et?et.deltaY:"wheelDeltaY"in et?-et.wheelDeltaY:"wheelDelta"in et?-et.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd=rd(Yd),$d=[9,13,27,32],ae=ia&&"CompositionEvent"in window,be=null;ia&&"documentMode"in document&&(be=document.documentMode);var ce=ia&&"TextEvent"in window&&!be,de=ia&&(!ae||be&&8<be&&11>=be),ee$1=" ",fe=!1;function ge(et,_){switch(et){case"keyup":return $d.indexOf(_.keyCode)!==-1;case"keydown":return _.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function he(et){return et=et.detail,typeof et=="object"&&"data"in et?et.data:null}var ie=!1;function je(et,_){switch(et){case"compositionend":return he(_);case"keypress":return _.which!==32?null:(fe=!0,ee$1);case"textInput":return et=_.data,et===ee$1&&fe?null:et;default:return null}}function ke(et,_){if(ie)return et==="compositionend"||!ae&&ge(et,_)?(et=nd(),md=ld=kd=null,ie=!1,et):null;switch(et){case"paste":return null;case"keypress":if(!(_.ctrlKey||_.altKey||_.metaKey)||_.ctrlKey&&_.altKey){if(_.char&&1<_.char.length)return _.char;if(_.which)return String.fromCharCode(_.which)}return null;case"compositionend":return de&&_.locale!=="ko"?null:_.data;default:return null}}var le={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me(et){var _=et&&et.nodeName&&et.nodeName.toLowerCase();return _==="input"?!!le[et.type]:_==="textarea"}function ne(et,_,_e,tt){Eb(tt),_=oe(_,"onChange"),0<_.length&&(_e=new td("onChange","change",null,_e,tt),et.push({event:_e,listeners:_}))}var pe=null,qe=null;function re$1(et){se(et,0)}function te(et){var _=ue(et);if(Wa(_))return et}function ve(et,_){if(et==="change")return _}var we=!1;if(ia){var xe$1;if(ia){var ye="oninput"in document;if(!ye){var ze=document.createElement("div");ze.setAttribute("oninput","return;"),ye=typeof ze.oninput=="function"}xe$1=ye}else xe$1=!1;we=xe$1&&(!document.documentMode||9<document.documentMode)}function Ae(){pe&&(pe.detachEvent("onpropertychange",Be),qe=pe=null)}function Be(et){if(et.propertyName==="value"&&te(qe)){var _=[];ne(_,qe,et,xb(et)),Jb(re$1,_)}}function Ce$1(et,_,_e){et==="focusin"?(Ae(),pe=_,qe=_e,pe.attachEvent("onpropertychange",Be)):et==="focusout"&&Ae()}function De(et){if(et==="selectionchange"||et==="keyup"||et==="keydown")return te(qe)}function Ee(et,_){if(et==="click")return te(_)}function Fe(et,_){if(et==="input"||et==="change")return te(_)}function Ge(et,_){return et===_&&(et!==0||1/et===1/_)||et!==et&&_!==_}var He=typeof Object.is=="function"?Object.is:Ge;function Ie(et,_){if(He(et,_))return!0;if(typeof et!="object"||et===null||typeof _!="object"||_===null)return!1;var _e=Object.keys(et),tt=Object.keys(_);if(_e.length!==tt.length)return!1;for(tt=0;tt<_e.length;tt++){var nt=_e[tt];if(!ja.call(_,nt)||!He(et[nt],_[nt]))return!1}return!0}function Je(et){for(;et&&et.firstChild;)et=et.firstChild;return et}function Ke(et,_){var _e=Je(et);et=0;for(var tt;_e;){if(_e.nodeType===3){if(tt=et+_e.textContent.length,et<=_&&tt>=_)return{node:_e,offset:_-et};et=tt}e:{for(;_e;){if(_e.nextSibling){_e=_e.nextSibling;break e}_e=_e.parentNode}_e=void 0}_e=Je(_e)}}function Le(et,_){return et&&_?et===_?!0:et&&et.nodeType===3?!1:_&&_.nodeType===3?Le(et,_.parentNode):"contains"in et?et.contains(_):et.compareDocumentPosition?!!(et.compareDocumentPosition(_)&16):!1:!1}function Me$1(){for(var et=window,_=Xa();_ instanceof et.HTMLIFrameElement;){try{var _e=typeof _.contentWindow.location.href=="string"}catch{_e=!1}if(_e)et=_.contentWindow;else break;_=Xa(et.document)}return _}function Ne$1(et){var _=et&&et.nodeName&&et.nodeName.toLowerCase();return _&&(_==="input"&&(et.type==="text"||et.type==="search"||et.type==="tel"||et.type==="url"||et.type==="password")||_==="textarea"||et.contentEditable==="true")}function Oe(et){var _=Me$1(),_e=et.focusedElem,tt=et.selectionRange;if(_!==_e&&_e&&_e.ownerDocument&&Le(_e.ownerDocument.documentElement,_e)){if(tt!==null&&Ne$1(_e)){if(_=tt.start,et=tt.end,et===void 0&&(et=_),"selectionStart"in _e)_e.selectionStart=_,_e.selectionEnd=Math.min(et,_e.value.length);else if(et=(_=_e.ownerDocument||document)&&_.defaultView||window,et.getSelection){et=et.getSelection();var nt=_e.textContent.length,rt=Math.min(tt.start,nt);tt=tt.end===void 0?rt:Math.min(tt.end,nt),!et.extend&&rt>tt&&(nt=tt,tt=rt,rt=nt),nt=Ke(_e,rt);var ot=Ke(_e,tt);nt&&ot&&(et.rangeCount!==1||et.anchorNode!==nt.node||et.anchorOffset!==nt.offset||et.focusNode!==ot.node||et.focusOffset!==ot.offset)&&(_=_.createRange(),_.setStart(nt.node,nt.offset),et.removeAllRanges(),rt>tt?(et.addRange(_),et.extend(ot.node,ot.offset)):(_.setEnd(ot.node,ot.offset),et.addRange(_)))}}for(_=[],et=_e;et=et.parentNode;)et.nodeType===1&&_.push({element:et,left:et.scrollLeft,top:et.scrollTop});for(typeof _e.focus=="function"&&_e.focus(),_e=0;_e<_.length;_e++)et=_[_e],et.element.scrollLeft=et.left,et.element.scrollTop=et.top}}var Pe=ia&&"documentMode"in document&&11>=document.documentMode,Qe=null,Re=null,Se=null,Te=!1;function Ue(et,_,_e){var tt=_e.window===_e?_e.document:_e.nodeType===9?_e:_e.ownerDocument;Te||Qe==null||Qe!==Xa(tt)||(tt=Qe,"selectionStart"in tt&&Ne$1(tt)?tt={start:tt.selectionStart,end:tt.selectionEnd}:(tt=(tt.ownerDocument&&tt.ownerDocument.defaultView||window).getSelection(),tt={anchorNode:tt.anchorNode,anchorOffset:tt.anchorOffset,focusNode:tt.focusNode,focusOffset:tt.focusOffset}),Se&&Ie(Se,tt)||(Se=tt,tt=oe(Re,"onSelect"),0<tt.length&&(_=new td("onSelect","select",null,_,_e),et.push({event:_,listeners:tt}),_.target=Qe)))}function Ve(et,_){var _e={};return _e[et.toLowerCase()]=_.toLowerCase(),_e["Webkit"+et]="webkit"+_,_e["Moz"+et]="moz"+_,_e}var We={animationend:Ve("Animation","AnimationEnd"),animationiteration:Ve("Animation","AnimationIteration"),animationstart:Ve("Animation","AnimationStart"),transitionend:Ve("Transition","TransitionEnd")},Xe={},Ye={};ia&&(Ye=document.createElement("div").style,"AnimationEvent"in window||(delete We.animationend.animation,delete We.animationiteration.animation,delete We.animationstart.animation),"TransitionEvent"in window||delete We.transitionend.transition);function Ze(et){if(Xe[et])return Xe[et];if(!We[et])return et;var _=We[et],_e;for(_e in _)if(_.hasOwnProperty(_e)&&_e in Ye)return Xe[et]=_[_e];return et}var $e=Ze("animationend"),af=Ze("animationiteration"),bf=Ze("animationstart"),cf=Ze("transitionend"),df=new Map,ef="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function ff(et,_){df.set(et,_),fa(_,[et])}for(var gf=0;gf<ef.length;gf++){var hf=ef[gf],jf=hf.toLowerCase(),kf=hf[0].toUpperCase()+hf.slice(1);ff(jf,"on"+kf)}ff($e,"onAnimationEnd");ff(af,"onAnimationIteration");ff(bf,"onAnimationStart");ff("dblclick","onDoubleClick");ff("focusin","onFocus");ff("focusout","onBlur");ff(cf,"onTransitionEnd");ha("onMouseEnter",["mouseout","mouseover"]);ha("onMouseLeave",["mouseout","mouseover"]);ha("onPointerEnter",["pointerout","pointerover"]);ha("onPointerLeave",["pointerout","pointerover"]);fa("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));fa("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));fa("onBeforeInput",["compositionend","keypress","textInput","paste"]);fa("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));fa("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));fa("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var lf="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),mf=new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));function nf(et,_,_e){var tt=et.type||"unknown-event";et.currentTarget=_e,Ub(tt,_,void 0,et),et.currentTarget=null}function se(et,_){_=(_&4)!==0;for(var _e=0;_e<et.length;_e++){var tt=et[_e],nt=tt.event;tt=tt.listeners;e:{var rt=void 0;if(_)for(var ot=tt.length-1;0<=ot;ot--){var at=tt[ot],lt=at.instance,ut=at.currentTarget;if(at=at.listener,lt!==rt&&nt.isPropagationStopped())break e;nf(nt,at,ut),rt=lt}else for(ot=0;ot<tt.length;ot++){if(at=tt[ot],lt=at.instance,ut=at.currentTarget,at=at.listener,lt!==rt&&nt.isPropagationStopped())break e;nf(nt,at,ut),rt=lt}}}if(Qb)throw et=Rb,Qb=!1,Rb=null,et}function D$1(et,_){var _e=_[of];_e===void 0&&(_e=_[of]=new Set);var tt=et+"__bubble";_e.has(tt)||(pf(_,et,2,!1),_e.add(tt))}function qf(et,_,_e){var tt=0;_&&(tt|=4),pf(_e,et,tt,_)}var rf="_reactListening"+Math.random().toString(36).slice(2);function sf(et){if(!et[rf]){et[rf]=!0,da.forEach(function(_e){_e!=="selectionchange"&&(mf.has(_e)||qf(_e,!1,et),qf(_e,!0,et))});var _=et.nodeType===9?et:et.ownerDocument;_===null||_[rf]||(_[rf]=!0,qf("selectionchange",!1,_))}}function pf(et,_,_e,tt){switch(jd(_)){case 1:var nt=ed;break;case 4:nt=gd;break;default:nt=fd}_e=nt.bind(null,_,_e,et),nt=void 0,!Lb||_!=="touchstart"&&_!=="touchmove"&&_!=="wheel"||(nt=!0),tt?nt!==void 0?et.addEventListener(_,_e,{capture:!0,passive:nt}):et.addEventListener(_,_e,!0):nt!==void 0?et.addEventListener(_,_e,{passive:nt}):et.addEventListener(_,_e,!1)}function hd(et,_,_e,tt,nt){var rt=tt;if(!(_&1)&&!(_&2)&&tt!==null)e:for(;;){if(tt===null)return;var ot=tt.tag;if(ot===3||ot===4){var at=tt.stateNode.containerInfo;if(at===nt||at.nodeType===8&&at.parentNode===nt)break;if(ot===4)for(ot=tt.return;ot!==null;){var lt=ot.tag;if((lt===3||lt===4)&&(lt=ot.stateNode.containerInfo,lt===nt||lt.nodeType===8&&lt.parentNode===nt))return;ot=ot.return}for(;at!==null;){if(ot=Wc(at),ot===null)return;if(lt=ot.tag,lt===5||lt===6){tt=rt=ot;continue e}at=at.parentNode}}tt=tt.return}Jb(function(){var ut=rt,dt=xb(_e),st=[];e:{var it=df.get(et);if(it!==void 0){var ct=td,ft=et;switch(et){case"keypress":if(od(_e)===0)break e;case"keydown":case"keyup":ct=Rd;break;case"focusin":ft="focus",ct=Fd;break;case"focusout":ft="blur",ct=Fd;break;case"beforeblur":case"afterblur":ct=Fd;break;case"click":if(_e.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":ct=Bd;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":ct=Dd;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":ct=Vd;break;case $e:case af:case bf:ct=Hd;break;case cf:ct=Xd;break;case"scroll":ct=vd;break;case"wheel":ct=Zd;break;case"copy":case"cut":case"paste":ct=Jd;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":ct=Td}var ht=(_&4)!==0,mt=!ht&&et==="scroll",pt=ht?it!==null?it+"Capture":null:it;ht=[];for(var _t=ut,vt;_t!==null;){vt=_t;var bt=vt.stateNode;if(vt.tag===5&&bt!==null&&(vt=bt,pt!==null&&(bt=Kb(_t,pt),bt!=null&&ht.push(tf(_t,bt,vt)))),mt)break;_t=_t.return}0<ht.length&&(it=new ct(it,ft,null,_e,dt),st.push({event:it,listeners:ht}))}}if(!(_&7)){e:{if(it=et==="mouseover"||et==="pointerover",ct=et==="mouseout"||et==="pointerout",it&&_e!==wb&&(ft=_e.relatedTarget||_e.fromElement)&&(Wc(ft)||ft[uf]))break e;if((ct||it)&&(it=dt.window===dt?dt:(it=dt.ownerDocument)?it.defaultView||it.parentWindow:window,ct?(ft=_e.relatedTarget||_e.toElement,ct=ut,ft=ft?Wc(ft):null,ft!==null&&(mt=Vb(ft),ft!==mt||ft.tag!==5&&ft.tag!==6)&&(ft=null)):(ct=null,ft=ut),ct!==ft)){if(ht=Bd,bt="onMouseLeave",pt="onMouseEnter",_t="mouse",(et==="pointerout"||et==="pointerover")&&(ht=Td,bt="onPointerLeave",pt="onPointerEnter",_t="pointer"),mt=ct==null?it:ue(ct),vt=ft==null?it:ue(ft),it=new ht(bt,_t+"leave",ct,_e,dt),it.target=mt,it.relatedTarget=vt,bt=null,Wc(dt)===ut&&(ht=new ht(pt,_t+"enter",ft,_e,dt),ht.target=vt,ht.relatedTarget=mt,bt=ht),mt=bt,ct&&ft)t:{for(ht=ct,pt=ft,_t=0,vt=ht;vt;vt=vf(vt))_t++;for(vt=0,bt=pt;bt;bt=vf(bt))vt++;for(;0<_t-vt;)ht=vf(ht),_t--;for(;0<vt-_t;)pt=vf(pt),vt--;for(;_t--;){if(ht===pt||pt!==null&&ht===pt.alternate)break t;ht=vf(ht),pt=vf(pt)}ht=null}else ht=null;ct!==null&&wf(st,it,ct,ht,!1),ft!==null&&mt!==null&&wf(st,mt,ft,ht,!0)}}e:{if(it=ut?ue(ut):window,ct=it.nodeName&&it.nodeName.toLowerCase(),ct==="select"||ct==="input"&&it.type==="file")var wt=ve;else if(me(it))if(we)wt=Fe;else{wt=De;var xt=Ce$1}else(ct=it.nodeName)&&ct.toLowerCase()==="input"&&(it.type==="checkbox"||it.type==="radio")&&(wt=Ee);if(wt&&(wt=wt(et,ut))){ne(st,wt,_e,dt);break e}xt&&xt(et,it,ut),et==="focusout"&&(xt=it._wrapperState)&&xt.controlled&&it.type==="number"&&cb(it,"number",it.value)}switch(xt=ut?ue(ut):window,et){case"focusin":(me(xt)||xt.contentEditable==="true")&&(Qe=xt,Re=ut,Se=null);break;case"focusout":Se=Re=Qe=null;break;case"mousedown":Te=!0;break;case"contextmenu":case"mouseup":case"dragend":Te=!1,Ue(st,_e,dt);break;case"selectionchange":if(Pe)break;case"keydown":case"keyup":Ue(st,_e,dt)}var Mt;if(ae)e:{switch(et){case"compositionstart":var At="onCompositionStart";break e;case"compositionend":At="onCompositionEnd";break e;case"compositionupdate":At="onCompositionUpdate";break e}At=void 0}else ie?ge(et,_e)&&(At="onCompositionEnd"):et==="keydown"&&_e.keyCode===229&&(At="onCompositionStart");At&&(de&&_e.locale!=="ko"&&(ie||At!=="onCompositionStart"?At==="onCompositionEnd"&&ie&&(Mt=nd()):(kd=dt,ld="value"in kd?kd.value:kd.textContent,ie=!0)),xt=oe(ut,At),0<xt.length&&(At=new Ld(At,et,null,_e,dt),st.push({event:At,listeners:xt}),Mt?At.data=Mt:(Mt=he(_e),Mt!==null&&(At.data=Mt)))),(Mt=ce?je(et,_e):ke(et,_e))&&(ut=oe(ut,"onBeforeInput"),0<ut.length&&(dt=new Ld("onBeforeInput","beforeinput",null,_e,dt),st.push({event:dt,listeners:ut}),dt.data=Mt))}se(st,_)})}function tf(et,_,_e){return{instance:et,listener:_,currentTarget:_e}}function oe(et,_){for(var _e=_+"Capture",tt=[];et!==null;){var nt=et,rt=nt.stateNode;nt.tag===5&&rt!==null&&(nt=rt,rt=Kb(et,_e),rt!=null&&tt.unshift(tf(et,rt,nt)),rt=Kb(et,_),rt!=null&&tt.push(tf(et,rt,nt))),et=et.return}return tt}function vf(et){if(et===null)return null;do et=et.return;while(et&&et.tag!==5);return et||null}function wf(et,_,_e,tt,nt){for(var rt=_._reactName,ot=[];_e!==null&&_e!==tt;){var at=_e,lt=at.alternate,ut=at.stateNode;if(lt!==null&&lt===tt)break;at.tag===5&&ut!==null&&(at=ut,nt?(lt=Kb(_e,rt),lt!=null&&ot.unshift(tf(_e,lt,at))):nt||(lt=Kb(_e,rt),lt!=null&&ot.push(tf(_e,lt,at)))),_e=_e.return}ot.length!==0&&et.push({event:_,listeners:ot})}var xf=/\r\n?/g,yf=/\u0000|\uFFFD/g;function zf(et){return(typeof et=="string"?et:""+et).replace(xf,`
`).replace(yf,"")}function Af(et,_,_e){if(_=zf(_),zf(et)!==_&&_e)throw Error(p$4(425))}function Bf(){}var Cf=null,Df=null;function Ef(et,_){return et==="textarea"||et==="noscript"||typeof _.children=="string"||typeof _.children=="number"||typeof _.dangerouslySetInnerHTML=="object"&&_.dangerouslySetInnerHTML!==null&&_.dangerouslySetInnerHTML.__html!=null}var Ff=typeof setTimeout=="function"?setTimeout:void 0,Gf=typeof clearTimeout=="function"?clearTimeout:void 0,Hf=typeof Promise=="function"?Promise:void 0,Jf=typeof queueMicrotask=="function"?queueMicrotask:typeof Hf<"u"?function(et){return Hf.resolve(null).then(et).catch(If$1)}:Ff;function If$1(et){setTimeout(function(){throw et})}function Kf(et,_){var _e=_,tt=0;do{var nt=_e.nextSibling;if(et.removeChild(_e),nt&&nt.nodeType===8)if(_e=nt.data,_e==="/$"){if(tt===0){et.removeChild(nt),bd(_);return}tt--}else _e!=="$"&&_e!=="$?"&&_e!=="$!"||tt++;_e=nt}while(_e);bd(_)}function Lf(et){for(;et!=null;et=et.nextSibling){var _=et.nodeType;if(_===1||_===3)break;if(_===8){if(_=et.data,_==="$"||_==="$!"||_==="$?")break;if(_==="/$")return null}}return et}function Mf(et){et=et.previousSibling;for(var _=0;et;){if(et.nodeType===8){var _e=et.data;if(_e==="$"||_e==="$!"||_e==="$?"){if(_===0)return et;_--}else _e==="/$"&&_++}et=et.previousSibling}return null}var Nf=Math.random().toString(36).slice(2),Of="__reactFiber$"+Nf,Pf="__reactProps$"+Nf,uf="__reactContainer$"+Nf,of="__reactEvents$"+Nf,Qf="__reactListeners$"+Nf,Rf="__reactHandles$"+Nf;function Wc(et){var _=et[Of];if(_)return _;for(var _e=et.parentNode;_e;){if(_=_e[uf]||_e[Of]){if(_e=_.alternate,_.child!==null||_e!==null&&_e.child!==null)for(et=Mf(et);et!==null;){if(_e=et[Of])return _e;et=Mf(et)}return _}et=_e,_e=et.parentNode}return null}function Cb(et){return et=et[Of]||et[uf],!et||et.tag!==5&&et.tag!==6&&et.tag!==13&&et.tag!==3?null:et}function ue(et){if(et.tag===5||et.tag===6)return et.stateNode;throw Error(p$4(33))}function Db(et){return et[Pf]||null}var Sf=[],Tf=-1;function Uf(et){return{current:et}}function E$1(et){0>Tf||(et.current=Sf[Tf],Sf[Tf]=null,Tf--)}function G$1(et,_){Tf++,Sf[Tf]=et.current,et.current=_}var Vf={},H$2=Uf(Vf),Wf=Uf(!1),Xf=Vf;function Yf(et,_){var _e=et.type.contextTypes;if(!_e)return Vf;var tt=et.stateNode;if(tt&&tt.__reactInternalMemoizedUnmaskedChildContext===_)return tt.__reactInternalMemoizedMaskedChildContext;var nt={},rt;for(rt in _e)nt[rt]=_[rt];return tt&&(et=et.stateNode,et.__reactInternalMemoizedUnmaskedChildContext=_,et.__reactInternalMemoizedMaskedChildContext=nt),nt}function Zf(et){return et=et.childContextTypes,et!=null}function $f(){E$1(Wf),E$1(H$2)}function ag(et,_,_e){if(H$2.current!==Vf)throw Error(p$4(168));G$1(H$2,_),G$1(Wf,_e)}function bg(et,_,_e){var tt=et.stateNode;if(_=_.childContextTypes,typeof tt.getChildContext!="function")return _e;tt=tt.getChildContext();for(var nt in tt)if(!(nt in _))throw Error(p$4(108,Ra(et)||"Unknown",nt));return A$1({},_e,tt)}function cg(et){return et=(et=et.stateNode)&&et.__reactInternalMemoizedMergedChildContext||Vf,Xf=H$2.current,G$1(H$2,et),G$1(Wf,Wf.current),!0}function dg(et,_,_e){var tt=et.stateNode;if(!tt)throw Error(p$4(169));_e?(et=bg(et,_,Xf),tt.__reactInternalMemoizedMergedChildContext=et,E$1(Wf),E$1(H$2),G$1(H$2,et)):E$1(Wf),G$1(Wf,_e)}var eg=null,fg=!1,gg=!1;function hg(et){eg===null?eg=[et]:eg.push(et)}function ig(et){fg=!0,hg(et)}function jg(){if(!gg&&eg!==null){gg=!0;var et=0,_=C$1;try{var _e=eg;for(C$1=1;et<_e.length;et++){var tt=_e[et];do tt=tt(!0);while(tt!==null)}eg=null,fg=!1}catch(nt){throw eg!==null&&(eg=eg.slice(et+1)),ac(fc,jg),nt}finally{C$1=_,gg=!1}}return null}var kg=[],lg=0,mg=null,ng=0,og=[],pg=0,qg=null,rg=1,sg="";function tg(et,_){kg[lg++]=ng,kg[lg++]=mg,mg=et,ng=_}function ug(et,_,_e){og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,qg=et;var tt=rg;et=sg;var nt=32-oc(tt)-1;tt&=~(1<<nt),_e+=1;var rt=32-oc(_)+nt;if(30<rt){var ot=nt-nt%5;rt=(tt&(1<<ot)-1).toString(32),tt>>=ot,nt-=ot,rg=1<<32-oc(_)+nt|_e<<nt|tt,sg=rt+et}else rg=1<<rt|_e<<nt|tt,sg=et}function vg(et){et.return!==null&&(tg(et,1),ug(et,1,0))}function wg(et){for(;et===mg;)mg=kg[--lg],kg[lg]=null,ng=kg[--lg],kg[lg]=null;for(;et===qg;)qg=og[--pg],og[pg]=null,sg=og[--pg],og[pg]=null,rg=og[--pg],og[pg]=null}var xg=null,yg=null,I$3=!1,zg=null;function Ag(et,_){var _e=Bg(5,null,null,0);_e.elementType="DELETED",_e.stateNode=_,_e.return=et,_=et.deletions,_===null?(et.deletions=[_e],et.flags|=16):_.push(_e)}function Cg(et,_){switch(et.tag){case 5:var _e=et.type;return _=_.nodeType!==1||_e.toLowerCase()!==_.nodeName.toLowerCase()?null:_,_!==null?(et.stateNode=_,xg=et,yg=Lf(_.firstChild),!0):!1;case 6:return _=et.pendingProps===""||_.nodeType!==3?null:_,_!==null?(et.stateNode=_,xg=et,yg=null,!0):!1;case 13:return _=_.nodeType!==8?null:_,_!==null?(_e=qg!==null?{id:rg,overflow:sg}:null,et.memoizedState={dehydrated:_,treeContext:_e,retryLane:1073741824},_e=Bg(18,null,null,0),_e.stateNode=_,_e.return=et,et.child=_e,xg=et,yg=null,!0):!1;default:return!1}}function Dg(et){return(et.mode&1)!==0&&(et.flags&128)===0}function Eg(et){if(I$3){var _=yg;if(_){var _e=_;if(!Cg(et,_)){if(Dg(et))throw Error(p$4(418));_=Lf(_e.nextSibling);var tt=xg;_&&Cg(et,_)?Ag(tt,_e):(et.flags=et.flags&-4097|2,I$3=!1,xg=et)}}else{if(Dg(et))throw Error(p$4(418));et.flags=et.flags&-4097|2,I$3=!1,xg=et}}}function Fg(et){for(et=et.return;et!==null&&et.tag!==5&&et.tag!==3&&et.tag!==13;)et=et.return;xg=et}function Gg(et){if(et!==xg)return!1;if(!I$3)return Fg(et),I$3=!0,!1;var _;if((_=et.tag!==3)&&!(_=et.tag!==5)&&(_=et.type,_=_!=="head"&&_!=="body"&&!Ef(et.type,et.memoizedProps)),_&&(_=yg)){if(Dg(et))throw Hg(),Error(p$4(418));for(;_;)Ag(et,_),_=Lf(_.nextSibling)}if(Fg(et),et.tag===13){if(et=et.memoizedState,et=et!==null?et.dehydrated:null,!et)throw Error(p$4(317));e:{for(et=et.nextSibling,_=0;et;){if(et.nodeType===8){var _e=et.data;if(_e==="/$"){if(_===0){yg=Lf(et.nextSibling);break e}_--}else _e!=="$"&&_e!=="$!"&&_e!=="$?"||_++}et=et.nextSibling}yg=null}}else yg=xg?Lf(et.stateNode.nextSibling):null;return!0}function Hg(){for(var et=yg;et;)et=Lf(et.nextSibling)}function Ig(){yg=xg=null,I$3=!1}function Jg(et){zg===null?zg=[et]:zg.push(et)}var Kg=ua.ReactCurrentBatchConfig;function Lg(et,_,_e){if(et=_e.ref,et!==null&&typeof et!="function"&&typeof et!="object"){if(_e._owner){if(_e=_e._owner,_e){if(_e.tag!==1)throw Error(p$4(309));var tt=_e.stateNode}if(!tt)throw Error(p$4(147,et));var nt=tt,rt=""+et;return _!==null&&_.ref!==null&&typeof _.ref=="function"&&_.ref._stringRef===rt?_.ref:(_=function(ot){var at=nt.refs;ot===null?delete at[rt]:at[rt]=ot},_._stringRef=rt,_)}if(typeof et!="string")throw Error(p$4(284));if(!_e._owner)throw Error(p$4(290,et))}return et}function Mg(et,_){throw et=Object.prototype.toString.call(_),Error(p$4(31,et==="[object Object]"?"object with keys {"+Object.keys(_).join(", ")+"}":et))}function Ng(et){var _=et._init;return _(et._payload)}function Og(et){function _(pt,_t){if(et){var vt=pt.deletions;vt===null?(pt.deletions=[_t],pt.flags|=16):vt.push(_t)}}function _e(pt,_t){if(!et)return null;for(;_t!==null;)_(pt,_t),_t=_t.sibling;return null}function tt(pt,_t){for(pt=new Map;_t!==null;)_t.key!==null?pt.set(_t.key,_t):pt.set(_t.index,_t),_t=_t.sibling;return pt}function nt(pt,_t){return pt=Pg(pt,_t),pt.index=0,pt.sibling=null,pt}function rt(pt,_t,vt){return pt.index=vt,et?(vt=pt.alternate,vt!==null?(vt=vt.index,vt<_t?(pt.flags|=2,_t):vt):(pt.flags|=2,_t)):(pt.flags|=1048576,_t)}function ot(pt){return et&&pt.alternate===null&&(pt.flags|=2),pt}function at(pt,_t,vt,bt){return _t===null||_t.tag!==6?(_t=Qg(vt,pt.mode,bt),_t.return=pt,_t):(_t=nt(_t,vt),_t.return=pt,_t)}function lt(pt,_t,vt,bt){var wt=vt.type;return wt===ya?dt(pt,_t,vt.props.children,bt,vt.key):_t!==null&&(_t.elementType===wt||typeof wt=="object"&&wt!==null&&wt.$$typeof===Ha&&Ng(wt)===_t.type)?(bt=nt(_t,vt.props),bt.ref=Lg(pt,_t,vt),bt.return=pt,bt):(bt=Rg(vt.type,vt.key,vt.props,null,pt.mode,bt),bt.ref=Lg(pt,_t,vt),bt.return=pt,bt)}function ut(pt,_t,vt,bt){return _t===null||_t.tag!==4||_t.stateNode.containerInfo!==vt.containerInfo||_t.stateNode.implementation!==vt.implementation?(_t=Sg(vt,pt.mode,bt),_t.return=pt,_t):(_t=nt(_t,vt.children||[]),_t.return=pt,_t)}function dt(pt,_t,vt,bt,wt){return _t===null||_t.tag!==7?(_t=Tg(vt,pt.mode,bt,wt),_t.return=pt,_t):(_t=nt(_t,vt),_t.return=pt,_t)}function st(pt,_t,vt){if(typeof _t=="string"&&_t!==""||typeof _t=="number")return _t=Qg(""+_t,pt.mode,vt),_t.return=pt,_t;if(typeof _t=="object"&&_t!==null){switch(_t.$$typeof){case va:return vt=Rg(_t.type,_t.key,_t.props,null,pt.mode,vt),vt.ref=Lg(pt,null,_t),vt.return=pt,vt;case wa:return _t=Sg(_t,pt.mode,vt),_t.return=pt,_t;case Ha:var bt=_t._init;return st(pt,bt(_t._payload),vt)}if(eb(_t)||Ka(_t))return _t=Tg(_t,pt.mode,vt,null),_t.return=pt,_t;Mg(pt,_t)}return null}function it(pt,_t,vt,bt){var wt=_t!==null?_t.key:null;if(typeof vt=="string"&&vt!==""||typeof vt=="number")return wt!==null?null:at(pt,_t,""+vt,bt);if(typeof vt=="object"&&vt!==null){switch(vt.$$typeof){case va:return vt.key===wt?lt(pt,_t,vt,bt):null;case wa:return vt.key===wt?ut(pt,_t,vt,bt):null;case Ha:return wt=vt._init,it(pt,_t,wt(vt._payload),bt)}if(eb(vt)||Ka(vt))return wt!==null?null:dt(pt,_t,vt,bt,null);Mg(pt,vt)}return null}function ct(pt,_t,vt,bt,wt){if(typeof bt=="string"&&bt!==""||typeof bt=="number")return pt=pt.get(vt)||null,at(_t,pt,""+bt,wt);if(typeof bt=="object"&&bt!==null){switch(bt.$$typeof){case va:return pt=pt.get(bt.key===null?vt:bt.key)||null,lt(_t,pt,bt,wt);case wa:return pt=pt.get(bt.key===null?vt:bt.key)||null,ut(_t,pt,bt,wt);case Ha:var xt=bt._init;return ct(pt,_t,vt,xt(bt._payload),wt)}if(eb(bt)||Ka(bt))return pt=pt.get(vt)||null,dt(_t,pt,bt,wt,null);Mg(_t,bt)}return null}function ft(pt,_t,vt,bt){for(var wt=null,xt=null,Mt=_t,At=_t=0,St=null;Mt!==null&&At<vt.length;At++){Mt.index>At?(St=Mt,Mt=null):St=Mt.sibling;var Tt=it(pt,Mt,vt[At],bt);if(Tt===null){Mt===null&&(Mt=St);break}et&&Mt&&Tt.alternate===null&&_(pt,Mt),_t=rt(Tt,_t,At),xt===null?wt=Tt:xt.sibling=Tt,xt=Tt,Mt=St}if(At===vt.length)return _e(pt,Mt),I$3&&tg(pt,At),wt;if(Mt===null){for(;At<vt.length;At++)Mt=st(pt,vt[At],bt),Mt!==null&&(_t=rt(Mt,_t,At),xt===null?wt=Mt:xt.sibling=Mt,xt=Mt);return I$3&&tg(pt,At),wt}for(Mt=tt(pt,Mt);At<vt.length;At++)St=ct(Mt,pt,At,vt[At],bt),St!==null&&(et&&St.alternate!==null&&Mt.delete(St.key===null?At:St.key),_t=rt(St,_t,At),xt===null?wt=St:xt.sibling=St,xt=St);return et&&Mt.forEach(function(Ct){return _(pt,Ct)}),I$3&&tg(pt,At),wt}function ht(pt,_t,vt,bt){var wt=Ka(vt);if(typeof wt!="function")throw Error(p$4(150));if(vt=wt.call(vt),vt==null)throw Error(p$4(151));for(var xt=wt=null,Mt=_t,At=_t=0,St=null,Tt=vt.next();Mt!==null&&!Tt.done;At++,Tt=vt.next()){Mt.index>At?(St=Mt,Mt=null):St=Mt.sibling;var Ct=it(pt,Mt,Tt.value,bt);if(Ct===null){Mt===null&&(Mt=St);break}et&&Mt&&Ct.alternate===null&&_(pt,Mt),_t=rt(Ct,_t,At),xt===null?wt=Ct:xt.sibling=Ct,xt=Ct,Mt=St}if(Tt.done)return _e(pt,Mt),I$3&&tg(pt,At),wt;if(Mt===null){for(;!Tt.done;At++,Tt=vt.next())Tt=st(pt,Tt.value,bt),Tt!==null&&(_t=rt(Tt,_t,At),xt===null?wt=Tt:xt.sibling=Tt,xt=Tt);return I$3&&tg(pt,At),wt}for(Mt=tt(pt,Mt);!Tt.done;At++,Tt=vt.next())Tt=ct(Mt,pt,At,Tt.value,bt),Tt!==null&&(et&&Tt.alternate!==null&&Mt.delete(Tt.key===null?At:Tt.key),_t=rt(Tt,_t,At),xt===null?wt=Tt:xt.sibling=Tt,xt=Tt);return et&&Mt.forEach(function(It){return _(pt,It)}),I$3&&tg(pt,At),wt}function mt(pt,_t,vt,bt){if(typeof vt=="object"&&vt!==null&&vt.type===ya&&vt.key===null&&(vt=vt.props.children),typeof vt=="object"&&vt!==null){switch(vt.$$typeof){case va:e:{for(var wt=vt.key,xt=_t;xt!==null;){if(xt.key===wt){if(wt=vt.type,wt===ya){if(xt.tag===7){_e(pt,xt.sibling),_t=nt(xt,vt.props.children),_t.return=pt,pt=_t;break e}}else if(xt.elementType===wt||typeof wt=="object"&&wt!==null&&wt.$$typeof===Ha&&Ng(wt)===xt.type){_e(pt,xt.sibling),_t=nt(xt,vt.props),_t.ref=Lg(pt,xt,vt),_t.return=pt,pt=_t;break e}_e(pt,xt);break}else _(pt,xt);xt=xt.sibling}vt.type===ya?(_t=Tg(vt.props.children,pt.mode,bt,vt.key),_t.return=pt,pt=_t):(bt=Rg(vt.type,vt.key,vt.props,null,pt.mode,bt),bt.ref=Lg(pt,_t,vt),bt.return=pt,pt=bt)}return ot(pt);case wa:e:{for(xt=vt.key;_t!==null;){if(_t.key===xt)if(_t.tag===4&&_t.stateNode.containerInfo===vt.containerInfo&&_t.stateNode.implementation===vt.implementation){_e(pt,_t.sibling),_t=nt(_t,vt.children||[]),_t.return=pt,pt=_t;break e}else{_e(pt,_t);break}else _(pt,_t);_t=_t.sibling}_t=Sg(vt,pt.mode,bt),_t.return=pt,pt=_t}return ot(pt);case Ha:return xt=vt._init,mt(pt,_t,xt(vt._payload),bt)}if(eb(vt))return ft(pt,_t,vt,bt);if(Ka(vt))return ht(pt,_t,vt,bt);Mg(pt,vt)}return typeof vt=="string"&&vt!==""||typeof vt=="number"?(vt=""+vt,_t!==null&&_t.tag===6?(_e(pt,_t.sibling),_t=nt(_t,vt),_t.return=pt,pt=_t):(_e(pt,_t),_t=Qg(vt,pt.mode,bt),_t.return=pt,pt=_t),ot(pt)):_e(pt,_t)}return mt}var Ug=Og(!0),Vg=Og(!1),Wg=Uf(null),Xg=null,Yg=null,Zg=null;function $g(){Zg=Yg=Xg=null}function ah(et){var _=Wg.current;E$1(Wg),et._currentValue=_}function bh(et,_,_e){for(;et!==null;){var tt=et.alternate;if((et.childLanes&_)!==_?(et.childLanes|=_,tt!==null&&(tt.childLanes|=_)):tt!==null&&(tt.childLanes&_)!==_&&(tt.childLanes|=_),et===_e)break;et=et.return}}function ch(et,_){Xg=et,Zg=Yg=null,et=et.dependencies,et!==null&&et.firstContext!==null&&(et.lanes&_&&(dh=!0),et.firstContext=null)}function eh(et){var _=et._currentValue;if(Zg!==et)if(et={context:et,memoizedValue:_,next:null},Yg===null){if(Xg===null)throw Error(p$4(308));Yg=et,Xg.dependencies={lanes:0,firstContext:et}}else Yg=Yg.next=et;return _}var fh=null;function gh(et){fh===null?fh=[et]:fh.push(et)}function hh(et,_,_e,tt){var nt=_.interleaved;return nt===null?(_e.next=_e,gh(_)):(_e.next=nt.next,nt.next=_e),_.interleaved=_e,ih(et,tt)}function ih(et,_){et.lanes|=_;var _e=et.alternate;for(_e!==null&&(_e.lanes|=_),_e=et,et=et.return;et!==null;)et.childLanes|=_,_e=et.alternate,_e!==null&&(_e.childLanes|=_),_e=et,et=et.return;return _e.tag===3?_e.stateNode:null}var jh=!1;function kh(et){et.updateQueue={baseState:et.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function lh(et,_){et=et.updateQueue,_.updateQueue===et&&(_.updateQueue={baseState:et.baseState,firstBaseUpdate:et.firstBaseUpdate,lastBaseUpdate:et.lastBaseUpdate,shared:et.shared,effects:et.effects})}function mh(et,_){return{eventTime:et,lane:_,tag:0,payload:null,callback:null,next:null}}function nh(et,_,_e){var tt=et.updateQueue;if(tt===null)return null;if(tt=tt.shared,K&2){var nt=tt.pending;return nt===null?_.next=_:(_.next=nt.next,nt.next=_),tt.pending=_,ih(et,_e)}return nt=tt.interleaved,nt===null?(_.next=_,gh(tt)):(_.next=nt.next,nt.next=_),tt.interleaved=_,ih(et,_e)}function oh(et,_,_e){if(_=_.updateQueue,_!==null&&(_=_.shared,(_e&4194240)!==0)){var tt=_.lanes;tt&=et.pendingLanes,_e|=tt,_.lanes=_e,Cc(et,_e)}}function ph(et,_){var _e=et.updateQueue,tt=et.alternate;if(tt!==null&&(tt=tt.updateQueue,_e===tt)){var nt=null,rt=null;if(_e=_e.firstBaseUpdate,_e!==null){do{var ot={eventTime:_e.eventTime,lane:_e.lane,tag:_e.tag,payload:_e.payload,callback:_e.callback,next:null};rt===null?nt=rt=ot:rt=rt.next=ot,_e=_e.next}while(_e!==null);rt===null?nt=rt=_:rt=rt.next=_}else nt=rt=_;_e={baseState:tt.baseState,firstBaseUpdate:nt,lastBaseUpdate:rt,shared:tt.shared,effects:tt.effects},et.updateQueue=_e;return}et=_e.lastBaseUpdate,et===null?_e.firstBaseUpdate=_:et.next=_,_e.lastBaseUpdate=_}function qh(et,_,_e,tt){var nt=et.updateQueue;jh=!1;var rt=nt.firstBaseUpdate,ot=nt.lastBaseUpdate,at=nt.shared.pending;if(at!==null){nt.shared.pending=null;var lt=at,ut=lt.next;lt.next=null,ot===null?rt=ut:ot.next=ut,ot=lt;var dt=et.alternate;dt!==null&&(dt=dt.updateQueue,at=dt.lastBaseUpdate,at!==ot&&(at===null?dt.firstBaseUpdate=ut:at.next=ut,dt.lastBaseUpdate=lt))}if(rt!==null){var st=nt.baseState;ot=0,dt=ut=lt=null,at=rt;do{var it=at.lane,ct=at.eventTime;if((tt&it)===it){dt!==null&&(dt=dt.next={eventTime:ct,lane:0,tag:at.tag,payload:at.payload,callback:at.callback,next:null});e:{var ft=et,ht=at;switch(it=_,ct=_e,ht.tag){case 1:if(ft=ht.payload,typeof ft=="function"){st=ft.call(ct,st,it);break e}st=ft;break e;case 3:ft.flags=ft.flags&-65537|128;case 0:if(ft=ht.payload,it=typeof ft=="function"?ft.call(ct,st,it):ft,it==null)break e;st=A$1({},st,it);break e;case 2:jh=!0}}at.callback!==null&&at.lane!==0&&(et.flags|=64,it=nt.effects,it===null?nt.effects=[at]:it.push(at))}else ct={eventTime:ct,lane:it,tag:at.tag,payload:at.payload,callback:at.callback,next:null},dt===null?(ut=dt=ct,lt=st):dt=dt.next=ct,ot|=it;if(at=at.next,at===null){if(at=nt.shared.pending,at===null)break;it=at,at=it.next,it.next=null,nt.lastBaseUpdate=it,nt.shared.pending=null}}while(!0);if(dt===null&&(lt=st),nt.baseState=lt,nt.firstBaseUpdate=ut,nt.lastBaseUpdate=dt,_=nt.shared.interleaved,_!==null){nt=_;do ot|=nt.lane,nt=nt.next;while(nt!==_)}else rt===null&&(nt.shared.lanes=0);rh|=ot,et.lanes=ot,et.memoizedState=st}}function sh(et,_,_e){if(et=_.effects,_.effects=null,et!==null)for(_=0;_<et.length;_++){var tt=et[_],nt=tt.callback;if(nt!==null){if(tt.callback=null,tt=_e,typeof nt!="function")throw Error(p$4(191,nt));nt.call(tt)}}}var th={},uh=Uf(th),vh=Uf(th),wh=Uf(th);function xh(et){if(et===th)throw Error(p$4(174));return et}function yh(et,_){switch(G$1(wh,_),G$1(vh,et),G$1(uh,th),et=_.nodeType,et){case 9:case 11:_=(_=_.documentElement)?_.namespaceURI:lb(null,"");break;default:et=et===8?_.parentNode:_,_=et.namespaceURI||null,et=et.tagName,_=lb(_,et)}E$1(uh),G$1(uh,_)}function zh(){E$1(uh),E$1(vh),E$1(wh)}function Ah(et){xh(wh.current);var _=xh(uh.current),_e=lb(_,et.type);_!==_e&&(G$1(vh,et),G$1(uh,_e))}function Bh(et){vh.current===et&&(E$1(uh),E$1(vh))}var L$2=Uf(0);function Ch(et){for(var _=et;_!==null;){if(_.tag===13){var _e=_.memoizedState;if(_e!==null&&(_e=_e.dehydrated,_e===null||_e.data==="$?"||_e.data==="$!"))return _}else if(_.tag===19&&_.memoizedProps.revealOrder!==void 0){if(_.flags&128)return _}else if(_.child!==null){_.child.return=_,_=_.child;continue}if(_===et)break;for(;_.sibling===null;){if(_.return===null||_.return===et)return null;_=_.return}_.sibling.return=_.return,_=_.sibling}return null}var Dh=[];function Eh(){for(var et=0;et<Dh.length;et++)Dh[et]._workInProgressVersionPrimary=null;Dh.length=0}var Fh=ua.ReactCurrentDispatcher,Gh=ua.ReactCurrentBatchConfig,Hh=0,M$2=null,N$2=null,O$1=null,Ih=!1,Jh=!1,Kh=0,Lh=0;function P$1(){throw Error(p$4(321))}function Mh(et,_){if(_===null)return!1;for(var _e=0;_e<_.length&&_e<et.length;_e++)if(!He(et[_e],_[_e]))return!1;return!0}function Nh(et,_,_e,tt,nt,rt){if(Hh=rt,M$2=_,_.memoizedState=null,_.updateQueue=null,_.lanes=0,Fh.current=et===null||et.memoizedState===null?Oh:Ph,et=_e(tt,nt),Jh){rt=0;do{if(Jh=!1,Kh=0,25<=rt)throw Error(p$4(301));rt+=1,O$1=N$2=null,_.updateQueue=null,Fh.current=Qh,et=_e(tt,nt)}while(Jh)}if(Fh.current=Rh,_=N$2!==null&&N$2.next!==null,Hh=0,O$1=N$2=M$2=null,Ih=!1,_)throw Error(p$4(300));return et}function Sh(){var et=Kh!==0;return Kh=0,et}function Th(){var et={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return O$1===null?M$2.memoizedState=O$1=et:O$1=O$1.next=et,O$1}function Uh(){if(N$2===null){var et=M$2.alternate;et=et!==null?et.memoizedState:null}else et=N$2.next;var _=O$1===null?M$2.memoizedState:O$1.next;if(_!==null)O$1=_,N$2=et;else{if(et===null)throw Error(p$4(310));N$2=et,et={memoizedState:N$2.memoizedState,baseState:N$2.baseState,baseQueue:N$2.baseQueue,queue:N$2.queue,next:null},O$1===null?M$2.memoizedState=O$1=et:O$1=O$1.next=et}return O$1}function Vh(et,_){return typeof _=="function"?_(et):_}function Wh(et){var _=Uh(),_e=_.queue;if(_e===null)throw Error(p$4(311));_e.lastRenderedReducer=et;var tt=N$2,nt=tt.baseQueue,rt=_e.pending;if(rt!==null){if(nt!==null){var ot=nt.next;nt.next=rt.next,rt.next=ot}tt.baseQueue=nt=rt,_e.pending=null}if(nt!==null){rt=nt.next,tt=tt.baseState;var at=ot=null,lt=null,ut=rt;do{var dt=ut.lane;if((Hh&dt)===dt)lt!==null&&(lt=lt.next={lane:0,action:ut.action,hasEagerState:ut.hasEagerState,eagerState:ut.eagerState,next:null}),tt=ut.hasEagerState?ut.eagerState:et(tt,ut.action);else{var st={lane:dt,action:ut.action,hasEagerState:ut.hasEagerState,eagerState:ut.eagerState,next:null};lt===null?(at=lt=st,ot=tt):lt=lt.next=st,M$2.lanes|=dt,rh|=dt}ut=ut.next}while(ut!==null&&ut!==rt);lt===null?ot=tt:lt.next=at,He(tt,_.memoizedState)||(dh=!0),_.memoizedState=tt,_.baseState=ot,_.baseQueue=lt,_e.lastRenderedState=tt}if(et=_e.interleaved,et!==null){nt=et;do rt=nt.lane,M$2.lanes|=rt,rh|=rt,nt=nt.next;while(nt!==et)}else nt===null&&(_e.lanes=0);return[_.memoizedState,_e.dispatch]}function Xh(et){var _=Uh(),_e=_.queue;if(_e===null)throw Error(p$4(311));_e.lastRenderedReducer=et;var tt=_e.dispatch,nt=_e.pending,rt=_.memoizedState;if(nt!==null){_e.pending=null;var ot=nt=nt.next;do rt=et(rt,ot.action),ot=ot.next;while(ot!==nt);He(rt,_.memoizedState)||(dh=!0),_.memoizedState=rt,_.baseQueue===null&&(_.baseState=rt),_e.lastRenderedState=rt}return[rt,tt]}function Yh(){}function Zh(et,_){var _e=M$2,tt=Uh(),nt=_(),rt=!He(tt.memoizedState,nt);if(rt&&(tt.memoizedState=nt,dh=!0),tt=tt.queue,$h(ai.bind(null,_e,tt,et),[et]),tt.getSnapshot!==_||rt||O$1!==null&&O$1.memoizedState.tag&1){if(_e.flags|=2048,bi(9,ci.bind(null,_e,tt,nt,_),void 0,null),Q$1===null)throw Error(p$4(349));Hh&30||di(_e,_,nt)}return nt}function di(et,_,_e){et.flags|=16384,et={getSnapshot:_,value:_e},_=M$2.updateQueue,_===null?(_={lastEffect:null,stores:null},M$2.updateQueue=_,_.stores=[et]):(_e=_.stores,_e===null?_.stores=[et]:_e.push(et))}function ci(et,_,_e,tt){_.value=_e,_.getSnapshot=tt,ei(_)&&fi(et)}function ai(et,_,_e){return _e(function(){ei(_)&&fi(et)})}function ei(et){var _=et.getSnapshot;et=et.value;try{var _e=_();return!He(et,_e)}catch{return!0}}function fi(et){var _=ih(et,1);_!==null&&gi(_,et,1,-1)}function hi(et){var _=Th();return typeof et=="function"&&(et=et()),_.memoizedState=_.baseState=et,et={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Vh,lastRenderedState:et},_.queue=et,et=et.dispatch=ii.bind(null,M$2,et),[_.memoizedState,et]}function bi(et,_,_e,tt){return et={tag:et,create:_,destroy:_e,deps:tt,next:null},_=M$2.updateQueue,_===null?(_={lastEffect:null,stores:null},M$2.updateQueue=_,_.lastEffect=et.next=et):(_e=_.lastEffect,_e===null?_.lastEffect=et.next=et:(tt=_e.next,_e.next=et,et.next=tt,_.lastEffect=et)),et}function ji(){return Uh().memoizedState}function ki(et,_,_e,tt){var nt=Th();M$2.flags|=et,nt.memoizedState=bi(1|_,_e,void 0,tt===void 0?null:tt)}function li(et,_,_e,tt){var nt=Uh();tt=tt===void 0?null:tt;var rt=void 0;if(N$2!==null){var ot=N$2.memoizedState;if(rt=ot.destroy,tt!==null&&Mh(tt,ot.deps)){nt.memoizedState=bi(_,_e,rt,tt);return}}M$2.flags|=et,nt.memoizedState=bi(1|_,_e,rt,tt)}function mi(et,_){return ki(8390656,8,et,_)}function $h(et,_){return li(2048,8,et,_)}function ni(et,_){return li(4,2,et,_)}function oi(et,_){return li(4,4,et,_)}function pi(et,_){if(typeof _=="function")return et=et(),_(et),function(){_(null)};if(_!=null)return et=et(),_.current=et,function(){_.current=null}}function qi(et,_,_e){return _e=_e!=null?_e.concat([et]):null,li(4,4,pi.bind(null,_,et),_e)}function ri(){}function si(et,_){var _e=Uh();_=_===void 0?null:_;var tt=_e.memoizedState;return tt!==null&&_!==null&&Mh(_,tt[1])?tt[0]:(_e.memoizedState=[et,_],et)}function ti(et,_){var _e=Uh();_=_===void 0?null:_;var tt=_e.memoizedState;return tt!==null&&_!==null&&Mh(_,tt[1])?tt[0]:(et=et(),_e.memoizedState=[et,_],et)}function ui(et,_,_e){return Hh&21?(He(_e,_)||(_e=yc(),M$2.lanes|=_e,rh|=_e,et.baseState=!0),_):(et.baseState&&(et.baseState=!1,dh=!0),et.memoizedState=_e)}function vi(et,_){var _e=C$1;C$1=_e!==0&&4>_e?_e:4,et(!0);var tt=Gh.transition;Gh.transition={};try{et(!1),_()}finally{C$1=_e,Gh.transition=tt}}function wi(){return Uh().memoizedState}function xi(et,_,_e){var tt=yi(et);if(_e={lane:tt,action:_e,hasEagerState:!1,eagerState:null,next:null},zi(et))Ai(_,_e);else if(_e=hh(et,_,_e,tt),_e!==null){var nt=R$1();gi(_e,et,tt,nt),Bi(_e,_,tt)}}function ii(et,_,_e){var tt=yi(et),nt={lane:tt,action:_e,hasEagerState:!1,eagerState:null,next:null};if(zi(et))Ai(_,nt);else{var rt=et.alternate;if(et.lanes===0&&(rt===null||rt.lanes===0)&&(rt=_.lastRenderedReducer,rt!==null))try{var ot=_.lastRenderedState,at=rt(ot,_e);if(nt.hasEagerState=!0,nt.eagerState=at,He(at,ot)){var lt=_.interleaved;lt===null?(nt.next=nt,gh(_)):(nt.next=lt.next,lt.next=nt),_.interleaved=nt;return}}catch{}finally{}_e=hh(et,_,nt,tt),_e!==null&&(nt=R$1(),gi(_e,et,tt,nt),Bi(_e,_,tt))}}function zi(et){var _=et.alternate;return et===M$2||_!==null&&_===M$2}function Ai(et,_){Jh=Ih=!0;var _e=et.pending;_e===null?_.next=_:(_.next=_e.next,_e.next=_),et.pending=_}function Bi(et,_,_e){if(_e&4194240){var tt=_.lanes;tt&=et.pendingLanes,_e|=tt,_.lanes=_e,Cc(et,_e)}}var Rh={readContext:eh,useCallback:P$1,useContext:P$1,useEffect:P$1,useImperativeHandle:P$1,useInsertionEffect:P$1,useLayoutEffect:P$1,useMemo:P$1,useReducer:P$1,useRef:P$1,useState:P$1,useDebugValue:P$1,useDeferredValue:P$1,useTransition:P$1,useMutableSource:P$1,useSyncExternalStore:P$1,useId:P$1,unstable_isNewReconciler:!1},Oh={readContext:eh,useCallback:function(et,_){return Th().memoizedState=[et,_===void 0?null:_],et},useContext:eh,useEffect:mi,useImperativeHandle:function(et,_,_e){return _e=_e!=null?_e.concat([et]):null,ki(4194308,4,pi.bind(null,_,et),_e)},useLayoutEffect:function(et,_){return ki(4194308,4,et,_)},useInsertionEffect:function(et,_){return ki(4,2,et,_)},useMemo:function(et,_){var _e=Th();return _=_===void 0?null:_,et=et(),_e.memoizedState=[et,_],et},useReducer:function(et,_,_e){var tt=Th();return _=_e!==void 0?_e(_):_,tt.memoizedState=tt.baseState=_,et={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:et,lastRenderedState:_},tt.queue=et,et=et.dispatch=xi.bind(null,M$2,et),[tt.memoizedState,et]},useRef:function(et){var _=Th();return et={current:et},_.memoizedState=et},useState:hi,useDebugValue:ri,useDeferredValue:function(et){return Th().memoizedState=et},useTransition:function(){var et=hi(!1),_=et[0];return et=vi.bind(null,et[1]),Th().memoizedState=et,[_,et]},useMutableSource:function(){},useSyncExternalStore:function(et,_,_e){var tt=M$2,nt=Th();if(I$3){if(_e===void 0)throw Error(p$4(407));_e=_e()}else{if(_e=_(),Q$1===null)throw Error(p$4(349));Hh&30||di(tt,_,_e)}nt.memoizedState=_e;var rt={value:_e,getSnapshot:_};return nt.queue=rt,mi(ai.bind(null,tt,rt,et),[et]),tt.flags|=2048,bi(9,ci.bind(null,tt,rt,_e,_),void 0,null),_e},useId:function(){var et=Th(),_=Q$1.identifierPrefix;if(I$3){var _e=sg,tt=rg;_e=(tt&~(1<<32-oc(tt)-1)).toString(32)+_e,_=":"+_+"R"+_e,_e=Kh++,0<_e&&(_+="H"+_e.toString(32)),_+=":"}else _e=Lh++,_=":"+_+"r"+_e.toString(32)+":";return et.memoizedState=_},unstable_isNewReconciler:!1},Ph={readContext:eh,useCallback:si,useContext:eh,useEffect:$h,useImperativeHandle:qi,useInsertionEffect:ni,useLayoutEffect:oi,useMemo:ti,useReducer:Wh,useRef:ji,useState:function(){return Wh(Vh)},useDebugValue:ri,useDeferredValue:function(et){var _=Uh();return ui(_,N$2.memoizedState,et)},useTransition:function(){var et=Wh(Vh)[0],_=Uh().memoizedState;return[et,_]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:wi,unstable_isNewReconciler:!1},Qh={readContext:eh,useCallback:si,useContext:eh,useEffect:$h,useImperativeHandle:qi,useInsertionEffect:ni,useLayoutEffect:oi,useMemo:ti,useReducer:Xh,useRef:ji,useState:function(){return Xh(Vh)},useDebugValue:ri,useDeferredValue:function(et){var _=Uh();return N$2===null?_.memoizedState=et:ui(_,N$2.memoizedState,et)},useTransition:function(){var et=Xh(Vh)[0],_=Uh().memoizedState;return[et,_]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:wi,unstable_isNewReconciler:!1};function Ci(et,_){if(et&&et.defaultProps){_=A$1({},_),et=et.defaultProps;for(var _e in et)_[_e]===void 0&&(_[_e]=et[_e]);return _}return _}function Di(et,_,_e,tt){_=et.memoizedState,_e=_e(tt,_),_e=_e==null?_:A$1({},_,_e),et.memoizedState=_e,et.lanes===0&&(et.updateQueue.baseState=_e)}var Ei={isMounted:function(et){return(et=et._reactInternals)?Vb(et)===et:!1},enqueueSetState:function(et,_,_e){et=et._reactInternals;var tt=R$1(),nt=yi(et),rt=mh(tt,nt);rt.payload=_,_e!=null&&(rt.callback=_e),_=nh(et,rt,nt),_!==null&&(gi(_,et,nt,tt),oh(_,et,nt))},enqueueReplaceState:function(et,_,_e){et=et._reactInternals;var tt=R$1(),nt=yi(et),rt=mh(tt,nt);rt.tag=1,rt.payload=_,_e!=null&&(rt.callback=_e),_=nh(et,rt,nt),_!==null&&(gi(_,et,nt,tt),oh(_,et,nt))},enqueueForceUpdate:function(et,_){et=et._reactInternals;var _e=R$1(),tt=yi(et),nt=mh(_e,tt);nt.tag=2,_!=null&&(nt.callback=_),_=nh(et,nt,tt),_!==null&&(gi(_,et,tt,_e),oh(_,et,tt))}};function Fi(et,_,_e,tt,nt,rt,ot){return et=et.stateNode,typeof et.shouldComponentUpdate=="function"?et.shouldComponentUpdate(tt,rt,ot):_.prototype&&_.prototype.isPureReactComponent?!Ie(_e,tt)||!Ie(nt,rt):!0}function Gi(et,_,_e){var tt=!1,nt=Vf,rt=_.contextType;return typeof rt=="object"&&rt!==null?rt=eh(rt):(nt=Zf(_)?Xf:H$2.current,tt=_.contextTypes,rt=(tt=tt!=null)?Yf(et,nt):Vf),_=new _(_e,rt),et.memoizedState=_.state!==null&&_.state!==void 0?_.state:null,_.updater=Ei,et.stateNode=_,_._reactInternals=et,tt&&(et=et.stateNode,et.__reactInternalMemoizedUnmaskedChildContext=nt,et.__reactInternalMemoizedMaskedChildContext=rt),_}function Hi(et,_,_e,tt){et=_.state,typeof _.componentWillReceiveProps=="function"&&_.componentWillReceiveProps(_e,tt),typeof _.UNSAFE_componentWillReceiveProps=="function"&&_.UNSAFE_componentWillReceiveProps(_e,tt),_.state!==et&&Ei.enqueueReplaceState(_,_.state,null)}function Ii(et,_,_e,tt){var nt=et.stateNode;nt.props=_e,nt.state=et.memoizedState,nt.refs={},kh(et);var rt=_.contextType;typeof rt=="object"&&rt!==null?nt.context=eh(rt):(rt=Zf(_)?Xf:H$2.current,nt.context=Yf(et,rt)),nt.state=et.memoizedState,rt=_.getDerivedStateFromProps,typeof rt=="function"&&(Di(et,_,rt,_e),nt.state=et.memoizedState),typeof _.getDerivedStateFromProps=="function"||typeof nt.getSnapshotBeforeUpdate=="function"||typeof nt.UNSAFE_componentWillMount!="function"&&typeof nt.componentWillMount!="function"||(_=nt.state,typeof nt.componentWillMount=="function"&&nt.componentWillMount(),typeof nt.UNSAFE_componentWillMount=="function"&&nt.UNSAFE_componentWillMount(),_!==nt.state&&Ei.enqueueReplaceState(nt,nt.state,null),qh(et,_e,nt,tt),nt.state=et.memoizedState),typeof nt.componentDidMount=="function"&&(et.flags|=4194308)}function Ji(et,_){try{var _e="",tt=_;do _e+=Pa(tt),tt=tt.return;while(tt);var nt=_e}catch(rt){nt=`
Error generating stack: `+rt.message+`
`+rt.stack}return{value:et,source:_,stack:nt,digest:null}}function Ki(et,_,_e){return{value:et,source:null,stack:_e??null,digest:_??null}}function Li(et,_){try{console.error(_.value)}catch(_e){setTimeout(function(){throw _e})}}var Mi=typeof WeakMap=="function"?WeakMap:Map;function Ni(et,_,_e){_e=mh(-1,_e),_e.tag=3,_e.payload={element:null};var tt=_.value;return _e.callback=function(){Oi||(Oi=!0,Pi=tt),Li(et,_)},_e}function Qi(et,_,_e){_e=mh(-1,_e),_e.tag=3;var tt=et.type.getDerivedStateFromError;if(typeof tt=="function"){var nt=_.value;_e.payload=function(){return tt(nt)},_e.callback=function(){Li(et,_)}}var rt=et.stateNode;return rt!==null&&typeof rt.componentDidCatch=="function"&&(_e.callback=function(){Li(et,_),typeof tt!="function"&&(Ri===null?Ri=new Set([this]):Ri.add(this));var ot=_.stack;this.componentDidCatch(_.value,{componentStack:ot!==null?ot:""})}),_e}function Si(et,_,_e){var tt=et.pingCache;if(tt===null){tt=et.pingCache=new Mi;var nt=new Set;tt.set(_,nt)}else nt=tt.get(_),nt===void 0&&(nt=new Set,tt.set(_,nt));nt.has(_e)||(nt.add(_e),et=Ti.bind(null,et,_,_e),_.then(et,et))}function Ui(et){do{var _;if((_=et.tag===13)&&(_=et.memoizedState,_=_!==null?_.dehydrated!==null:!0),_)return et;et=et.return}while(et!==null);return null}function Vi(et,_,_e,tt,nt){return et.mode&1?(et.flags|=65536,et.lanes=nt,et):(et===_?et.flags|=65536:(et.flags|=128,_e.flags|=131072,_e.flags&=-52805,_e.tag===1&&(_e.alternate===null?_e.tag=17:(_=mh(-1,1),_.tag=2,nh(_e,_,1))),_e.lanes|=1),et)}var Wi=ua.ReactCurrentOwner,dh=!1;function Xi(et,_,_e,tt){_.child=et===null?Vg(_,null,_e,tt):Ug(_,et.child,_e,tt)}function Yi(et,_,_e,tt,nt){_e=_e.render;var rt=_.ref;return ch(_,nt),tt=Nh(et,_,_e,tt,rt,nt),_e=Sh(),et!==null&&!dh?(_.updateQueue=et.updateQueue,_.flags&=-2053,et.lanes&=~nt,Zi(et,_,nt)):(I$3&&_e&&vg(_),_.flags|=1,Xi(et,_,tt,nt),_.child)}function $i(et,_,_e,tt,nt){if(et===null){var rt=_e.type;return typeof rt=="function"&&!aj(rt)&&rt.defaultProps===void 0&&_e.compare===null&&_e.defaultProps===void 0?(_.tag=15,_.type=rt,bj(et,_,rt,tt,nt)):(et=Rg(_e.type,null,tt,_,_.mode,nt),et.ref=_.ref,et.return=_,_.child=et)}if(rt=et.child,!(et.lanes&nt)){var ot=rt.memoizedProps;if(_e=_e.compare,_e=_e!==null?_e:Ie,_e(ot,tt)&&et.ref===_.ref)return Zi(et,_,nt)}return _.flags|=1,et=Pg(rt,tt),et.ref=_.ref,et.return=_,_.child=et}function bj(et,_,_e,tt,nt){if(et!==null){var rt=et.memoizedProps;if(Ie(rt,tt)&&et.ref===_.ref)if(dh=!1,_.pendingProps=tt=rt,(et.lanes&nt)!==0)et.flags&131072&&(dh=!0);else return _.lanes=et.lanes,Zi(et,_,nt)}return cj(et,_,_e,tt,nt)}function dj(et,_,_e){var tt=_.pendingProps,nt=tt.children,rt=et!==null?et.memoizedState:null;if(tt.mode==="hidden")if(!(_.mode&1))_.memoizedState={baseLanes:0,cachePool:null,transitions:null},G$1(ej,fj),fj|=_e;else{if(!(_e&1073741824))return et=rt!==null?rt.baseLanes|_e:_e,_.lanes=_.childLanes=1073741824,_.memoizedState={baseLanes:et,cachePool:null,transitions:null},_.updateQueue=null,G$1(ej,fj),fj|=et,null;_.memoizedState={baseLanes:0,cachePool:null,transitions:null},tt=rt!==null?rt.baseLanes:_e,G$1(ej,fj),fj|=tt}else rt!==null?(tt=rt.baseLanes|_e,_.memoizedState=null):tt=_e,G$1(ej,fj),fj|=tt;return Xi(et,_,nt,_e),_.child}function gj(et,_){var _e=_.ref;(et===null&&_e!==null||et!==null&&et.ref!==_e)&&(_.flags|=512,_.flags|=2097152)}function cj(et,_,_e,tt,nt){var rt=Zf(_e)?Xf:H$2.current;return rt=Yf(_,rt),ch(_,nt),_e=Nh(et,_,_e,tt,rt,nt),tt=Sh(),et!==null&&!dh?(_.updateQueue=et.updateQueue,_.flags&=-2053,et.lanes&=~nt,Zi(et,_,nt)):(I$3&&tt&&vg(_),_.flags|=1,Xi(et,_,_e,nt),_.child)}function hj(et,_,_e,tt,nt){if(Zf(_e)){var rt=!0;cg(_)}else rt=!1;if(ch(_,nt),_.stateNode===null)ij(et,_),Gi(_,_e,tt),Ii(_,_e,tt,nt),tt=!0;else if(et===null){var ot=_.stateNode,at=_.memoizedProps;ot.props=at;var lt=ot.context,ut=_e.contextType;typeof ut=="object"&&ut!==null?ut=eh(ut):(ut=Zf(_e)?Xf:H$2.current,ut=Yf(_,ut));var dt=_e.getDerivedStateFromProps,st=typeof dt=="function"||typeof ot.getSnapshotBeforeUpdate=="function";st||typeof ot.UNSAFE_componentWillReceiveProps!="function"&&typeof ot.componentWillReceiveProps!="function"||(at!==tt||lt!==ut)&&Hi(_,ot,tt,ut),jh=!1;var it=_.memoizedState;ot.state=it,qh(_,tt,ot,nt),lt=_.memoizedState,at!==tt||it!==lt||Wf.current||jh?(typeof dt=="function"&&(Di(_,_e,dt,tt),lt=_.memoizedState),(at=jh||Fi(_,_e,at,tt,it,lt,ut))?(st||typeof ot.UNSAFE_componentWillMount!="function"&&typeof ot.componentWillMount!="function"||(typeof ot.componentWillMount=="function"&&ot.componentWillMount(),typeof ot.UNSAFE_componentWillMount=="function"&&ot.UNSAFE_componentWillMount()),typeof ot.componentDidMount=="function"&&(_.flags|=4194308)):(typeof ot.componentDidMount=="function"&&(_.flags|=4194308),_.memoizedProps=tt,_.memoizedState=lt),ot.props=tt,ot.state=lt,ot.context=ut,tt=at):(typeof ot.componentDidMount=="function"&&(_.flags|=4194308),tt=!1)}else{ot=_.stateNode,lh(et,_),at=_.memoizedProps,ut=_.type===_.elementType?at:Ci(_.type,at),ot.props=ut,st=_.pendingProps,it=ot.context,lt=_e.contextType,typeof lt=="object"&&lt!==null?lt=eh(lt):(lt=Zf(_e)?Xf:H$2.current,lt=Yf(_,lt));var ct=_e.getDerivedStateFromProps;(dt=typeof ct=="function"||typeof ot.getSnapshotBeforeUpdate=="function")||typeof ot.UNSAFE_componentWillReceiveProps!="function"&&typeof ot.componentWillReceiveProps!="function"||(at!==st||it!==lt)&&Hi(_,ot,tt,lt),jh=!1,it=_.memoizedState,ot.state=it,qh(_,tt,ot,nt);var ft=_.memoizedState;at!==st||it!==ft||Wf.current||jh?(typeof ct=="function"&&(Di(_,_e,ct,tt),ft=_.memoizedState),(ut=jh||Fi(_,_e,ut,tt,it,ft,lt)||!1)?(dt||typeof ot.UNSAFE_componentWillUpdate!="function"&&typeof ot.componentWillUpdate!="function"||(typeof ot.componentWillUpdate=="function"&&ot.componentWillUpdate(tt,ft,lt),typeof ot.UNSAFE_componentWillUpdate=="function"&&ot.UNSAFE_componentWillUpdate(tt,ft,lt)),typeof ot.componentDidUpdate=="function"&&(_.flags|=4),typeof ot.getSnapshotBeforeUpdate=="function"&&(_.flags|=1024)):(typeof ot.componentDidUpdate!="function"||at===et.memoizedProps&&it===et.memoizedState||(_.flags|=4),typeof ot.getSnapshotBeforeUpdate!="function"||at===et.memoizedProps&&it===et.memoizedState||(_.flags|=1024),_.memoizedProps=tt,_.memoizedState=ft),ot.props=tt,ot.state=ft,ot.context=lt,tt=ut):(typeof ot.componentDidUpdate!="function"||at===et.memoizedProps&&it===et.memoizedState||(_.flags|=4),typeof ot.getSnapshotBeforeUpdate!="function"||at===et.memoizedProps&&it===et.memoizedState||(_.flags|=1024),tt=!1)}return jj(et,_,_e,tt,rt,nt)}function jj(et,_,_e,tt,nt,rt){gj(et,_);var ot=(_.flags&128)!==0;if(!tt&&!ot)return nt&&dg(_,_e,!1),Zi(et,_,rt);tt=_.stateNode,Wi.current=_;var at=ot&&typeof _e.getDerivedStateFromError!="function"?null:tt.render();return _.flags|=1,et!==null&&ot?(_.child=Ug(_,et.child,null,rt),_.child=Ug(_,null,at,rt)):Xi(et,_,at,rt),_.memoizedState=tt.state,nt&&dg(_,_e,!0),_.child}function kj(et){var _=et.stateNode;_.pendingContext?ag(et,_.pendingContext,_.pendingContext!==_.context):_.context&&ag(et,_.context,!1),yh(et,_.containerInfo)}function lj(et,_,_e,tt,nt){return Ig(),Jg(nt),_.flags|=256,Xi(et,_,_e,tt),_.child}var mj={dehydrated:null,treeContext:null,retryLane:0};function nj(et){return{baseLanes:et,cachePool:null,transitions:null}}function oj(et,_,_e){var tt=_.pendingProps,nt=L$2.current,rt=!1,ot=(_.flags&128)!==0,at;if((at=ot)||(at=et!==null&&et.memoizedState===null?!1:(nt&2)!==0),at?(rt=!0,_.flags&=-129):(et===null||et.memoizedState!==null)&&(nt|=1),G$1(L$2,nt&1),et===null)return Eg(_),et=_.memoizedState,et!==null&&(et=et.dehydrated,et!==null)?(_.mode&1?et.data==="$!"?_.lanes=8:_.lanes=1073741824:_.lanes=1,null):(ot=tt.children,et=tt.fallback,rt?(tt=_.mode,rt=_.child,ot={mode:"hidden",children:ot},!(tt&1)&&rt!==null?(rt.childLanes=0,rt.pendingProps=ot):rt=pj(ot,tt,0,null),et=Tg(et,tt,_e,null),rt.return=_,et.return=_,rt.sibling=et,_.child=rt,_.child.memoizedState=nj(_e),_.memoizedState=mj,et):qj(_,ot));if(nt=et.memoizedState,nt!==null&&(at=nt.dehydrated,at!==null))return rj(et,_,ot,tt,at,nt,_e);if(rt){rt=tt.fallback,ot=_.mode,nt=et.child,at=nt.sibling;var lt={mode:"hidden",children:tt.children};return!(ot&1)&&_.child!==nt?(tt=_.child,tt.childLanes=0,tt.pendingProps=lt,_.deletions=null):(tt=Pg(nt,lt),tt.subtreeFlags=nt.subtreeFlags&14680064),at!==null?rt=Pg(at,rt):(rt=Tg(rt,ot,_e,null),rt.flags|=2),rt.return=_,tt.return=_,tt.sibling=rt,_.child=tt,tt=rt,rt=_.child,ot=et.child.memoizedState,ot=ot===null?nj(_e):{baseLanes:ot.baseLanes|_e,cachePool:null,transitions:ot.transitions},rt.memoizedState=ot,rt.childLanes=et.childLanes&~_e,_.memoizedState=mj,tt}return rt=et.child,et=rt.sibling,tt=Pg(rt,{mode:"visible",children:tt.children}),!(_.mode&1)&&(tt.lanes=_e),tt.return=_,tt.sibling=null,et!==null&&(_e=_.deletions,_e===null?(_.deletions=[et],_.flags|=16):_e.push(et)),_.child=tt,_.memoizedState=null,tt}function qj(et,_){return _=pj({mode:"visible",children:_},et.mode,0,null),_.return=et,et.child=_}function sj(et,_,_e,tt){return tt!==null&&Jg(tt),Ug(_,et.child,null,_e),et=qj(_,_.pendingProps.children),et.flags|=2,_.memoizedState=null,et}function rj(et,_,_e,tt,nt,rt,ot){if(_e)return _.flags&256?(_.flags&=-257,tt=Ki(Error(p$4(422))),sj(et,_,ot,tt)):_.memoizedState!==null?(_.child=et.child,_.flags|=128,null):(rt=tt.fallback,nt=_.mode,tt=pj({mode:"visible",children:tt.children},nt,0,null),rt=Tg(rt,nt,ot,null),rt.flags|=2,tt.return=_,rt.return=_,tt.sibling=rt,_.child=tt,_.mode&1&&Ug(_,et.child,null,ot),_.child.memoizedState=nj(ot),_.memoizedState=mj,rt);if(!(_.mode&1))return sj(et,_,ot,null);if(nt.data==="$!"){if(tt=nt.nextSibling&&nt.nextSibling.dataset,tt)var at=tt.dgst;return tt=at,rt=Error(p$4(419)),tt=Ki(rt,tt,void 0),sj(et,_,ot,tt)}if(at=(ot&et.childLanes)!==0,dh||at){if(tt=Q$1,tt!==null){switch(ot&-ot){case 4:nt=2;break;case 16:nt=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:nt=32;break;case 536870912:nt=268435456;break;default:nt=0}nt=nt&(tt.suspendedLanes|ot)?0:nt,nt!==0&&nt!==rt.retryLane&&(rt.retryLane=nt,ih(et,nt),gi(tt,et,nt,-1))}return tj(),tt=Ki(Error(p$4(421))),sj(et,_,ot,tt)}return nt.data==="$?"?(_.flags|=128,_.child=et.child,_=uj.bind(null,et),nt._reactRetry=_,null):(et=rt.treeContext,yg=Lf(nt.nextSibling),xg=_,I$3=!0,zg=null,et!==null&&(og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,rg=et.id,sg=et.overflow,qg=_),_=qj(_,tt.children),_.flags|=4096,_)}function vj(et,_,_e){et.lanes|=_;var tt=et.alternate;tt!==null&&(tt.lanes|=_),bh(et.return,_,_e)}function wj(et,_,_e,tt,nt){var rt=et.memoizedState;rt===null?et.memoizedState={isBackwards:_,rendering:null,renderingStartTime:0,last:tt,tail:_e,tailMode:nt}:(rt.isBackwards=_,rt.rendering=null,rt.renderingStartTime=0,rt.last=tt,rt.tail=_e,rt.tailMode=nt)}function xj(et,_,_e){var tt=_.pendingProps,nt=tt.revealOrder,rt=tt.tail;if(Xi(et,_,tt.children,_e),tt=L$2.current,tt&2)tt=tt&1|2,_.flags|=128;else{if(et!==null&&et.flags&128)e:for(et=_.child;et!==null;){if(et.tag===13)et.memoizedState!==null&&vj(et,_e,_);else if(et.tag===19)vj(et,_e,_);else if(et.child!==null){et.child.return=et,et=et.child;continue}if(et===_)break e;for(;et.sibling===null;){if(et.return===null||et.return===_)break e;et=et.return}et.sibling.return=et.return,et=et.sibling}tt&=1}if(G$1(L$2,tt),!(_.mode&1))_.memoizedState=null;else switch(nt){case"forwards":for(_e=_.child,nt=null;_e!==null;)et=_e.alternate,et!==null&&Ch(et)===null&&(nt=_e),_e=_e.sibling;_e=nt,_e===null?(nt=_.child,_.child=null):(nt=_e.sibling,_e.sibling=null),wj(_,!1,nt,_e,rt);break;case"backwards":for(_e=null,nt=_.child,_.child=null;nt!==null;){if(et=nt.alternate,et!==null&&Ch(et)===null){_.child=nt;break}et=nt.sibling,nt.sibling=_e,_e=nt,nt=et}wj(_,!0,_e,null,rt);break;case"together":wj(_,!1,null,null,void 0);break;default:_.memoizedState=null}return _.child}function ij(et,_){!(_.mode&1)&&et!==null&&(et.alternate=null,_.alternate=null,_.flags|=2)}function Zi(et,_,_e){if(et!==null&&(_.dependencies=et.dependencies),rh|=_.lanes,!(_e&_.childLanes))return null;if(et!==null&&_.child!==et.child)throw Error(p$4(153));if(_.child!==null){for(et=_.child,_e=Pg(et,et.pendingProps),_.child=_e,_e.return=_;et.sibling!==null;)et=et.sibling,_e=_e.sibling=Pg(et,et.pendingProps),_e.return=_;_e.sibling=null}return _.child}function yj(et,_,_e){switch(_.tag){case 3:kj(_),Ig();break;case 5:Ah(_);break;case 1:Zf(_.type)&&cg(_);break;case 4:yh(_,_.stateNode.containerInfo);break;case 10:var tt=_.type._context,nt=_.memoizedProps.value;G$1(Wg,tt._currentValue),tt._currentValue=nt;break;case 13:if(tt=_.memoizedState,tt!==null)return tt.dehydrated!==null?(G$1(L$2,L$2.current&1),_.flags|=128,null):_e&_.child.childLanes?oj(et,_,_e):(G$1(L$2,L$2.current&1),et=Zi(et,_,_e),et!==null?et.sibling:null);G$1(L$2,L$2.current&1);break;case 19:if(tt=(_e&_.childLanes)!==0,et.flags&128){if(tt)return xj(et,_,_e);_.flags|=128}if(nt=_.memoizedState,nt!==null&&(nt.rendering=null,nt.tail=null,nt.lastEffect=null),G$1(L$2,L$2.current),tt)break;return null;case 22:case 23:return _.lanes=0,dj(et,_,_e)}return Zi(et,_,_e)}var zj,Aj,Bj,Cj;zj=function(et,_){for(var _e=_.child;_e!==null;){if(_e.tag===5||_e.tag===6)et.appendChild(_e.stateNode);else if(_e.tag!==4&&_e.child!==null){_e.child.return=_e,_e=_e.child;continue}if(_e===_)break;for(;_e.sibling===null;){if(_e.return===null||_e.return===_)return;_e=_e.return}_e.sibling.return=_e.return,_e=_e.sibling}};Aj=function(){};Bj=function(et,_,_e,tt){var nt=et.memoizedProps;if(nt!==tt){et=_.stateNode,xh(uh.current);var rt=null;switch(_e){case"input":nt=Ya(et,nt),tt=Ya(et,tt),rt=[];break;case"select":nt=A$1({},nt,{value:void 0}),tt=A$1({},tt,{value:void 0}),rt=[];break;case"textarea":nt=gb(et,nt),tt=gb(et,tt),rt=[];break;default:typeof nt.onClick!="function"&&typeof tt.onClick=="function"&&(et.onclick=Bf)}ub(_e,tt);var ot;_e=null;for(ut in nt)if(!tt.hasOwnProperty(ut)&&nt.hasOwnProperty(ut)&&nt[ut]!=null)if(ut==="style"){var at=nt[ut];for(ot in at)at.hasOwnProperty(ot)&&(_e||(_e={}),_e[ot]="")}else ut!=="dangerouslySetInnerHTML"&&ut!=="children"&&ut!=="suppressContentEditableWarning"&&ut!=="suppressHydrationWarning"&&ut!=="autoFocus"&&(ea.hasOwnProperty(ut)?rt||(rt=[]):(rt=rt||[]).push(ut,null));for(ut in tt){var lt=tt[ut];if(at=nt!=null?nt[ut]:void 0,tt.hasOwnProperty(ut)&&lt!==at&&(lt!=null||at!=null))if(ut==="style")if(at){for(ot in at)!at.hasOwnProperty(ot)||lt&&lt.hasOwnProperty(ot)||(_e||(_e={}),_e[ot]="");for(ot in lt)lt.hasOwnProperty(ot)&&at[ot]!==lt[ot]&&(_e||(_e={}),_e[ot]=lt[ot])}else _e||(rt||(rt=[]),rt.push(ut,_e)),_e=lt;else ut==="dangerouslySetInnerHTML"?(lt=lt?lt.__html:void 0,at=at?at.__html:void 0,lt!=null&&at!==lt&&(rt=rt||[]).push(ut,lt)):ut==="children"?typeof lt!="string"&&typeof lt!="number"||(rt=rt||[]).push(ut,""+lt):ut!=="suppressContentEditableWarning"&&ut!=="suppressHydrationWarning"&&(ea.hasOwnProperty(ut)?(lt!=null&&ut==="onScroll"&&D$1("scroll",et),rt||at===lt||(rt=[])):(rt=rt||[]).push(ut,lt))}_e&&(rt=rt||[]).push("style",_e);var ut=rt;(_.updateQueue=ut)&&(_.flags|=4)}};Cj=function(et,_,_e,tt){_e!==tt&&(_.flags|=4)};function Dj(et,_){if(!I$3)switch(et.tailMode){case"hidden":_=et.tail;for(var _e=null;_!==null;)_.alternate!==null&&(_e=_),_=_.sibling;_e===null?et.tail=null:_e.sibling=null;break;case"collapsed":_e=et.tail;for(var tt=null;_e!==null;)_e.alternate!==null&&(tt=_e),_e=_e.sibling;tt===null?_||et.tail===null?et.tail=null:et.tail.sibling=null:tt.sibling=null}}function S$3(et){var _=et.alternate!==null&&et.alternate.child===et.child,_e=0,tt=0;if(_)for(var nt=et.child;nt!==null;)_e|=nt.lanes|nt.childLanes,tt|=nt.subtreeFlags&14680064,tt|=nt.flags&14680064,nt.return=et,nt=nt.sibling;else for(nt=et.child;nt!==null;)_e|=nt.lanes|nt.childLanes,tt|=nt.subtreeFlags,tt|=nt.flags,nt.return=et,nt=nt.sibling;return et.subtreeFlags|=tt,et.childLanes=_e,_}function Ej(et,_,_e){var tt=_.pendingProps;switch(wg(_),_.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return S$3(_),null;case 1:return Zf(_.type)&&$f(),S$3(_),null;case 3:return tt=_.stateNode,zh(),E$1(Wf),E$1(H$2),Eh(),tt.pendingContext&&(tt.context=tt.pendingContext,tt.pendingContext=null),(et===null||et.child===null)&&(Gg(_)?_.flags|=4:et===null||et.memoizedState.isDehydrated&&!(_.flags&256)||(_.flags|=1024,zg!==null&&(Fj(zg),zg=null))),Aj(et,_),S$3(_),null;case 5:Bh(_);var nt=xh(wh.current);if(_e=_.type,et!==null&&_.stateNode!=null)Bj(et,_,_e,tt,nt),et.ref!==_.ref&&(_.flags|=512,_.flags|=2097152);else{if(!tt){if(_.stateNode===null)throw Error(p$4(166));return S$3(_),null}if(et=xh(uh.current),Gg(_)){tt=_.stateNode,_e=_.type;var rt=_.memoizedProps;switch(tt[Of]=_,tt[Pf]=rt,et=(_.mode&1)!==0,_e){case"dialog":D$1("cancel",tt),D$1("close",tt);break;case"iframe":case"object":case"embed":D$1("load",tt);break;case"video":case"audio":for(nt=0;nt<lf.length;nt++)D$1(lf[nt],tt);break;case"source":D$1("error",tt);break;case"img":case"image":case"link":D$1("error",tt),D$1("load",tt);break;case"details":D$1("toggle",tt);break;case"input":Za(tt,rt),D$1("invalid",tt);break;case"select":tt._wrapperState={wasMultiple:!!rt.multiple},D$1("invalid",tt);break;case"textarea":hb(tt,rt),D$1("invalid",tt)}ub(_e,rt),nt=null;for(var ot in rt)if(rt.hasOwnProperty(ot)){var at=rt[ot];ot==="children"?typeof at=="string"?tt.textContent!==at&&(rt.suppressHydrationWarning!==!0&&Af(tt.textContent,at,et),nt=["children",at]):typeof at=="number"&&tt.textContent!==""+at&&(rt.suppressHydrationWarning!==!0&&Af(tt.textContent,at,et),nt=["children",""+at]):ea.hasOwnProperty(ot)&&at!=null&&ot==="onScroll"&&D$1("scroll",tt)}switch(_e){case"input":Va(tt),db(tt,rt,!0);break;case"textarea":Va(tt),jb(tt);break;case"select":case"option":break;default:typeof rt.onClick=="function"&&(tt.onclick=Bf)}tt=nt,_.updateQueue=tt,tt!==null&&(_.flags|=4)}else{ot=nt.nodeType===9?nt:nt.ownerDocument,et==="http://www.w3.org/1999/xhtml"&&(et=kb(_e)),et==="http://www.w3.org/1999/xhtml"?_e==="script"?(et=ot.createElement("div"),et.innerHTML="<script><\/script>",et=et.removeChild(et.firstChild)):typeof tt.is=="string"?et=ot.createElement(_e,{is:tt.is}):(et=ot.createElement(_e),_e==="select"&&(ot=et,tt.multiple?ot.multiple=!0:tt.size&&(ot.size=tt.size))):et=ot.createElementNS(et,_e),et[Of]=_,et[Pf]=tt,zj(et,_,!1,!1),_.stateNode=et;e:{switch(ot=vb(_e,tt),_e){case"dialog":D$1("cancel",et),D$1("close",et),nt=tt;break;case"iframe":case"object":case"embed":D$1("load",et),nt=tt;break;case"video":case"audio":for(nt=0;nt<lf.length;nt++)D$1(lf[nt],et);nt=tt;break;case"source":D$1("error",et),nt=tt;break;case"img":case"image":case"link":D$1("error",et),D$1("load",et),nt=tt;break;case"details":D$1("toggle",et),nt=tt;break;case"input":Za(et,tt),nt=Ya(et,tt),D$1("invalid",et);break;case"option":nt=tt;break;case"select":et._wrapperState={wasMultiple:!!tt.multiple},nt=A$1({},tt,{value:void 0}),D$1("invalid",et);break;case"textarea":hb(et,tt),nt=gb(et,tt),D$1("invalid",et);break;default:nt=tt}ub(_e,nt),at=nt;for(rt in at)if(at.hasOwnProperty(rt)){var lt=at[rt];rt==="style"?sb(et,lt):rt==="dangerouslySetInnerHTML"?(lt=lt?lt.__html:void 0,lt!=null&&nb(et,lt)):rt==="children"?typeof lt=="string"?(_e!=="textarea"||lt!=="")&&ob(et,lt):typeof lt=="number"&&ob(et,""+lt):rt!=="suppressContentEditableWarning"&&rt!=="suppressHydrationWarning"&&rt!=="autoFocus"&&(ea.hasOwnProperty(rt)?lt!=null&&rt==="onScroll"&&D$1("scroll",et):lt!=null&&ta(et,rt,lt,ot))}switch(_e){case"input":Va(et),db(et,tt,!1);break;case"textarea":Va(et),jb(et);break;case"option":tt.value!=null&&et.setAttribute("value",""+Sa(tt.value));break;case"select":et.multiple=!!tt.multiple,rt=tt.value,rt!=null?fb(et,!!tt.multiple,rt,!1):tt.defaultValue!=null&&fb(et,!!tt.multiple,tt.defaultValue,!0);break;default:typeof nt.onClick=="function"&&(et.onclick=Bf)}switch(_e){case"button":case"input":case"select":case"textarea":tt=!!tt.autoFocus;break e;case"img":tt=!0;break e;default:tt=!1}}tt&&(_.flags|=4)}_.ref!==null&&(_.flags|=512,_.flags|=2097152)}return S$3(_),null;case 6:if(et&&_.stateNode!=null)Cj(et,_,et.memoizedProps,tt);else{if(typeof tt!="string"&&_.stateNode===null)throw Error(p$4(166));if(_e=xh(wh.current),xh(uh.current),Gg(_)){if(tt=_.stateNode,_e=_.memoizedProps,tt[Of]=_,(rt=tt.nodeValue!==_e)&&(et=xg,et!==null))switch(et.tag){case 3:Af(tt.nodeValue,_e,(et.mode&1)!==0);break;case 5:et.memoizedProps.suppressHydrationWarning!==!0&&Af(tt.nodeValue,_e,(et.mode&1)!==0)}rt&&(_.flags|=4)}else tt=(_e.nodeType===9?_e:_e.ownerDocument).createTextNode(tt),tt[Of]=_,_.stateNode=tt}return S$3(_),null;case 13:if(E$1(L$2),tt=_.memoizedState,et===null||et.memoizedState!==null&&et.memoizedState.dehydrated!==null){if(I$3&&yg!==null&&_.mode&1&&!(_.flags&128))Hg(),Ig(),_.flags|=98560,rt=!1;else if(rt=Gg(_),tt!==null&&tt.dehydrated!==null){if(et===null){if(!rt)throw Error(p$4(318));if(rt=_.memoizedState,rt=rt!==null?rt.dehydrated:null,!rt)throw Error(p$4(317));rt[Of]=_}else Ig(),!(_.flags&128)&&(_.memoizedState=null),_.flags|=4;S$3(_),rt=!1}else zg!==null&&(Fj(zg),zg=null),rt=!0;if(!rt)return _.flags&65536?_:null}return _.flags&128?(_.lanes=_e,_):(tt=tt!==null,tt!==(et!==null&&et.memoizedState!==null)&&tt&&(_.child.flags|=8192,_.mode&1&&(et===null||L$2.current&1?T$2===0&&(T$2=3):tj())),_.updateQueue!==null&&(_.flags|=4),S$3(_),null);case 4:return zh(),Aj(et,_),et===null&&sf(_.stateNode.containerInfo),S$3(_),null;case 10:return ah(_.type._context),S$3(_),null;case 17:return Zf(_.type)&&$f(),S$3(_),null;case 19:if(E$1(L$2),rt=_.memoizedState,rt===null)return S$3(_),null;if(tt=(_.flags&128)!==0,ot=rt.rendering,ot===null)if(tt)Dj(rt,!1);else{if(T$2!==0||et!==null&&et.flags&128)for(et=_.child;et!==null;){if(ot=Ch(et),ot!==null){for(_.flags|=128,Dj(rt,!1),tt=ot.updateQueue,tt!==null&&(_.updateQueue=tt,_.flags|=4),_.subtreeFlags=0,tt=_e,_e=_.child;_e!==null;)rt=_e,et=tt,rt.flags&=14680066,ot=rt.alternate,ot===null?(rt.childLanes=0,rt.lanes=et,rt.child=null,rt.subtreeFlags=0,rt.memoizedProps=null,rt.memoizedState=null,rt.updateQueue=null,rt.dependencies=null,rt.stateNode=null):(rt.childLanes=ot.childLanes,rt.lanes=ot.lanes,rt.child=ot.child,rt.subtreeFlags=0,rt.deletions=null,rt.memoizedProps=ot.memoizedProps,rt.memoizedState=ot.memoizedState,rt.updateQueue=ot.updateQueue,rt.type=ot.type,et=ot.dependencies,rt.dependencies=et===null?null:{lanes:et.lanes,firstContext:et.firstContext}),_e=_e.sibling;return G$1(L$2,L$2.current&1|2),_.child}et=et.sibling}rt.tail!==null&&B$1()>Gj&&(_.flags|=128,tt=!0,Dj(rt,!1),_.lanes=4194304)}else{if(!tt)if(et=Ch(ot),et!==null){if(_.flags|=128,tt=!0,_e=et.updateQueue,_e!==null&&(_.updateQueue=_e,_.flags|=4),Dj(rt,!0),rt.tail===null&&rt.tailMode==="hidden"&&!ot.alternate&&!I$3)return S$3(_),null}else 2*B$1()-rt.renderingStartTime>Gj&&_e!==1073741824&&(_.flags|=128,tt=!0,Dj(rt,!1),_.lanes=4194304);rt.isBackwards?(ot.sibling=_.child,_.child=ot):(_e=rt.last,_e!==null?_e.sibling=ot:_.child=ot,rt.last=ot)}return rt.tail!==null?(_=rt.tail,rt.rendering=_,rt.tail=_.sibling,rt.renderingStartTime=B$1(),_.sibling=null,_e=L$2.current,G$1(L$2,tt?_e&1|2:_e&1),_):(S$3(_),null);case 22:case 23:return Hj(),tt=_.memoizedState!==null,et!==null&&et.memoizedState!==null!==tt&&(_.flags|=8192),tt&&_.mode&1?fj&1073741824&&(S$3(_),_.subtreeFlags&6&&(_.flags|=8192)):S$3(_),null;case 24:return null;case 25:return null}throw Error(p$4(156,_.tag))}function Ij(et,_){switch(wg(_),_.tag){case 1:return Zf(_.type)&&$f(),et=_.flags,et&65536?(_.flags=et&-65537|128,_):null;case 3:return zh(),E$1(Wf),E$1(H$2),Eh(),et=_.flags,et&65536&&!(et&128)?(_.flags=et&-65537|128,_):null;case 5:return Bh(_),null;case 13:if(E$1(L$2),et=_.memoizedState,et!==null&&et.dehydrated!==null){if(_.alternate===null)throw Error(p$4(340));Ig()}return et=_.flags,et&65536?(_.flags=et&-65537|128,_):null;case 19:return E$1(L$2),null;case 4:return zh(),null;case 10:return ah(_.type._context),null;case 22:case 23:return Hj(),null;case 24:return null;default:return null}}var Jj=!1,U$2=!1,Kj=typeof WeakSet=="function"?WeakSet:Set,V$3=null;function Lj(et,_){var _e=et.ref;if(_e!==null)if(typeof _e=="function")try{_e(null)}catch(tt){W$1(et,_,tt)}else _e.current=null}function Mj(et,_,_e){try{_e()}catch(tt){W$1(et,_,tt)}}var Nj=!1;function Oj(et,_){if(Cf=dd,et=Me$1(),Ne$1(et)){if("selectionStart"in et)var _e={start:et.selectionStart,end:et.selectionEnd};else e:{_e=(_e=et.ownerDocument)&&_e.defaultView||window;var tt=_e.getSelection&&_e.getSelection();if(tt&&tt.rangeCount!==0){_e=tt.anchorNode;var nt=tt.anchorOffset,rt=tt.focusNode;tt=tt.focusOffset;try{_e.nodeType,rt.nodeType}catch{_e=null;break e}var ot=0,at=-1,lt=-1,ut=0,dt=0,st=et,it=null;t:for(;;){for(var ct;st!==_e||nt!==0&&st.nodeType!==3||(at=ot+nt),st!==rt||tt!==0&&st.nodeType!==3||(lt=ot+tt),st.nodeType===3&&(ot+=st.nodeValue.length),(ct=st.firstChild)!==null;)it=st,st=ct;for(;;){if(st===et)break t;if(it===_e&&++ut===nt&&(at=ot),it===rt&&++dt===tt&&(lt=ot),(ct=st.nextSibling)!==null)break;st=it,it=st.parentNode}st=ct}_e=at===-1||lt===-1?null:{start:at,end:lt}}else _e=null}_e=_e||{start:0,end:0}}else _e=null;for(Df={focusedElem:et,selectionRange:_e},dd=!1,V$3=_;V$3!==null;)if(_=V$3,et=_.child,(_.subtreeFlags&1028)!==0&&et!==null)et.return=_,V$3=et;else for(;V$3!==null;){_=V$3;try{var ft=_.alternate;if(_.flags&1024)switch(_.tag){case 0:case 11:case 15:break;case 1:if(ft!==null){var ht=ft.memoizedProps,mt=ft.memoizedState,pt=_.stateNode,_t=pt.getSnapshotBeforeUpdate(_.elementType===_.type?ht:Ci(_.type,ht),mt);pt.__reactInternalSnapshotBeforeUpdate=_t}break;case 3:var vt=_.stateNode.containerInfo;vt.nodeType===1?vt.textContent="":vt.nodeType===9&&vt.documentElement&&vt.removeChild(vt.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(p$4(163))}}catch(bt){W$1(_,_.return,bt)}if(et=_.sibling,et!==null){et.return=_.return,V$3=et;break}V$3=_.return}return ft=Nj,Nj=!1,ft}function Pj(et,_,_e){var tt=_.updateQueue;if(tt=tt!==null?tt.lastEffect:null,tt!==null){var nt=tt=tt.next;do{if((nt.tag&et)===et){var rt=nt.destroy;nt.destroy=void 0,rt!==void 0&&Mj(_,_e,rt)}nt=nt.next}while(nt!==tt)}}function Qj(et,_){if(_=_.updateQueue,_=_!==null?_.lastEffect:null,_!==null){var _e=_=_.next;do{if((_e.tag&et)===et){var tt=_e.create;_e.destroy=tt()}_e=_e.next}while(_e!==_)}}function Rj(et){var _=et.ref;if(_!==null){var _e=et.stateNode;switch(et.tag){case 5:et=_e;break;default:et=_e}typeof _=="function"?_(et):_.current=et}}function Sj(et){var _=et.alternate;_!==null&&(et.alternate=null,Sj(_)),et.child=null,et.deletions=null,et.sibling=null,et.tag===5&&(_=et.stateNode,_!==null&&(delete _[Of],delete _[Pf],delete _[of],delete _[Qf],delete _[Rf])),et.stateNode=null,et.return=null,et.dependencies=null,et.memoizedProps=null,et.memoizedState=null,et.pendingProps=null,et.stateNode=null,et.updateQueue=null}function Tj(et){return et.tag===5||et.tag===3||et.tag===4}function Uj(et){e:for(;;){for(;et.sibling===null;){if(et.return===null||Tj(et.return))return null;et=et.return}for(et.sibling.return=et.return,et=et.sibling;et.tag!==5&&et.tag!==6&&et.tag!==18;){if(et.flags&2||et.child===null||et.tag===4)continue e;et.child.return=et,et=et.child}if(!(et.flags&2))return et.stateNode}}function Vj(et,_,_e){var tt=et.tag;if(tt===5||tt===6)et=et.stateNode,_?_e.nodeType===8?_e.parentNode.insertBefore(et,_):_e.insertBefore(et,_):(_e.nodeType===8?(_=_e.parentNode,_.insertBefore(et,_e)):(_=_e,_.appendChild(et)),_e=_e._reactRootContainer,_e!=null||_.onclick!==null||(_.onclick=Bf));else if(tt!==4&&(et=et.child,et!==null))for(Vj(et,_,_e),et=et.sibling;et!==null;)Vj(et,_,_e),et=et.sibling}function Wj(et,_,_e){var tt=et.tag;if(tt===5||tt===6)et=et.stateNode,_?_e.insertBefore(et,_):_e.appendChild(et);else if(tt!==4&&(et=et.child,et!==null))for(Wj(et,_,_e),et=et.sibling;et!==null;)Wj(et,_,_e),et=et.sibling}var X=null,Xj=!1;function Yj(et,_,_e){for(_e=_e.child;_e!==null;)Zj(et,_,_e),_e=_e.sibling}function Zj(et,_,_e){if(lc&&typeof lc.onCommitFiberUnmount=="function")try{lc.onCommitFiberUnmount(kc,_e)}catch{}switch(_e.tag){case 5:U$2||Lj(_e,_);case 6:var tt=X,nt=Xj;X=null,Yj(et,_,_e),X=tt,Xj=nt,X!==null&&(Xj?(et=X,_e=_e.stateNode,et.nodeType===8?et.parentNode.removeChild(_e):et.removeChild(_e)):X.removeChild(_e.stateNode));break;case 18:X!==null&&(Xj?(et=X,_e=_e.stateNode,et.nodeType===8?Kf(et.parentNode,_e):et.nodeType===1&&Kf(et,_e),bd(et)):Kf(X,_e.stateNode));break;case 4:tt=X,nt=Xj,X=_e.stateNode.containerInfo,Xj=!0,Yj(et,_,_e),X=tt,Xj=nt;break;case 0:case 11:case 14:case 15:if(!U$2&&(tt=_e.updateQueue,tt!==null&&(tt=tt.lastEffect,tt!==null))){nt=tt=tt.next;do{var rt=nt,ot=rt.destroy;rt=rt.tag,ot!==void 0&&(rt&2||rt&4)&&Mj(_e,_,ot),nt=nt.next}while(nt!==tt)}Yj(et,_,_e);break;case 1:if(!U$2&&(Lj(_e,_),tt=_e.stateNode,typeof tt.componentWillUnmount=="function"))try{tt.props=_e.memoizedProps,tt.state=_e.memoizedState,tt.componentWillUnmount()}catch(at){W$1(_e,_,at)}Yj(et,_,_e);break;case 21:Yj(et,_,_e);break;case 22:_e.mode&1?(U$2=(tt=U$2)||_e.memoizedState!==null,Yj(et,_,_e),U$2=tt):Yj(et,_,_e);break;default:Yj(et,_,_e)}}function ak(et){var _=et.updateQueue;if(_!==null){et.updateQueue=null;var _e=et.stateNode;_e===null&&(_e=et.stateNode=new Kj),_.forEach(function(tt){var nt=bk.bind(null,et,tt);_e.has(tt)||(_e.add(tt),tt.then(nt,nt))})}}function ck(et,_){var _e=_.deletions;if(_e!==null)for(var tt=0;tt<_e.length;tt++){var nt=_e[tt];try{var rt=et,ot=_,at=ot;e:for(;at!==null;){switch(at.tag){case 5:X=at.stateNode,Xj=!1;break e;case 3:X=at.stateNode.containerInfo,Xj=!0;break e;case 4:X=at.stateNode.containerInfo,Xj=!0;break e}at=at.return}if(X===null)throw Error(p$4(160));Zj(rt,ot,nt),X=null,Xj=!1;var lt=nt.alternate;lt!==null&&(lt.return=null),nt.return=null}catch(ut){W$1(nt,_,ut)}}if(_.subtreeFlags&12854)for(_=_.child;_!==null;)dk(_,et),_=_.sibling}function dk(et,_){var _e=et.alternate,tt=et.flags;switch(et.tag){case 0:case 11:case 14:case 15:if(ck(_,et),ek(et),tt&4){try{Pj(3,et,et.return),Qj(3,et)}catch(ht){W$1(et,et.return,ht)}try{Pj(5,et,et.return)}catch(ht){W$1(et,et.return,ht)}}break;case 1:ck(_,et),ek(et),tt&512&&_e!==null&&Lj(_e,_e.return);break;case 5:if(ck(_,et),ek(et),tt&512&&_e!==null&&Lj(_e,_e.return),et.flags&32){var nt=et.stateNode;try{ob(nt,"")}catch(ht){W$1(et,et.return,ht)}}if(tt&4&&(nt=et.stateNode,nt!=null)){var rt=et.memoizedProps,ot=_e!==null?_e.memoizedProps:rt,at=et.type,lt=et.updateQueue;if(et.updateQueue=null,lt!==null)try{at==="input"&&rt.type==="radio"&&rt.name!=null&&ab(nt,rt),vb(at,ot);var ut=vb(at,rt);for(ot=0;ot<lt.length;ot+=2){var dt=lt[ot],st=lt[ot+1];dt==="style"?sb(nt,st):dt==="dangerouslySetInnerHTML"?nb(nt,st):dt==="children"?ob(nt,st):ta(nt,dt,st,ut)}switch(at){case"input":bb(nt,rt);break;case"textarea":ib(nt,rt);break;case"select":var it=nt._wrapperState.wasMultiple;nt._wrapperState.wasMultiple=!!rt.multiple;var ct=rt.value;ct!=null?fb(nt,!!rt.multiple,ct,!1):it!==!!rt.multiple&&(rt.defaultValue!=null?fb(nt,!!rt.multiple,rt.defaultValue,!0):fb(nt,!!rt.multiple,rt.multiple?[]:"",!1))}nt[Pf]=rt}catch(ht){W$1(et,et.return,ht)}}break;case 6:if(ck(_,et),ek(et),tt&4){if(et.stateNode===null)throw Error(p$4(162));nt=et.stateNode,rt=et.memoizedProps;try{nt.nodeValue=rt}catch(ht){W$1(et,et.return,ht)}}break;case 3:if(ck(_,et),ek(et),tt&4&&_e!==null&&_e.memoizedState.isDehydrated)try{bd(_.containerInfo)}catch(ht){W$1(et,et.return,ht)}break;case 4:ck(_,et),ek(et);break;case 13:ck(_,et),ek(et),nt=et.child,nt.flags&8192&&(rt=nt.memoizedState!==null,nt.stateNode.isHidden=rt,!rt||nt.alternate!==null&&nt.alternate.memoizedState!==null||(fk=B$1())),tt&4&&ak(et);break;case 22:if(dt=_e!==null&&_e.memoizedState!==null,et.mode&1?(U$2=(ut=U$2)||dt,ck(_,et),U$2=ut):ck(_,et),ek(et),tt&8192){if(ut=et.memoizedState!==null,(et.stateNode.isHidden=ut)&&!dt&&et.mode&1)for(V$3=et,dt=et.child;dt!==null;){for(st=V$3=dt;V$3!==null;){switch(it=V$3,ct=it.child,it.tag){case 0:case 11:case 14:case 15:Pj(4,it,it.return);break;case 1:Lj(it,it.return);var ft=it.stateNode;if(typeof ft.componentWillUnmount=="function"){tt=it,_e=it.return;try{_=tt,ft.props=_.memoizedProps,ft.state=_.memoizedState,ft.componentWillUnmount()}catch(ht){W$1(tt,_e,ht)}}break;case 5:Lj(it,it.return);break;case 22:if(it.memoizedState!==null){gk(st);continue}}ct!==null?(ct.return=it,V$3=ct):gk(st)}dt=dt.sibling}e:for(dt=null,st=et;;){if(st.tag===5){if(dt===null){dt=st;try{nt=st.stateNode,ut?(rt=nt.style,typeof rt.setProperty=="function"?rt.setProperty("display","none","important"):rt.display="none"):(at=st.stateNode,lt=st.memoizedProps.style,ot=lt!=null&&lt.hasOwnProperty("display")?lt.display:null,at.style.display=rb("display",ot))}catch(ht){W$1(et,et.return,ht)}}}else if(st.tag===6){if(dt===null)try{st.stateNode.nodeValue=ut?"":st.memoizedProps}catch(ht){W$1(et,et.return,ht)}}else if((st.tag!==22&&st.tag!==23||st.memoizedState===null||st===et)&&st.child!==null){st.child.return=st,st=st.child;continue}if(st===et)break e;for(;st.sibling===null;){if(st.return===null||st.return===et)break e;dt===st&&(dt=null),st=st.return}dt===st&&(dt=null),st.sibling.return=st.return,st=st.sibling}}break;case 19:ck(_,et),ek(et),tt&4&&ak(et);break;case 21:break;default:ck(_,et),ek(et)}}function ek(et){var _=et.flags;if(_&2){try{e:{for(var _e=et.return;_e!==null;){if(Tj(_e)){var tt=_e;break e}_e=_e.return}throw Error(p$4(160))}switch(tt.tag){case 5:var nt=tt.stateNode;tt.flags&32&&(ob(nt,""),tt.flags&=-33);var rt=Uj(et);Wj(et,rt,nt);break;case 3:case 4:var ot=tt.stateNode.containerInfo,at=Uj(et);Vj(et,at,ot);break;default:throw Error(p$4(161))}}catch(lt){W$1(et,et.return,lt)}et.flags&=-3}_&4096&&(et.flags&=-4097)}function hk(et,_,_e){V$3=et,ik(et)}function ik(et,_,_e){for(var tt=(et.mode&1)!==0;V$3!==null;){var nt=V$3,rt=nt.child;if(nt.tag===22&&tt){var ot=nt.memoizedState!==null||Jj;if(!ot){var at=nt.alternate,lt=at!==null&&at.memoizedState!==null||U$2;at=Jj;var ut=U$2;if(Jj=ot,(U$2=lt)&&!ut)for(V$3=nt;V$3!==null;)ot=V$3,lt=ot.child,ot.tag===22&&ot.memoizedState!==null?jk(nt):lt!==null?(lt.return=ot,V$3=lt):jk(nt);for(;rt!==null;)V$3=rt,ik(rt),rt=rt.sibling;V$3=nt,Jj=at,U$2=ut}kk(et)}else nt.subtreeFlags&8772&&rt!==null?(rt.return=nt,V$3=rt):kk(et)}}function kk(et){for(;V$3!==null;){var _=V$3;if(_.flags&8772){var _e=_.alternate;try{if(_.flags&8772)switch(_.tag){case 0:case 11:case 15:U$2||Qj(5,_);break;case 1:var tt=_.stateNode;if(_.flags&4&&!U$2)if(_e===null)tt.componentDidMount();else{var nt=_.elementType===_.type?_e.memoizedProps:Ci(_.type,_e.memoizedProps);tt.componentDidUpdate(nt,_e.memoizedState,tt.__reactInternalSnapshotBeforeUpdate)}var rt=_.updateQueue;rt!==null&&sh(_,rt,tt);break;case 3:var ot=_.updateQueue;if(ot!==null){if(_e=null,_.child!==null)switch(_.child.tag){case 5:_e=_.child.stateNode;break;case 1:_e=_.child.stateNode}sh(_,ot,_e)}break;case 5:var at=_.stateNode;if(_e===null&&_.flags&4){_e=at;var lt=_.memoizedProps;switch(_.type){case"button":case"input":case"select":case"textarea":lt.autoFocus&&_e.focus();break;case"img":lt.src&&(_e.src=lt.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(_.memoizedState===null){var ut=_.alternate;if(ut!==null){var dt=ut.memoizedState;if(dt!==null){var st=dt.dehydrated;st!==null&&bd(st)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(p$4(163))}U$2||_.flags&512&&Rj(_)}catch(it){W$1(_,_.return,it)}}if(_===et){V$3=null;break}if(_e=_.sibling,_e!==null){_e.return=_.return,V$3=_e;break}V$3=_.return}}function gk(et){for(;V$3!==null;){var _=V$3;if(_===et){V$3=null;break}var _e=_.sibling;if(_e!==null){_e.return=_.return,V$3=_e;break}V$3=_.return}}function jk(et){for(;V$3!==null;){var _=V$3;try{switch(_.tag){case 0:case 11:case 15:var _e=_.return;try{Qj(4,_)}catch(lt){W$1(_,_e,lt)}break;case 1:var tt=_.stateNode;if(typeof tt.componentDidMount=="function"){var nt=_.return;try{tt.componentDidMount()}catch(lt){W$1(_,nt,lt)}}var rt=_.return;try{Rj(_)}catch(lt){W$1(_,rt,lt)}break;case 5:var ot=_.return;try{Rj(_)}catch(lt){W$1(_,ot,lt)}}}catch(lt){W$1(_,_.return,lt)}if(_===et){V$3=null;break}var at=_.sibling;if(at!==null){at.return=_.return,V$3=at;break}V$3=_.return}}var lk=Math.ceil,mk=ua.ReactCurrentDispatcher,nk=ua.ReactCurrentOwner,ok=ua.ReactCurrentBatchConfig,K=0,Q$1=null,Y$2=null,Z=0,fj=0,ej=Uf(0),T$2=0,pk=null,rh=0,qk=0,rk=0,sk=null,tk=null,fk=0,Gj=1/0,uk=null,Oi=!1,Pi=null,Ri=null,vk=!1,wk=null,xk=0,yk=0,zk=null,Ak=-1,Bk=0;function R$1(){return K&6?B$1():Ak!==-1?Ak:Ak=B$1()}function yi(et){return et.mode&1?K&2&&Z!==0?Z&-Z:Kg.transition!==null?(Bk===0&&(Bk=yc()),Bk):(et=C$1,et!==0||(et=window.event,et=et===void 0?16:jd(et.type)),et):1}function gi(et,_,_e,tt){if(50<yk)throw yk=0,zk=null,Error(p$4(185));Ac(et,_e,tt),(!(K&2)||et!==Q$1)&&(et===Q$1&&(!(K&2)&&(qk|=_e),T$2===4&&Ck(et,Z)),Dk(et,tt),_e===1&&K===0&&!(_.mode&1)&&(Gj=B$1()+500,fg&&jg()))}function Dk(et,_){var _e=et.callbackNode;wc(et,_);var tt=uc(et,et===Q$1?Z:0);if(tt===0)_e!==null&&bc(_e),et.callbackNode=null,et.callbackPriority=0;else if(_=tt&-tt,et.callbackPriority!==_){if(_e!=null&&bc(_e),_===1)et.tag===0?ig(Ek.bind(null,et)):hg(Ek.bind(null,et)),Jf(function(){!(K&6)&&jg()}),_e=null;else{switch(Dc(tt)){case 1:_e=fc;break;case 4:_e=gc;break;case 16:_e=hc;break;case 536870912:_e=jc;break;default:_e=hc}_e=Fk(_e,Gk.bind(null,et))}et.callbackPriority=_,et.callbackNode=_e}}function Gk(et,_){if(Ak=-1,Bk=0,K&6)throw Error(p$4(327));var _e=et.callbackNode;if(Hk()&&et.callbackNode!==_e)return null;var tt=uc(et,et===Q$1?Z:0);if(tt===0)return null;if(tt&30||tt&et.expiredLanes||_)_=Ik(et,tt);else{_=tt;var nt=K;K|=2;var rt=Jk();(Q$1!==et||Z!==_)&&(uk=null,Gj=B$1()+500,Kk(et,_));do try{Lk();break}catch(at){Mk(et,at)}while(!0);$g(),mk.current=rt,K=nt,Y$2!==null?_=0:(Q$1=null,Z=0,_=T$2)}if(_!==0){if(_===2&&(nt=xc(et),nt!==0&&(tt=nt,_=Nk(et,nt))),_===1)throw _e=pk,Kk(et,0),Ck(et,tt),Dk(et,B$1()),_e;if(_===6)Ck(et,tt);else{if(nt=et.current.alternate,!(tt&30)&&!Ok(nt)&&(_=Ik(et,tt),_===2&&(rt=xc(et),rt!==0&&(tt=rt,_=Nk(et,rt))),_===1))throw _e=pk,Kk(et,0),Ck(et,tt),Dk(et,B$1()),_e;switch(et.finishedWork=nt,et.finishedLanes=tt,_){case 0:case 1:throw Error(p$4(345));case 2:Pk(et,tk,uk);break;case 3:if(Ck(et,tt),(tt&130023424)===tt&&(_=fk+500-B$1(),10<_)){if(uc(et,0)!==0)break;if(nt=et.suspendedLanes,(nt&tt)!==tt){R$1(),et.pingedLanes|=et.suspendedLanes&nt;break}et.timeoutHandle=Ff(Pk.bind(null,et,tk,uk),_);break}Pk(et,tk,uk);break;case 4:if(Ck(et,tt),(tt&4194240)===tt)break;for(_=et.eventTimes,nt=-1;0<tt;){var ot=31-oc(tt);rt=1<<ot,ot=_[ot],ot>nt&&(nt=ot),tt&=~rt}if(tt=nt,tt=B$1()-tt,tt=(120>tt?120:480>tt?480:1080>tt?1080:1920>tt?1920:3e3>tt?3e3:4320>tt?4320:1960*lk(tt/1960))-tt,10<tt){et.timeoutHandle=Ff(Pk.bind(null,et,tk,uk),tt);break}Pk(et,tk,uk);break;case 5:Pk(et,tk,uk);break;default:throw Error(p$4(329))}}}return Dk(et,B$1()),et.callbackNode===_e?Gk.bind(null,et):null}function Nk(et,_){var _e=sk;return et.current.memoizedState.isDehydrated&&(Kk(et,_).flags|=256),et=Ik(et,_),et!==2&&(_=tk,tk=_e,_!==null&&Fj(_)),et}function Fj(et){tk===null?tk=et:tk.push.apply(tk,et)}function Ok(et){for(var _=et;;){if(_.flags&16384){var _e=_.updateQueue;if(_e!==null&&(_e=_e.stores,_e!==null))for(var tt=0;tt<_e.length;tt++){var nt=_e[tt],rt=nt.getSnapshot;nt=nt.value;try{if(!He(rt(),nt))return!1}catch{return!1}}}if(_e=_.child,_.subtreeFlags&16384&&_e!==null)_e.return=_,_=_e;else{if(_===et)break;for(;_.sibling===null;){if(_.return===null||_.return===et)return!0;_=_.return}_.sibling.return=_.return,_=_.sibling}}return!0}function Ck(et,_){for(_&=~rk,_&=~qk,et.suspendedLanes|=_,et.pingedLanes&=~_,et=et.expirationTimes;0<_;){var _e=31-oc(_),tt=1<<_e;et[_e]=-1,_&=~tt}}function Ek(et){if(K&6)throw Error(p$4(327));Hk();var _=uc(et,0);if(!(_&1))return Dk(et,B$1()),null;var _e=Ik(et,_);if(et.tag!==0&&_e===2){var tt=xc(et);tt!==0&&(_=tt,_e=Nk(et,tt))}if(_e===1)throw _e=pk,Kk(et,0),Ck(et,_),Dk(et,B$1()),_e;if(_e===6)throw Error(p$4(345));return et.finishedWork=et.current.alternate,et.finishedLanes=_,Pk(et,tk,uk),Dk(et,B$1()),null}function Qk(et,_){var _e=K;K|=1;try{return et(_)}finally{K=_e,K===0&&(Gj=B$1()+500,fg&&jg())}}function Rk(et){wk!==null&&wk.tag===0&&!(K&6)&&Hk();var _=K;K|=1;var _e=ok.transition,tt=C$1;try{if(ok.transition=null,C$1=1,et)return et()}finally{C$1=tt,ok.transition=_e,K=_,!(K&6)&&jg()}}function Hj(){fj=ej.current,E$1(ej)}function Kk(et,_){et.finishedWork=null,et.finishedLanes=0;var _e=et.timeoutHandle;if(_e!==-1&&(et.timeoutHandle=-1,Gf(_e)),Y$2!==null)for(_e=Y$2.return;_e!==null;){var tt=_e;switch(wg(tt),tt.tag){case 1:tt=tt.type.childContextTypes,tt!=null&&$f();break;case 3:zh(),E$1(Wf),E$1(H$2),Eh();break;case 5:Bh(tt);break;case 4:zh();break;case 13:E$1(L$2);break;case 19:E$1(L$2);break;case 10:ah(tt.type._context);break;case 22:case 23:Hj()}_e=_e.return}if(Q$1=et,Y$2=et=Pg(et.current,null),Z=fj=_,T$2=0,pk=null,rk=qk=rh=0,tk=sk=null,fh!==null){for(_=0;_<fh.length;_++)if(_e=fh[_],tt=_e.interleaved,tt!==null){_e.interleaved=null;var nt=tt.next,rt=_e.pending;if(rt!==null){var ot=rt.next;rt.next=nt,tt.next=ot}_e.pending=tt}fh=null}return et}function Mk(et,_){do{var _e=Y$2;try{if($g(),Fh.current=Rh,Ih){for(var tt=M$2.memoizedState;tt!==null;){var nt=tt.queue;nt!==null&&(nt.pending=null),tt=tt.next}Ih=!1}if(Hh=0,O$1=N$2=M$2=null,Jh=!1,Kh=0,nk.current=null,_e===null||_e.return===null){T$2=1,pk=_,Y$2=null;break}e:{var rt=et,ot=_e.return,at=_e,lt=_;if(_=Z,at.flags|=32768,lt!==null&&typeof lt=="object"&&typeof lt.then=="function"){var ut=lt,dt=at,st=dt.tag;if(!(dt.mode&1)&&(st===0||st===11||st===15)){var it=dt.alternate;it?(dt.updateQueue=it.updateQueue,dt.memoizedState=it.memoizedState,dt.lanes=it.lanes):(dt.updateQueue=null,dt.memoizedState=null)}var ct=Ui(ot);if(ct!==null){ct.flags&=-257,Vi(ct,ot,at,rt,_),ct.mode&1&&Si(rt,ut,_),_=ct,lt=ut;var ft=_.updateQueue;if(ft===null){var ht=new Set;ht.add(lt),_.updateQueue=ht}else ft.add(lt);break e}else{if(!(_&1)){Si(rt,ut,_),tj();break e}lt=Error(p$4(426))}}else if(I$3&&at.mode&1){var mt=Ui(ot);if(mt!==null){!(mt.flags&65536)&&(mt.flags|=256),Vi(mt,ot,at,rt,_),Jg(Ji(lt,at));break e}}rt=lt=Ji(lt,at),T$2!==4&&(T$2=2),sk===null?sk=[rt]:sk.push(rt),rt=ot;do{switch(rt.tag){case 3:rt.flags|=65536,_&=-_,rt.lanes|=_;var pt=Ni(rt,lt,_);ph(rt,pt);break e;case 1:at=lt;var _t=rt.type,vt=rt.stateNode;if(!(rt.flags&128)&&(typeof _t.getDerivedStateFromError=="function"||vt!==null&&typeof vt.componentDidCatch=="function"&&(Ri===null||!Ri.has(vt)))){rt.flags|=65536,_&=-_,rt.lanes|=_;var bt=Qi(rt,at,_);ph(rt,bt);break e}}rt=rt.return}while(rt!==null)}Sk(_e)}catch(wt){_=wt,Y$2===_e&&_e!==null&&(Y$2=_e=_e.return);continue}break}while(!0)}function Jk(){var et=mk.current;return mk.current=Rh,et===null?Rh:et}function tj(){(T$2===0||T$2===3||T$2===2)&&(T$2=4),Q$1===null||!(rh&268435455)&&!(qk&268435455)||Ck(Q$1,Z)}function Ik(et,_){var _e=K;K|=2;var tt=Jk();(Q$1!==et||Z!==_)&&(uk=null,Kk(et,_));do try{Tk();break}catch(nt){Mk(et,nt)}while(!0);if($g(),K=_e,mk.current=tt,Y$2!==null)throw Error(p$4(261));return Q$1=null,Z=0,T$2}function Tk(){for(;Y$2!==null;)Uk(Y$2)}function Lk(){for(;Y$2!==null&&!cc();)Uk(Y$2)}function Uk(et){var _=Vk(et.alternate,et,fj);et.memoizedProps=et.pendingProps,_===null?Sk(et):Y$2=_,nk.current=null}function Sk(et){var _=et;do{var _e=_.alternate;if(et=_.return,_.flags&32768){if(_e=Ij(_e,_),_e!==null){_e.flags&=32767,Y$2=_e;return}if(et!==null)et.flags|=32768,et.subtreeFlags=0,et.deletions=null;else{T$2=6,Y$2=null;return}}else if(_e=Ej(_e,_,fj),_e!==null){Y$2=_e;return}if(_=_.sibling,_!==null){Y$2=_;return}Y$2=_=et}while(_!==null);T$2===0&&(T$2=5)}function Pk(et,_,_e){var tt=C$1,nt=ok.transition;try{ok.transition=null,C$1=1,Wk(et,_,_e,tt)}finally{ok.transition=nt,C$1=tt}return null}function Wk(et,_,_e,tt){do Hk();while(wk!==null);if(K&6)throw Error(p$4(327));_e=et.finishedWork;var nt=et.finishedLanes;if(_e===null)return null;if(et.finishedWork=null,et.finishedLanes=0,_e===et.current)throw Error(p$4(177));et.callbackNode=null,et.callbackPriority=0;var rt=_e.lanes|_e.childLanes;if(Bc(et,rt),et===Q$1&&(Y$2=Q$1=null,Z=0),!(_e.subtreeFlags&2064)&&!(_e.flags&2064)||vk||(vk=!0,Fk(hc,function(){return Hk(),null})),rt=(_e.flags&15990)!==0,_e.subtreeFlags&15990||rt){rt=ok.transition,ok.transition=null;var ot=C$1;C$1=1;var at=K;K|=4,nk.current=null,Oj(et,_e),dk(_e,et),Oe(Df),dd=!!Cf,Df=Cf=null,et.current=_e,hk(_e),dc(),K=at,C$1=ot,ok.transition=rt}else et.current=_e;if(vk&&(vk=!1,wk=et,xk=nt),rt=et.pendingLanes,rt===0&&(Ri=null),mc(_e.stateNode),Dk(et,B$1()),_!==null)for(tt=et.onRecoverableError,_e=0;_e<_.length;_e++)nt=_[_e],tt(nt.value,{componentStack:nt.stack,digest:nt.digest});if(Oi)throw Oi=!1,et=Pi,Pi=null,et;return xk&1&&et.tag!==0&&Hk(),rt=et.pendingLanes,rt&1?et===zk?yk++:(yk=0,zk=et):yk=0,jg(),null}function Hk(){if(wk!==null){var et=Dc(xk),_=ok.transition,_e=C$1;try{if(ok.transition=null,C$1=16>et?16:et,wk===null)var tt=!1;else{if(et=wk,wk=null,xk=0,K&6)throw Error(p$4(331));var nt=K;for(K|=4,V$3=et.current;V$3!==null;){var rt=V$3,ot=rt.child;if(V$3.flags&16){var at=rt.deletions;if(at!==null){for(var lt=0;lt<at.length;lt++){var ut=at[lt];for(V$3=ut;V$3!==null;){var dt=V$3;switch(dt.tag){case 0:case 11:case 15:Pj(8,dt,rt)}var st=dt.child;if(st!==null)st.return=dt,V$3=st;else for(;V$3!==null;){dt=V$3;var it=dt.sibling,ct=dt.return;if(Sj(dt),dt===ut){V$3=null;break}if(it!==null){it.return=ct,V$3=it;break}V$3=ct}}}var ft=rt.alternate;if(ft!==null){var ht=ft.child;if(ht!==null){ft.child=null;do{var mt=ht.sibling;ht.sibling=null,ht=mt}while(ht!==null)}}V$3=rt}}if(rt.subtreeFlags&2064&&ot!==null)ot.return=rt,V$3=ot;else e:for(;V$3!==null;){if(rt=V$3,rt.flags&2048)switch(rt.tag){case 0:case 11:case 15:Pj(9,rt,rt.return)}var pt=rt.sibling;if(pt!==null){pt.return=rt.return,V$3=pt;break e}V$3=rt.return}}var _t=et.current;for(V$3=_t;V$3!==null;){ot=V$3;var vt=ot.child;if(ot.subtreeFlags&2064&&vt!==null)vt.return=ot,V$3=vt;else e:for(ot=_t;V$3!==null;){if(at=V$3,at.flags&2048)try{switch(at.tag){case 0:case 11:case 15:Qj(9,at)}}catch(wt){W$1(at,at.return,wt)}if(at===ot){V$3=null;break e}var bt=at.sibling;if(bt!==null){bt.return=at.return,V$3=bt;break e}V$3=at.return}}if(K=nt,jg(),lc&&typeof lc.onPostCommitFiberRoot=="function")try{lc.onPostCommitFiberRoot(kc,et)}catch{}tt=!0}return tt}finally{C$1=_e,ok.transition=_}}return!1}function Xk(et,_,_e){_=Ji(_e,_),_=Ni(et,_,1),et=nh(et,_,1),_=R$1(),et!==null&&(Ac(et,1,_),Dk(et,_))}function W$1(et,_,_e){if(et.tag===3)Xk(et,et,_e);else for(;_!==null;){if(_.tag===3){Xk(_,et,_e);break}else if(_.tag===1){var tt=_.stateNode;if(typeof _.type.getDerivedStateFromError=="function"||typeof tt.componentDidCatch=="function"&&(Ri===null||!Ri.has(tt))){et=Ji(_e,et),et=Qi(_,et,1),_=nh(_,et,1),et=R$1(),_!==null&&(Ac(_,1,et),Dk(_,et));break}}_=_.return}}function Ti(et,_,_e){var tt=et.pingCache;tt!==null&&tt.delete(_),_=R$1(),et.pingedLanes|=et.suspendedLanes&_e,Q$1===et&&(Z&_e)===_e&&(T$2===4||T$2===3&&(Z&130023424)===Z&&500>B$1()-fk?Kk(et,0):rk|=_e),Dk(et,_)}function Yk(et,_){_===0&&(et.mode&1?(_=sc,sc<<=1,!(sc&130023424)&&(sc=4194304)):_=1);var _e=R$1();et=ih(et,_),et!==null&&(Ac(et,_,_e),Dk(et,_e))}function uj(et){var _=et.memoizedState,_e=0;_!==null&&(_e=_.retryLane),Yk(et,_e)}function bk(et,_){var _e=0;switch(et.tag){case 13:var tt=et.stateNode,nt=et.memoizedState;nt!==null&&(_e=nt.retryLane);break;case 19:tt=et.stateNode;break;default:throw Error(p$4(314))}tt!==null&&tt.delete(_),Yk(et,_e)}var Vk;Vk=function(et,_,_e){if(et!==null)if(et.memoizedProps!==_.pendingProps||Wf.current)dh=!0;else{if(!(et.lanes&_e)&&!(_.flags&128))return dh=!1,yj(et,_,_e);dh=!!(et.flags&131072)}else dh=!1,I$3&&_.flags&1048576&&ug(_,ng,_.index);switch(_.lanes=0,_.tag){case 2:var tt=_.type;ij(et,_),et=_.pendingProps;var nt=Yf(_,H$2.current);ch(_,_e),nt=Nh(null,_,tt,et,nt,_e);var rt=Sh();return _.flags|=1,typeof nt=="object"&&nt!==null&&typeof nt.render=="function"&&nt.$$typeof===void 0?(_.tag=1,_.memoizedState=null,_.updateQueue=null,Zf(tt)?(rt=!0,cg(_)):rt=!1,_.memoizedState=nt.state!==null&&nt.state!==void 0?nt.state:null,kh(_),nt.updater=Ei,_.stateNode=nt,nt._reactInternals=_,Ii(_,tt,et,_e),_=jj(null,_,tt,!0,rt,_e)):(_.tag=0,I$3&&rt&&vg(_),Xi(null,_,nt,_e),_=_.child),_;case 16:tt=_.elementType;e:{switch(ij(et,_),et=_.pendingProps,nt=tt._init,tt=nt(tt._payload),_.type=tt,nt=_.tag=Zk(tt),et=Ci(tt,et),nt){case 0:_=cj(null,_,tt,et,_e);break e;case 1:_=hj(null,_,tt,et,_e);break e;case 11:_=Yi(null,_,tt,et,_e);break e;case 14:_=$i(null,_,tt,Ci(tt.type,et),_e);break e}throw Error(p$4(306,tt,""))}return _;case 0:return tt=_.type,nt=_.pendingProps,nt=_.elementType===tt?nt:Ci(tt,nt),cj(et,_,tt,nt,_e);case 1:return tt=_.type,nt=_.pendingProps,nt=_.elementType===tt?nt:Ci(tt,nt),hj(et,_,tt,nt,_e);case 3:e:{if(kj(_),et===null)throw Error(p$4(387));tt=_.pendingProps,rt=_.memoizedState,nt=rt.element,lh(et,_),qh(_,tt,null,_e);var ot=_.memoizedState;if(tt=ot.element,rt.isDehydrated)if(rt={element:tt,isDehydrated:!1,cache:ot.cache,pendingSuspenseBoundaries:ot.pendingSuspenseBoundaries,transitions:ot.transitions},_.updateQueue.baseState=rt,_.memoizedState=rt,_.flags&256){nt=Ji(Error(p$4(423)),_),_=lj(et,_,tt,_e,nt);break e}else if(tt!==nt){nt=Ji(Error(p$4(424)),_),_=lj(et,_,tt,_e,nt);break e}else for(yg=Lf(_.stateNode.containerInfo.firstChild),xg=_,I$3=!0,zg=null,_e=Vg(_,null,tt,_e),_.child=_e;_e;)_e.flags=_e.flags&-3|4096,_e=_e.sibling;else{if(Ig(),tt===nt){_=Zi(et,_,_e);break e}Xi(et,_,tt,_e)}_=_.child}return _;case 5:return Ah(_),et===null&&Eg(_),tt=_.type,nt=_.pendingProps,rt=et!==null?et.memoizedProps:null,ot=nt.children,Ef(tt,nt)?ot=null:rt!==null&&Ef(tt,rt)&&(_.flags|=32),gj(et,_),Xi(et,_,ot,_e),_.child;case 6:return et===null&&Eg(_),null;case 13:return oj(et,_,_e);case 4:return yh(_,_.stateNode.containerInfo),tt=_.pendingProps,et===null?_.child=Ug(_,null,tt,_e):Xi(et,_,tt,_e),_.child;case 11:return tt=_.type,nt=_.pendingProps,nt=_.elementType===tt?nt:Ci(tt,nt),Yi(et,_,tt,nt,_e);case 7:return Xi(et,_,_.pendingProps,_e),_.child;case 8:return Xi(et,_,_.pendingProps.children,_e),_.child;case 12:return Xi(et,_,_.pendingProps.children,_e),_.child;case 10:e:{if(tt=_.type._context,nt=_.pendingProps,rt=_.memoizedProps,ot=nt.value,G$1(Wg,tt._currentValue),tt._currentValue=ot,rt!==null)if(He(rt.value,ot)){if(rt.children===nt.children&&!Wf.current){_=Zi(et,_,_e);break e}}else for(rt=_.child,rt!==null&&(rt.return=_);rt!==null;){var at=rt.dependencies;if(at!==null){ot=rt.child;for(var lt=at.firstContext;lt!==null;){if(lt.context===tt){if(rt.tag===1){lt=mh(-1,_e&-_e),lt.tag=2;var ut=rt.updateQueue;if(ut!==null){ut=ut.shared;var dt=ut.pending;dt===null?lt.next=lt:(lt.next=dt.next,dt.next=lt),ut.pending=lt}}rt.lanes|=_e,lt=rt.alternate,lt!==null&&(lt.lanes|=_e),bh(rt.return,_e,_),at.lanes|=_e;break}lt=lt.next}}else if(rt.tag===10)ot=rt.type===_.type?null:rt.child;else if(rt.tag===18){if(ot=rt.return,ot===null)throw Error(p$4(341));ot.lanes|=_e,at=ot.alternate,at!==null&&(at.lanes|=_e),bh(ot,_e,_),ot=rt.sibling}else ot=rt.child;if(ot!==null)ot.return=rt;else for(ot=rt;ot!==null;){if(ot===_){ot=null;break}if(rt=ot.sibling,rt!==null){rt.return=ot.return,ot=rt;break}ot=ot.return}rt=ot}Xi(et,_,nt.children,_e),_=_.child}return _;case 9:return nt=_.type,tt=_.pendingProps.children,ch(_,_e),nt=eh(nt),tt=tt(nt),_.flags|=1,Xi(et,_,tt,_e),_.child;case 14:return tt=_.type,nt=Ci(tt,_.pendingProps),nt=Ci(tt.type,nt),$i(et,_,tt,nt,_e);case 15:return bj(et,_,_.type,_.pendingProps,_e);case 17:return tt=_.type,nt=_.pendingProps,nt=_.elementType===tt?nt:Ci(tt,nt),ij(et,_),_.tag=1,Zf(tt)?(et=!0,cg(_)):et=!1,ch(_,_e),Gi(_,tt,nt),Ii(_,tt,nt,_e),jj(null,_,tt,!0,et,_e);case 19:return xj(et,_,_e);case 22:return dj(et,_,_e)}throw Error(p$4(156,_.tag))};function Fk(et,_){return ac(et,_)}function $k(et,_,_e,tt){this.tag=et,this.key=_e,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=_,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=tt,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Bg(et,_,_e,tt){return new $k(et,_,_e,tt)}function aj(et){return et=et.prototype,!(!et||!et.isReactComponent)}function Zk(et){if(typeof et=="function")return aj(et)?1:0;if(et!=null){if(et=et.$$typeof,et===Da)return 11;if(et===Ga)return 14}return 2}function Pg(et,_){var _e=et.alternate;return _e===null?(_e=Bg(et.tag,_,et.key,et.mode),_e.elementType=et.elementType,_e.type=et.type,_e.stateNode=et.stateNode,_e.alternate=et,et.alternate=_e):(_e.pendingProps=_,_e.type=et.type,_e.flags=0,_e.subtreeFlags=0,_e.deletions=null),_e.flags=et.flags&14680064,_e.childLanes=et.childLanes,_e.lanes=et.lanes,_e.child=et.child,_e.memoizedProps=et.memoizedProps,_e.memoizedState=et.memoizedState,_e.updateQueue=et.updateQueue,_=et.dependencies,_e.dependencies=_===null?null:{lanes:_.lanes,firstContext:_.firstContext},_e.sibling=et.sibling,_e.index=et.index,_e.ref=et.ref,_e}function Rg(et,_,_e,tt,nt,rt){var ot=2;if(tt=et,typeof et=="function")aj(et)&&(ot=1);else if(typeof et=="string")ot=5;else e:switch(et){case ya:return Tg(_e.children,nt,rt,_);case za:ot=8,nt|=8;break;case Aa:return et=Bg(12,_e,_,nt|2),et.elementType=Aa,et.lanes=rt,et;case Ea:return et=Bg(13,_e,_,nt),et.elementType=Ea,et.lanes=rt,et;case Fa:return et=Bg(19,_e,_,nt),et.elementType=Fa,et.lanes=rt,et;case Ia:return pj(_e,nt,rt,_);default:if(typeof et=="object"&&et!==null)switch(et.$$typeof){case Ba:ot=10;break e;case Ca:ot=9;break e;case Da:ot=11;break e;case Ga:ot=14;break e;case Ha:ot=16,tt=null;break e}throw Error(p$4(130,et==null?et:typeof et,""))}return _=Bg(ot,_e,_,nt),_.elementType=et,_.type=tt,_.lanes=rt,_}function Tg(et,_,_e,tt){return et=Bg(7,et,tt,_),et.lanes=_e,et}function pj(et,_,_e,tt){return et=Bg(22,et,tt,_),et.elementType=Ia,et.lanes=_e,et.stateNode={isHidden:!1},et}function Qg(et,_,_e){return et=Bg(6,et,null,_),et.lanes=_e,et}function Sg(et,_,_e){return _=Bg(4,et.children!==null?et.children:[],et.key,_),_.lanes=_e,_.stateNode={containerInfo:et.containerInfo,pendingChildren:null,implementation:et.implementation},_}function al(et,_,_e,tt,nt){this.tag=_,this.containerInfo=et,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=zc(0),this.expirationTimes=zc(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=zc(0),this.identifierPrefix=tt,this.onRecoverableError=nt,this.mutableSourceEagerHydrationData=null}function bl(et,_,_e,tt,nt,rt,ot,at,lt){return et=new al(et,_,_e,at,lt),_===1?(_=1,rt===!0&&(_|=8)):_=0,rt=Bg(3,null,null,_),et.current=rt,rt.stateNode=et,rt.memoizedState={element:tt,isDehydrated:_e,cache:null,transitions:null,pendingSuspenseBoundaries:null},kh(rt),et}function cl(et,_,_e){var tt=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:wa,key:tt==null?null:""+tt,children:et,containerInfo:_,implementation:_e}}function dl(et){if(!et)return Vf;et=et._reactInternals;e:{if(Vb(et)!==et||et.tag!==1)throw Error(p$4(170));var _=et;do{switch(_.tag){case 3:_=_.stateNode.context;break e;case 1:if(Zf(_.type)){_=_.stateNode.__reactInternalMemoizedMergedChildContext;break e}}_=_.return}while(_!==null);throw Error(p$4(171))}if(et.tag===1){var _e=et.type;if(Zf(_e))return bg(et,_e,_)}return _}function el(et,_,_e,tt,nt,rt,ot,at,lt){return et=bl(_e,tt,!0,et,nt,rt,ot,at,lt),et.context=dl(null),_e=et.current,tt=R$1(),nt=yi(_e),rt=mh(tt,nt),rt.callback=_??null,nh(_e,rt,nt),et.current.lanes=nt,Ac(et,nt,tt),Dk(et,tt),et}function fl(et,_,_e,tt){var nt=_.current,rt=R$1(),ot=yi(nt);return _e=dl(_e),_.context===null?_.context=_e:_.pendingContext=_e,_=mh(rt,ot),_.payload={element:et},tt=tt===void 0?null:tt,tt!==null&&(_.callback=tt),et=nh(nt,_,ot),et!==null&&(gi(et,nt,ot,rt),oh(et,nt,ot)),ot}function gl(et){if(et=et.current,!et.child)return null;switch(et.child.tag){case 5:return et.child.stateNode;default:return et.child.stateNode}}function hl(et,_){if(et=et.memoizedState,et!==null&&et.dehydrated!==null){var _e=et.retryLane;et.retryLane=_e!==0&&_e<_?_e:_}}function il(et,_){hl(et,_),(et=et.alternate)&&hl(et,_)}function jl(){return null}var kl=typeof reportError=="function"?reportError:function(et){console.error(et)};function ll(et){this._internalRoot=et}ml.prototype.render=ll.prototype.render=function(et){var _=this._internalRoot;if(_===null)throw Error(p$4(409));fl(et,_,null,null)};ml.prototype.unmount=ll.prototype.unmount=function(){var et=this._internalRoot;if(et!==null){this._internalRoot=null;var _=et.containerInfo;Rk(function(){fl(null,et,null,null)}),_[uf]=null}};function ml(et){this._internalRoot=et}ml.prototype.unstable_scheduleHydration=function(et){if(et){var _=Hc();et={blockedOn:null,target:et,priority:_};for(var _e=0;_e<Qc.length&&_!==0&&_<Qc[_e].priority;_e++);Qc.splice(_e,0,et),_e===0&&Vc(et)}};function nl(et){return!(!et||et.nodeType!==1&&et.nodeType!==9&&et.nodeType!==11)}function ol(et){return!(!et||et.nodeType!==1&&et.nodeType!==9&&et.nodeType!==11&&(et.nodeType!==8||et.nodeValue!==" react-mount-point-unstable "))}function pl(){}function ql(et,_,_e,tt,nt){if(nt){if(typeof tt=="function"){var rt=tt;tt=function(){var ut=gl(ot);rt.call(ut)}}var ot=el(_,tt,et,0,null,!1,!1,"",pl);return et._reactRootContainer=ot,et[uf]=ot.current,sf(et.nodeType===8?et.parentNode:et),Rk(),ot}for(;nt=et.lastChild;)et.removeChild(nt);if(typeof tt=="function"){var at=tt;tt=function(){var ut=gl(lt);at.call(ut)}}var lt=bl(et,0,!1,null,null,!1,!1,"",pl);return et._reactRootContainer=lt,et[uf]=lt.current,sf(et.nodeType===8?et.parentNode:et),Rk(function(){fl(_,lt,_e,tt)}),lt}function rl(et,_,_e,tt,nt){var rt=_e._reactRootContainer;if(rt){var ot=rt;if(typeof nt=="function"){var at=nt;nt=function(){var lt=gl(ot);at.call(lt)}}fl(_,ot,et,nt)}else ot=ql(_e,_,et,nt,tt);return gl(ot)}Ec=function(et){switch(et.tag){case 3:var _=et.stateNode;if(_.current.memoizedState.isDehydrated){var _e=tc(_.pendingLanes);_e!==0&&(Cc(_,_e|1),Dk(_,B$1()),!(K&6)&&(Gj=B$1()+500,jg()))}break;case 13:Rk(function(){var tt=ih(et,1);if(tt!==null){var nt=R$1();gi(tt,et,1,nt)}}),il(et,1)}};Fc=function(et){if(et.tag===13){var _=ih(et,134217728);if(_!==null){var _e=R$1();gi(_,et,134217728,_e)}il(et,134217728)}};Gc=function(et){if(et.tag===13){var _=yi(et),_e=ih(et,_);if(_e!==null){var tt=R$1();gi(_e,et,_,tt)}il(et,_)}};Hc=function(){return C$1};Ic=function(et,_){var _e=C$1;try{return C$1=et,_()}finally{C$1=_e}};yb=function(et,_,_e){switch(_){case"input":if(bb(et,_e),_=_e.name,_e.type==="radio"&&_!=null){for(_e=et;_e.parentNode;)_e=_e.parentNode;for(_e=_e.querySelectorAll("input[name="+JSON.stringify(""+_)+'][type="radio"]'),_=0;_<_e.length;_++){var tt=_e[_];if(tt!==et&&tt.form===et.form){var nt=Db(tt);if(!nt)throw Error(p$4(90));Wa(tt),bb(tt,nt)}}}break;case"textarea":ib(et,_e);break;case"select":_=_e.value,_!=null&&fb(et,!!_e.multiple,_,!1)}};Gb=Qk;Hb=Rk;var sl={usingClientEntryPoint:!1,Events:[Cb,ue,Db,Eb,Fb,Qk]},tl={findFiberByHostInstance:Wc,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},ul={bundleType:tl.bundleType,version:tl.version,rendererPackageName:tl.rendererPackageName,rendererConfig:tl.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ua.ReactCurrentDispatcher,findHostInstanceByFiber:function(et){return et=Zb(et),et===null?null:et.stateNode},findFiberByHostInstance:tl.findFiberByHostInstance||jl,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var vl=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!vl.isDisabled&&vl.supportsFiber)try{kc=vl.inject(ul),lc=vl}catch{}}reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=sl;reactDom_production_min.createPortal=function(et,_){var _e=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!nl(_))throw Error(p$4(200));return cl(et,_,null,_e)};reactDom_production_min.createRoot=function(et,_){if(!nl(et))throw Error(p$4(299));var _e=!1,tt="",nt=kl;return _!=null&&(_.unstable_strictMode===!0&&(_e=!0),_.identifierPrefix!==void 0&&(tt=_.identifierPrefix),_.onRecoverableError!==void 0&&(nt=_.onRecoverableError)),_=bl(et,1,!1,null,null,_e,!1,tt,nt),et[uf]=_.current,sf(et.nodeType===8?et.parentNode:et),new ll(_)};reactDom_production_min.findDOMNode=function(et){if(et==null)return null;if(et.nodeType===1)return et;var _=et._reactInternals;if(_===void 0)throw typeof et.render=="function"?Error(p$4(188)):(et=Object.keys(et).join(","),Error(p$4(268,et)));return et=Zb(_),et=et===null?null:et.stateNode,et};reactDom_production_min.flushSync=function(et){return Rk(et)};reactDom_production_min.hydrate=function(et,_,_e){if(!ol(_))throw Error(p$4(200));return rl(null,et,_,!0,_e)};reactDom_production_min.hydrateRoot=function(et,_,_e){if(!nl(et))throw Error(p$4(405));var tt=_e!=null&&_e.hydratedSources||null,nt=!1,rt="",ot=kl;if(_e!=null&&(_e.unstable_strictMode===!0&&(nt=!0),_e.identifierPrefix!==void 0&&(rt=_e.identifierPrefix),_e.onRecoverableError!==void 0&&(ot=_e.onRecoverableError)),_=el(_,null,et,1,_e??null,nt,!1,rt,ot),et[uf]=_.current,sf(et),tt)for(et=0;et<tt.length;et++)_e=tt[et],nt=_e._getVersion,nt=nt(_e._source),_.mutableSourceEagerHydrationData==null?_.mutableSourceEagerHydrationData=[_e,nt]:_.mutableSourceEagerHydrationData.push(_e,nt);return new ml(_)};reactDom_production_min.render=function(et,_,_e){if(!ol(_))throw Error(p$4(200));return rl(null,et,_,!1,_e)};reactDom_production_min.unmountComponentAtNode=function(et){if(!ol(et))throw Error(p$4(40));return et._reactRootContainer?(Rk(function(){rl(null,null,et,!1,function(){et._reactRootContainer=null,et[uf]=null})}),!0):!1};reactDom_production_min.unstable_batchedUpdates=Qk;reactDom_production_min.unstable_renderSubtreeIntoContainer=function(et,_,_e,tt){if(!ol(_e))throw Error(p$4(200));if(et==null||et._reactInternals===void 0)throw Error(p$4(38));return rl(et,_,_e,!1,tt)};reactDom_production_min.version="18.3.1-next-f1338f8080-20240426";function checkDCE(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)}catch(et){console.error(et)}}checkDCE(),reactDom.exports=reactDom_production_min;var reactDomExports=reactDom.exports;const ReactDOM=getDefaultExportFromCjs(reactDomExports);var m$3=reactDomExports;client.createRoot=m$3.createRoot,client.hydrateRoot=m$3.hydrateRoot;/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const REVISION="166",MOUSE={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},TOUCH={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},CullFaceNone=0,CullFaceBack=1,CullFaceFront=2,CullFaceFrontBack=3,BasicShadowMap=0,PCFShadowMap=1,PCFSoftShadowMap=2,VSMShadowMap=3,FrontSide=0,BackSide=1,DoubleSide=2,NoBlending=0,NormalBlending=1,AdditiveBlending=2,SubtractiveBlending=3,MultiplyBlending=4,CustomBlending=5,AddEquation=100,SubtractEquation=101,ReverseSubtractEquation=102,MinEquation=103,MaxEquation=104,ZeroFactor=200,OneFactor=201,SrcColorFactor=202,OneMinusSrcColorFactor=203,SrcAlphaFactor=204,OneMinusSrcAlphaFactor=205,DstAlphaFactor=206,OneMinusDstAlphaFactor=207,DstColorFactor=208,OneMinusDstColorFactor=209,SrcAlphaSaturateFactor=210,ConstantColorFactor=211,OneMinusConstantColorFactor=212,ConstantAlphaFactor=213,OneMinusConstantAlphaFactor=214,NeverDepth=0,AlwaysDepth=1,LessDepth=2,LessEqualDepth=3,EqualDepth=4,GreaterEqualDepth=5,GreaterDepth=6,NotEqualDepth=7,MultiplyOperation=0,MixOperation=1,AddOperation=2,NoToneMapping=0,LinearToneMapping=1,ReinhardToneMapping=2,CineonToneMapping=3,ACESFilmicToneMapping=4,CustomToneMapping=5,AgXToneMapping=6,NeutralToneMapping=7,AttachedBindMode="attached",DetachedBindMode="detached",UVMapping=300,CubeReflectionMapping=301,CubeRefractionMapping=302,EquirectangularReflectionMapping=303,EquirectangularRefractionMapping=304,CubeUVReflectionMapping=306,RepeatWrapping=1e3,ClampToEdgeWrapping=1001,MirroredRepeatWrapping=1002,NearestFilter=1003,NearestMipmapNearestFilter=1004,NearestMipMapNearestFilter=1004,NearestMipmapLinearFilter=1005,NearestMipMapLinearFilter=1005,LinearFilter=1006,LinearMipmapNearestFilter=1007,LinearMipMapNearestFilter=1007,LinearMipmapLinearFilter=1008,LinearMipMapLinearFilter=1008,UnsignedByteType=1009,ByteType=1010,ShortType=1011,UnsignedShortType=1012,IntType=1013,UnsignedIntType=1014,FloatType=1015,HalfFloatType=1016,UnsignedShort4444Type=1017,UnsignedShort5551Type=1018,UnsignedInt248Type=1020,UnsignedInt5999Type=35902,AlphaFormat=1021,RGBFormat=1022,RGBAFormat=1023,LuminanceFormat=1024,LuminanceAlphaFormat=1025,DepthFormat=1026,DepthStencilFormat=1027,RedFormat=1028,RedIntegerFormat=1029,RGFormat=1030,RGIntegerFormat=1031,RGBIntegerFormat=1032,RGBAIntegerFormat=1033,RGB_S3TC_DXT1_Format=33776,RGBA_S3TC_DXT1_Format=33777,RGBA_S3TC_DXT3_Format=33778,RGBA_S3TC_DXT5_Format=33779,RGB_PVRTC_4BPPV1_Format=35840,RGB_PVRTC_2BPPV1_Format=35841,RGBA_PVRTC_4BPPV1_Format=35842,RGBA_PVRTC_2BPPV1_Format=35843,RGB_ETC1_Format=36196,RGB_ETC2_Format=37492,RGBA_ETC2_EAC_Format=37496,RGBA_ASTC_4x4_Format=37808,RGBA_ASTC_5x4_Format=37809,RGBA_ASTC_5x5_Format=37810,RGBA_ASTC_6x5_Format=37811,RGBA_ASTC_6x6_Format=37812,RGBA_ASTC_8x5_Format=37813,RGBA_ASTC_8x6_Format=37814,RGBA_ASTC_8x8_Format=37815,RGBA_ASTC_10x5_Format=37816,RGBA_ASTC_10x6_Format=37817,RGBA_ASTC_10x8_Format=37818,RGBA_ASTC_10x10_Format=37819,RGBA_ASTC_12x10_Format=37820,RGBA_ASTC_12x12_Format=37821,RGBA_BPTC_Format=36492,RGB_BPTC_SIGNED_Format=36494,RGB_BPTC_UNSIGNED_Format=36495,RED_RGTC1_Format=36283,SIGNED_RED_RGTC1_Format=36284,RED_GREEN_RGTC2_Format=36285,SIGNED_RED_GREEN_RGTC2_Format=36286,LoopOnce=2200,LoopRepeat=2201,LoopPingPong=2202,InterpolateDiscrete=2300,InterpolateLinear=2301,InterpolateSmooth=2302,ZeroCurvatureEnding=2400,ZeroSlopeEnding=2401,WrapAroundEnding=2402,NormalAnimationBlendMode=2500,AdditiveAnimationBlendMode=2501,TrianglesDrawMode=0,TriangleStripDrawMode=1,TriangleFanDrawMode=2,BasicDepthPacking=3200,RGBADepthPacking=3201,TangentSpaceNormalMap=0,ObjectSpaceNormalMap=1,NoColorSpace="",SRGBColorSpace="srgb",LinearSRGBColorSpace="srgb-linear",DisplayP3ColorSpace="display-p3",LinearDisplayP3ColorSpace="display-p3-linear",LinearTransfer="linear",SRGBTransfer="srgb",Rec709Primaries="rec709",P3Primaries="p3",ZeroStencilOp=0,KeepStencilOp=7680,ReplaceStencilOp=7681,IncrementStencilOp=7682,DecrementStencilOp=7683,IncrementWrapStencilOp=34055,DecrementWrapStencilOp=34056,InvertStencilOp=5386,NeverStencilFunc=512,LessStencilFunc=513,EqualStencilFunc=514,LessEqualStencilFunc=515,GreaterStencilFunc=516,NotEqualStencilFunc=517,GreaterEqualStencilFunc=518,AlwaysStencilFunc=519,NeverCompare=512,LessCompare=513,EqualCompare=514,LessEqualCompare=515,GreaterCompare=516,NotEqualCompare=517,GreaterEqualCompare=518,AlwaysCompare=519,StaticDrawUsage=35044,DynamicDrawUsage=35048,StreamDrawUsage=35040,StaticReadUsage=35045,DynamicReadUsage=35049,StreamReadUsage=35041,StaticCopyUsage=35046,DynamicCopyUsage=35050,StreamCopyUsage=35042,GLSL1="100",GLSL3="300 es",WebGLCoordinateSystem=2e3,WebGPUCoordinateSystem=2001;class EventDispatcher{addEventListener(_,_e){this._listeners===void 0&&(this._listeners={});const tt=this._listeners;tt[_]===void 0&&(tt[_]=[]),tt[_].indexOf(_e)===-1&&tt[_].push(_e)}hasEventListener(_,_e){if(this._listeners===void 0)return!1;const tt=this._listeners;return tt[_]!==void 0&&tt[_].indexOf(_e)!==-1}removeEventListener(_,_e){if(this._listeners===void 0)return;const nt=this._listeners[_];if(nt!==void 0){const rt=nt.indexOf(_e);rt!==-1&&nt.splice(rt,1)}}dispatchEvent(_){if(this._listeners===void 0)return;const tt=this._listeners[_.type];if(tt!==void 0){_.target=this;const nt=tt.slice(0);for(let rt=0,ot=nt.length;rt<ot;rt++)nt[rt].call(this,_);_.target=null}}}const _lut=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let _seed=1234567;const DEG2RAD=Math.PI/180,RAD2DEG=180/Math.PI;function generateUUID(){const et=Math.random()*4294967295|0,_=Math.random()*4294967295|0,_e=Math.random()*4294967295|0,tt=Math.random()*4294967295|0;return(_lut[et&255]+_lut[et>>8&255]+_lut[et>>16&255]+_lut[et>>24&255]+"-"+_lut[_&255]+_lut[_>>8&255]+"-"+_lut[_>>16&15|64]+_lut[_>>24&255]+"-"+_lut[_e&63|128]+_lut[_e>>8&255]+"-"+_lut[_e>>16&255]+_lut[_e>>24&255]+_lut[tt&255]+_lut[tt>>8&255]+_lut[tt>>16&255]+_lut[tt>>24&255]).toLowerCase()}function clamp$4(et,_,_e){return Math.max(_,Math.min(_e,et))}function euclideanModulo(et,_){return(et%_+_)%_}function mapLinear(et,_,_e,tt,nt){return tt+(et-_)*(nt-tt)/(_e-_)}function inverseLerp(et,_,_e){return et!==_?(_e-et)/(_-et):0}function lerp(et,_,_e){return(1-_e)*et+_e*_}function damp$1(et,_,_e,tt){return lerp(et,_,1-Math.exp(-_e*tt))}function pingpong(et,_=1){return _-Math.abs(euclideanModulo(et,_*2)-_)}function smoothstep(et,_,_e){return et<=_?0:et>=_e?1:(et=(et-_)/(_e-_),et*et*(3-2*et))}function smootherstep(et,_,_e){return et<=_?0:et>=_e?1:(et=(et-_)/(_e-_),et*et*et*(et*(et*6-15)+10))}function randInt(et,_){return et+Math.floor(Math.random()*(_-et+1))}function randFloat(et,_){return et+Math.random()*(_-et)}function randFloatSpread(et){return et*(.5-Math.random())}function seededRandom(et){et!==void 0&&(_seed=et);let _=_seed+=1831565813;return _=Math.imul(_^_>>>15,_|1),_^=_+Math.imul(_^_>>>7,_|61),((_^_>>>14)>>>0)/4294967296}function degToRad(et){return et*DEG2RAD}function radToDeg(et){return et*RAD2DEG}function isPowerOfTwo$1(et){return(et&et-1)===0&&et!==0}function ceilPowerOfTwo(et){return Math.pow(2,Math.ceil(Math.log(et)/Math.LN2))}function floorPowerOfTwo(et){return Math.pow(2,Math.floor(Math.log(et)/Math.LN2))}function setQuaternionFromProperEuler(et,_,_e,tt,nt){const rt=Math.cos,ot=Math.sin,at=rt(_e/2),lt=ot(_e/2),ut=rt((_+tt)/2),dt=ot((_+tt)/2),st=rt((_-tt)/2),it=ot((_-tt)/2),ct=rt((tt-_)/2),ft=ot((tt-_)/2);switch(nt){case"XYX":et.set(at*dt,lt*st,lt*it,at*ut);break;case"YZY":et.set(lt*it,at*dt,lt*st,at*ut);break;case"ZXZ":et.set(lt*st,lt*it,at*dt,at*ut);break;case"XZX":et.set(at*dt,lt*ft,lt*ct,at*ut);break;case"YXY":et.set(lt*ct,at*dt,lt*ft,at*ut);break;case"ZYZ":et.set(lt*ft,lt*ct,at*dt,at*ut);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+nt)}}function denormalize(et,_){switch(_.constructor){case Float32Array:return et;case Uint32Array:return et/4294967295;case Uint16Array:return et/65535;case Uint8Array:return et/255;case Int32Array:return Math.max(et/2147483647,-1);case Int16Array:return Math.max(et/32767,-1);case Int8Array:return Math.max(et/127,-1);default:throw new Error("Invalid component type.")}}function normalize$5(et,_){switch(_.constructor){case Float32Array:return et;case Uint32Array:return Math.round(et*4294967295);case Uint16Array:return Math.round(et*65535);case Uint8Array:return Math.round(et*255);case Int32Array:return Math.round(et*2147483647);case Int16Array:return Math.round(et*32767);case Int8Array:return Math.round(et*127);default:throw new Error("Invalid component type.")}}const MathUtils={DEG2RAD,RAD2DEG,generateUUID,clamp:clamp$4,euclideanModulo,mapLinear,inverseLerp,lerp,damp:damp$1,pingpong,smoothstep,smootherstep,randInt,randFloat,randFloatSpread,seededRandom,degToRad,radToDeg,isPowerOfTwo:isPowerOfTwo$1,ceilPowerOfTwo,floorPowerOfTwo,setQuaternionFromProperEuler,normalize:normalize$5,denormalize};class Vector2{constructor(_=0,_e=0){Vector2.prototype.isVector2=!0,this.x=_,this.y=_e}get width(){return this.x}set width(_){this.x=_}get height(){return this.y}set height(_){this.y=_}set(_,_e){return this.x=_,this.y=_e,this}setScalar(_){return this.x=_,this.y=_,this}setX(_){return this.x=_,this}setY(_){return this.y=_,this}setComponent(_,_e){switch(_){case 0:this.x=_e;break;case 1:this.y=_e;break;default:throw new Error("index is out of range: "+_)}return this}getComponent(_){switch(_){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+_)}}clone(){return new this.constructor(this.x,this.y)}copy(_){return this.x=_.x,this.y=_.y,this}add(_){return this.x+=_.x,this.y+=_.y,this}addScalar(_){return this.x+=_,this.y+=_,this}addVectors(_,_e){return this.x=_.x+_e.x,this.y=_.y+_e.y,this}addScaledVector(_,_e){return this.x+=_.x*_e,this.y+=_.y*_e,this}sub(_){return this.x-=_.x,this.y-=_.y,this}subScalar(_){return this.x-=_,this.y-=_,this}subVectors(_,_e){return this.x=_.x-_e.x,this.y=_.y-_e.y,this}multiply(_){return this.x*=_.x,this.y*=_.y,this}multiplyScalar(_){return this.x*=_,this.y*=_,this}divide(_){return this.x/=_.x,this.y/=_.y,this}divideScalar(_){return this.multiplyScalar(1/_)}applyMatrix3(_){const _e=this.x,tt=this.y,nt=_.elements;return this.x=nt[0]*_e+nt[3]*tt+nt[6],this.y=nt[1]*_e+nt[4]*tt+nt[7],this}min(_){return this.x=Math.min(this.x,_.x),this.y=Math.min(this.y,_.y),this}max(_){return this.x=Math.max(this.x,_.x),this.y=Math.max(this.y,_.y),this}clamp(_,_e){return this.x=Math.max(_.x,Math.min(_e.x,this.x)),this.y=Math.max(_.y,Math.min(_e.y,this.y)),this}clampScalar(_,_e){return this.x=Math.max(_,Math.min(_e,this.x)),this.y=Math.max(_,Math.min(_e,this.y)),this}clampLength(_,_e){const tt=this.length();return this.divideScalar(tt||1).multiplyScalar(Math.max(_,Math.min(_e,tt)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(_){return this.x*_.x+this.y*_.y}cross(_){return this.x*_.y-this.y*_.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(_){const _e=Math.sqrt(this.lengthSq()*_.lengthSq());if(_e===0)return Math.PI/2;const tt=this.dot(_)/_e;return Math.acos(clamp$4(tt,-1,1))}distanceTo(_){return Math.sqrt(this.distanceToSquared(_))}distanceToSquared(_){const _e=this.x-_.x,tt=this.y-_.y;return _e*_e+tt*tt}manhattanDistanceTo(_){return Math.abs(this.x-_.x)+Math.abs(this.y-_.y)}setLength(_){return this.normalize().multiplyScalar(_)}lerp(_,_e){return this.x+=(_.x-this.x)*_e,this.y+=(_.y-this.y)*_e,this}lerpVectors(_,_e,tt){return this.x=_.x+(_e.x-_.x)*tt,this.y=_.y+(_e.y-_.y)*tt,this}equals(_){return _.x===this.x&&_.y===this.y}fromArray(_,_e=0){return this.x=_[_e],this.y=_[_e+1],this}toArray(_=[],_e=0){return _[_e]=this.x,_[_e+1]=this.y,_}fromBufferAttribute(_,_e){return this.x=_.getX(_e),this.y=_.getY(_e),this}rotateAround(_,_e){const tt=Math.cos(_e),nt=Math.sin(_e),rt=this.x-_.x,ot=this.y-_.y;return this.x=rt*tt-ot*nt+_.x,this.y=rt*nt+ot*tt+_.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Matrix3{constructor(_,_e,tt,nt,rt,ot,at,lt,ut){Matrix3.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],_!==void 0&&this.set(_,_e,tt,nt,rt,ot,at,lt,ut)}set(_,_e,tt,nt,rt,ot,at,lt,ut){const dt=this.elements;return dt[0]=_,dt[1]=nt,dt[2]=at,dt[3]=_e,dt[4]=rt,dt[5]=lt,dt[6]=tt,dt[7]=ot,dt[8]=ut,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(_){const _e=this.elements,tt=_.elements;return _e[0]=tt[0],_e[1]=tt[1],_e[2]=tt[2],_e[3]=tt[3],_e[4]=tt[4],_e[5]=tt[5],_e[6]=tt[6],_e[7]=tt[7],_e[8]=tt[8],this}extractBasis(_,_e,tt){return _.setFromMatrix3Column(this,0),_e.setFromMatrix3Column(this,1),tt.setFromMatrix3Column(this,2),this}setFromMatrix4(_){const _e=_.elements;return this.set(_e[0],_e[4],_e[8],_e[1],_e[5],_e[9],_e[2],_e[6],_e[10]),this}multiply(_){return this.multiplyMatrices(this,_)}premultiply(_){return this.multiplyMatrices(_,this)}multiplyMatrices(_,_e){const tt=_.elements,nt=_e.elements,rt=this.elements,ot=tt[0],at=tt[3],lt=tt[6],ut=tt[1],dt=tt[4],st=tt[7],it=tt[2],ct=tt[5],ft=tt[8],ht=nt[0],mt=nt[3],pt=nt[6],_t=nt[1],vt=nt[4],bt=nt[7],wt=nt[2],xt=nt[5],Mt=nt[8];return rt[0]=ot*ht+at*_t+lt*wt,rt[3]=ot*mt+at*vt+lt*xt,rt[6]=ot*pt+at*bt+lt*Mt,rt[1]=ut*ht+dt*_t+st*wt,rt[4]=ut*mt+dt*vt+st*xt,rt[7]=ut*pt+dt*bt+st*Mt,rt[2]=it*ht+ct*_t+ft*wt,rt[5]=it*mt+ct*vt+ft*xt,rt[8]=it*pt+ct*bt+ft*Mt,this}multiplyScalar(_){const _e=this.elements;return _e[0]*=_,_e[3]*=_,_e[6]*=_,_e[1]*=_,_e[4]*=_,_e[7]*=_,_e[2]*=_,_e[5]*=_,_e[8]*=_,this}determinant(){const _=this.elements,_e=_[0],tt=_[1],nt=_[2],rt=_[3],ot=_[4],at=_[5],lt=_[6],ut=_[7],dt=_[8];return _e*ot*dt-_e*at*ut-tt*rt*dt+tt*at*lt+nt*rt*ut-nt*ot*lt}invert(){const _=this.elements,_e=_[0],tt=_[1],nt=_[2],rt=_[3],ot=_[4],at=_[5],lt=_[6],ut=_[7],dt=_[8],st=dt*ot-at*ut,it=at*lt-dt*rt,ct=ut*rt-ot*lt,ft=_e*st+tt*it+nt*ct;if(ft===0)return this.set(0,0,0,0,0,0,0,0,0);const ht=1/ft;return _[0]=st*ht,_[1]=(nt*ut-dt*tt)*ht,_[2]=(at*tt-nt*ot)*ht,_[3]=it*ht,_[4]=(dt*_e-nt*lt)*ht,_[5]=(nt*rt-at*_e)*ht,_[6]=ct*ht,_[7]=(tt*lt-ut*_e)*ht,_[8]=(ot*_e-tt*rt)*ht,this}transpose(){let _;const _e=this.elements;return _=_e[1],_e[1]=_e[3],_e[3]=_,_=_e[2],_e[2]=_e[6],_e[6]=_,_=_e[5],_e[5]=_e[7],_e[7]=_,this}getNormalMatrix(_){return this.setFromMatrix4(_).invert().transpose()}transposeIntoArray(_){const _e=this.elements;return _[0]=_e[0],_[1]=_e[3],_[2]=_e[6],_[3]=_e[1],_[4]=_e[4],_[5]=_e[7],_[6]=_e[2],_[7]=_e[5],_[8]=_e[8],this}setUvTransform(_,_e,tt,nt,rt,ot,at){const lt=Math.cos(rt),ut=Math.sin(rt);return this.set(tt*lt,tt*ut,-tt*(lt*ot+ut*at)+ot+_,-nt*ut,nt*lt,-nt*(-ut*ot+lt*at)+at+_e,0,0,1),this}scale(_,_e){return this.premultiply(_m3.makeScale(_,_e)),this}rotate(_){return this.premultiply(_m3.makeRotation(-_)),this}translate(_,_e){return this.premultiply(_m3.makeTranslation(_,_e)),this}makeTranslation(_,_e){return _.isVector2?this.set(1,0,_.x,0,1,_.y,0,0,1):this.set(1,0,_,0,1,_e,0,0,1),this}makeRotation(_){const _e=Math.cos(_),tt=Math.sin(_);return this.set(_e,-tt,0,tt,_e,0,0,0,1),this}makeScale(_,_e){return this.set(_,0,0,0,_e,0,0,0,1),this}equals(_){const _e=this.elements,tt=_.elements;for(let nt=0;nt<9;nt++)if(_e[nt]!==tt[nt])return!1;return!0}fromArray(_,_e=0){for(let tt=0;tt<9;tt++)this.elements[tt]=_[tt+_e];return this}toArray(_=[],_e=0){const tt=this.elements;return _[_e]=tt[0],_[_e+1]=tt[1],_[_e+2]=tt[2],_[_e+3]=tt[3],_[_e+4]=tt[4],_[_e+5]=tt[5],_[_e+6]=tt[6],_[_e+7]=tt[7],_[_e+8]=tt[8],_}clone(){return new this.constructor().fromArray(this.elements)}}const _m3=new Matrix3;function arrayNeedsUint32(et){for(let _=et.length-1;_>=0;--_)if(et[_]>=65535)return!0;return!1}const TYPED_ARRAYS={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function getTypedArray(et,_){return new TYPED_ARRAYS[et](_)}function createElementNS(et){return document.createElementNS("http://www.w3.org/1999/xhtml",et)}function createCanvasElement(){const et=createElementNS("canvas");return et.style.display="block",et}const _cache={};function warnOnce(et){et in _cache||(_cache[et]=!0,console.warn(et))}function probeAsync(et,_,_e){return new Promise(function(tt,nt){function rt(){switch(et.clientWaitSync(_,et.SYNC_FLUSH_COMMANDS_BIT,0)){case et.WAIT_FAILED:nt();break;case et.TIMEOUT_EXPIRED:setTimeout(rt,_e);break;default:tt()}}setTimeout(rt,_e)})}const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3=new Matrix3().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),LINEAR_DISPLAY_P3_TO_LINEAR_SRGB=new Matrix3().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),COLOR_SPACES={[LinearSRGBColorSpace]:{transfer:LinearTransfer,primaries:Rec709Primaries,toReference:et=>et,fromReference:et=>et},[SRGBColorSpace]:{transfer:SRGBTransfer,primaries:Rec709Primaries,toReference:et=>et.convertSRGBToLinear(),fromReference:et=>et.convertLinearToSRGB()},[LinearDisplayP3ColorSpace]:{transfer:LinearTransfer,primaries:P3Primaries,toReference:et=>et.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),fromReference:et=>et.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3)},[DisplayP3ColorSpace]:{transfer:SRGBTransfer,primaries:P3Primaries,toReference:et=>et.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),fromReference:et=>et.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB()}},SUPPORTED_WORKING_COLOR_SPACES=new Set([LinearSRGBColorSpace,LinearDisplayP3ColorSpace]),ColorManagement={enabled:!0,_workingColorSpace:LinearSRGBColorSpace,get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(et){if(!SUPPORTED_WORKING_COLOR_SPACES.has(et))throw new Error(`Unsupported working color space, "${et}".`);this._workingColorSpace=et},convert:function(et,_,_e){if(this.enabled===!1||_===_e||!_||!_e)return et;const tt=COLOR_SPACES[_].toReference,nt=COLOR_SPACES[_e].fromReference;return nt(tt(et))},fromWorkingColorSpace:function(et,_){return this.convert(et,this._workingColorSpace,_)},toWorkingColorSpace:function(et,_){return this.convert(et,_,this._workingColorSpace)},getPrimaries:function(et){return COLOR_SPACES[et].primaries},getTransfer:function(et){return et===NoColorSpace?LinearTransfer:COLOR_SPACES[et].transfer}};function SRGBToLinear(et){return et<.04045?et*.0773993808:Math.pow(et*.9478672986+.0521327014,2.4)}function LinearToSRGB(et){return et<.0031308?et*12.92:1.055*Math.pow(et,.41666)-.055}let _canvas;class ImageUtils{static getDataURL(_){if(/^data:/i.test(_.src)||typeof HTMLCanvasElement>"u")return _.src;let _e;if(_ instanceof HTMLCanvasElement)_e=_;else{_canvas===void 0&&(_canvas=createElementNS("canvas")),_canvas.width=_.width,_canvas.height=_.height;const tt=_canvas.getContext("2d");_ instanceof ImageData?tt.putImageData(_,0,0):tt.drawImage(_,0,0,_.width,_.height),_e=_canvas}return _e.width>2048||_e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",_),_e.toDataURL("image/jpeg",.6)):_e.toDataURL("image/png")}static sRGBToLinear(_){if(typeof HTMLImageElement<"u"&&_ instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&_ instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&_ instanceof ImageBitmap){const _e=createElementNS("canvas");_e.width=_.width,_e.height=_.height;const tt=_e.getContext("2d");tt.drawImage(_,0,0,_.width,_.height);const nt=tt.getImageData(0,0,_.width,_.height),rt=nt.data;for(let ot=0;ot<rt.length;ot++)rt[ot]=SRGBToLinear(rt[ot]/255)*255;return tt.putImageData(nt,0,0),_e}else if(_.data){const _e=_.data.slice(0);for(let tt=0;tt<_e.length;tt++)_e instanceof Uint8Array||_e instanceof Uint8ClampedArray?_e[tt]=Math.floor(SRGBToLinear(_e[tt]/255)*255):_e[tt]=SRGBToLinear(_e[tt]);return{data:_e,width:_.width,height:_.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),_}}let _sourceId=0;class Source{constructor(_=null){this.isSource=!0,Object.defineProperty(this,"id",{value:_sourceId++}),this.uuid=generateUUID(),this.data=_,this.dataReady=!0,this.version=0}set needsUpdate(_){_===!0&&this.version++}toJSON(_){const _e=_===void 0||typeof _=="string";if(!_e&&_.images[this.uuid]!==void 0)return _.images[this.uuid];const tt={uuid:this.uuid,url:""},nt=this.data;if(nt!==null){let rt;if(Array.isArray(nt)){rt=[];for(let ot=0,at=nt.length;ot<at;ot++)nt[ot].isDataTexture?rt.push(serializeImage(nt[ot].image)):rt.push(serializeImage(nt[ot]))}else rt=serializeImage(nt);tt.url=rt}return _e||(_.images[this.uuid]=tt),tt}}function serializeImage(et){return typeof HTMLImageElement<"u"&&et instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&et instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&et instanceof ImageBitmap?ImageUtils.getDataURL(et):et.data?{data:Array.from(et.data),width:et.width,height:et.height,type:et.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let _textureId=0;class Texture extends EventDispatcher{constructor(_=Texture.DEFAULT_IMAGE,_e=Texture.DEFAULT_MAPPING,tt=ClampToEdgeWrapping,nt=ClampToEdgeWrapping,rt=LinearFilter,ot=LinearMipmapLinearFilter,at=RGBAFormat,lt=UnsignedByteType,ut=Texture.DEFAULT_ANISOTROPY,dt=NoColorSpace){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:_textureId++}),this.uuid=generateUUID(),this.name="",this.source=new Source(_),this.mipmaps=[],this.mapping=_e,this.channel=0,this.wrapS=tt,this.wrapT=nt,this.magFilter=rt,this.minFilter=ot,this.anisotropy=ut,this.format=at,this.internalFormat=null,this.type=lt,this.offset=new Vector2(0,0),this.repeat=new Vector2(1,1),this.center=new Vector2(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Matrix3,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=dt,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(_=null){this.source.data=_}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(_){return this.name=_.name,this.source=_.source,this.mipmaps=_.mipmaps.slice(0),this.mapping=_.mapping,this.channel=_.channel,this.wrapS=_.wrapS,this.wrapT=_.wrapT,this.magFilter=_.magFilter,this.minFilter=_.minFilter,this.anisotropy=_.anisotropy,this.format=_.format,this.internalFormat=_.internalFormat,this.type=_.type,this.offset.copy(_.offset),this.repeat.copy(_.repeat),this.center.copy(_.center),this.rotation=_.rotation,this.matrixAutoUpdate=_.matrixAutoUpdate,this.matrix.copy(_.matrix),this.generateMipmaps=_.generateMipmaps,this.premultiplyAlpha=_.premultiplyAlpha,this.flipY=_.flipY,this.unpackAlignment=_.unpackAlignment,this.colorSpace=_.colorSpace,this.userData=JSON.parse(JSON.stringify(_.userData)),this.needsUpdate=!0,this}toJSON(_){const _e=_===void 0||typeof _=="string";if(!_e&&_.textures[this.uuid]!==void 0)return _.textures[this.uuid];const tt={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(_).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(tt.userData=this.userData),_e||(_.textures[this.uuid]=tt),tt}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(_){if(this.mapping!==UVMapping)return _;if(_.applyMatrix3(this.matrix),_.x<0||_.x>1)switch(this.wrapS){case RepeatWrapping:_.x=_.x-Math.floor(_.x);break;case ClampToEdgeWrapping:_.x=_.x<0?0:1;break;case MirroredRepeatWrapping:Math.abs(Math.floor(_.x)%2)===1?_.x=Math.ceil(_.x)-_.x:_.x=_.x-Math.floor(_.x);break}if(_.y<0||_.y>1)switch(this.wrapT){case RepeatWrapping:_.y=_.y-Math.floor(_.y);break;case ClampToEdgeWrapping:_.y=_.y<0?0:1;break;case MirroredRepeatWrapping:Math.abs(Math.floor(_.y)%2)===1?_.y=Math.ceil(_.y)-_.y:_.y=_.y-Math.floor(_.y);break}return this.flipY&&(_.y=1-_.y),_}set needsUpdate(_){_===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(_){_===!0&&this.pmremVersion++}}Texture.DEFAULT_IMAGE=null;Texture.DEFAULT_MAPPING=UVMapping;Texture.DEFAULT_ANISOTROPY=1;class Vector4{constructor(_=0,_e=0,tt=0,nt=1){Vector4.prototype.isVector4=!0,this.x=_,this.y=_e,this.z=tt,this.w=nt}get width(){return this.z}set width(_){this.z=_}get height(){return this.w}set height(_){this.w=_}set(_,_e,tt,nt){return this.x=_,this.y=_e,this.z=tt,this.w=nt,this}setScalar(_){return this.x=_,this.y=_,this.z=_,this.w=_,this}setX(_){return this.x=_,this}setY(_){return this.y=_,this}setZ(_){return this.z=_,this}setW(_){return this.w=_,this}setComponent(_,_e){switch(_){case 0:this.x=_e;break;case 1:this.y=_e;break;case 2:this.z=_e;break;case 3:this.w=_e;break;default:throw new Error("index is out of range: "+_)}return this}getComponent(_){switch(_){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+_)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(_){return this.x=_.x,this.y=_.y,this.z=_.z,this.w=_.w!==void 0?_.w:1,this}add(_){return this.x+=_.x,this.y+=_.y,this.z+=_.z,this.w+=_.w,this}addScalar(_){return this.x+=_,this.y+=_,this.z+=_,this.w+=_,this}addVectors(_,_e){return this.x=_.x+_e.x,this.y=_.y+_e.y,this.z=_.z+_e.z,this.w=_.w+_e.w,this}addScaledVector(_,_e){return this.x+=_.x*_e,this.y+=_.y*_e,this.z+=_.z*_e,this.w+=_.w*_e,this}sub(_){return this.x-=_.x,this.y-=_.y,this.z-=_.z,this.w-=_.w,this}subScalar(_){return this.x-=_,this.y-=_,this.z-=_,this.w-=_,this}subVectors(_,_e){return this.x=_.x-_e.x,this.y=_.y-_e.y,this.z=_.z-_e.z,this.w=_.w-_e.w,this}multiply(_){return this.x*=_.x,this.y*=_.y,this.z*=_.z,this.w*=_.w,this}multiplyScalar(_){return this.x*=_,this.y*=_,this.z*=_,this.w*=_,this}applyMatrix4(_){const _e=this.x,tt=this.y,nt=this.z,rt=this.w,ot=_.elements;return this.x=ot[0]*_e+ot[4]*tt+ot[8]*nt+ot[12]*rt,this.y=ot[1]*_e+ot[5]*tt+ot[9]*nt+ot[13]*rt,this.z=ot[2]*_e+ot[6]*tt+ot[10]*nt+ot[14]*rt,this.w=ot[3]*_e+ot[7]*tt+ot[11]*nt+ot[15]*rt,this}divideScalar(_){return this.multiplyScalar(1/_)}setAxisAngleFromQuaternion(_){this.w=2*Math.acos(_.w);const _e=Math.sqrt(1-_.w*_.w);return _e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=_.x/_e,this.y=_.y/_e,this.z=_.z/_e),this}setAxisAngleFromRotationMatrix(_){let _e,tt,nt,rt;const lt=_.elements,ut=lt[0],dt=lt[4],st=lt[8],it=lt[1],ct=lt[5],ft=lt[9],ht=lt[2],mt=lt[6],pt=lt[10];if(Math.abs(dt-it)<.01&&Math.abs(st-ht)<.01&&Math.abs(ft-mt)<.01){if(Math.abs(dt+it)<.1&&Math.abs(st+ht)<.1&&Math.abs(ft+mt)<.1&&Math.abs(ut+ct+pt-3)<.1)return this.set(1,0,0,0),this;_e=Math.PI;const vt=(ut+1)/2,bt=(ct+1)/2,wt=(pt+1)/2,xt=(dt+it)/4,Mt=(st+ht)/4,At=(ft+mt)/4;return vt>bt&&vt>wt?vt<.01?(tt=0,nt=.707106781,rt=.707106781):(tt=Math.sqrt(vt),nt=xt/tt,rt=Mt/tt):bt>wt?bt<.01?(tt=.707106781,nt=0,rt=.707106781):(nt=Math.sqrt(bt),tt=xt/nt,rt=At/nt):wt<.01?(tt=.707106781,nt=.707106781,rt=0):(rt=Math.sqrt(wt),tt=Mt/rt,nt=At/rt),this.set(tt,nt,rt,_e),this}let _t=Math.sqrt((mt-ft)*(mt-ft)+(st-ht)*(st-ht)+(it-dt)*(it-dt));return Math.abs(_t)<.001&&(_t=1),this.x=(mt-ft)/_t,this.y=(st-ht)/_t,this.z=(it-dt)/_t,this.w=Math.acos((ut+ct+pt-1)/2),this}setFromMatrixPosition(_){const _e=_.elements;return this.x=_e[12],this.y=_e[13],this.z=_e[14],this.w=_e[15],this}min(_){return this.x=Math.min(this.x,_.x),this.y=Math.min(this.y,_.y),this.z=Math.min(this.z,_.z),this.w=Math.min(this.w,_.w),this}max(_){return this.x=Math.max(this.x,_.x),this.y=Math.max(this.y,_.y),this.z=Math.max(this.z,_.z),this.w=Math.max(this.w,_.w),this}clamp(_,_e){return this.x=Math.max(_.x,Math.min(_e.x,this.x)),this.y=Math.max(_.y,Math.min(_e.y,this.y)),this.z=Math.max(_.z,Math.min(_e.z,this.z)),this.w=Math.max(_.w,Math.min(_e.w,this.w)),this}clampScalar(_,_e){return this.x=Math.max(_,Math.min(_e,this.x)),this.y=Math.max(_,Math.min(_e,this.y)),this.z=Math.max(_,Math.min(_e,this.z)),this.w=Math.max(_,Math.min(_e,this.w)),this}clampLength(_,_e){const tt=this.length();return this.divideScalar(tt||1).multiplyScalar(Math.max(_,Math.min(_e,tt)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(_){return this.x*_.x+this.y*_.y+this.z*_.z+this.w*_.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(_){return this.normalize().multiplyScalar(_)}lerp(_,_e){return this.x+=(_.x-this.x)*_e,this.y+=(_.y-this.y)*_e,this.z+=(_.z-this.z)*_e,this.w+=(_.w-this.w)*_e,this}lerpVectors(_,_e,tt){return this.x=_.x+(_e.x-_.x)*tt,this.y=_.y+(_e.y-_.y)*tt,this.z=_.z+(_e.z-_.z)*tt,this.w=_.w+(_e.w-_.w)*tt,this}equals(_){return _.x===this.x&&_.y===this.y&&_.z===this.z&&_.w===this.w}fromArray(_,_e=0){return this.x=_[_e],this.y=_[_e+1],this.z=_[_e+2],this.w=_[_e+3],this}toArray(_=[],_e=0){return _[_e]=this.x,_[_e+1]=this.y,_[_e+2]=this.z,_[_e+3]=this.w,_}fromBufferAttribute(_,_e){return this.x=_.getX(_e),this.y=_.getY(_e),this.z=_.getZ(_e),this.w=_.getW(_e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class RenderTarget extends EventDispatcher{constructor(_=1,_e=1,tt={}){super(),this.isRenderTarget=!0,this.width=_,this.height=_e,this.depth=1,this.scissor=new Vector4(0,0,_,_e),this.scissorTest=!1,this.viewport=new Vector4(0,0,_,_e);const nt={width:_,height:_e,depth:1};tt=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:LinearFilter,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},tt);const rt=new Texture(nt,tt.mapping,tt.wrapS,tt.wrapT,tt.magFilter,tt.minFilter,tt.format,tt.type,tt.anisotropy,tt.colorSpace);rt.flipY=!1,rt.generateMipmaps=tt.generateMipmaps,rt.internalFormat=tt.internalFormat,this.textures=[];const ot=tt.count;for(let at=0;at<ot;at++)this.textures[at]=rt.clone(),this.textures[at].isRenderTargetTexture=!0;this.depthBuffer=tt.depthBuffer,this.stencilBuffer=tt.stencilBuffer,this.resolveDepthBuffer=tt.resolveDepthBuffer,this.resolveStencilBuffer=tt.resolveStencilBuffer,this.depthTexture=tt.depthTexture,this.samples=tt.samples}get texture(){return this.textures[0]}set texture(_){this.textures[0]=_}setSize(_,_e,tt=1){if(this.width!==_||this.height!==_e||this.depth!==tt){this.width=_,this.height=_e,this.depth=tt;for(let nt=0,rt=this.textures.length;nt<rt;nt++)this.textures[nt].image.width=_,this.textures[nt].image.height=_e,this.textures[nt].image.depth=tt;this.dispose()}this.viewport.set(0,0,_,_e),this.scissor.set(0,0,_,_e)}clone(){return new this.constructor().copy(this)}copy(_){this.width=_.width,this.height=_.height,this.depth=_.depth,this.scissor.copy(_.scissor),this.scissorTest=_.scissorTest,this.viewport.copy(_.viewport),this.textures.length=0;for(let tt=0,nt=_.textures.length;tt<nt;tt++)this.textures[tt]=_.textures[tt].clone(),this.textures[tt].isRenderTargetTexture=!0;const _e=Object.assign({},_.texture.image);return this.texture.source=new Source(_e),this.depthBuffer=_.depthBuffer,this.stencilBuffer=_.stencilBuffer,this.resolveDepthBuffer=_.resolveDepthBuffer,this.resolveStencilBuffer=_.resolveStencilBuffer,_.depthTexture!==null&&(this.depthTexture=_.depthTexture.clone()),this.samples=_.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class WebGLRenderTarget extends RenderTarget{constructor(_=1,_e=1,tt={}){super(_,_e,tt),this.isWebGLRenderTarget=!0}}class DataArrayTexture extends Texture{constructor(_=null,_e=1,tt=1,nt=1){super(null),this.isDataArrayTexture=!0,this.image={data:_,width:_e,height:tt,depth:nt},this.magFilter=NearestFilter,this.minFilter=NearestFilter,this.wrapR=ClampToEdgeWrapping,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(_){this.layerUpdates.add(_)}clearLayerUpdates(){this.layerUpdates.clear()}}class WebGLArrayRenderTarget extends WebGLRenderTarget{constructor(_=1,_e=1,tt=1,nt={}){super(_,_e,nt),this.isWebGLArrayRenderTarget=!0,this.depth=tt,this.texture=new DataArrayTexture(null,_,_e,tt),this.texture.isRenderTargetTexture=!0}}class Data3DTexture extends Texture{constructor(_=null,_e=1,tt=1,nt=1){super(null),this.isData3DTexture=!0,this.image={data:_,width:_e,height:tt,depth:nt},this.magFilter=NearestFilter,this.minFilter=NearestFilter,this.wrapR=ClampToEdgeWrapping,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class WebGL3DRenderTarget extends WebGLRenderTarget{constructor(_=1,_e=1,tt=1,nt={}){super(_,_e,nt),this.isWebGL3DRenderTarget=!0,this.depth=tt,this.texture=new Data3DTexture(null,_,_e,tt),this.texture.isRenderTargetTexture=!0}}class Quaternion{constructor(_=0,_e=0,tt=0,nt=1){this.isQuaternion=!0,this._x=_,this._y=_e,this._z=tt,this._w=nt}static slerpFlat(_,_e,tt,nt,rt,ot,at){let lt=tt[nt+0],ut=tt[nt+1],dt=tt[nt+2],st=tt[nt+3];const it=rt[ot+0],ct=rt[ot+1],ft=rt[ot+2],ht=rt[ot+3];if(at===0){_[_e+0]=lt,_[_e+1]=ut,_[_e+2]=dt,_[_e+3]=st;return}if(at===1){_[_e+0]=it,_[_e+1]=ct,_[_e+2]=ft,_[_e+3]=ht;return}if(st!==ht||lt!==it||ut!==ct||dt!==ft){let mt=1-at;const pt=lt*it+ut*ct+dt*ft+st*ht,_t=pt>=0?1:-1,vt=1-pt*pt;if(vt>Number.EPSILON){const wt=Math.sqrt(vt),xt=Math.atan2(wt,pt*_t);mt=Math.sin(mt*xt)/wt,at=Math.sin(at*xt)/wt}const bt=at*_t;if(lt=lt*mt+it*bt,ut=ut*mt+ct*bt,dt=dt*mt+ft*bt,st=st*mt+ht*bt,mt===1-at){const wt=1/Math.sqrt(lt*lt+ut*ut+dt*dt+st*st);lt*=wt,ut*=wt,dt*=wt,st*=wt}}_[_e]=lt,_[_e+1]=ut,_[_e+2]=dt,_[_e+3]=st}static multiplyQuaternionsFlat(_,_e,tt,nt,rt,ot){const at=tt[nt],lt=tt[nt+1],ut=tt[nt+2],dt=tt[nt+3],st=rt[ot],it=rt[ot+1],ct=rt[ot+2],ft=rt[ot+3];return _[_e]=at*ft+dt*st+lt*ct-ut*it,_[_e+1]=lt*ft+dt*it+ut*st-at*ct,_[_e+2]=ut*ft+dt*ct+at*it-lt*st,_[_e+3]=dt*ft-at*st-lt*it-ut*ct,_}get x(){return this._x}set x(_){this._x=_,this._onChangeCallback()}get y(){return this._y}set y(_){this._y=_,this._onChangeCallback()}get z(){return this._z}set z(_){this._z=_,this._onChangeCallback()}get w(){return this._w}set w(_){this._w=_,this._onChangeCallback()}set(_,_e,tt,nt){return this._x=_,this._y=_e,this._z=tt,this._w=nt,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(_){return this._x=_.x,this._y=_.y,this._z=_.z,this._w=_.w,this._onChangeCallback(),this}setFromEuler(_,_e=!0){const tt=_._x,nt=_._y,rt=_._z,ot=_._order,at=Math.cos,lt=Math.sin,ut=at(tt/2),dt=at(nt/2),st=at(rt/2),it=lt(tt/2),ct=lt(nt/2),ft=lt(rt/2);switch(ot){case"XYZ":this._x=it*dt*st+ut*ct*ft,this._y=ut*ct*st-it*dt*ft,this._z=ut*dt*ft+it*ct*st,this._w=ut*dt*st-it*ct*ft;break;case"YXZ":this._x=it*dt*st+ut*ct*ft,this._y=ut*ct*st-it*dt*ft,this._z=ut*dt*ft-it*ct*st,this._w=ut*dt*st+it*ct*ft;break;case"ZXY":this._x=it*dt*st-ut*ct*ft,this._y=ut*ct*st+it*dt*ft,this._z=ut*dt*ft+it*ct*st,this._w=ut*dt*st-it*ct*ft;break;case"ZYX":this._x=it*dt*st-ut*ct*ft,this._y=ut*ct*st+it*dt*ft,this._z=ut*dt*ft-it*ct*st,this._w=ut*dt*st+it*ct*ft;break;case"YZX":this._x=it*dt*st+ut*ct*ft,this._y=ut*ct*st+it*dt*ft,this._z=ut*dt*ft-it*ct*st,this._w=ut*dt*st-it*ct*ft;break;case"XZY":this._x=it*dt*st-ut*ct*ft,this._y=ut*ct*st-it*dt*ft,this._z=ut*dt*ft+it*ct*st,this._w=ut*dt*st+it*ct*ft;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+ot)}return _e===!0&&this._onChangeCallback(),this}setFromAxisAngle(_,_e){const tt=_e/2,nt=Math.sin(tt);return this._x=_.x*nt,this._y=_.y*nt,this._z=_.z*nt,this._w=Math.cos(tt),this._onChangeCallback(),this}setFromRotationMatrix(_){const _e=_.elements,tt=_e[0],nt=_e[4],rt=_e[8],ot=_e[1],at=_e[5],lt=_e[9],ut=_e[2],dt=_e[6],st=_e[10],it=tt+at+st;if(it>0){const ct=.5/Math.sqrt(it+1);this._w=.25/ct,this._x=(dt-lt)*ct,this._y=(rt-ut)*ct,this._z=(ot-nt)*ct}else if(tt>at&&tt>st){const ct=2*Math.sqrt(1+tt-at-st);this._w=(dt-lt)/ct,this._x=.25*ct,this._y=(nt+ot)/ct,this._z=(rt+ut)/ct}else if(at>st){const ct=2*Math.sqrt(1+at-tt-st);this._w=(rt-ut)/ct,this._x=(nt+ot)/ct,this._y=.25*ct,this._z=(lt+dt)/ct}else{const ct=2*Math.sqrt(1+st-tt-at);this._w=(ot-nt)/ct,this._x=(rt+ut)/ct,this._y=(lt+dt)/ct,this._z=.25*ct}return this._onChangeCallback(),this}setFromUnitVectors(_,_e){let tt=_.dot(_e)+1;return tt<Number.EPSILON?(tt=0,Math.abs(_.x)>Math.abs(_.z)?(this._x=-_.y,this._y=_.x,this._z=0,this._w=tt):(this._x=0,this._y=-_.z,this._z=_.y,this._w=tt)):(this._x=_.y*_e.z-_.z*_e.y,this._y=_.z*_e.x-_.x*_e.z,this._z=_.x*_e.y-_.y*_e.x,this._w=tt),this.normalize()}angleTo(_){return 2*Math.acos(Math.abs(clamp$4(this.dot(_),-1,1)))}rotateTowards(_,_e){const tt=this.angleTo(_);if(tt===0)return this;const nt=Math.min(1,_e/tt);return this.slerp(_,nt),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(_){return this._x*_._x+this._y*_._y+this._z*_._z+this._w*_._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let _=this.length();return _===0?(this._x=0,this._y=0,this._z=0,this._w=1):(_=1/_,this._x=this._x*_,this._y=this._y*_,this._z=this._z*_,this._w=this._w*_),this._onChangeCallback(),this}multiply(_){return this.multiplyQuaternions(this,_)}premultiply(_){return this.multiplyQuaternions(_,this)}multiplyQuaternions(_,_e){const tt=_._x,nt=_._y,rt=_._z,ot=_._w,at=_e._x,lt=_e._y,ut=_e._z,dt=_e._w;return this._x=tt*dt+ot*at+nt*ut-rt*lt,this._y=nt*dt+ot*lt+rt*at-tt*ut,this._z=rt*dt+ot*ut+tt*lt-nt*at,this._w=ot*dt-tt*at-nt*lt-rt*ut,this._onChangeCallback(),this}slerp(_,_e){if(_e===0)return this;if(_e===1)return this.copy(_);const tt=this._x,nt=this._y,rt=this._z,ot=this._w;let at=ot*_._w+tt*_._x+nt*_._y+rt*_._z;if(at<0?(this._w=-_._w,this._x=-_._x,this._y=-_._y,this._z=-_._z,at=-at):this.copy(_),at>=1)return this._w=ot,this._x=tt,this._y=nt,this._z=rt,this;const lt=1-at*at;if(lt<=Number.EPSILON){const ct=1-_e;return this._w=ct*ot+_e*this._w,this._x=ct*tt+_e*this._x,this._y=ct*nt+_e*this._y,this._z=ct*rt+_e*this._z,this.normalize(),this}const ut=Math.sqrt(lt),dt=Math.atan2(ut,at),st=Math.sin((1-_e)*dt)/ut,it=Math.sin(_e*dt)/ut;return this._w=ot*st+this._w*it,this._x=tt*st+this._x*it,this._y=nt*st+this._y*it,this._z=rt*st+this._z*it,this._onChangeCallback(),this}slerpQuaternions(_,_e,tt){return this.copy(_).slerp(_e,tt)}random(){const _=2*Math.PI*Math.random(),_e=2*Math.PI*Math.random(),tt=Math.random(),nt=Math.sqrt(1-tt),rt=Math.sqrt(tt);return this.set(nt*Math.sin(_),nt*Math.cos(_),rt*Math.sin(_e),rt*Math.cos(_e))}equals(_){return _._x===this._x&&_._y===this._y&&_._z===this._z&&_._w===this._w}fromArray(_,_e=0){return this._x=_[_e],this._y=_[_e+1],this._z=_[_e+2],this._w=_[_e+3],this._onChangeCallback(),this}toArray(_=[],_e=0){return _[_e]=this._x,_[_e+1]=this._y,_[_e+2]=this._z,_[_e+3]=this._w,_}fromBufferAttribute(_,_e){return this._x=_.getX(_e),this._y=_.getY(_e),this._z=_.getZ(_e),this._w=_.getW(_e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(_){return this._onChangeCallback=_,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class Vector3{constructor(_=0,_e=0,tt=0){Vector3.prototype.isVector3=!0,this.x=_,this.y=_e,this.z=tt}set(_,_e,tt){return tt===void 0&&(tt=this.z),this.x=_,this.y=_e,this.z=tt,this}setScalar(_){return this.x=_,this.y=_,this.z=_,this}setX(_){return this.x=_,this}setY(_){return this.y=_,this}setZ(_){return this.z=_,this}setComponent(_,_e){switch(_){case 0:this.x=_e;break;case 1:this.y=_e;break;case 2:this.z=_e;break;default:throw new Error("index is out of range: "+_)}return this}getComponent(_){switch(_){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+_)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(_){return this.x=_.x,this.y=_.y,this.z=_.z,this}add(_){return this.x+=_.x,this.y+=_.y,this.z+=_.z,this}addScalar(_){return this.x+=_,this.y+=_,this.z+=_,this}addVectors(_,_e){return this.x=_.x+_e.x,this.y=_.y+_e.y,this.z=_.z+_e.z,this}addScaledVector(_,_e){return this.x+=_.x*_e,this.y+=_.y*_e,this.z+=_.z*_e,this}sub(_){return this.x-=_.x,this.y-=_.y,this.z-=_.z,this}subScalar(_){return this.x-=_,this.y-=_,this.z-=_,this}subVectors(_,_e){return this.x=_.x-_e.x,this.y=_.y-_e.y,this.z=_.z-_e.z,this}multiply(_){return this.x*=_.x,this.y*=_.y,this.z*=_.z,this}multiplyScalar(_){return this.x*=_,this.y*=_,this.z*=_,this}multiplyVectors(_,_e){return this.x=_.x*_e.x,this.y=_.y*_e.y,this.z=_.z*_e.z,this}applyEuler(_){return this.applyQuaternion(_quaternion$4.setFromEuler(_))}applyAxisAngle(_,_e){return this.applyQuaternion(_quaternion$4.setFromAxisAngle(_,_e))}applyMatrix3(_){const _e=this.x,tt=this.y,nt=this.z,rt=_.elements;return this.x=rt[0]*_e+rt[3]*tt+rt[6]*nt,this.y=rt[1]*_e+rt[4]*tt+rt[7]*nt,this.z=rt[2]*_e+rt[5]*tt+rt[8]*nt,this}applyNormalMatrix(_){return this.applyMatrix3(_).normalize()}applyMatrix4(_){const _e=this.x,tt=this.y,nt=this.z,rt=_.elements,ot=1/(rt[3]*_e+rt[7]*tt+rt[11]*nt+rt[15]);return this.x=(rt[0]*_e+rt[4]*tt+rt[8]*nt+rt[12])*ot,this.y=(rt[1]*_e+rt[5]*tt+rt[9]*nt+rt[13])*ot,this.z=(rt[2]*_e+rt[6]*tt+rt[10]*nt+rt[14])*ot,this}applyQuaternion(_){const _e=this.x,tt=this.y,nt=this.z,rt=_.x,ot=_.y,at=_.z,lt=_.w,ut=2*(ot*nt-at*tt),dt=2*(at*_e-rt*nt),st=2*(rt*tt-ot*_e);return this.x=_e+lt*ut+ot*st-at*dt,this.y=tt+lt*dt+at*ut-rt*st,this.z=nt+lt*st+rt*dt-ot*ut,this}project(_){return this.applyMatrix4(_.matrixWorldInverse).applyMatrix4(_.projectionMatrix)}unproject(_){return this.applyMatrix4(_.projectionMatrixInverse).applyMatrix4(_.matrixWorld)}transformDirection(_){const _e=this.x,tt=this.y,nt=this.z,rt=_.elements;return this.x=rt[0]*_e+rt[4]*tt+rt[8]*nt,this.y=rt[1]*_e+rt[5]*tt+rt[9]*nt,this.z=rt[2]*_e+rt[6]*tt+rt[10]*nt,this.normalize()}divide(_){return this.x/=_.x,this.y/=_.y,this.z/=_.z,this}divideScalar(_){return this.multiplyScalar(1/_)}min(_){return this.x=Math.min(this.x,_.x),this.y=Math.min(this.y,_.y),this.z=Math.min(this.z,_.z),this}max(_){return this.x=Math.max(this.x,_.x),this.y=Math.max(this.y,_.y),this.z=Math.max(this.z,_.z),this}clamp(_,_e){return this.x=Math.max(_.x,Math.min(_e.x,this.x)),this.y=Math.max(_.y,Math.min(_e.y,this.y)),this.z=Math.max(_.z,Math.min(_e.z,this.z)),this}clampScalar(_,_e){return this.x=Math.max(_,Math.min(_e,this.x)),this.y=Math.max(_,Math.min(_e,this.y)),this.z=Math.max(_,Math.min(_e,this.z)),this}clampLength(_,_e){const tt=this.length();return this.divideScalar(tt||1).multiplyScalar(Math.max(_,Math.min(_e,tt)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(_){return this.x*_.x+this.y*_.y+this.z*_.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(_){return this.normalize().multiplyScalar(_)}lerp(_,_e){return this.x+=(_.x-this.x)*_e,this.y+=(_.y-this.y)*_e,this.z+=(_.z-this.z)*_e,this}lerpVectors(_,_e,tt){return this.x=_.x+(_e.x-_.x)*tt,this.y=_.y+(_e.y-_.y)*tt,this.z=_.z+(_e.z-_.z)*tt,this}cross(_){return this.crossVectors(this,_)}crossVectors(_,_e){const tt=_.x,nt=_.y,rt=_.z,ot=_e.x,at=_e.y,lt=_e.z;return this.x=nt*lt-rt*at,this.y=rt*ot-tt*lt,this.z=tt*at-nt*ot,this}projectOnVector(_){const _e=_.lengthSq();if(_e===0)return this.set(0,0,0);const tt=_.dot(this)/_e;return this.copy(_).multiplyScalar(tt)}projectOnPlane(_){return _vector$c.copy(this).projectOnVector(_),this.sub(_vector$c)}reflect(_){return this.sub(_vector$c.copy(_).multiplyScalar(2*this.dot(_)))}angleTo(_){const _e=Math.sqrt(this.lengthSq()*_.lengthSq());if(_e===0)return Math.PI/2;const tt=this.dot(_)/_e;return Math.acos(clamp$4(tt,-1,1))}distanceTo(_){return Math.sqrt(this.distanceToSquared(_))}distanceToSquared(_){const _e=this.x-_.x,tt=this.y-_.y,nt=this.z-_.z;return _e*_e+tt*tt+nt*nt}manhattanDistanceTo(_){return Math.abs(this.x-_.x)+Math.abs(this.y-_.y)+Math.abs(this.z-_.z)}setFromSpherical(_){return this.setFromSphericalCoords(_.radius,_.phi,_.theta)}setFromSphericalCoords(_,_e,tt){const nt=Math.sin(_e)*_;return this.x=nt*Math.sin(tt),this.y=Math.cos(_e)*_,this.z=nt*Math.cos(tt),this}setFromCylindrical(_){return this.setFromCylindricalCoords(_.radius,_.theta,_.y)}setFromCylindricalCoords(_,_e,tt){return this.x=_*Math.sin(_e),this.y=tt,this.z=_*Math.cos(_e),this}setFromMatrixPosition(_){const _e=_.elements;return this.x=_e[12],this.y=_e[13],this.z=_e[14],this}setFromMatrixScale(_){const _e=this.setFromMatrixColumn(_,0).length(),tt=this.setFromMatrixColumn(_,1).length(),nt=this.setFromMatrixColumn(_,2).length();return this.x=_e,this.y=tt,this.z=nt,this}setFromMatrixColumn(_,_e){return this.fromArray(_.elements,_e*4)}setFromMatrix3Column(_,_e){return this.fromArray(_.elements,_e*3)}setFromEuler(_){return this.x=_._x,this.y=_._y,this.z=_._z,this}setFromColor(_){return this.x=_.r,this.y=_.g,this.z=_.b,this}equals(_){return _.x===this.x&&_.y===this.y&&_.z===this.z}fromArray(_,_e=0){return this.x=_[_e],this.y=_[_e+1],this.z=_[_e+2],this}toArray(_=[],_e=0){return _[_e]=this.x,_[_e+1]=this.y,_[_e+2]=this.z,_}fromBufferAttribute(_,_e){return this.x=_.getX(_e),this.y=_.getY(_e),this.z=_.getZ(_e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const _=Math.random()*Math.PI*2,_e=Math.random()*2-1,tt=Math.sqrt(1-_e*_e);return this.x=tt*Math.cos(_),this.y=_e,this.z=tt*Math.sin(_),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const _vector$c=new Vector3,_quaternion$4=new Quaternion;class Box3{constructor(_=new Vector3(1/0,1/0,1/0),_e=new Vector3(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=_,this.max=_e}set(_,_e){return this.min.copy(_),this.max.copy(_e),this}setFromArray(_){this.makeEmpty();for(let _e=0,tt=_.length;_e<tt;_e+=3)this.expandByPoint(_vector$b.fromArray(_,_e));return this}setFromBufferAttribute(_){this.makeEmpty();for(let _e=0,tt=_.count;_e<tt;_e++)this.expandByPoint(_vector$b.fromBufferAttribute(_,_e));return this}setFromPoints(_){this.makeEmpty();for(let _e=0,tt=_.length;_e<tt;_e++)this.expandByPoint(_[_e]);return this}setFromCenterAndSize(_,_e){const tt=_vector$b.copy(_e).multiplyScalar(.5);return this.min.copy(_).sub(tt),this.max.copy(_).add(tt),this}setFromObject(_,_e=!1){return this.makeEmpty(),this.expandByObject(_,_e)}clone(){return new this.constructor().copy(this)}copy(_){return this.min.copy(_.min),this.max.copy(_.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(_){return this.isEmpty()?_.set(0,0,0):_.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(_){return this.isEmpty()?_.set(0,0,0):_.subVectors(this.max,this.min)}expandByPoint(_){return this.min.min(_),this.max.max(_),this}expandByVector(_){return this.min.sub(_),this.max.add(_),this}expandByScalar(_){return this.min.addScalar(-_),this.max.addScalar(_),this}expandByObject(_,_e=!1){_.updateWorldMatrix(!1,!1);const tt=_.geometry;if(tt!==void 0){const rt=tt.getAttribute("position");if(_e===!0&&rt!==void 0&&_.isInstancedMesh!==!0)for(let ot=0,at=rt.count;ot<at;ot++)_.isMesh===!0?_.getVertexPosition(ot,_vector$b):_vector$b.fromBufferAttribute(rt,ot),_vector$b.applyMatrix4(_.matrixWorld),this.expandByPoint(_vector$b);else _.boundingBox!==void 0?(_.boundingBox===null&&_.computeBoundingBox(),_box$4.copy(_.boundingBox)):(tt.boundingBox===null&&tt.computeBoundingBox(),_box$4.copy(tt.boundingBox)),_box$4.applyMatrix4(_.matrixWorld),this.union(_box$4)}const nt=_.children;for(let rt=0,ot=nt.length;rt<ot;rt++)this.expandByObject(nt[rt],_e);return this}containsPoint(_){return!(_.x<this.min.x||_.x>this.max.x||_.y<this.min.y||_.y>this.max.y||_.z<this.min.z||_.z>this.max.z)}containsBox(_){return this.min.x<=_.min.x&&_.max.x<=this.max.x&&this.min.y<=_.min.y&&_.max.y<=this.max.y&&this.min.z<=_.min.z&&_.max.z<=this.max.z}getParameter(_,_e){return _e.set((_.x-this.min.x)/(this.max.x-this.min.x),(_.y-this.min.y)/(this.max.y-this.min.y),(_.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(_){return!(_.max.x<this.min.x||_.min.x>this.max.x||_.max.y<this.min.y||_.min.y>this.max.y||_.max.z<this.min.z||_.min.z>this.max.z)}intersectsSphere(_){return this.clampPoint(_.center,_vector$b),_vector$b.distanceToSquared(_.center)<=_.radius*_.radius}intersectsPlane(_){let _e,tt;return _.normal.x>0?(_e=_.normal.x*this.min.x,tt=_.normal.x*this.max.x):(_e=_.normal.x*this.max.x,tt=_.normal.x*this.min.x),_.normal.y>0?(_e+=_.normal.y*this.min.y,tt+=_.normal.y*this.max.y):(_e+=_.normal.y*this.max.y,tt+=_.normal.y*this.min.y),_.normal.z>0?(_e+=_.normal.z*this.min.z,tt+=_.normal.z*this.max.z):(_e+=_.normal.z*this.max.z,tt+=_.normal.z*this.min.z),_e<=-_.constant&&tt>=-_.constant}intersectsTriangle(_){if(this.isEmpty())return!1;this.getCenter(_center),_extents.subVectors(this.max,_center),_v0$2.subVectors(_.a,_center),_v1$7.subVectors(_.b,_center),_v2$4.subVectors(_.c,_center),_f0.subVectors(_v1$7,_v0$2),_f1.subVectors(_v2$4,_v1$7),_f2.subVectors(_v0$2,_v2$4);let _e=[0,-_f0.z,_f0.y,0,-_f1.z,_f1.y,0,-_f2.z,_f2.y,_f0.z,0,-_f0.x,_f1.z,0,-_f1.x,_f2.z,0,-_f2.x,-_f0.y,_f0.x,0,-_f1.y,_f1.x,0,-_f2.y,_f2.x,0];return!satForAxes(_e,_v0$2,_v1$7,_v2$4,_extents)||(_e=[1,0,0,0,1,0,0,0,1],!satForAxes(_e,_v0$2,_v1$7,_v2$4,_extents))?!1:(_triangleNormal.crossVectors(_f0,_f1),_e=[_triangleNormal.x,_triangleNormal.y,_triangleNormal.z],satForAxes(_e,_v0$2,_v1$7,_v2$4,_extents))}clampPoint(_,_e){return _e.copy(_).clamp(this.min,this.max)}distanceToPoint(_){return this.clampPoint(_,_vector$b).distanceTo(_)}getBoundingSphere(_){return this.isEmpty()?_.makeEmpty():(this.getCenter(_.center),_.radius=this.getSize(_vector$b).length()*.5),_}intersect(_){return this.min.max(_.min),this.max.min(_.max),this.isEmpty()&&this.makeEmpty(),this}union(_){return this.min.min(_.min),this.max.max(_.max),this}applyMatrix4(_){return this.isEmpty()?this:(_points[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(_),_points[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(_),_points[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(_),_points[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(_),_points[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(_),_points[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(_),_points[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(_),_points[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(_),this.setFromPoints(_points),this)}translate(_){return this.min.add(_),this.max.add(_),this}equals(_){return _.min.equals(this.min)&&_.max.equals(this.max)}}const _points=[new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3],_vector$b=new Vector3,_box$4=new Box3,_v0$2=new Vector3,_v1$7=new Vector3,_v2$4=new Vector3,_f0=new Vector3,_f1=new Vector3,_f2=new Vector3,_center=new Vector3,_extents=new Vector3,_triangleNormal=new Vector3,_testAxis=new Vector3;function satForAxes(et,_,_e,tt,nt){for(let rt=0,ot=et.length-3;rt<=ot;rt+=3){_testAxis.fromArray(et,rt);const at=nt.x*Math.abs(_testAxis.x)+nt.y*Math.abs(_testAxis.y)+nt.z*Math.abs(_testAxis.z),lt=_.dot(_testAxis),ut=_e.dot(_testAxis),dt=tt.dot(_testAxis);if(Math.max(-Math.max(lt,ut,dt),Math.min(lt,ut,dt))>at)return!1}return!0}const _box$3=new Box3,_v1$6=new Vector3,_v2$3=new Vector3;class Sphere{constructor(_=new Vector3,_e=-1){this.isSphere=!0,this.center=_,this.radius=_e}set(_,_e){return this.center.copy(_),this.radius=_e,this}setFromPoints(_,_e){const tt=this.center;_e!==void 0?tt.copy(_e):_box$3.setFromPoints(_).getCenter(tt);let nt=0;for(let rt=0,ot=_.length;rt<ot;rt++)nt=Math.max(nt,tt.distanceToSquared(_[rt]));return this.radius=Math.sqrt(nt),this}copy(_){return this.center.copy(_.center),this.radius=_.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(_){return _.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(_){return _.distanceTo(this.center)-this.radius}intersectsSphere(_){const _e=this.radius+_.radius;return _.center.distanceToSquared(this.center)<=_e*_e}intersectsBox(_){return _.intersectsSphere(this)}intersectsPlane(_){return Math.abs(_.distanceToPoint(this.center))<=this.radius}clampPoint(_,_e){const tt=this.center.distanceToSquared(_);return _e.copy(_),tt>this.radius*this.radius&&(_e.sub(this.center).normalize(),_e.multiplyScalar(this.radius).add(this.center)),_e}getBoundingBox(_){return this.isEmpty()?(_.makeEmpty(),_):(_.set(this.center,this.center),_.expandByScalar(this.radius),_)}applyMatrix4(_){return this.center.applyMatrix4(_),this.radius=this.radius*_.getMaxScaleOnAxis(),this}translate(_){return this.center.add(_),this}expandByPoint(_){if(this.isEmpty())return this.center.copy(_),this.radius=0,this;_v1$6.subVectors(_,this.center);const _e=_v1$6.lengthSq();if(_e>this.radius*this.radius){const tt=Math.sqrt(_e),nt=(tt-this.radius)*.5;this.center.addScaledVector(_v1$6,nt/tt),this.radius+=nt}return this}union(_){return _.isEmpty()?this:this.isEmpty()?(this.copy(_),this):(this.center.equals(_.center)===!0?this.radius=Math.max(this.radius,_.radius):(_v2$3.subVectors(_.center,this.center).setLength(_.radius),this.expandByPoint(_v1$6.copy(_.center).add(_v2$3)),this.expandByPoint(_v1$6.copy(_.center).sub(_v2$3))),this)}equals(_){return _.center.equals(this.center)&&_.radius===this.radius}clone(){return new this.constructor().copy(this)}}const _vector$a=new Vector3,_segCenter=new Vector3,_segDir=new Vector3,_diff=new Vector3,_edge1=new Vector3,_edge2=new Vector3,_normal$1=new Vector3;class Ray{constructor(_=new Vector3,_e=new Vector3(0,0,-1)){this.origin=_,this.direction=_e}set(_,_e){return this.origin.copy(_),this.direction.copy(_e),this}copy(_){return this.origin.copy(_.origin),this.direction.copy(_.direction),this}at(_,_e){return _e.copy(this.origin).addScaledVector(this.direction,_)}lookAt(_){return this.direction.copy(_).sub(this.origin).normalize(),this}recast(_){return this.origin.copy(this.at(_,_vector$a)),this}closestPointToPoint(_,_e){_e.subVectors(_,this.origin);const tt=_e.dot(this.direction);return tt<0?_e.copy(this.origin):_e.copy(this.origin).addScaledVector(this.direction,tt)}distanceToPoint(_){return Math.sqrt(this.distanceSqToPoint(_))}distanceSqToPoint(_){const _e=_vector$a.subVectors(_,this.origin).dot(this.direction);return _e<0?this.origin.distanceToSquared(_):(_vector$a.copy(this.origin).addScaledVector(this.direction,_e),_vector$a.distanceToSquared(_))}distanceSqToSegment(_,_e,tt,nt){_segCenter.copy(_).add(_e).multiplyScalar(.5),_segDir.copy(_e).sub(_).normalize(),_diff.copy(this.origin).sub(_segCenter);const rt=_.distanceTo(_e)*.5,ot=-this.direction.dot(_segDir),at=_diff.dot(this.direction),lt=-_diff.dot(_segDir),ut=_diff.lengthSq(),dt=Math.abs(1-ot*ot);let st,it,ct,ft;if(dt>0)if(st=ot*lt-at,it=ot*at-lt,ft=rt*dt,st>=0)if(it>=-ft)if(it<=ft){const ht=1/dt;st*=ht,it*=ht,ct=st*(st+ot*it+2*at)+it*(ot*st+it+2*lt)+ut}else it=rt,st=Math.max(0,-(ot*it+at)),ct=-st*st+it*(it+2*lt)+ut;else it=-rt,st=Math.max(0,-(ot*it+at)),ct=-st*st+it*(it+2*lt)+ut;else it<=-ft?(st=Math.max(0,-(-ot*rt+at)),it=st>0?-rt:Math.min(Math.max(-rt,-lt),rt),ct=-st*st+it*(it+2*lt)+ut):it<=ft?(st=0,it=Math.min(Math.max(-rt,-lt),rt),ct=it*(it+2*lt)+ut):(st=Math.max(0,-(ot*rt+at)),it=st>0?rt:Math.min(Math.max(-rt,-lt),rt),ct=-st*st+it*(it+2*lt)+ut);else it=ot>0?-rt:rt,st=Math.max(0,-(ot*it+at)),ct=-st*st+it*(it+2*lt)+ut;return tt&&tt.copy(this.origin).addScaledVector(this.direction,st),nt&&nt.copy(_segCenter).addScaledVector(_segDir,it),ct}intersectSphere(_,_e){_vector$a.subVectors(_.center,this.origin);const tt=_vector$a.dot(this.direction),nt=_vector$a.dot(_vector$a)-tt*tt,rt=_.radius*_.radius;if(nt>rt)return null;const ot=Math.sqrt(rt-nt),at=tt-ot,lt=tt+ot;return lt<0?null:at<0?this.at(lt,_e):this.at(at,_e)}intersectsSphere(_){return this.distanceSqToPoint(_.center)<=_.radius*_.radius}distanceToPlane(_){const _e=_.normal.dot(this.direction);if(_e===0)return _.distanceToPoint(this.origin)===0?0:null;const tt=-(this.origin.dot(_.normal)+_.constant)/_e;return tt>=0?tt:null}intersectPlane(_,_e){const tt=this.distanceToPlane(_);return tt===null?null:this.at(tt,_e)}intersectsPlane(_){const _e=_.distanceToPoint(this.origin);return _e===0||_.normal.dot(this.direction)*_e<0}intersectBox(_,_e){let tt,nt,rt,ot,at,lt;const ut=1/this.direction.x,dt=1/this.direction.y,st=1/this.direction.z,it=this.origin;return ut>=0?(tt=(_.min.x-it.x)*ut,nt=(_.max.x-it.x)*ut):(tt=(_.max.x-it.x)*ut,nt=(_.min.x-it.x)*ut),dt>=0?(rt=(_.min.y-it.y)*dt,ot=(_.max.y-it.y)*dt):(rt=(_.max.y-it.y)*dt,ot=(_.min.y-it.y)*dt),tt>ot||rt>nt||((rt>tt||isNaN(tt))&&(tt=rt),(ot<nt||isNaN(nt))&&(nt=ot),st>=0?(at=(_.min.z-it.z)*st,lt=(_.max.z-it.z)*st):(at=(_.max.z-it.z)*st,lt=(_.min.z-it.z)*st),tt>lt||at>nt)||((at>tt||tt!==tt)&&(tt=at),(lt<nt||nt!==nt)&&(nt=lt),nt<0)?null:this.at(tt>=0?tt:nt,_e)}intersectsBox(_){return this.intersectBox(_,_vector$a)!==null}intersectTriangle(_,_e,tt,nt,rt){_edge1.subVectors(_e,_),_edge2.subVectors(tt,_),_normal$1.crossVectors(_edge1,_edge2);let ot=this.direction.dot(_normal$1),at;if(ot>0){if(nt)return null;at=1}else if(ot<0)at=-1,ot=-ot;else return null;_diff.subVectors(this.origin,_);const lt=at*this.direction.dot(_edge2.crossVectors(_diff,_edge2));if(lt<0)return null;const ut=at*this.direction.dot(_edge1.cross(_diff));if(ut<0||lt+ut>ot)return null;const dt=-at*_diff.dot(_normal$1);return dt<0?null:this.at(dt/ot,rt)}applyMatrix4(_){return this.origin.applyMatrix4(_),this.direction.transformDirection(_),this}equals(_){return _.origin.equals(this.origin)&&_.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Matrix4{constructor(_,_e,tt,nt,rt,ot,at,lt,ut,dt,st,it,ct,ft,ht,mt){Matrix4.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],_!==void 0&&this.set(_,_e,tt,nt,rt,ot,at,lt,ut,dt,st,it,ct,ft,ht,mt)}set(_,_e,tt,nt,rt,ot,at,lt,ut,dt,st,it,ct,ft,ht,mt){const pt=this.elements;return pt[0]=_,pt[4]=_e,pt[8]=tt,pt[12]=nt,pt[1]=rt,pt[5]=ot,pt[9]=at,pt[13]=lt,pt[2]=ut,pt[6]=dt,pt[10]=st,pt[14]=it,pt[3]=ct,pt[7]=ft,pt[11]=ht,pt[15]=mt,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Matrix4().fromArray(this.elements)}copy(_){const _e=this.elements,tt=_.elements;return _e[0]=tt[0],_e[1]=tt[1],_e[2]=tt[2],_e[3]=tt[3],_e[4]=tt[4],_e[5]=tt[5],_e[6]=tt[6],_e[7]=tt[7],_e[8]=tt[8],_e[9]=tt[9],_e[10]=tt[10],_e[11]=tt[11],_e[12]=tt[12],_e[13]=tt[13],_e[14]=tt[14],_e[15]=tt[15],this}copyPosition(_){const _e=this.elements,tt=_.elements;return _e[12]=tt[12],_e[13]=tt[13],_e[14]=tt[14],this}setFromMatrix3(_){const _e=_.elements;return this.set(_e[0],_e[3],_e[6],0,_e[1],_e[4],_e[7],0,_e[2],_e[5],_e[8],0,0,0,0,1),this}extractBasis(_,_e,tt){return _.setFromMatrixColumn(this,0),_e.setFromMatrixColumn(this,1),tt.setFromMatrixColumn(this,2),this}makeBasis(_,_e,tt){return this.set(_.x,_e.x,tt.x,0,_.y,_e.y,tt.y,0,_.z,_e.z,tt.z,0,0,0,0,1),this}extractRotation(_){const _e=this.elements,tt=_.elements,nt=1/_v1$5.setFromMatrixColumn(_,0).length(),rt=1/_v1$5.setFromMatrixColumn(_,1).length(),ot=1/_v1$5.setFromMatrixColumn(_,2).length();return _e[0]=tt[0]*nt,_e[1]=tt[1]*nt,_e[2]=tt[2]*nt,_e[3]=0,_e[4]=tt[4]*rt,_e[5]=tt[5]*rt,_e[6]=tt[6]*rt,_e[7]=0,_e[8]=tt[8]*ot,_e[9]=tt[9]*ot,_e[10]=tt[10]*ot,_e[11]=0,_e[12]=0,_e[13]=0,_e[14]=0,_e[15]=1,this}makeRotationFromEuler(_){const _e=this.elements,tt=_.x,nt=_.y,rt=_.z,ot=Math.cos(tt),at=Math.sin(tt),lt=Math.cos(nt),ut=Math.sin(nt),dt=Math.cos(rt),st=Math.sin(rt);if(_.order==="XYZ"){const it=ot*dt,ct=ot*st,ft=at*dt,ht=at*st;_e[0]=lt*dt,_e[4]=-lt*st,_e[8]=ut,_e[1]=ct+ft*ut,_e[5]=it-ht*ut,_e[9]=-at*lt,_e[2]=ht-it*ut,_e[6]=ft+ct*ut,_e[10]=ot*lt}else if(_.order==="YXZ"){const it=lt*dt,ct=lt*st,ft=ut*dt,ht=ut*st;_e[0]=it+ht*at,_e[4]=ft*at-ct,_e[8]=ot*ut,_e[1]=ot*st,_e[5]=ot*dt,_e[9]=-at,_e[2]=ct*at-ft,_e[6]=ht+it*at,_e[10]=ot*lt}else if(_.order==="ZXY"){const it=lt*dt,ct=lt*st,ft=ut*dt,ht=ut*st;_e[0]=it-ht*at,_e[4]=-ot*st,_e[8]=ft+ct*at,_e[1]=ct+ft*at,_e[5]=ot*dt,_e[9]=ht-it*at,_e[2]=-ot*ut,_e[6]=at,_e[10]=ot*lt}else if(_.order==="ZYX"){const it=ot*dt,ct=ot*st,ft=at*dt,ht=at*st;_e[0]=lt*dt,_e[4]=ft*ut-ct,_e[8]=it*ut+ht,_e[1]=lt*st,_e[5]=ht*ut+it,_e[9]=ct*ut-ft,_e[2]=-ut,_e[6]=at*lt,_e[10]=ot*lt}else if(_.order==="YZX"){const it=ot*lt,ct=ot*ut,ft=at*lt,ht=at*ut;_e[0]=lt*dt,_e[4]=ht-it*st,_e[8]=ft*st+ct,_e[1]=st,_e[5]=ot*dt,_e[9]=-at*dt,_e[2]=-ut*dt,_e[6]=ct*st+ft,_e[10]=it-ht*st}else if(_.order==="XZY"){const it=ot*lt,ct=ot*ut,ft=at*lt,ht=at*ut;_e[0]=lt*dt,_e[4]=-st,_e[8]=ut*dt,_e[1]=it*st+ht,_e[5]=ot*dt,_e[9]=ct*st-ft,_e[2]=ft*st-ct,_e[6]=at*dt,_e[10]=ht*st+it}return _e[3]=0,_e[7]=0,_e[11]=0,_e[12]=0,_e[13]=0,_e[14]=0,_e[15]=1,this}makeRotationFromQuaternion(_){return this.compose(_zero,_,_one)}lookAt(_,_e,tt){const nt=this.elements;return _z.subVectors(_,_e),_z.lengthSq()===0&&(_z.z=1),_z.normalize(),_x.crossVectors(tt,_z),_x.lengthSq()===0&&(Math.abs(tt.z)===1?_z.x+=1e-4:_z.z+=1e-4,_z.normalize(),_x.crossVectors(tt,_z)),_x.normalize(),_y.crossVectors(_z,_x),nt[0]=_x.x,nt[4]=_y.x,nt[8]=_z.x,nt[1]=_x.y,nt[5]=_y.y,nt[9]=_z.y,nt[2]=_x.z,nt[6]=_y.z,nt[10]=_z.z,this}multiply(_){return this.multiplyMatrices(this,_)}premultiply(_){return this.multiplyMatrices(_,this)}multiplyMatrices(_,_e){const tt=_.elements,nt=_e.elements,rt=this.elements,ot=tt[0],at=tt[4],lt=tt[8],ut=tt[12],dt=tt[1],st=tt[5],it=tt[9],ct=tt[13],ft=tt[2],ht=tt[6],mt=tt[10],pt=tt[14],_t=tt[3],vt=tt[7],bt=tt[11],wt=tt[15],xt=nt[0],Mt=nt[4],At=nt[8],St=nt[12],Tt=nt[1],Ct=nt[5],It=nt[9],$t=nt[13],Nt=nt[2],Bt=nt[6],Ot=nt[10],Ut=nt[14],Lt=nt[3],zt=nt[7],Yt=nt[11],en=nt[15];return rt[0]=ot*xt+at*Tt+lt*Nt+ut*Lt,rt[4]=ot*Mt+at*Ct+lt*Bt+ut*zt,rt[8]=ot*At+at*It+lt*Ot+ut*Yt,rt[12]=ot*St+at*$t+lt*Ut+ut*en,rt[1]=dt*xt+st*Tt+it*Nt+ct*Lt,rt[5]=dt*Mt+st*Ct+it*Bt+ct*zt,rt[9]=dt*At+st*It+it*Ot+ct*Yt,rt[13]=dt*St+st*$t+it*Ut+ct*en,rt[2]=ft*xt+ht*Tt+mt*Nt+pt*Lt,rt[6]=ft*Mt+ht*Ct+mt*Bt+pt*zt,rt[10]=ft*At+ht*It+mt*Ot+pt*Yt,rt[14]=ft*St+ht*$t+mt*Ut+pt*en,rt[3]=_t*xt+vt*Tt+bt*Nt+wt*Lt,rt[7]=_t*Mt+vt*Ct+bt*Bt+wt*zt,rt[11]=_t*At+vt*It+bt*Ot+wt*Yt,rt[15]=_t*St+vt*$t+bt*Ut+wt*en,this}multiplyScalar(_){const _e=this.elements;return _e[0]*=_,_e[4]*=_,_e[8]*=_,_e[12]*=_,_e[1]*=_,_e[5]*=_,_e[9]*=_,_e[13]*=_,_e[2]*=_,_e[6]*=_,_e[10]*=_,_e[14]*=_,_e[3]*=_,_e[7]*=_,_e[11]*=_,_e[15]*=_,this}determinant(){const _=this.elements,_e=_[0],tt=_[4],nt=_[8],rt=_[12],ot=_[1],at=_[5],lt=_[9],ut=_[13],dt=_[2],st=_[6],it=_[10],ct=_[14],ft=_[3],ht=_[7],mt=_[11],pt=_[15];return ft*(+rt*lt*st-nt*ut*st-rt*at*it+tt*ut*it+nt*at*ct-tt*lt*ct)+ht*(+_e*lt*ct-_e*ut*it+rt*ot*it-nt*ot*ct+nt*ut*dt-rt*lt*dt)+mt*(+_e*ut*st-_e*at*ct-rt*ot*st+tt*ot*ct+rt*at*dt-tt*ut*dt)+pt*(-nt*at*dt-_e*lt*st+_e*at*it+nt*ot*st-tt*ot*it+tt*lt*dt)}transpose(){const _=this.elements;let _e;return _e=_[1],_[1]=_[4],_[4]=_e,_e=_[2],_[2]=_[8],_[8]=_e,_e=_[6],_[6]=_[9],_[9]=_e,_e=_[3],_[3]=_[12],_[12]=_e,_e=_[7],_[7]=_[13],_[13]=_e,_e=_[11],_[11]=_[14],_[14]=_e,this}setPosition(_,_e,tt){const nt=this.elements;return _.isVector3?(nt[12]=_.x,nt[13]=_.y,nt[14]=_.z):(nt[12]=_,nt[13]=_e,nt[14]=tt),this}invert(){const _=this.elements,_e=_[0],tt=_[1],nt=_[2],rt=_[3],ot=_[4],at=_[5],lt=_[6],ut=_[7],dt=_[8],st=_[9],it=_[10],ct=_[11],ft=_[12],ht=_[13],mt=_[14],pt=_[15],_t=st*mt*ut-ht*it*ut+ht*lt*ct-at*mt*ct-st*lt*pt+at*it*pt,vt=ft*it*ut-dt*mt*ut-ft*lt*ct+ot*mt*ct+dt*lt*pt-ot*it*pt,bt=dt*ht*ut-ft*st*ut+ft*at*ct-ot*ht*ct-dt*at*pt+ot*st*pt,wt=ft*st*lt-dt*ht*lt-ft*at*it+ot*ht*it+dt*at*mt-ot*st*mt,xt=_e*_t+tt*vt+nt*bt+rt*wt;if(xt===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const Mt=1/xt;return _[0]=_t*Mt,_[1]=(ht*it*rt-st*mt*rt-ht*nt*ct+tt*mt*ct+st*nt*pt-tt*it*pt)*Mt,_[2]=(at*mt*rt-ht*lt*rt+ht*nt*ut-tt*mt*ut-at*nt*pt+tt*lt*pt)*Mt,_[3]=(st*lt*rt-at*it*rt-st*nt*ut+tt*it*ut+at*nt*ct-tt*lt*ct)*Mt,_[4]=vt*Mt,_[5]=(dt*mt*rt-ft*it*rt+ft*nt*ct-_e*mt*ct-dt*nt*pt+_e*it*pt)*Mt,_[6]=(ft*lt*rt-ot*mt*rt-ft*nt*ut+_e*mt*ut+ot*nt*pt-_e*lt*pt)*Mt,_[7]=(ot*it*rt-dt*lt*rt+dt*nt*ut-_e*it*ut-ot*nt*ct+_e*lt*ct)*Mt,_[8]=bt*Mt,_[9]=(ft*st*rt-dt*ht*rt-ft*tt*ct+_e*ht*ct+dt*tt*pt-_e*st*pt)*Mt,_[10]=(ot*ht*rt-ft*at*rt+ft*tt*ut-_e*ht*ut-ot*tt*pt+_e*at*pt)*Mt,_[11]=(dt*at*rt-ot*st*rt-dt*tt*ut+_e*st*ut+ot*tt*ct-_e*at*ct)*Mt,_[12]=wt*Mt,_[13]=(dt*ht*nt-ft*st*nt+ft*tt*it-_e*ht*it-dt*tt*mt+_e*st*mt)*Mt,_[14]=(ft*at*nt-ot*ht*nt-ft*tt*lt+_e*ht*lt+ot*tt*mt-_e*at*mt)*Mt,_[15]=(ot*st*nt-dt*at*nt+dt*tt*lt-_e*st*lt-ot*tt*it+_e*at*it)*Mt,this}scale(_){const _e=this.elements,tt=_.x,nt=_.y,rt=_.z;return _e[0]*=tt,_e[4]*=nt,_e[8]*=rt,_e[1]*=tt,_e[5]*=nt,_e[9]*=rt,_e[2]*=tt,_e[6]*=nt,_e[10]*=rt,_e[3]*=tt,_e[7]*=nt,_e[11]*=rt,this}getMaxScaleOnAxis(){const _=this.elements,_e=_[0]*_[0]+_[1]*_[1]+_[2]*_[2],tt=_[4]*_[4]+_[5]*_[5]+_[6]*_[6],nt=_[8]*_[8]+_[9]*_[9]+_[10]*_[10];return Math.sqrt(Math.max(_e,tt,nt))}makeTranslation(_,_e,tt){return _.isVector3?this.set(1,0,0,_.x,0,1,0,_.y,0,0,1,_.z,0,0,0,1):this.set(1,0,0,_,0,1,0,_e,0,0,1,tt,0,0,0,1),this}makeRotationX(_){const _e=Math.cos(_),tt=Math.sin(_);return this.set(1,0,0,0,0,_e,-tt,0,0,tt,_e,0,0,0,0,1),this}makeRotationY(_){const _e=Math.cos(_),tt=Math.sin(_);return this.set(_e,0,tt,0,0,1,0,0,-tt,0,_e,0,0,0,0,1),this}makeRotationZ(_){const _e=Math.cos(_),tt=Math.sin(_);return this.set(_e,-tt,0,0,tt,_e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(_,_e){const tt=Math.cos(_e),nt=Math.sin(_e),rt=1-tt,ot=_.x,at=_.y,lt=_.z,ut=rt*ot,dt=rt*at;return this.set(ut*ot+tt,ut*at-nt*lt,ut*lt+nt*at,0,ut*at+nt*lt,dt*at+tt,dt*lt-nt*ot,0,ut*lt-nt*at,dt*lt+nt*ot,rt*lt*lt+tt,0,0,0,0,1),this}makeScale(_,_e,tt){return this.set(_,0,0,0,0,_e,0,0,0,0,tt,0,0,0,0,1),this}makeShear(_,_e,tt,nt,rt,ot){return this.set(1,tt,rt,0,_,1,ot,0,_e,nt,1,0,0,0,0,1),this}compose(_,_e,tt){const nt=this.elements,rt=_e._x,ot=_e._y,at=_e._z,lt=_e._w,ut=rt+rt,dt=ot+ot,st=at+at,it=rt*ut,ct=rt*dt,ft=rt*st,ht=ot*dt,mt=ot*st,pt=at*st,_t=lt*ut,vt=lt*dt,bt=lt*st,wt=tt.x,xt=tt.y,Mt=tt.z;return nt[0]=(1-(ht+pt))*wt,nt[1]=(ct+bt)*wt,nt[2]=(ft-vt)*wt,nt[3]=0,nt[4]=(ct-bt)*xt,nt[5]=(1-(it+pt))*xt,nt[6]=(mt+_t)*xt,nt[7]=0,nt[8]=(ft+vt)*Mt,nt[9]=(mt-_t)*Mt,nt[10]=(1-(it+ht))*Mt,nt[11]=0,nt[12]=_.x,nt[13]=_.y,nt[14]=_.z,nt[15]=1,this}decompose(_,_e,tt){const nt=this.elements;let rt=_v1$5.set(nt[0],nt[1],nt[2]).length();const ot=_v1$5.set(nt[4],nt[5],nt[6]).length(),at=_v1$5.set(nt[8],nt[9],nt[10]).length();this.determinant()<0&&(rt=-rt),_.x=nt[12],_.y=nt[13],_.z=nt[14],_m1$4.copy(this);const ut=1/rt,dt=1/ot,st=1/at;return _m1$4.elements[0]*=ut,_m1$4.elements[1]*=ut,_m1$4.elements[2]*=ut,_m1$4.elements[4]*=dt,_m1$4.elements[5]*=dt,_m1$4.elements[6]*=dt,_m1$4.elements[8]*=st,_m1$4.elements[9]*=st,_m1$4.elements[10]*=st,_e.setFromRotationMatrix(_m1$4),tt.x=rt,tt.y=ot,tt.z=at,this}makePerspective(_,_e,tt,nt,rt,ot,at=WebGLCoordinateSystem){const lt=this.elements,ut=2*rt/(_e-_),dt=2*rt/(tt-nt),st=(_e+_)/(_e-_),it=(tt+nt)/(tt-nt);let ct,ft;if(at===WebGLCoordinateSystem)ct=-(ot+rt)/(ot-rt),ft=-2*ot*rt/(ot-rt);else if(at===WebGPUCoordinateSystem)ct=-ot/(ot-rt),ft=-ot*rt/(ot-rt);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+at);return lt[0]=ut,lt[4]=0,lt[8]=st,lt[12]=0,lt[1]=0,lt[5]=dt,lt[9]=it,lt[13]=0,lt[2]=0,lt[6]=0,lt[10]=ct,lt[14]=ft,lt[3]=0,lt[7]=0,lt[11]=-1,lt[15]=0,this}makeOrthographic(_,_e,tt,nt,rt,ot,at=WebGLCoordinateSystem){const lt=this.elements,ut=1/(_e-_),dt=1/(tt-nt),st=1/(ot-rt),it=(_e+_)*ut,ct=(tt+nt)*dt;let ft,ht;if(at===WebGLCoordinateSystem)ft=(ot+rt)*st,ht=-2*st;else if(at===WebGPUCoordinateSystem)ft=rt*st,ht=-1*st;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+at);return lt[0]=2*ut,lt[4]=0,lt[8]=0,lt[12]=-it,lt[1]=0,lt[5]=2*dt,lt[9]=0,lt[13]=-ct,lt[2]=0,lt[6]=0,lt[10]=ht,lt[14]=-ft,lt[3]=0,lt[7]=0,lt[11]=0,lt[15]=1,this}equals(_){const _e=this.elements,tt=_.elements;for(let nt=0;nt<16;nt++)if(_e[nt]!==tt[nt])return!1;return!0}fromArray(_,_e=0){for(let tt=0;tt<16;tt++)this.elements[tt]=_[tt+_e];return this}toArray(_=[],_e=0){const tt=this.elements;return _[_e]=tt[0],_[_e+1]=tt[1],_[_e+2]=tt[2],_[_e+3]=tt[3],_[_e+4]=tt[4],_[_e+5]=tt[5],_[_e+6]=tt[6],_[_e+7]=tt[7],_[_e+8]=tt[8],_[_e+9]=tt[9],_[_e+10]=tt[10],_[_e+11]=tt[11],_[_e+12]=tt[12],_[_e+13]=tt[13],_[_e+14]=tt[14],_[_e+15]=tt[15],_}}const _v1$5=new Vector3,_m1$4=new Matrix4,_zero=new Vector3(0,0,0),_one=new Vector3(1,1,1),_x=new Vector3,_y=new Vector3,_z=new Vector3,_matrix$2=new Matrix4,_quaternion$3=new Quaternion;class Euler{constructor(_=0,_e=0,tt=0,nt=Euler.DEFAULT_ORDER){this.isEuler=!0,this._x=_,this._y=_e,this._z=tt,this._order=nt}get x(){return this._x}set x(_){this._x=_,this._onChangeCallback()}get y(){return this._y}set y(_){this._y=_,this._onChangeCallback()}get z(){return this._z}set z(_){this._z=_,this._onChangeCallback()}get order(){return this._order}set order(_){this._order=_,this._onChangeCallback()}set(_,_e,tt,nt=this._order){return this._x=_,this._y=_e,this._z=tt,this._order=nt,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(_){return this._x=_._x,this._y=_._y,this._z=_._z,this._order=_._order,this._onChangeCallback(),this}setFromRotationMatrix(_,_e=this._order,tt=!0){const nt=_.elements,rt=nt[0],ot=nt[4],at=nt[8],lt=nt[1],ut=nt[5],dt=nt[9],st=nt[2],it=nt[6],ct=nt[10];switch(_e){case"XYZ":this._y=Math.asin(clamp$4(at,-1,1)),Math.abs(at)<.9999999?(this._x=Math.atan2(-dt,ct),this._z=Math.atan2(-ot,rt)):(this._x=Math.atan2(it,ut),this._z=0);break;case"YXZ":this._x=Math.asin(-clamp$4(dt,-1,1)),Math.abs(dt)<.9999999?(this._y=Math.atan2(at,ct),this._z=Math.atan2(lt,ut)):(this._y=Math.atan2(-st,rt),this._z=0);break;case"ZXY":this._x=Math.asin(clamp$4(it,-1,1)),Math.abs(it)<.9999999?(this._y=Math.atan2(-st,ct),this._z=Math.atan2(-ot,ut)):(this._y=0,this._z=Math.atan2(lt,rt));break;case"ZYX":this._y=Math.asin(-clamp$4(st,-1,1)),Math.abs(st)<.9999999?(this._x=Math.atan2(it,ct),this._z=Math.atan2(lt,rt)):(this._x=0,this._z=Math.atan2(-ot,ut));break;case"YZX":this._z=Math.asin(clamp$4(lt,-1,1)),Math.abs(lt)<.9999999?(this._x=Math.atan2(-dt,ut),this._y=Math.atan2(-st,rt)):(this._x=0,this._y=Math.atan2(at,ct));break;case"XZY":this._z=Math.asin(-clamp$4(ot,-1,1)),Math.abs(ot)<.9999999?(this._x=Math.atan2(it,ut),this._y=Math.atan2(at,rt)):(this._x=Math.atan2(-dt,ct),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+_e)}return this._order=_e,tt===!0&&this._onChangeCallback(),this}setFromQuaternion(_,_e,tt){return _matrix$2.makeRotationFromQuaternion(_),this.setFromRotationMatrix(_matrix$2,_e,tt)}setFromVector3(_,_e=this._order){return this.set(_.x,_.y,_.z,_e)}reorder(_){return _quaternion$3.setFromEuler(this),this.setFromQuaternion(_quaternion$3,_)}equals(_){return _._x===this._x&&_._y===this._y&&_._z===this._z&&_._order===this._order}fromArray(_){return this._x=_[0],this._y=_[1],this._z=_[2],_[3]!==void 0&&(this._order=_[3]),this._onChangeCallback(),this}toArray(_=[],_e=0){return _[_e]=this._x,_[_e+1]=this._y,_[_e+2]=this._z,_[_e+3]=this._order,_}_onChange(_){return this._onChangeCallback=_,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Euler.DEFAULT_ORDER="XYZ";class Layers{constructor(){this.mask=1}set(_){this.mask=(1<<_|0)>>>0}enable(_){this.mask|=1<<_|0}enableAll(){this.mask=-1}toggle(_){this.mask^=1<<_|0}disable(_){this.mask&=~(1<<_|0)}disableAll(){this.mask=0}test(_){return(this.mask&_.mask)!==0}isEnabled(_){return(this.mask&(1<<_|0))!==0}}let _object3DId=0;const _v1$4=new Vector3,_q1$1=new Quaternion,_m1$3=new Matrix4,_target=new Vector3,_position$3=new Vector3,_scale$2=new Vector3,_quaternion$2=new Quaternion,_xAxis=new Vector3(1,0,0),_yAxis=new Vector3(0,1,0),_zAxis=new Vector3(0,0,1),_addedEvent={type:"added"},_removedEvent={type:"removed"},_childaddedEvent={type:"childadded",child:null},_childremovedEvent={type:"childremoved",child:null};class Object3D extends EventDispatcher{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:_object3DId++}),this.uuid=generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Object3D.DEFAULT_UP.clone();const _=new Vector3,_e=new Euler,tt=new Quaternion,nt=new Vector3(1,1,1);function rt(){tt.setFromEuler(_e,!1)}function ot(){_e.setFromQuaternion(tt,void 0,!1)}_e._onChange(rt),tt._onChange(ot),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:_},rotation:{configurable:!0,enumerable:!0,value:_e},quaternion:{configurable:!0,enumerable:!0,value:tt},scale:{configurable:!0,enumerable:!0,value:nt},modelViewMatrix:{value:new Matrix4},normalMatrix:{value:new Matrix3}}),this.matrix=new Matrix4,this.matrixWorld=new Matrix4,this.matrixAutoUpdate=Object3D.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Layers,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(_){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(_),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(_){return this.quaternion.premultiply(_),this}setRotationFromAxisAngle(_,_e){this.quaternion.setFromAxisAngle(_,_e)}setRotationFromEuler(_){this.quaternion.setFromEuler(_,!0)}setRotationFromMatrix(_){this.quaternion.setFromRotationMatrix(_)}setRotationFromQuaternion(_){this.quaternion.copy(_)}rotateOnAxis(_,_e){return _q1$1.setFromAxisAngle(_,_e),this.quaternion.multiply(_q1$1),this}rotateOnWorldAxis(_,_e){return _q1$1.setFromAxisAngle(_,_e),this.quaternion.premultiply(_q1$1),this}rotateX(_){return this.rotateOnAxis(_xAxis,_)}rotateY(_){return this.rotateOnAxis(_yAxis,_)}rotateZ(_){return this.rotateOnAxis(_zAxis,_)}translateOnAxis(_,_e){return _v1$4.copy(_).applyQuaternion(this.quaternion),this.position.add(_v1$4.multiplyScalar(_e)),this}translateX(_){return this.translateOnAxis(_xAxis,_)}translateY(_){return this.translateOnAxis(_yAxis,_)}translateZ(_){return this.translateOnAxis(_zAxis,_)}localToWorld(_){return this.updateWorldMatrix(!0,!1),_.applyMatrix4(this.matrixWorld)}worldToLocal(_){return this.updateWorldMatrix(!0,!1),_.applyMatrix4(_m1$3.copy(this.matrixWorld).invert())}lookAt(_,_e,tt){_.isVector3?_target.copy(_):_target.set(_,_e,tt);const nt=this.parent;this.updateWorldMatrix(!0,!1),_position$3.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?_m1$3.lookAt(_position$3,_target,this.up):_m1$3.lookAt(_target,_position$3,this.up),this.quaternion.setFromRotationMatrix(_m1$3),nt&&(_m1$3.extractRotation(nt.matrixWorld),_q1$1.setFromRotationMatrix(_m1$3),this.quaternion.premultiply(_q1$1.invert()))}add(_){if(arguments.length>1){for(let _e=0;_e<arguments.length;_e++)this.add(arguments[_e]);return this}return _===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",_),this):(_&&_.isObject3D?(_.removeFromParent(),_.parent=this,this.children.push(_),_.dispatchEvent(_addedEvent),_childaddedEvent.child=_,this.dispatchEvent(_childaddedEvent),_childaddedEvent.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",_),this)}remove(_){if(arguments.length>1){for(let tt=0;tt<arguments.length;tt++)this.remove(arguments[tt]);return this}const _e=this.children.indexOf(_);return _e!==-1&&(_.parent=null,this.children.splice(_e,1),_.dispatchEvent(_removedEvent),_childremovedEvent.child=_,this.dispatchEvent(_childremovedEvent),_childremovedEvent.child=null),this}removeFromParent(){const _=this.parent;return _!==null&&_.remove(this),this}clear(){return this.remove(...this.children)}attach(_){return this.updateWorldMatrix(!0,!1),_m1$3.copy(this.matrixWorld).invert(),_.parent!==null&&(_.parent.updateWorldMatrix(!0,!1),_m1$3.multiply(_.parent.matrixWorld)),_.applyMatrix4(_m1$3),_.removeFromParent(),_.parent=this,this.children.push(_),_.updateWorldMatrix(!1,!0),_.dispatchEvent(_addedEvent),_childaddedEvent.child=_,this.dispatchEvent(_childaddedEvent),_childaddedEvent.child=null,this}getObjectById(_){return this.getObjectByProperty("id",_)}getObjectByName(_){return this.getObjectByProperty("name",_)}getObjectByProperty(_,_e){if(this[_]===_e)return this;for(let tt=0,nt=this.children.length;tt<nt;tt++){const ot=this.children[tt].getObjectByProperty(_,_e);if(ot!==void 0)return ot}}getObjectsByProperty(_,_e,tt=[]){this[_]===_e&&tt.push(this);const nt=this.children;for(let rt=0,ot=nt.length;rt<ot;rt++)nt[rt].getObjectsByProperty(_,_e,tt);return tt}getWorldPosition(_){return this.updateWorldMatrix(!0,!1),_.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(_){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(_position$3,_,_scale$2),_}getWorldScale(_){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(_position$3,_quaternion$2,_),_}getWorldDirection(_){this.updateWorldMatrix(!0,!1);const _e=this.matrixWorld.elements;return _.set(_e[8],_e[9],_e[10]).normalize()}raycast(){}traverse(_){_(this);const _e=this.children;for(let tt=0,nt=_e.length;tt<nt;tt++)_e[tt].traverse(_)}traverseVisible(_){if(this.visible===!1)return;_(this);const _e=this.children;for(let tt=0,nt=_e.length;tt<nt;tt++)_e[tt].traverseVisible(_)}traverseAncestors(_){const _e=this.parent;_e!==null&&(_(_e),_e.traverseAncestors(_))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(_){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||_)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,_=!0);const _e=this.children;for(let tt=0,nt=_e.length;tt<nt;tt++)_e[tt].updateMatrixWorld(_)}updateWorldMatrix(_,_e){const tt=this.parent;if(_===!0&&tt!==null&&tt.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),_e===!0){const nt=this.children;for(let rt=0,ot=nt.length;rt<ot;rt++)nt[rt].updateWorldMatrix(!1,!0)}}toJSON(_){const _e=_===void 0||typeof _=="string",tt={};_e&&(_={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},tt.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const nt={};nt.uuid=this.uuid,nt.type=this.type,this.name!==""&&(nt.name=this.name),this.castShadow===!0&&(nt.castShadow=!0),this.receiveShadow===!0&&(nt.receiveShadow=!0),this.visible===!1&&(nt.visible=!1),this.frustumCulled===!1&&(nt.frustumCulled=!1),this.renderOrder!==0&&(nt.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(nt.userData=this.userData),nt.layers=this.layers.mask,nt.matrix=this.matrix.toArray(),nt.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(nt.matrixAutoUpdate=!1),this.isInstancedMesh&&(nt.type="InstancedMesh",nt.count=this.count,nt.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(nt.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(nt.type="BatchedMesh",nt.perObjectFrustumCulled=this.perObjectFrustumCulled,nt.sortObjects=this.sortObjects,nt.drawRanges=this._drawRanges,nt.reservedRanges=this._reservedRanges,nt.visibility=this._visibility,nt.active=this._active,nt.bounds=this._bounds.map(at=>({boxInitialized:at.boxInitialized,boxMin:at.box.min.toArray(),boxMax:at.box.max.toArray(),sphereInitialized:at.sphereInitialized,sphereRadius:at.sphere.radius,sphereCenter:at.sphere.center.toArray()})),nt.maxInstanceCount=this._maxInstanceCount,nt.maxVertexCount=this._maxVertexCount,nt.maxIndexCount=this._maxIndexCount,nt.geometryInitialized=this._geometryInitialized,nt.geometryCount=this._geometryCount,nt.matricesTexture=this._matricesTexture.toJSON(_),this._colorsTexture!==null&&(nt.colorsTexture=this._colorsTexture.toJSON(_)),this.boundingSphere!==null&&(nt.boundingSphere={center:nt.boundingSphere.center.toArray(),radius:nt.boundingSphere.radius}),this.boundingBox!==null&&(nt.boundingBox={min:nt.boundingBox.min.toArray(),max:nt.boundingBox.max.toArray()}));function rt(at,lt){return at[lt.uuid]===void 0&&(at[lt.uuid]=lt.toJSON(_)),lt.uuid}if(this.isScene)this.background&&(this.background.isColor?nt.background=this.background.toJSON():this.background.isTexture&&(nt.background=this.background.toJSON(_).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(nt.environment=this.environment.toJSON(_).uuid);else if(this.isMesh||this.isLine||this.isPoints){nt.geometry=rt(_.geometries,this.geometry);const at=this.geometry.parameters;if(at!==void 0&&at.shapes!==void 0){const lt=at.shapes;if(Array.isArray(lt))for(let ut=0,dt=lt.length;ut<dt;ut++){const st=lt[ut];rt(_.shapes,st)}else rt(_.shapes,lt)}}if(this.isSkinnedMesh&&(nt.bindMode=this.bindMode,nt.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(rt(_.skeletons,this.skeleton),nt.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const at=[];for(let lt=0,ut=this.material.length;lt<ut;lt++)at.push(rt(_.materials,this.material[lt]));nt.material=at}else nt.material=rt(_.materials,this.material);if(this.children.length>0){nt.children=[];for(let at=0;at<this.children.length;at++)nt.children.push(this.children[at].toJSON(_).object)}if(this.animations.length>0){nt.animations=[];for(let at=0;at<this.animations.length;at++){const lt=this.animations[at];nt.animations.push(rt(_.animations,lt))}}if(_e){const at=ot(_.geometries),lt=ot(_.materials),ut=ot(_.textures),dt=ot(_.images),st=ot(_.shapes),it=ot(_.skeletons),ct=ot(_.animations),ft=ot(_.nodes);at.length>0&&(tt.geometries=at),lt.length>0&&(tt.materials=lt),ut.length>0&&(tt.textures=ut),dt.length>0&&(tt.images=dt),st.length>0&&(tt.shapes=st),it.length>0&&(tt.skeletons=it),ct.length>0&&(tt.animations=ct),ft.length>0&&(tt.nodes=ft)}return tt.object=nt,tt;function ot(at){const lt=[];for(const ut in at){const dt=at[ut];delete dt.metadata,lt.push(dt)}return lt}}clone(_){return new this.constructor().copy(this,_)}copy(_,_e=!0){if(this.name=_.name,this.up.copy(_.up),this.position.copy(_.position),this.rotation.order=_.rotation.order,this.quaternion.copy(_.quaternion),this.scale.copy(_.scale),this.matrix.copy(_.matrix),this.matrixWorld.copy(_.matrixWorld),this.matrixAutoUpdate=_.matrixAutoUpdate,this.matrixWorldAutoUpdate=_.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=_.matrixWorldNeedsUpdate,this.layers.mask=_.layers.mask,this.visible=_.visible,this.castShadow=_.castShadow,this.receiveShadow=_.receiveShadow,this.frustumCulled=_.frustumCulled,this.renderOrder=_.renderOrder,this.animations=_.animations.slice(),this.userData=JSON.parse(JSON.stringify(_.userData)),_e===!0)for(let tt=0;tt<_.children.length;tt++){const nt=_.children[tt];this.add(nt.clone())}return this}}Object3D.DEFAULT_UP=new Vector3(0,1,0);Object3D.DEFAULT_MATRIX_AUTO_UPDATE=!0;Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const _v0$1=new Vector3,_v1$3=new Vector3,_v2$2=new Vector3,_v3$2=new Vector3,_vab=new Vector3,_vac=new Vector3,_vbc=new Vector3,_vap=new Vector3,_vbp=new Vector3,_vcp=new Vector3;class Triangle{constructor(_=new Vector3,_e=new Vector3,tt=new Vector3){this.a=_,this.b=_e,this.c=tt}static getNormal(_,_e,tt,nt){nt.subVectors(tt,_e),_v0$1.subVectors(_,_e),nt.cross(_v0$1);const rt=nt.lengthSq();return rt>0?nt.multiplyScalar(1/Math.sqrt(rt)):nt.set(0,0,0)}static getBarycoord(_,_e,tt,nt,rt){_v0$1.subVectors(nt,_e),_v1$3.subVectors(tt,_e),_v2$2.subVectors(_,_e);const ot=_v0$1.dot(_v0$1),at=_v0$1.dot(_v1$3),lt=_v0$1.dot(_v2$2),ut=_v1$3.dot(_v1$3),dt=_v1$3.dot(_v2$2),st=ot*ut-at*at;if(st===0)return rt.set(0,0,0),null;const it=1/st,ct=(ut*lt-at*dt)*it,ft=(ot*dt-at*lt)*it;return rt.set(1-ct-ft,ft,ct)}static containsPoint(_,_e,tt,nt){return this.getBarycoord(_,_e,tt,nt,_v3$2)===null?!1:_v3$2.x>=0&&_v3$2.y>=0&&_v3$2.x+_v3$2.y<=1}static getInterpolation(_,_e,tt,nt,rt,ot,at,lt){return this.getBarycoord(_,_e,tt,nt,_v3$2)===null?(lt.x=0,lt.y=0,"z"in lt&&(lt.z=0),"w"in lt&&(lt.w=0),null):(lt.setScalar(0),lt.addScaledVector(rt,_v3$2.x),lt.addScaledVector(ot,_v3$2.y),lt.addScaledVector(at,_v3$2.z),lt)}static isFrontFacing(_,_e,tt,nt){return _v0$1.subVectors(tt,_e),_v1$3.subVectors(_,_e),_v0$1.cross(_v1$3).dot(nt)<0}set(_,_e,tt){return this.a.copy(_),this.b.copy(_e),this.c.copy(tt),this}setFromPointsAndIndices(_,_e,tt,nt){return this.a.copy(_[_e]),this.b.copy(_[tt]),this.c.copy(_[nt]),this}setFromAttributeAndIndices(_,_e,tt,nt){return this.a.fromBufferAttribute(_,_e),this.b.fromBufferAttribute(_,tt),this.c.fromBufferAttribute(_,nt),this}clone(){return new this.constructor().copy(this)}copy(_){return this.a.copy(_.a),this.b.copy(_.b),this.c.copy(_.c),this}getArea(){return _v0$1.subVectors(this.c,this.b),_v1$3.subVectors(this.a,this.b),_v0$1.cross(_v1$3).length()*.5}getMidpoint(_){return _.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(_){return Triangle.getNormal(this.a,this.b,this.c,_)}getPlane(_){return _.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(_,_e){return Triangle.getBarycoord(_,this.a,this.b,this.c,_e)}getInterpolation(_,_e,tt,nt,rt){return Triangle.getInterpolation(_,this.a,this.b,this.c,_e,tt,nt,rt)}containsPoint(_){return Triangle.containsPoint(_,this.a,this.b,this.c)}isFrontFacing(_){return Triangle.isFrontFacing(this.a,this.b,this.c,_)}intersectsBox(_){return _.intersectsTriangle(this)}closestPointToPoint(_,_e){const tt=this.a,nt=this.b,rt=this.c;let ot,at;_vab.subVectors(nt,tt),_vac.subVectors(rt,tt),_vap.subVectors(_,tt);const lt=_vab.dot(_vap),ut=_vac.dot(_vap);if(lt<=0&&ut<=0)return _e.copy(tt);_vbp.subVectors(_,nt);const dt=_vab.dot(_vbp),st=_vac.dot(_vbp);if(dt>=0&&st<=dt)return _e.copy(nt);const it=lt*st-dt*ut;if(it<=0&&lt>=0&&dt<=0)return ot=lt/(lt-dt),_e.copy(tt).addScaledVector(_vab,ot);_vcp.subVectors(_,rt);const ct=_vab.dot(_vcp),ft=_vac.dot(_vcp);if(ft>=0&&ct<=ft)return _e.copy(rt);const ht=ct*ut-lt*ft;if(ht<=0&&ut>=0&&ft<=0)return at=ut/(ut-ft),_e.copy(tt).addScaledVector(_vac,at);const mt=dt*ft-ct*st;if(mt<=0&&st-dt>=0&&ct-ft>=0)return _vbc.subVectors(rt,nt),at=(st-dt)/(st-dt+(ct-ft)),_e.copy(nt).addScaledVector(_vbc,at);const pt=1/(mt+ht+it);return ot=ht*pt,at=it*pt,_e.copy(tt).addScaledVector(_vab,ot).addScaledVector(_vac,at)}equals(_){return _.a.equals(this.a)&&_.b.equals(this.b)&&_.c.equals(this.c)}}const _colorKeywords={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},_hslA={h:0,s:0,l:0},_hslB={h:0,s:0,l:0};function hue2rgb(et,_,_e){return _e<0&&(_e+=1),_e>1&&(_e-=1),_e<1/6?et+(_-et)*6*_e:_e<1/2?_:_e<2/3?et+(_-et)*6*(2/3-_e):et}let Color$1=class{constructor(_,_e,tt){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(_,_e,tt)}set(_,_e,tt){if(_e===void 0&&tt===void 0){const nt=_;nt&&nt.isColor?this.copy(nt):typeof nt=="number"?this.setHex(nt):typeof nt=="string"&&this.setStyle(nt)}else this.setRGB(_,_e,tt);return this}setScalar(_){return this.r=_,this.g=_,this.b=_,this}setHex(_,_e=SRGBColorSpace){return _=Math.floor(_),this.r=(_>>16&255)/255,this.g=(_>>8&255)/255,this.b=(_&255)/255,ColorManagement.toWorkingColorSpace(this,_e),this}setRGB(_,_e,tt,nt=ColorManagement.workingColorSpace){return this.r=_,this.g=_e,this.b=tt,ColorManagement.toWorkingColorSpace(this,nt),this}setHSL(_,_e,tt,nt=ColorManagement.workingColorSpace){if(_=euclideanModulo(_,1),_e=clamp$4(_e,0,1),tt=clamp$4(tt,0,1),_e===0)this.r=this.g=this.b=tt;else{const rt=tt<=.5?tt*(1+_e):tt+_e-tt*_e,ot=2*tt-rt;this.r=hue2rgb(ot,rt,_+1/3),this.g=hue2rgb(ot,rt,_),this.b=hue2rgb(ot,rt,_-1/3)}return ColorManagement.toWorkingColorSpace(this,nt),this}setStyle(_,_e=SRGBColorSpace){function tt(rt){rt!==void 0&&parseFloat(rt)<1&&console.warn("THREE.Color: Alpha component of "+_+" will be ignored.")}let nt;if(nt=/^(\w+)\(([^\)]*)\)/.exec(_)){let rt;const ot=nt[1],at=nt[2];switch(ot){case"rgb":case"rgba":if(rt=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(at))return tt(rt[4]),this.setRGB(Math.min(255,parseInt(rt[1],10))/255,Math.min(255,parseInt(rt[2],10))/255,Math.min(255,parseInt(rt[3],10))/255,_e);if(rt=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(at))return tt(rt[4]),this.setRGB(Math.min(100,parseInt(rt[1],10))/100,Math.min(100,parseInt(rt[2],10))/100,Math.min(100,parseInt(rt[3],10))/100,_e);break;case"hsl":case"hsla":if(rt=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(at))return tt(rt[4]),this.setHSL(parseFloat(rt[1])/360,parseFloat(rt[2])/100,parseFloat(rt[3])/100,_e);break;default:console.warn("THREE.Color: Unknown color model "+_)}}else if(nt=/^\#([A-Fa-f\d]+)$/.exec(_)){const rt=nt[1],ot=rt.length;if(ot===3)return this.setRGB(parseInt(rt.charAt(0),16)/15,parseInt(rt.charAt(1),16)/15,parseInt(rt.charAt(2),16)/15,_e);if(ot===6)return this.setHex(parseInt(rt,16),_e);console.warn("THREE.Color: Invalid hex color "+_)}else if(_&&_.length>0)return this.setColorName(_,_e);return this}setColorName(_,_e=SRGBColorSpace){const tt=_colorKeywords[_.toLowerCase()];return tt!==void 0?this.setHex(tt,_e):console.warn("THREE.Color: Unknown color "+_),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(_){return this.r=_.r,this.g=_.g,this.b=_.b,this}copySRGBToLinear(_){return this.r=SRGBToLinear(_.r),this.g=SRGBToLinear(_.g),this.b=SRGBToLinear(_.b),this}copyLinearToSRGB(_){return this.r=LinearToSRGB(_.r),this.g=LinearToSRGB(_.g),this.b=LinearToSRGB(_.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(_=SRGBColorSpace){return ColorManagement.fromWorkingColorSpace(_color.copy(this),_),Math.round(clamp$4(_color.r*255,0,255))*65536+Math.round(clamp$4(_color.g*255,0,255))*256+Math.round(clamp$4(_color.b*255,0,255))}getHexString(_=SRGBColorSpace){return("000000"+this.getHex(_).toString(16)).slice(-6)}getHSL(_,_e=ColorManagement.workingColorSpace){ColorManagement.fromWorkingColorSpace(_color.copy(this),_e);const tt=_color.r,nt=_color.g,rt=_color.b,ot=Math.max(tt,nt,rt),at=Math.min(tt,nt,rt);let lt,ut;const dt=(at+ot)/2;if(at===ot)lt=0,ut=0;else{const st=ot-at;switch(ut=dt<=.5?st/(ot+at):st/(2-ot-at),ot){case tt:lt=(nt-rt)/st+(nt<rt?6:0);break;case nt:lt=(rt-tt)/st+2;break;case rt:lt=(tt-nt)/st+4;break}lt/=6}return _.h=lt,_.s=ut,_.l=dt,_}getRGB(_,_e=ColorManagement.workingColorSpace){return ColorManagement.fromWorkingColorSpace(_color.copy(this),_e),_.r=_color.r,_.g=_color.g,_.b=_color.b,_}getStyle(_=SRGBColorSpace){ColorManagement.fromWorkingColorSpace(_color.copy(this),_);const _e=_color.r,tt=_color.g,nt=_color.b;return _!==SRGBColorSpace?`color(${_} ${_e.toFixed(3)} ${tt.toFixed(3)} ${nt.toFixed(3)})`:`rgb(${Math.round(_e*255)},${Math.round(tt*255)},${Math.round(nt*255)})`}offsetHSL(_,_e,tt){return this.getHSL(_hslA),this.setHSL(_hslA.h+_,_hslA.s+_e,_hslA.l+tt)}add(_){return this.r+=_.r,this.g+=_.g,this.b+=_.b,this}addColors(_,_e){return this.r=_.r+_e.r,this.g=_.g+_e.g,this.b=_.b+_e.b,this}addScalar(_){return this.r+=_,this.g+=_,this.b+=_,this}sub(_){return this.r=Math.max(0,this.r-_.r),this.g=Math.max(0,this.g-_.g),this.b=Math.max(0,this.b-_.b),this}multiply(_){return this.r*=_.r,this.g*=_.g,this.b*=_.b,this}multiplyScalar(_){return this.r*=_,this.g*=_,this.b*=_,this}lerp(_,_e){return this.r+=(_.r-this.r)*_e,this.g+=(_.g-this.g)*_e,this.b+=(_.b-this.b)*_e,this}lerpColors(_,_e,tt){return this.r=_.r+(_e.r-_.r)*tt,this.g=_.g+(_e.g-_.g)*tt,this.b=_.b+(_e.b-_.b)*tt,this}lerpHSL(_,_e){this.getHSL(_hslA),_.getHSL(_hslB);const tt=lerp(_hslA.h,_hslB.h,_e),nt=lerp(_hslA.s,_hslB.s,_e),rt=lerp(_hslA.l,_hslB.l,_e);return this.setHSL(tt,nt,rt),this}setFromVector3(_){return this.r=_.x,this.g=_.y,this.b=_.z,this}applyMatrix3(_){const _e=this.r,tt=this.g,nt=this.b,rt=_.elements;return this.r=rt[0]*_e+rt[3]*tt+rt[6]*nt,this.g=rt[1]*_e+rt[4]*tt+rt[7]*nt,this.b=rt[2]*_e+rt[5]*tt+rt[8]*nt,this}equals(_){return _.r===this.r&&_.g===this.g&&_.b===this.b}fromArray(_,_e=0){return this.r=_[_e],this.g=_[_e+1],this.b=_[_e+2],this}toArray(_=[],_e=0){return _[_e]=this.r,_[_e+1]=this.g,_[_e+2]=this.b,_}fromBufferAttribute(_,_e){return this.r=_.getX(_e),this.g=_.getY(_e),this.b=_.getZ(_e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}};const _color=new Color$1;Color$1.NAMES=_colorKeywords;let _materialId=0;class Material extends EventDispatcher{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:_materialId++}),this.uuid=generateUUID(),this.name="",this.type="Material",this.blending=NormalBlending,this.side=FrontSide,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=SrcAlphaFactor,this.blendDst=OneMinusSrcAlphaFactor,this.blendEquation=AddEquation,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Color$1(0,0,0),this.blendAlpha=0,this.depthFunc=LessEqualDepth,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=AlwaysStencilFunc,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=KeepStencilOp,this.stencilZFail=KeepStencilOp,this.stencilZPass=KeepStencilOp,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(_){this._alphaTest>0!=_>0&&this.version++,this._alphaTest=_}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(_){if(_!==void 0)for(const _e in _){const tt=_[_e];if(tt===void 0){console.warn(`THREE.Material: parameter '${_e}' has value of undefined.`);continue}const nt=this[_e];if(nt===void 0){console.warn(`THREE.Material: '${_e}' is not a property of THREE.${this.type}.`);continue}nt&&nt.isColor?nt.set(tt):nt&&nt.isVector3&&tt&&tt.isVector3?nt.copy(tt):this[_e]=tt}}toJSON(_){const _e=_===void 0||typeof _=="string";_e&&(_={textures:{},images:{}});const tt={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};tt.uuid=this.uuid,tt.type=this.type,this.name!==""&&(tt.name=this.name),this.color&&this.color.isColor&&(tt.color=this.color.getHex()),this.roughness!==void 0&&(tt.roughness=this.roughness),this.metalness!==void 0&&(tt.metalness=this.metalness),this.sheen!==void 0&&(tt.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(tt.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(tt.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(tt.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(tt.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(tt.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(tt.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(tt.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(tt.shininess=this.shininess),this.clearcoat!==void 0&&(tt.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(tt.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(tt.clearcoatMap=this.clearcoatMap.toJSON(_).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(tt.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(_).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(tt.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(_).uuid,tt.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(tt.dispersion=this.dispersion),this.iridescence!==void 0&&(tt.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(tt.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(tt.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(tt.iridescenceMap=this.iridescenceMap.toJSON(_).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(tt.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(_).uuid),this.anisotropy!==void 0&&(tt.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(tt.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(tt.anisotropyMap=this.anisotropyMap.toJSON(_).uuid),this.map&&this.map.isTexture&&(tt.map=this.map.toJSON(_).uuid),this.matcap&&this.matcap.isTexture&&(tt.matcap=this.matcap.toJSON(_).uuid),this.alphaMap&&this.alphaMap.isTexture&&(tt.alphaMap=this.alphaMap.toJSON(_).uuid),this.lightMap&&this.lightMap.isTexture&&(tt.lightMap=this.lightMap.toJSON(_).uuid,tt.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(tt.aoMap=this.aoMap.toJSON(_).uuid,tt.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(tt.bumpMap=this.bumpMap.toJSON(_).uuid,tt.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(tt.normalMap=this.normalMap.toJSON(_).uuid,tt.normalMapType=this.normalMapType,tt.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(tt.displacementMap=this.displacementMap.toJSON(_).uuid,tt.displacementScale=this.displacementScale,tt.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(tt.roughnessMap=this.roughnessMap.toJSON(_).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(tt.metalnessMap=this.metalnessMap.toJSON(_).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(tt.emissiveMap=this.emissiveMap.toJSON(_).uuid),this.specularMap&&this.specularMap.isTexture&&(tt.specularMap=this.specularMap.toJSON(_).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(tt.specularIntensityMap=this.specularIntensityMap.toJSON(_).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(tt.specularColorMap=this.specularColorMap.toJSON(_).uuid),this.envMap&&this.envMap.isTexture&&(tt.envMap=this.envMap.toJSON(_).uuid,this.combine!==void 0&&(tt.combine=this.combine)),this.envMapRotation!==void 0&&(tt.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(tt.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(tt.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(tt.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(tt.gradientMap=this.gradientMap.toJSON(_).uuid),this.transmission!==void 0&&(tt.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(tt.transmissionMap=this.transmissionMap.toJSON(_).uuid),this.thickness!==void 0&&(tt.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(tt.thicknessMap=this.thicknessMap.toJSON(_).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(tt.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(tt.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(tt.size=this.size),this.shadowSide!==null&&(tt.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(tt.sizeAttenuation=this.sizeAttenuation),this.blending!==NormalBlending&&(tt.blending=this.blending),this.side!==FrontSide&&(tt.side=this.side),this.vertexColors===!0&&(tt.vertexColors=!0),this.opacity<1&&(tt.opacity=this.opacity),this.transparent===!0&&(tt.transparent=!0),this.blendSrc!==SrcAlphaFactor&&(tt.blendSrc=this.blendSrc),this.blendDst!==OneMinusSrcAlphaFactor&&(tt.blendDst=this.blendDst),this.blendEquation!==AddEquation&&(tt.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(tt.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(tt.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(tt.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(tt.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(tt.blendAlpha=this.blendAlpha),this.depthFunc!==LessEqualDepth&&(tt.depthFunc=this.depthFunc),this.depthTest===!1&&(tt.depthTest=this.depthTest),this.depthWrite===!1&&(tt.depthWrite=this.depthWrite),this.colorWrite===!1&&(tt.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(tt.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==AlwaysStencilFunc&&(tt.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(tt.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(tt.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==KeepStencilOp&&(tt.stencilFail=this.stencilFail),this.stencilZFail!==KeepStencilOp&&(tt.stencilZFail=this.stencilZFail),this.stencilZPass!==KeepStencilOp&&(tt.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(tt.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(tt.rotation=this.rotation),this.polygonOffset===!0&&(tt.polygonOffset=!0),this.polygonOffsetFactor!==0&&(tt.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(tt.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(tt.linewidth=this.linewidth),this.dashSize!==void 0&&(tt.dashSize=this.dashSize),this.gapSize!==void 0&&(tt.gapSize=this.gapSize),this.scale!==void 0&&(tt.scale=this.scale),this.dithering===!0&&(tt.dithering=!0),this.alphaTest>0&&(tt.alphaTest=this.alphaTest),this.alphaHash===!0&&(tt.alphaHash=!0),this.alphaToCoverage===!0&&(tt.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(tt.premultipliedAlpha=!0),this.forceSinglePass===!0&&(tt.forceSinglePass=!0),this.wireframe===!0&&(tt.wireframe=!0),this.wireframeLinewidth>1&&(tt.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(tt.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(tt.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(tt.flatShading=!0),this.visible===!1&&(tt.visible=!1),this.toneMapped===!1&&(tt.toneMapped=!1),this.fog===!1&&(tt.fog=!1),Object.keys(this.userData).length>0&&(tt.userData=this.userData);function nt(rt){const ot=[];for(const at in rt){const lt=rt[at];delete lt.metadata,ot.push(lt)}return ot}if(_e){const rt=nt(_.textures),ot=nt(_.images);rt.length>0&&(tt.textures=rt),ot.length>0&&(tt.images=ot)}return tt}clone(){return new this.constructor().copy(this)}copy(_){this.name=_.name,this.blending=_.blending,this.side=_.side,this.vertexColors=_.vertexColors,this.opacity=_.opacity,this.transparent=_.transparent,this.blendSrc=_.blendSrc,this.blendDst=_.blendDst,this.blendEquation=_.blendEquation,this.blendSrcAlpha=_.blendSrcAlpha,this.blendDstAlpha=_.blendDstAlpha,this.blendEquationAlpha=_.blendEquationAlpha,this.blendColor.copy(_.blendColor),this.blendAlpha=_.blendAlpha,this.depthFunc=_.depthFunc,this.depthTest=_.depthTest,this.depthWrite=_.depthWrite,this.stencilWriteMask=_.stencilWriteMask,this.stencilFunc=_.stencilFunc,this.stencilRef=_.stencilRef,this.stencilFuncMask=_.stencilFuncMask,this.stencilFail=_.stencilFail,this.stencilZFail=_.stencilZFail,this.stencilZPass=_.stencilZPass,this.stencilWrite=_.stencilWrite;const _e=_.clippingPlanes;let tt=null;if(_e!==null){const nt=_e.length;tt=new Array(nt);for(let rt=0;rt!==nt;++rt)tt[rt]=_e[rt].clone()}return this.clippingPlanes=tt,this.clipIntersection=_.clipIntersection,this.clipShadows=_.clipShadows,this.shadowSide=_.shadowSide,this.colorWrite=_.colorWrite,this.precision=_.precision,this.polygonOffset=_.polygonOffset,this.polygonOffsetFactor=_.polygonOffsetFactor,this.polygonOffsetUnits=_.polygonOffsetUnits,this.dithering=_.dithering,this.alphaTest=_.alphaTest,this.alphaHash=_.alphaHash,this.alphaToCoverage=_.alphaToCoverage,this.premultipliedAlpha=_.premultipliedAlpha,this.forceSinglePass=_.forceSinglePass,this.visible=_.visible,this.toneMapped=_.toneMapped,this.userData=JSON.parse(JSON.stringify(_.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(_){_===!0&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}onBeforeRender(){console.warn("Material: onBeforeRender() has been removed.")}}class MeshBasicMaterial extends Material{constructor(_){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Color$1(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.combine=MultiplyOperation,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(_)}copy(_){return super.copy(_),this.color.copy(_.color),this.map=_.map,this.lightMap=_.lightMap,this.lightMapIntensity=_.lightMapIntensity,this.aoMap=_.aoMap,this.aoMapIntensity=_.aoMapIntensity,this.specularMap=_.specularMap,this.alphaMap=_.alphaMap,this.envMap=_.envMap,this.envMapRotation.copy(_.envMapRotation),this.combine=_.combine,this.reflectivity=_.reflectivity,this.refractionRatio=_.refractionRatio,this.wireframe=_.wireframe,this.wireframeLinewidth=_.wireframeLinewidth,this.wireframeLinecap=_.wireframeLinecap,this.wireframeLinejoin=_.wireframeLinejoin,this.fog=_.fog,this}}const _tables=_generateTables();function _generateTables(){const et=new ArrayBuffer(4),_=new Float32Array(et),_e=new Uint32Array(et),tt=new Uint32Array(512),nt=new Uint32Array(512);for(let lt=0;lt<256;++lt){const ut=lt-127;ut<-27?(tt[lt]=0,tt[lt|256]=32768,nt[lt]=24,nt[lt|256]=24):ut<-14?(tt[lt]=1024>>-ut-14,tt[lt|256]=1024>>-ut-14|32768,nt[lt]=-ut-1,nt[lt|256]=-ut-1):ut<=15?(tt[lt]=ut+15<<10,tt[lt|256]=ut+15<<10|32768,nt[lt]=13,nt[lt|256]=13):ut<128?(tt[lt]=31744,tt[lt|256]=64512,nt[lt]=24,nt[lt|256]=24):(tt[lt]=31744,tt[lt|256]=64512,nt[lt]=13,nt[lt|256]=13)}const rt=new Uint32Array(2048),ot=new Uint32Array(64),at=new Uint32Array(64);for(let lt=1;lt<1024;++lt){let ut=lt<<13,dt=0;for(;!(ut&8388608);)ut<<=1,dt-=8388608;ut&=-8388609,dt+=947912704,rt[lt]=ut|dt}for(let lt=1024;lt<2048;++lt)rt[lt]=939524096+(lt-1024<<13);for(let lt=1;lt<31;++lt)ot[lt]=lt<<23;ot[31]=1199570944,ot[32]=2147483648;for(let lt=33;lt<63;++lt)ot[lt]=2147483648+(lt-32<<23);ot[63]=3347054592;for(let lt=1;lt<64;++lt)lt!==32&&(at[lt]=1024);return{floatView:_,uint32View:_e,baseTable:tt,shiftTable:nt,mantissaTable:rt,exponentTable:ot,offsetTable:at}}function toHalfFloat(et){Math.abs(et)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),et=clamp$4(et,-65504,65504),_tables.floatView[0]=et;const _=_tables.uint32View[0],_e=_>>23&511;return _tables.baseTable[_e]+((_&8388607)>>_tables.shiftTable[_e])}function fromHalfFloat(et){const _=et>>10;return _tables.uint32View[0]=_tables.mantissaTable[_tables.offsetTable[_]+(et&1023)]+_tables.exponentTable[_],_tables.floatView[0]}const DataUtils={toHalfFloat,fromHalfFloat},_vector$9=new Vector3,_vector2$1=new Vector2;class BufferAttribute{constructor(_,_e,tt=!1){if(Array.isArray(_))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=_,this.itemSize=_e,this.count=_!==void 0?_.length/_e:0,this.normalized=tt,this.usage=StaticDrawUsage,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.gpuType=FloatType,this.version=0}onUploadCallback(){}set needsUpdate(_){_===!0&&this.version++}get updateRange(){return warnOnce("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(_){return this.usage=_,this}addUpdateRange(_,_e){this.updateRanges.push({start:_,count:_e})}clearUpdateRanges(){this.updateRanges.length=0}copy(_){return this.name=_.name,this.array=new _.array.constructor(_.array),this.itemSize=_.itemSize,this.count=_.count,this.normalized=_.normalized,this.usage=_.usage,this.gpuType=_.gpuType,this}copyAt(_,_e,tt){_*=this.itemSize,tt*=_e.itemSize;for(let nt=0,rt=this.itemSize;nt<rt;nt++)this.array[_+nt]=_e.array[tt+nt];return this}copyArray(_){return this.array.set(_),this}applyMatrix3(_){if(this.itemSize===2)for(let _e=0,tt=this.count;_e<tt;_e++)_vector2$1.fromBufferAttribute(this,_e),_vector2$1.applyMatrix3(_),this.setXY(_e,_vector2$1.x,_vector2$1.y);else if(this.itemSize===3)for(let _e=0,tt=this.count;_e<tt;_e++)_vector$9.fromBufferAttribute(this,_e),_vector$9.applyMatrix3(_),this.setXYZ(_e,_vector$9.x,_vector$9.y,_vector$9.z);return this}applyMatrix4(_){for(let _e=0,tt=this.count;_e<tt;_e++)_vector$9.fromBufferAttribute(this,_e),_vector$9.applyMatrix4(_),this.setXYZ(_e,_vector$9.x,_vector$9.y,_vector$9.z);return this}applyNormalMatrix(_){for(let _e=0,tt=this.count;_e<tt;_e++)_vector$9.fromBufferAttribute(this,_e),_vector$9.applyNormalMatrix(_),this.setXYZ(_e,_vector$9.x,_vector$9.y,_vector$9.z);return this}transformDirection(_){for(let _e=0,tt=this.count;_e<tt;_e++)_vector$9.fromBufferAttribute(this,_e),_vector$9.transformDirection(_),this.setXYZ(_e,_vector$9.x,_vector$9.y,_vector$9.z);return this}set(_,_e=0){return this.array.set(_,_e),this}getComponent(_,_e){let tt=this.array[_*this.itemSize+_e];return this.normalized&&(tt=denormalize(tt,this.array)),tt}setComponent(_,_e,tt){return this.normalized&&(tt=normalize$5(tt,this.array)),this.array[_*this.itemSize+_e]=tt,this}getX(_){let _e=this.array[_*this.itemSize];return this.normalized&&(_e=denormalize(_e,this.array)),_e}setX(_,_e){return this.normalized&&(_e=normalize$5(_e,this.array)),this.array[_*this.itemSize]=_e,this}getY(_){let _e=this.array[_*this.itemSize+1];return this.normalized&&(_e=denormalize(_e,this.array)),_e}setY(_,_e){return this.normalized&&(_e=normalize$5(_e,this.array)),this.array[_*this.itemSize+1]=_e,this}getZ(_){let _e=this.array[_*this.itemSize+2];return this.normalized&&(_e=denormalize(_e,this.array)),_e}setZ(_,_e){return this.normalized&&(_e=normalize$5(_e,this.array)),this.array[_*this.itemSize+2]=_e,this}getW(_){let _e=this.array[_*this.itemSize+3];return this.normalized&&(_e=denormalize(_e,this.array)),_e}setW(_,_e){return this.normalized&&(_e=normalize$5(_e,this.array)),this.array[_*this.itemSize+3]=_e,this}setXY(_,_e,tt){return _*=this.itemSize,this.normalized&&(_e=normalize$5(_e,this.array),tt=normalize$5(tt,this.array)),this.array[_+0]=_e,this.array[_+1]=tt,this}setXYZ(_,_e,tt,nt){return _*=this.itemSize,this.normalized&&(_e=normalize$5(_e,this.array),tt=normalize$5(tt,this.array),nt=normalize$5(nt,this.array)),this.array[_+0]=_e,this.array[_+1]=tt,this.array[_+2]=nt,this}setXYZW(_,_e,tt,nt,rt){return _*=this.itemSize,this.normalized&&(_e=normalize$5(_e,this.array),tt=normalize$5(tt,this.array),nt=normalize$5(nt,this.array),rt=normalize$5(rt,this.array)),this.array[_+0]=_e,this.array[_+1]=tt,this.array[_+2]=nt,this.array[_+3]=rt,this}onUpload(_){return this.onUploadCallback=_,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const _={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(_.name=this.name),this.usage!==StaticDrawUsage&&(_.usage=this.usage),_}}class Int8BufferAttribute extends BufferAttribute{constructor(_,_e,tt){super(new Int8Array(_),_e,tt)}}class Uint8BufferAttribute extends BufferAttribute{constructor(_,_e,tt){super(new Uint8Array(_),_e,tt)}}class Uint8ClampedBufferAttribute extends BufferAttribute{constructor(_,_e,tt){super(new Uint8ClampedArray(_),_e,tt)}}class Int16BufferAttribute extends BufferAttribute{constructor(_,_e,tt){super(new Int16Array(_),_e,tt)}}class Uint16BufferAttribute extends BufferAttribute{constructor(_,_e,tt){super(new Uint16Array(_),_e,tt)}}class Int32BufferAttribute extends BufferAttribute{constructor(_,_e,tt){super(new Int32Array(_),_e,tt)}}class Uint32BufferAttribute extends BufferAttribute{constructor(_,_e,tt){super(new Uint32Array(_),_e,tt)}}class Float16BufferAttribute extends BufferAttribute{constructor(_,_e,tt){super(new Uint16Array(_),_e,tt),this.isFloat16BufferAttribute=!0}getX(_){let _e=fromHalfFloat(this.array[_*this.itemSize]);return this.normalized&&(_e=denormalize(_e,this.array)),_e}setX(_,_e){return this.normalized&&(_e=normalize$5(_e,this.array)),this.array[_*this.itemSize]=toHalfFloat(_e),this}getY(_){let _e=fromHalfFloat(this.array[_*this.itemSize+1]);return this.normalized&&(_e=denormalize(_e,this.array)),_e}setY(_,_e){return this.normalized&&(_e=normalize$5(_e,this.array)),this.array[_*this.itemSize+1]=toHalfFloat(_e),this}getZ(_){let _e=fromHalfFloat(this.array[_*this.itemSize+2]);return this.normalized&&(_e=denormalize(_e,this.array)),_e}setZ(_,_e){return this.normalized&&(_e=normalize$5(_e,this.array)),this.array[_*this.itemSize+2]=toHalfFloat(_e),this}getW(_){let _e=fromHalfFloat(this.array[_*this.itemSize+3]);return this.normalized&&(_e=denormalize(_e,this.array)),_e}setW(_,_e){return this.normalized&&(_e=normalize$5(_e,this.array)),this.array[_*this.itemSize+3]=toHalfFloat(_e),this}setXY(_,_e,tt){return _*=this.itemSize,this.normalized&&(_e=normalize$5(_e,this.array),tt=normalize$5(tt,this.array)),this.array[_+0]=toHalfFloat(_e),this.array[_+1]=toHalfFloat(tt),this}setXYZ(_,_e,tt,nt){return _*=this.itemSize,this.normalized&&(_e=normalize$5(_e,this.array),tt=normalize$5(tt,this.array),nt=normalize$5(nt,this.array)),this.array[_+0]=toHalfFloat(_e),this.array[_+1]=toHalfFloat(tt),this.array[_+2]=toHalfFloat(nt),this}setXYZW(_,_e,tt,nt,rt){return _*=this.itemSize,this.normalized&&(_e=normalize$5(_e,this.array),tt=normalize$5(tt,this.array),nt=normalize$5(nt,this.array),rt=normalize$5(rt,this.array)),this.array[_+0]=toHalfFloat(_e),this.array[_+1]=toHalfFloat(tt),this.array[_+2]=toHalfFloat(nt),this.array[_+3]=toHalfFloat(rt),this}}class Float32BufferAttribute extends BufferAttribute{constructor(_,_e,tt){super(new Float32Array(_),_e,tt)}}let _id$2=0;const _m1$2=new Matrix4,_obj=new Object3D,_offset=new Vector3,_box$2=new Box3,_boxMorphTargets=new Box3,_vector$8=new Vector3;class BufferGeometry extends EventDispatcher{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:_id$2++}),this.uuid=generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(_){return Array.isArray(_)?this.index=new(arrayNeedsUint32(_)?Uint32BufferAttribute:Uint16BufferAttribute)(_,1):this.index=_,this}getAttribute(_){return this.attributes[_]}setAttribute(_,_e){return this.attributes[_]=_e,this}deleteAttribute(_){return delete this.attributes[_],this}hasAttribute(_){return this.attributes[_]!==void 0}addGroup(_,_e,tt=0){this.groups.push({start:_,count:_e,materialIndex:tt})}clearGroups(){this.groups=[]}setDrawRange(_,_e){this.drawRange.start=_,this.drawRange.count=_e}applyMatrix4(_){const _e=this.attributes.position;_e!==void 0&&(_e.applyMatrix4(_),_e.needsUpdate=!0);const tt=this.attributes.normal;if(tt!==void 0){const rt=new Matrix3().getNormalMatrix(_);tt.applyNormalMatrix(rt),tt.needsUpdate=!0}const nt=this.attributes.tangent;return nt!==void 0&&(nt.transformDirection(_),nt.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(_){return _m1$2.makeRotationFromQuaternion(_),this.applyMatrix4(_m1$2),this}rotateX(_){return _m1$2.makeRotationX(_),this.applyMatrix4(_m1$2),this}rotateY(_){return _m1$2.makeRotationY(_),this.applyMatrix4(_m1$2),this}rotateZ(_){return _m1$2.makeRotationZ(_),this.applyMatrix4(_m1$2),this}translate(_,_e,tt){return _m1$2.makeTranslation(_,_e,tt),this.applyMatrix4(_m1$2),this}scale(_,_e,tt){return _m1$2.makeScale(_,_e,tt),this.applyMatrix4(_m1$2),this}lookAt(_){return _obj.lookAt(_),_obj.updateMatrix(),this.applyMatrix4(_obj.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(_offset).negate(),this.translate(_offset.x,_offset.y,_offset.z),this}setFromPoints(_){const _e=[];for(let tt=0,nt=_.length;tt<nt;tt++){const rt=_[tt];_e.push(rt.x,rt.y,rt.z||0)}return this.setAttribute("position",new Float32BufferAttribute(_e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Box3);const _=this.attributes.position,_e=this.morphAttributes.position;if(_&&_.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new Vector3(-1/0,-1/0,-1/0),new Vector3(1/0,1/0,1/0));return}if(_!==void 0){if(this.boundingBox.setFromBufferAttribute(_),_e)for(let tt=0,nt=_e.length;tt<nt;tt++){const rt=_e[tt];_box$2.setFromBufferAttribute(rt),this.morphTargetsRelative?(_vector$8.addVectors(this.boundingBox.min,_box$2.min),this.boundingBox.expandByPoint(_vector$8),_vector$8.addVectors(this.boundingBox.max,_box$2.max),this.boundingBox.expandByPoint(_vector$8)):(this.boundingBox.expandByPoint(_box$2.min),this.boundingBox.expandByPoint(_box$2.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Sphere);const _=this.attributes.position,_e=this.morphAttributes.position;if(_&&_.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new Vector3,1/0);return}if(_){const tt=this.boundingSphere.center;if(_box$2.setFromBufferAttribute(_),_e)for(let rt=0,ot=_e.length;rt<ot;rt++){const at=_e[rt];_boxMorphTargets.setFromBufferAttribute(at),this.morphTargetsRelative?(_vector$8.addVectors(_box$2.min,_boxMorphTargets.min),_box$2.expandByPoint(_vector$8),_vector$8.addVectors(_box$2.max,_boxMorphTargets.max),_box$2.expandByPoint(_vector$8)):(_box$2.expandByPoint(_boxMorphTargets.min),_box$2.expandByPoint(_boxMorphTargets.max))}_box$2.getCenter(tt);let nt=0;for(let rt=0,ot=_.count;rt<ot;rt++)_vector$8.fromBufferAttribute(_,rt),nt=Math.max(nt,tt.distanceToSquared(_vector$8));if(_e)for(let rt=0,ot=_e.length;rt<ot;rt++){const at=_e[rt],lt=this.morphTargetsRelative;for(let ut=0,dt=at.count;ut<dt;ut++)_vector$8.fromBufferAttribute(at,ut),lt&&(_offset.fromBufferAttribute(_,ut),_vector$8.add(_offset)),nt=Math.max(nt,tt.distanceToSquared(_vector$8))}this.boundingSphere.radius=Math.sqrt(nt),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const _=this.index,_e=this.attributes;if(_===null||_e.position===void 0||_e.normal===void 0||_e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const tt=_e.position,nt=_e.normal,rt=_e.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new BufferAttribute(new Float32Array(4*tt.count),4));const ot=this.getAttribute("tangent"),at=[],lt=[];for(let At=0;At<tt.count;At++)at[At]=new Vector3,lt[At]=new Vector3;const ut=new Vector3,dt=new Vector3,st=new Vector3,it=new Vector2,ct=new Vector2,ft=new Vector2,ht=new Vector3,mt=new Vector3;function pt(At,St,Tt){ut.fromBufferAttribute(tt,At),dt.fromBufferAttribute(tt,St),st.fromBufferAttribute(tt,Tt),it.fromBufferAttribute(rt,At),ct.fromBufferAttribute(rt,St),ft.fromBufferAttribute(rt,Tt),dt.sub(ut),st.sub(ut),ct.sub(it),ft.sub(it);const Ct=1/(ct.x*ft.y-ft.x*ct.y);isFinite(Ct)&&(ht.copy(dt).multiplyScalar(ft.y).addScaledVector(st,-ct.y).multiplyScalar(Ct),mt.copy(st).multiplyScalar(ct.x).addScaledVector(dt,-ft.x).multiplyScalar(Ct),at[At].add(ht),at[St].add(ht),at[Tt].add(ht),lt[At].add(mt),lt[St].add(mt),lt[Tt].add(mt))}let _t=this.groups;_t.length===0&&(_t=[{start:0,count:_.count}]);for(let At=0,St=_t.length;At<St;++At){const Tt=_t[At],Ct=Tt.start,It=Tt.count;for(let $t=Ct,Nt=Ct+It;$t<Nt;$t+=3)pt(_.getX($t+0),_.getX($t+1),_.getX($t+2))}const vt=new Vector3,bt=new Vector3,wt=new Vector3,xt=new Vector3;function Mt(At){wt.fromBufferAttribute(nt,At),xt.copy(wt);const St=at[At];vt.copy(St),vt.sub(wt.multiplyScalar(wt.dot(St))).normalize(),bt.crossVectors(xt,St);const Ct=bt.dot(lt[At])<0?-1:1;ot.setXYZW(At,vt.x,vt.y,vt.z,Ct)}for(let At=0,St=_t.length;At<St;++At){const Tt=_t[At],Ct=Tt.start,It=Tt.count;for(let $t=Ct,Nt=Ct+It;$t<Nt;$t+=3)Mt(_.getX($t+0)),Mt(_.getX($t+1)),Mt(_.getX($t+2))}}computeVertexNormals(){const _=this.index,_e=this.getAttribute("position");if(_e!==void 0){let tt=this.getAttribute("normal");if(tt===void 0)tt=new BufferAttribute(new Float32Array(_e.count*3),3),this.setAttribute("normal",tt);else for(let it=0,ct=tt.count;it<ct;it++)tt.setXYZ(it,0,0,0);const nt=new Vector3,rt=new Vector3,ot=new Vector3,at=new Vector3,lt=new Vector3,ut=new Vector3,dt=new Vector3,st=new Vector3;if(_)for(let it=0,ct=_.count;it<ct;it+=3){const ft=_.getX(it+0),ht=_.getX(it+1),mt=_.getX(it+2);nt.fromBufferAttribute(_e,ft),rt.fromBufferAttribute(_e,ht),ot.fromBufferAttribute(_e,mt),dt.subVectors(ot,rt),st.subVectors(nt,rt),dt.cross(st),at.fromBufferAttribute(tt,ft),lt.fromBufferAttribute(tt,ht),ut.fromBufferAttribute(tt,mt),at.add(dt),lt.add(dt),ut.add(dt),tt.setXYZ(ft,at.x,at.y,at.z),tt.setXYZ(ht,lt.x,lt.y,lt.z),tt.setXYZ(mt,ut.x,ut.y,ut.z)}else for(let it=0,ct=_e.count;it<ct;it+=3)nt.fromBufferAttribute(_e,it+0),rt.fromBufferAttribute(_e,it+1),ot.fromBufferAttribute(_e,it+2),dt.subVectors(ot,rt),st.subVectors(nt,rt),dt.cross(st),tt.setXYZ(it+0,dt.x,dt.y,dt.z),tt.setXYZ(it+1,dt.x,dt.y,dt.z),tt.setXYZ(it+2,dt.x,dt.y,dt.z);this.normalizeNormals(),tt.needsUpdate=!0}}normalizeNormals(){const _=this.attributes.normal;for(let _e=0,tt=_.count;_e<tt;_e++)_vector$8.fromBufferAttribute(_,_e),_vector$8.normalize(),_.setXYZ(_e,_vector$8.x,_vector$8.y,_vector$8.z)}toNonIndexed(){function _(at,lt){const ut=at.array,dt=at.itemSize,st=at.normalized,it=new ut.constructor(lt.length*dt);let ct=0,ft=0;for(let ht=0,mt=lt.length;ht<mt;ht++){at.isInterleavedBufferAttribute?ct=lt[ht]*at.data.stride+at.offset:ct=lt[ht]*dt;for(let pt=0;pt<dt;pt++)it[ft++]=ut[ct++]}return new BufferAttribute(it,dt,st)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const _e=new BufferGeometry,tt=this.index.array,nt=this.attributes;for(const at in nt){const lt=nt[at],ut=_(lt,tt);_e.setAttribute(at,ut)}const rt=this.morphAttributes;for(const at in rt){const lt=[],ut=rt[at];for(let dt=0,st=ut.length;dt<st;dt++){const it=ut[dt],ct=_(it,tt);lt.push(ct)}_e.morphAttributes[at]=lt}_e.morphTargetsRelative=this.morphTargetsRelative;const ot=this.groups;for(let at=0,lt=ot.length;at<lt;at++){const ut=ot[at];_e.addGroup(ut.start,ut.count,ut.materialIndex)}return _e}toJSON(){const _={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(_.uuid=this.uuid,_.type=this.type,this.name!==""&&(_.name=this.name),Object.keys(this.userData).length>0&&(_.userData=this.userData),this.parameters!==void 0){const lt=this.parameters;for(const ut in lt)lt[ut]!==void 0&&(_[ut]=lt[ut]);return _}_.data={attributes:{}};const _e=this.index;_e!==null&&(_.data.index={type:_e.array.constructor.name,array:Array.prototype.slice.call(_e.array)});const tt=this.attributes;for(const lt in tt){const ut=tt[lt];_.data.attributes[lt]=ut.toJSON(_.data)}const nt={};let rt=!1;for(const lt in this.morphAttributes){const ut=this.morphAttributes[lt],dt=[];for(let st=0,it=ut.length;st<it;st++){const ct=ut[st];dt.push(ct.toJSON(_.data))}dt.length>0&&(nt[lt]=dt,rt=!0)}rt&&(_.data.morphAttributes=nt,_.data.morphTargetsRelative=this.morphTargetsRelative);const ot=this.groups;ot.length>0&&(_.data.groups=JSON.parse(JSON.stringify(ot)));const at=this.boundingSphere;return at!==null&&(_.data.boundingSphere={center:at.center.toArray(),radius:at.radius}),_}clone(){return new this.constructor().copy(this)}copy(_){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const _e={};this.name=_.name;const tt=_.index;tt!==null&&this.setIndex(tt.clone(_e));const nt=_.attributes;for(const ut in nt){const dt=nt[ut];this.setAttribute(ut,dt.clone(_e))}const rt=_.morphAttributes;for(const ut in rt){const dt=[],st=rt[ut];for(let it=0,ct=st.length;it<ct;it++)dt.push(st[it].clone(_e));this.morphAttributes[ut]=dt}this.morphTargetsRelative=_.morphTargetsRelative;const ot=_.groups;for(let ut=0,dt=ot.length;ut<dt;ut++){const st=ot[ut];this.addGroup(st.start,st.count,st.materialIndex)}const at=_.boundingBox;at!==null&&(this.boundingBox=at.clone());const lt=_.boundingSphere;return lt!==null&&(this.boundingSphere=lt.clone()),this.drawRange.start=_.drawRange.start,this.drawRange.count=_.drawRange.count,this.userData=_.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const _inverseMatrix$3=new Matrix4,_ray$3=new Ray,_sphere$6=new Sphere,_sphereHitAt=new Vector3,_vA$1=new Vector3,_vB$1=new Vector3,_vC$1=new Vector3,_tempA=new Vector3,_morphA=new Vector3,_uvA$1=new Vector2,_uvB$1=new Vector2,_uvC$1=new Vector2,_normalA=new Vector3,_normalB=new Vector3,_normalC=new Vector3,_intersectionPoint=new Vector3,_intersectionPointWorld=new Vector3;class Mesh extends Object3D{constructor(_=new BufferGeometry,_e=new MeshBasicMaterial){super(),this.isMesh=!0,this.type="Mesh",this.geometry=_,this.material=_e,this.updateMorphTargets()}copy(_,_e){return super.copy(_,_e),_.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=_.morphTargetInfluences.slice()),_.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},_.morphTargetDictionary)),this.material=Array.isArray(_.material)?_.material.slice():_.material,this.geometry=_.geometry,this}updateMorphTargets(){const _e=this.geometry.morphAttributes,tt=Object.keys(_e);if(tt.length>0){const nt=_e[tt[0]];if(nt!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let rt=0,ot=nt.length;rt<ot;rt++){const at=nt[rt].name||String(rt);this.morphTargetInfluences.push(0),this.morphTargetDictionary[at]=rt}}}}getVertexPosition(_,_e){const tt=this.geometry,nt=tt.attributes.position,rt=tt.morphAttributes.position,ot=tt.morphTargetsRelative;_e.fromBufferAttribute(nt,_);const at=this.morphTargetInfluences;if(rt&&at){_morphA.set(0,0,0);for(let lt=0,ut=rt.length;lt<ut;lt++){const dt=at[lt],st=rt[lt];dt!==0&&(_tempA.fromBufferAttribute(st,_),ot?_morphA.addScaledVector(_tempA,dt):_morphA.addScaledVector(_tempA.sub(_e),dt))}_e.add(_morphA)}return _e}raycast(_,_e){const tt=this.geometry,nt=this.material,rt=this.matrixWorld;nt!==void 0&&(tt.boundingSphere===null&&tt.computeBoundingSphere(),_sphere$6.copy(tt.boundingSphere),_sphere$6.applyMatrix4(rt),_ray$3.copy(_.ray).recast(_.near),!(_sphere$6.containsPoint(_ray$3.origin)===!1&&(_ray$3.intersectSphere(_sphere$6,_sphereHitAt)===null||_ray$3.origin.distanceToSquared(_sphereHitAt)>(_.far-_.near)**2))&&(_inverseMatrix$3.copy(rt).invert(),_ray$3.copy(_.ray).applyMatrix4(_inverseMatrix$3),!(tt.boundingBox!==null&&_ray$3.intersectsBox(tt.boundingBox)===!1)&&this._computeIntersections(_,_e,_ray$3)))}_computeIntersections(_,_e,tt){let nt;const rt=this.geometry,ot=this.material,at=rt.index,lt=rt.attributes.position,ut=rt.attributes.uv,dt=rt.attributes.uv1,st=rt.attributes.normal,it=rt.groups,ct=rt.drawRange;if(at!==null)if(Array.isArray(ot))for(let ft=0,ht=it.length;ft<ht;ft++){const mt=it[ft],pt=ot[mt.materialIndex],_t=Math.max(mt.start,ct.start),vt=Math.min(at.count,Math.min(mt.start+mt.count,ct.start+ct.count));for(let bt=_t,wt=vt;bt<wt;bt+=3){const xt=at.getX(bt),Mt=at.getX(bt+1),At=at.getX(bt+2);nt=checkGeometryIntersection(this,pt,_,tt,ut,dt,st,xt,Mt,At),nt&&(nt.faceIndex=Math.floor(bt/3),nt.face.materialIndex=mt.materialIndex,_e.push(nt))}}else{const ft=Math.max(0,ct.start),ht=Math.min(at.count,ct.start+ct.count);for(let mt=ft,pt=ht;mt<pt;mt+=3){const _t=at.getX(mt),vt=at.getX(mt+1),bt=at.getX(mt+2);nt=checkGeometryIntersection(this,ot,_,tt,ut,dt,st,_t,vt,bt),nt&&(nt.faceIndex=Math.floor(mt/3),_e.push(nt))}}else if(lt!==void 0)if(Array.isArray(ot))for(let ft=0,ht=it.length;ft<ht;ft++){const mt=it[ft],pt=ot[mt.materialIndex],_t=Math.max(mt.start,ct.start),vt=Math.min(lt.count,Math.min(mt.start+mt.count,ct.start+ct.count));for(let bt=_t,wt=vt;bt<wt;bt+=3){const xt=bt,Mt=bt+1,At=bt+2;nt=checkGeometryIntersection(this,pt,_,tt,ut,dt,st,xt,Mt,At),nt&&(nt.faceIndex=Math.floor(bt/3),nt.face.materialIndex=mt.materialIndex,_e.push(nt))}}else{const ft=Math.max(0,ct.start),ht=Math.min(lt.count,ct.start+ct.count);for(let mt=ft,pt=ht;mt<pt;mt+=3){const _t=mt,vt=mt+1,bt=mt+2;nt=checkGeometryIntersection(this,ot,_,tt,ut,dt,st,_t,vt,bt),nt&&(nt.faceIndex=Math.floor(mt/3),_e.push(nt))}}}}function checkIntersection$1(et,_,_e,tt,nt,rt,ot,at){let lt;if(_.side===BackSide?lt=tt.intersectTriangle(ot,rt,nt,!0,at):lt=tt.intersectTriangle(nt,rt,ot,_.side===FrontSide,at),lt===null)return null;_intersectionPointWorld.copy(at),_intersectionPointWorld.applyMatrix4(et.matrixWorld);const ut=_e.ray.origin.distanceTo(_intersectionPointWorld);return ut<_e.near||ut>_e.far?null:{distance:ut,point:_intersectionPointWorld.clone(),object:et}}function checkGeometryIntersection(et,_,_e,tt,nt,rt,ot,at,lt,ut){et.getVertexPosition(at,_vA$1),et.getVertexPosition(lt,_vB$1),et.getVertexPosition(ut,_vC$1);const dt=checkIntersection$1(et,_,_e,tt,_vA$1,_vB$1,_vC$1,_intersectionPoint);if(dt){nt&&(_uvA$1.fromBufferAttribute(nt,at),_uvB$1.fromBufferAttribute(nt,lt),_uvC$1.fromBufferAttribute(nt,ut),dt.uv=Triangle.getInterpolation(_intersectionPoint,_vA$1,_vB$1,_vC$1,_uvA$1,_uvB$1,_uvC$1,new Vector2)),rt&&(_uvA$1.fromBufferAttribute(rt,at),_uvB$1.fromBufferAttribute(rt,lt),_uvC$1.fromBufferAttribute(rt,ut),dt.uv1=Triangle.getInterpolation(_intersectionPoint,_vA$1,_vB$1,_vC$1,_uvA$1,_uvB$1,_uvC$1,new Vector2)),ot&&(_normalA.fromBufferAttribute(ot,at),_normalB.fromBufferAttribute(ot,lt),_normalC.fromBufferAttribute(ot,ut),dt.normal=Triangle.getInterpolation(_intersectionPoint,_vA$1,_vB$1,_vC$1,_normalA,_normalB,_normalC,new Vector3),dt.normal.dot(tt.direction)>0&&dt.normal.multiplyScalar(-1));const st={a:at,b:lt,c:ut,normal:new Vector3,materialIndex:0};Triangle.getNormal(_vA$1,_vB$1,_vC$1,st.normal),dt.face=st}return dt}class BoxGeometry extends BufferGeometry{constructor(_=1,_e=1,tt=1,nt=1,rt=1,ot=1){super(),this.type="BoxGeometry",this.parameters={width:_,height:_e,depth:tt,widthSegments:nt,heightSegments:rt,depthSegments:ot};const at=this;nt=Math.floor(nt),rt=Math.floor(rt),ot=Math.floor(ot);const lt=[],ut=[],dt=[],st=[];let it=0,ct=0;ft("z","y","x",-1,-1,tt,_e,_,ot,rt,0),ft("z","y","x",1,-1,tt,_e,-_,ot,rt,1),ft("x","z","y",1,1,_,tt,_e,nt,ot,2),ft("x","z","y",1,-1,_,tt,-_e,nt,ot,3),ft("x","y","z",1,-1,_,_e,tt,nt,rt,4),ft("x","y","z",-1,-1,_,_e,-tt,nt,rt,5),this.setIndex(lt),this.setAttribute("position",new Float32BufferAttribute(ut,3)),this.setAttribute("normal",new Float32BufferAttribute(dt,3)),this.setAttribute("uv",new Float32BufferAttribute(st,2));function ft(ht,mt,pt,_t,vt,bt,wt,xt,Mt,At,St){const Tt=bt/Mt,Ct=wt/At,It=bt/2,$t=wt/2,Nt=xt/2,Bt=Mt+1,Ot=At+1;let Ut=0,Lt=0;const zt=new Vector3;for(let Yt=0;Yt<Ot;Yt++){const en=Yt*Ct-$t;for(let bn=0;bn<Bt;bn++){const Un=bn*Tt-It;zt[ht]=Un*_t,zt[mt]=en*vt,zt[pt]=Nt,ut.push(zt.x,zt.y,zt.z),zt[ht]=0,zt[mt]=0,zt[pt]=xt>0?1:-1,dt.push(zt.x,zt.y,zt.z),st.push(bn/Mt),st.push(1-Yt/At),Ut+=1}}for(let Yt=0;Yt<At;Yt++)for(let en=0;en<Mt;en++){const bn=it+en+Bt*Yt,Un=it+en+Bt*(Yt+1),mn=it+(en+1)+Bt*(Yt+1),vn=it+(en+1)+Bt*Yt;lt.push(bn,Un,vn),lt.push(Un,mn,vn),Lt+=6}at.addGroup(ct,Lt,St),ct+=Lt,it+=Ut}}copy(_){return super.copy(_),this.parameters=Object.assign({},_.parameters),this}static fromJSON(_){return new BoxGeometry(_.width,_.height,_.depth,_.widthSegments,_.heightSegments,_.depthSegments)}}function cloneUniforms(et){const _={};for(const _e in et){_[_e]={};for(const tt in et[_e]){const nt=et[_e][tt];nt&&(nt.isColor||nt.isMatrix3||nt.isMatrix4||nt.isVector2||nt.isVector3||nt.isVector4||nt.isTexture||nt.isQuaternion)?nt.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),_[_e][tt]=null):_[_e][tt]=nt.clone():Array.isArray(nt)?_[_e][tt]=nt.slice():_[_e][tt]=nt}}return _}function mergeUniforms(et){const _={};for(let _e=0;_e<et.length;_e++){const tt=cloneUniforms(et[_e]);for(const nt in tt)_[nt]=tt[nt]}return _}function cloneUniformsGroups(et){const _=[];for(let _e=0;_e<et.length;_e++)_.push(et[_e].clone());return _}function getUnlitUniformColorSpace(et){const _=et.getRenderTarget();return _===null?et.outputColorSpace:_.isXRRenderTarget===!0?_.texture.colorSpace:ColorManagement.workingColorSpace}const UniformsUtils={clone:cloneUniforms,merge:mergeUniforms};var default_vertex=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,default_fragment=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class ShaderMaterial extends Material{constructor(_){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=default_vertex,this.fragmentShader=default_fragment,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,_!==void 0&&this.setValues(_)}copy(_){return super.copy(_),this.fragmentShader=_.fragmentShader,this.vertexShader=_.vertexShader,this.uniforms=cloneUniforms(_.uniforms),this.uniformsGroups=cloneUniformsGroups(_.uniformsGroups),this.defines=Object.assign({},_.defines),this.wireframe=_.wireframe,this.wireframeLinewidth=_.wireframeLinewidth,this.fog=_.fog,this.lights=_.lights,this.clipping=_.clipping,this.extensions=Object.assign({},_.extensions),this.glslVersion=_.glslVersion,this}toJSON(_){const _e=super.toJSON(_);_e.glslVersion=this.glslVersion,_e.uniforms={};for(const nt in this.uniforms){const ot=this.uniforms[nt].value;ot&&ot.isTexture?_e.uniforms[nt]={type:"t",value:ot.toJSON(_).uuid}:ot&&ot.isColor?_e.uniforms[nt]={type:"c",value:ot.getHex()}:ot&&ot.isVector2?_e.uniforms[nt]={type:"v2",value:ot.toArray()}:ot&&ot.isVector3?_e.uniforms[nt]={type:"v3",value:ot.toArray()}:ot&&ot.isVector4?_e.uniforms[nt]={type:"v4",value:ot.toArray()}:ot&&ot.isMatrix3?_e.uniforms[nt]={type:"m3",value:ot.toArray()}:ot&&ot.isMatrix4?_e.uniforms[nt]={type:"m4",value:ot.toArray()}:_e.uniforms[nt]={value:ot}}Object.keys(this.defines).length>0&&(_e.defines=this.defines),_e.vertexShader=this.vertexShader,_e.fragmentShader=this.fragmentShader,_e.lights=this.lights,_e.clipping=this.clipping;const tt={};for(const nt in this.extensions)this.extensions[nt]===!0&&(tt[nt]=!0);return Object.keys(tt).length>0&&(_e.extensions=tt),_e}}class Camera extends Object3D{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Matrix4,this.projectionMatrix=new Matrix4,this.projectionMatrixInverse=new Matrix4,this.coordinateSystem=WebGLCoordinateSystem}copy(_,_e){return super.copy(_,_e),this.matrixWorldInverse.copy(_.matrixWorldInverse),this.projectionMatrix.copy(_.projectionMatrix),this.projectionMatrixInverse.copy(_.projectionMatrixInverse),this.coordinateSystem=_.coordinateSystem,this}getWorldDirection(_){return super.getWorldDirection(_).negate()}updateMatrixWorld(_){super.updateMatrixWorld(_),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(_,_e){super.updateWorldMatrix(_,_e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const _v3$1=new Vector3,_minTarget=new Vector2,_maxTarget=new Vector2;class PerspectiveCamera extends Camera{constructor(_=50,_e=1,tt=.1,nt=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=_,this.zoom=1,this.near=tt,this.far=nt,this.focus=10,this.aspect=_e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(_,_e){return super.copy(_,_e),this.fov=_.fov,this.zoom=_.zoom,this.near=_.near,this.far=_.far,this.focus=_.focus,this.aspect=_.aspect,this.view=_.view===null?null:Object.assign({},_.view),this.filmGauge=_.filmGauge,this.filmOffset=_.filmOffset,this}setFocalLength(_){const _e=.5*this.getFilmHeight()/_;this.fov=RAD2DEG*2*Math.atan(_e),this.updateProjectionMatrix()}getFocalLength(){const _=Math.tan(DEG2RAD*.5*this.fov);return .5*this.getFilmHeight()/_}getEffectiveFOV(){return RAD2DEG*2*Math.atan(Math.tan(DEG2RAD*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(_,_e,tt){_v3$1.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),_e.set(_v3$1.x,_v3$1.y).multiplyScalar(-_/_v3$1.z),_v3$1.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),tt.set(_v3$1.x,_v3$1.y).multiplyScalar(-_/_v3$1.z)}getViewSize(_,_e){return this.getViewBounds(_,_minTarget,_maxTarget),_e.subVectors(_maxTarget,_minTarget)}setViewOffset(_,_e,tt,nt,rt,ot){this.aspect=_/_e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=_,this.view.fullHeight=_e,this.view.offsetX=tt,this.view.offsetY=nt,this.view.width=rt,this.view.height=ot,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const _=this.near;let _e=_*Math.tan(DEG2RAD*.5*this.fov)/this.zoom,tt=2*_e,nt=this.aspect*tt,rt=-.5*nt;const ot=this.view;if(this.view!==null&&this.view.enabled){const lt=ot.fullWidth,ut=ot.fullHeight;rt+=ot.offsetX*nt/lt,_e-=ot.offsetY*tt/ut,nt*=ot.width/lt,tt*=ot.height/ut}const at=this.filmOffset;at!==0&&(rt+=_*at/this.getFilmWidth()),this.projectionMatrix.makePerspective(rt,rt+nt,_e,_e-tt,_,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(_){const _e=super.toJSON(_);return _e.object.fov=this.fov,_e.object.zoom=this.zoom,_e.object.near=this.near,_e.object.far=this.far,_e.object.focus=this.focus,_e.object.aspect=this.aspect,this.view!==null&&(_e.object.view=Object.assign({},this.view)),_e.object.filmGauge=this.filmGauge,_e.object.filmOffset=this.filmOffset,_e}}const fov=-90,aspect=1;class CubeCamera extends Object3D{constructor(_,_e,tt){super(),this.type="CubeCamera",this.renderTarget=tt,this.coordinateSystem=null,this.activeMipmapLevel=0;const nt=new PerspectiveCamera(fov,aspect,_,_e);nt.layers=this.layers,this.add(nt);const rt=new PerspectiveCamera(fov,aspect,_,_e);rt.layers=this.layers,this.add(rt);const ot=new PerspectiveCamera(fov,aspect,_,_e);ot.layers=this.layers,this.add(ot);const at=new PerspectiveCamera(fov,aspect,_,_e);at.layers=this.layers,this.add(at);const lt=new PerspectiveCamera(fov,aspect,_,_e);lt.layers=this.layers,this.add(lt);const ut=new PerspectiveCamera(fov,aspect,_,_e);ut.layers=this.layers,this.add(ut)}updateCoordinateSystem(){const _=this.coordinateSystem,_e=this.children.concat(),[tt,nt,rt,ot,at,lt]=_e;for(const ut of _e)this.remove(ut);if(_===WebGLCoordinateSystem)tt.up.set(0,1,0),tt.lookAt(1,0,0),nt.up.set(0,1,0),nt.lookAt(-1,0,0),rt.up.set(0,0,-1),rt.lookAt(0,1,0),ot.up.set(0,0,1),ot.lookAt(0,-1,0),at.up.set(0,1,0),at.lookAt(0,0,1),lt.up.set(0,1,0),lt.lookAt(0,0,-1);else if(_===WebGPUCoordinateSystem)tt.up.set(0,-1,0),tt.lookAt(-1,0,0),nt.up.set(0,-1,0),nt.lookAt(1,0,0),rt.up.set(0,0,1),rt.lookAt(0,1,0),ot.up.set(0,0,-1),ot.lookAt(0,-1,0),at.up.set(0,-1,0),at.lookAt(0,0,1),lt.up.set(0,-1,0),lt.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+_);for(const ut of _e)this.add(ut),ut.updateMatrixWorld()}update(_,_e){this.parent===null&&this.updateMatrixWorld();const{renderTarget:tt,activeMipmapLevel:nt}=this;this.coordinateSystem!==_.coordinateSystem&&(this.coordinateSystem=_.coordinateSystem,this.updateCoordinateSystem());const[rt,ot,at,lt,ut,dt]=this.children,st=_.getRenderTarget(),it=_.getActiveCubeFace(),ct=_.getActiveMipmapLevel(),ft=_.xr.enabled;_.xr.enabled=!1;const ht=tt.texture.generateMipmaps;tt.texture.generateMipmaps=!1,_.setRenderTarget(tt,0,nt),_.render(_e,rt),_.setRenderTarget(tt,1,nt),_.render(_e,ot),_.setRenderTarget(tt,2,nt),_.render(_e,at),_.setRenderTarget(tt,3,nt),_.render(_e,lt),_.setRenderTarget(tt,4,nt),_.render(_e,ut),tt.texture.generateMipmaps=ht,_.setRenderTarget(tt,5,nt),_.render(_e,dt),_.setRenderTarget(st,it,ct),_.xr.enabled=ft,tt.texture.needsPMREMUpdate=!0}}class CubeTexture extends Texture{constructor(_,_e,tt,nt,rt,ot,at,lt,ut,dt){_=_!==void 0?_:[],_e=_e!==void 0?_e:CubeReflectionMapping,super(_,_e,tt,nt,rt,ot,at,lt,ut,dt),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(_){this.image=_}}class WebGLCubeRenderTarget extends WebGLRenderTarget{constructor(_=1,_e={}){super(_,_,_e),this.isWebGLCubeRenderTarget=!0;const tt={width:_,height:_,depth:1},nt=[tt,tt,tt,tt,tt,tt];this.texture=new CubeTexture(nt,_e.mapping,_e.wrapS,_e.wrapT,_e.magFilter,_e.minFilter,_e.format,_e.type,_e.anisotropy,_e.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=_e.generateMipmaps!==void 0?_e.generateMipmaps:!1,this.texture.minFilter=_e.minFilter!==void 0?_e.minFilter:LinearFilter}fromEquirectangularTexture(_,_e){this.texture.type=_e.type,this.texture.colorSpace=_e.colorSpace,this.texture.generateMipmaps=_e.generateMipmaps,this.texture.minFilter=_e.minFilter,this.texture.magFilter=_e.magFilter;const tt={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},nt=new BoxGeometry(5,5,5),rt=new ShaderMaterial({name:"CubemapFromEquirect",uniforms:cloneUniforms(tt.uniforms),vertexShader:tt.vertexShader,fragmentShader:tt.fragmentShader,side:BackSide,blending:NoBlending});rt.uniforms.tEquirect.value=_e;const ot=new Mesh(nt,rt),at=_e.minFilter;return _e.minFilter===LinearMipmapLinearFilter&&(_e.minFilter=LinearFilter),new CubeCamera(1,10,this).update(_,ot),_e.minFilter=at,ot.geometry.dispose(),ot.material.dispose(),this}clear(_,_e,tt,nt){const rt=_.getRenderTarget();for(let ot=0;ot<6;ot++)_.setRenderTarget(this,ot),_.clear(_e,tt,nt);_.setRenderTarget(rt)}}const _vector1=new Vector3,_vector2=new Vector3,_normalMatrix=new Matrix3;class Plane{constructor(_=new Vector3(1,0,0),_e=0){this.isPlane=!0,this.normal=_,this.constant=_e}set(_,_e){return this.normal.copy(_),this.constant=_e,this}setComponents(_,_e,tt,nt){return this.normal.set(_,_e,tt),this.constant=nt,this}setFromNormalAndCoplanarPoint(_,_e){return this.normal.copy(_),this.constant=-_e.dot(this.normal),this}setFromCoplanarPoints(_,_e,tt){const nt=_vector1.subVectors(tt,_e).cross(_vector2.subVectors(_,_e)).normalize();return this.setFromNormalAndCoplanarPoint(nt,_),this}copy(_){return this.normal.copy(_.normal),this.constant=_.constant,this}normalize(){const _=1/this.normal.length();return this.normal.multiplyScalar(_),this.constant*=_,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(_){return this.normal.dot(_)+this.constant}distanceToSphere(_){return this.distanceToPoint(_.center)-_.radius}projectPoint(_,_e){return _e.copy(_).addScaledVector(this.normal,-this.distanceToPoint(_))}intersectLine(_,_e){const tt=_.delta(_vector1),nt=this.normal.dot(tt);if(nt===0)return this.distanceToPoint(_.start)===0?_e.copy(_.start):null;const rt=-(_.start.dot(this.normal)+this.constant)/nt;return rt<0||rt>1?null:_e.copy(_.start).addScaledVector(tt,rt)}intersectsLine(_){const _e=this.distanceToPoint(_.start),tt=this.distanceToPoint(_.end);return _e<0&&tt>0||tt<0&&_e>0}intersectsBox(_){return _.intersectsPlane(this)}intersectsSphere(_){return _.intersectsPlane(this)}coplanarPoint(_){return _.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(_,_e){const tt=_e||_normalMatrix.getNormalMatrix(_),nt=this.coplanarPoint(_vector1).applyMatrix4(_),rt=this.normal.applyMatrix3(tt).normalize();return this.constant=-nt.dot(rt),this}translate(_){return this.constant-=_.dot(this.normal),this}equals(_){return _.normal.equals(this.normal)&&_.constant===this.constant}clone(){return new this.constructor().copy(this)}}const _sphere$5=new Sphere,_vector$7=new Vector3;class Frustum{constructor(_=new Plane,_e=new Plane,tt=new Plane,nt=new Plane,rt=new Plane,ot=new Plane){this.planes=[_,_e,tt,nt,rt,ot]}set(_,_e,tt,nt,rt,ot){const at=this.planes;return at[0].copy(_),at[1].copy(_e),at[2].copy(tt),at[3].copy(nt),at[4].copy(rt),at[5].copy(ot),this}copy(_){const _e=this.planes;for(let tt=0;tt<6;tt++)_e[tt].copy(_.planes[tt]);return this}setFromProjectionMatrix(_,_e=WebGLCoordinateSystem){const tt=this.planes,nt=_.elements,rt=nt[0],ot=nt[1],at=nt[2],lt=nt[3],ut=nt[4],dt=nt[5],st=nt[6],it=nt[7],ct=nt[8],ft=nt[9],ht=nt[10],mt=nt[11],pt=nt[12],_t=nt[13],vt=nt[14],bt=nt[15];if(tt[0].setComponents(lt-rt,it-ut,mt-ct,bt-pt).normalize(),tt[1].setComponents(lt+rt,it+ut,mt+ct,bt+pt).normalize(),tt[2].setComponents(lt+ot,it+dt,mt+ft,bt+_t).normalize(),tt[3].setComponents(lt-ot,it-dt,mt-ft,bt-_t).normalize(),tt[4].setComponents(lt-at,it-st,mt-ht,bt-vt).normalize(),_e===WebGLCoordinateSystem)tt[5].setComponents(lt+at,it+st,mt+ht,bt+vt).normalize();else if(_e===WebGPUCoordinateSystem)tt[5].setComponents(at,st,ht,vt).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+_e);return this}intersectsObject(_){if(_.boundingSphere!==void 0)_.boundingSphere===null&&_.computeBoundingSphere(),_sphere$5.copy(_.boundingSphere).applyMatrix4(_.matrixWorld);else{const _e=_.geometry;_e.boundingSphere===null&&_e.computeBoundingSphere(),_sphere$5.copy(_e.boundingSphere).applyMatrix4(_.matrixWorld)}return this.intersectsSphere(_sphere$5)}intersectsSprite(_){return _sphere$5.center.set(0,0,0),_sphere$5.radius=.7071067811865476,_sphere$5.applyMatrix4(_.matrixWorld),this.intersectsSphere(_sphere$5)}intersectsSphere(_){const _e=this.planes,tt=_.center,nt=-_.radius;for(let rt=0;rt<6;rt++)if(_e[rt].distanceToPoint(tt)<nt)return!1;return!0}intersectsBox(_){const _e=this.planes;for(let tt=0;tt<6;tt++){const nt=_e[tt];if(_vector$7.x=nt.normal.x>0?_.max.x:_.min.x,_vector$7.y=nt.normal.y>0?_.max.y:_.min.y,_vector$7.z=nt.normal.z>0?_.max.z:_.min.z,nt.distanceToPoint(_vector$7)<0)return!1}return!0}containsPoint(_){const _e=this.planes;for(let tt=0;tt<6;tt++)if(_e[tt].distanceToPoint(_)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function WebGLAnimation(){let et=null,_=!1,_e=null,tt=null;function nt(rt,ot){_e(rt,ot),tt=et.requestAnimationFrame(nt)}return{start:function(){_!==!0&&_e!==null&&(tt=et.requestAnimationFrame(nt),_=!0)},stop:function(){et.cancelAnimationFrame(tt),_=!1},setAnimationLoop:function(rt){_e=rt},setContext:function(rt){et=rt}}}function WebGLAttributes(et){const _=new WeakMap;function _e(at,lt){const ut=at.array,dt=at.usage,st=ut.byteLength,it=et.createBuffer();et.bindBuffer(lt,it),et.bufferData(lt,ut,dt),at.onUploadCallback();let ct;if(ut instanceof Float32Array)ct=et.FLOAT;else if(ut instanceof Uint16Array)at.isFloat16BufferAttribute?ct=et.HALF_FLOAT:ct=et.UNSIGNED_SHORT;else if(ut instanceof Int16Array)ct=et.SHORT;else if(ut instanceof Uint32Array)ct=et.UNSIGNED_INT;else if(ut instanceof Int32Array)ct=et.INT;else if(ut instanceof Int8Array)ct=et.BYTE;else if(ut instanceof Uint8Array)ct=et.UNSIGNED_BYTE;else if(ut instanceof Uint8ClampedArray)ct=et.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+ut);return{buffer:it,type:ct,bytesPerElement:ut.BYTES_PER_ELEMENT,version:at.version,size:st}}function tt(at,lt,ut){const dt=lt.array,st=lt._updateRange,it=lt.updateRanges;if(et.bindBuffer(ut,at),st.count===-1&&it.length===0&&et.bufferSubData(ut,0,dt),it.length!==0){for(let ct=0,ft=it.length;ct<ft;ct++){const ht=it[ct];et.bufferSubData(ut,ht.start*dt.BYTES_PER_ELEMENT,dt,ht.start,ht.count)}lt.clearUpdateRanges()}st.count!==-1&&(et.bufferSubData(ut,st.offset*dt.BYTES_PER_ELEMENT,dt,st.offset,st.count),st.count=-1),lt.onUploadCallback()}function nt(at){return at.isInterleavedBufferAttribute&&(at=at.data),_.get(at)}function rt(at){at.isInterleavedBufferAttribute&&(at=at.data);const lt=_.get(at);lt&&(et.deleteBuffer(lt.buffer),_.delete(at))}function ot(at,lt){if(at.isGLBufferAttribute){const dt=_.get(at);(!dt||dt.version<at.version)&&_.set(at,{buffer:at.buffer,type:at.type,bytesPerElement:at.elementSize,version:at.version});return}at.isInterleavedBufferAttribute&&(at=at.data);const ut=_.get(at);if(ut===void 0)_.set(at,_e(at,lt));else if(ut.version<at.version){if(ut.size!==at.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");tt(ut.buffer,at,lt),ut.version=at.version}}return{get:nt,remove:rt,update:ot}}class PlaneGeometry extends BufferGeometry{constructor(_=1,_e=1,tt=1,nt=1){super(),this.type="PlaneGeometry",this.parameters={width:_,height:_e,widthSegments:tt,heightSegments:nt};const rt=_/2,ot=_e/2,at=Math.floor(tt),lt=Math.floor(nt),ut=at+1,dt=lt+1,st=_/at,it=_e/lt,ct=[],ft=[],ht=[],mt=[];for(let pt=0;pt<dt;pt++){const _t=pt*it-ot;for(let vt=0;vt<ut;vt++){const bt=vt*st-rt;ft.push(bt,-_t,0),ht.push(0,0,1),mt.push(vt/at),mt.push(1-pt/lt)}}for(let pt=0;pt<lt;pt++)for(let _t=0;_t<at;_t++){const vt=_t+ut*pt,bt=_t+ut*(pt+1),wt=_t+1+ut*(pt+1),xt=_t+1+ut*pt;ct.push(vt,bt,xt),ct.push(bt,wt,xt)}this.setIndex(ct),this.setAttribute("position",new Float32BufferAttribute(ft,3)),this.setAttribute("normal",new Float32BufferAttribute(ht,3)),this.setAttribute("uv",new Float32BufferAttribute(mt,2))}copy(_){return super.copy(_),this.parameters=Object.assign({},_.parameters),this}static fromJSON(_){return new PlaneGeometry(_.width,_.height,_.widthSegments,_.heightSegments)}}var alphahash_fragment=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,alphahash_pars_fragment=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,alphamap_fragment=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,alphamap_pars_fragment=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,alphatest_fragment=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,alphatest_pars_fragment=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,aomap_fragment=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,aomap_pars_fragment=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,batching_pars_vertex=`#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,batching_vertex=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,begin_vertex=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,beginnormal_vertex=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,bsdfs=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,iridescence_fragment=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,bumpmap_pars_fragment=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,clipping_planes_fragment=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,clipping_planes_pars_fragment=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,clipping_planes_pars_vertex=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,clipping_planes_vertex=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,color_fragment=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,color_pars_fragment=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,color_pars_vertex=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,color_vertex=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,common=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,cube_uv_reflection_fragment=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,defaultnormal_vertex=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,displacementmap_pars_vertex=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,displacementmap_vertex=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,emissivemap_fragment=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,emissivemap_pars_fragment=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,colorspace_fragment$1="gl_FragColor = linearToOutputTexel( gl_FragColor );",colorspace_pars_fragment=`
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,envmap_fragment=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,envmap_common_pars_fragment=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,envmap_pars_fragment=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,envmap_pars_vertex=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,envmap_vertex=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,fog_vertex=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,fog_pars_vertex=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,fog_fragment=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,fog_pars_fragment=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,gradientmap_pars_fragment=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,lightmap_pars_fragment=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,lights_lambert_fragment=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,lights_lambert_pars_fragment=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,lights_pars_begin=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,envmap_physical_pars_fragment=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,lights_toon_fragment=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,lights_toon_pars_fragment=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,lights_phong_fragment=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,lights_phong_pars_fragment=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,lights_physical_fragment=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,lights_physical_pars_fragment=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,lights_fragment_begin=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,lights_fragment_maps=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,lights_fragment_end=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,logdepthbuf_fragment=`#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,logdepthbuf_pars_fragment=`#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,logdepthbuf_pars_vertex=`#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,logdepthbuf_vertex=`#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,map_fragment=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,map_pars_fragment=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,map_particle_fragment=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,map_particle_pars_fragment=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,metalnessmap_fragment=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,metalnessmap_pars_fragment=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,morphinstance_vertex=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,morphcolor_vertex=`#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,morphnormal_vertex=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,morphtarget_pars_vertex=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,morphtarget_vertex=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,normal_fragment_begin=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,normal_fragment_maps=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,normal_pars_fragment=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,normal_pars_vertex=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,normal_vertex=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,normalmap_pars_fragment=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,clearcoat_normal_fragment_begin=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,clearcoat_normal_fragment_maps=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,clearcoat_pars_fragment=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,iridescence_pars_fragment=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,opaque_fragment=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,packing=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,premultiplied_alpha_fragment=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,project_vertex=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,dithering_fragment=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,dithering_pars_fragment=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,roughnessmap_fragment=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,roughnessmap_pars_fragment=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,shadowmap_pars_fragment=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,shadowmap_pars_vertex=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,shadowmap_vertex=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,shadowmask_pars_fragment=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,skinbase_vertex=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,skinning_pars_vertex=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,skinning_vertex=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,skinnormal_vertex=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,specularmap_fragment=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,specularmap_pars_fragment=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,tonemapping_fragment=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,tonemapping_pars_fragment=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,transmission_fragment=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,transmission_pars_fragment=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,uv_pars_fragment=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,uv_pars_vertex=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,uv_vertex=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,worldpos_vertex=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const vertex$h=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,fragment$h=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$g=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,fragment$g=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$f=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,fragment$f=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$e=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,fragment$e=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,vertex$d=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,fragment$d=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,vertex$c=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,fragment$c=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$b=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,fragment$b=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,vertex$a=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,fragment$a=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$9=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$9=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$8=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,fragment$8=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$7=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,fragment$7=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,vertex$6=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$6=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$5=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,fragment$5=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$4=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$4=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$3=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,fragment$3=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,vertex$2=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$2=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,vertex$1=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,fragment$1=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,ShaderChunk={alphahash_fragment,alphahash_pars_fragment,alphamap_fragment,alphamap_pars_fragment,alphatest_fragment,alphatest_pars_fragment,aomap_fragment,aomap_pars_fragment,batching_pars_vertex,batching_vertex,begin_vertex,beginnormal_vertex,bsdfs,iridescence_fragment,bumpmap_pars_fragment,clipping_planes_fragment,clipping_planes_pars_fragment,clipping_planes_pars_vertex,clipping_planes_vertex,color_fragment,color_pars_fragment,color_pars_vertex,color_vertex,common,cube_uv_reflection_fragment,defaultnormal_vertex,displacementmap_pars_vertex,displacementmap_vertex,emissivemap_fragment,emissivemap_pars_fragment,colorspace_fragment:colorspace_fragment$1,colorspace_pars_fragment,envmap_fragment,envmap_common_pars_fragment,envmap_pars_fragment,envmap_pars_vertex,envmap_physical_pars_fragment,envmap_vertex,fog_vertex,fog_pars_vertex,fog_fragment,fog_pars_fragment,gradientmap_pars_fragment,lightmap_pars_fragment,lights_lambert_fragment,lights_lambert_pars_fragment,lights_pars_begin,lights_toon_fragment,lights_toon_pars_fragment,lights_phong_fragment,lights_phong_pars_fragment,lights_physical_fragment,lights_physical_pars_fragment,lights_fragment_begin,lights_fragment_maps,lights_fragment_end,logdepthbuf_fragment,logdepthbuf_pars_fragment,logdepthbuf_pars_vertex,logdepthbuf_vertex,map_fragment,map_pars_fragment,map_particle_fragment,map_particle_pars_fragment,metalnessmap_fragment,metalnessmap_pars_fragment,morphinstance_vertex,morphcolor_vertex,morphnormal_vertex,morphtarget_pars_vertex,morphtarget_vertex,normal_fragment_begin,normal_fragment_maps,normal_pars_fragment,normal_pars_vertex,normal_vertex,normalmap_pars_fragment,clearcoat_normal_fragment_begin,clearcoat_normal_fragment_maps,clearcoat_pars_fragment,iridescence_pars_fragment,opaque_fragment,packing,premultiplied_alpha_fragment,project_vertex,dithering_fragment,dithering_pars_fragment,roughnessmap_fragment,roughnessmap_pars_fragment,shadowmap_pars_fragment,shadowmap_pars_vertex,shadowmap_vertex,shadowmask_pars_fragment,skinbase_vertex,skinning_pars_vertex,skinning_vertex,skinnormal_vertex,specularmap_fragment,specularmap_pars_fragment,tonemapping_fragment,tonemapping_pars_fragment,transmission_fragment,transmission_pars_fragment,uv_pars_fragment,uv_pars_vertex,uv_vertex,worldpos_vertex,background_vert:vertex$h,background_frag:fragment$h,backgroundCube_vert:vertex$g,backgroundCube_frag:fragment$g,cube_vert:vertex$f,cube_frag:fragment$f,depth_vert:vertex$e,depth_frag:fragment$e,distanceRGBA_vert:vertex$d,distanceRGBA_frag:fragment$d,equirect_vert:vertex$c,equirect_frag:fragment$c,linedashed_vert:vertex$b,linedashed_frag:fragment$b,meshbasic_vert:vertex$a,meshbasic_frag:fragment$a,meshlambert_vert:vertex$9,meshlambert_frag:fragment$9,meshmatcap_vert:vertex$8,meshmatcap_frag:fragment$8,meshnormal_vert:vertex$7,meshnormal_frag:fragment$7,meshphong_vert:vertex$6,meshphong_frag:fragment$6,meshphysical_vert:vertex$5,meshphysical_frag:fragment$5,meshtoon_vert:vertex$4,meshtoon_frag:fragment$4,points_vert:vertex$3,points_frag:fragment$3,shadow_vert:vertex$2,shadow_frag:fragment$2,sprite_vert:vertex$1,sprite_frag:fragment$1},UniformsLib={common:{diffuse:{value:new Color$1(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new Matrix3},alphaMap:{value:null},alphaMapTransform:{value:new Matrix3},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new Matrix3}},envmap:{envMap:{value:null},envMapRotation:{value:new Matrix3},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new Matrix3}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new Matrix3}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new Matrix3},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new Matrix3},normalScale:{value:new Vector2(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new Matrix3},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new Matrix3}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new Matrix3}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new Matrix3}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Color$1(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Color$1(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new Matrix3},alphaTest:{value:0},uvTransform:{value:new Matrix3}},sprite:{diffuse:{value:new Color$1(16777215)},opacity:{value:1},center:{value:new Vector2(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new Matrix3},alphaMap:{value:null},alphaMapTransform:{value:new Matrix3},alphaTest:{value:0}}},ShaderLib={basic:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.fog]),vertexShader:ShaderChunk.meshbasic_vert,fragmentShader:ShaderChunk.meshbasic_frag},lambert:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color$1(0)}}]),vertexShader:ShaderChunk.meshlambert_vert,fragmentShader:ShaderChunk.meshlambert_frag},phong:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color$1(0)},specular:{value:new Color$1(1118481)},shininess:{value:30}}]),vertexShader:ShaderChunk.meshphong_vert,fragmentShader:ShaderChunk.meshphong_frag},standard:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.roughnessmap,UniformsLib.metalnessmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color$1(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag},toon:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.gradientmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color$1(0)}}]),vertexShader:ShaderChunk.meshtoon_vert,fragmentShader:ShaderChunk.meshtoon_frag},matcap:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,{matcap:{value:null}}]),vertexShader:ShaderChunk.meshmatcap_vert,fragmentShader:ShaderChunk.meshmatcap_frag},points:{uniforms:mergeUniforms([UniformsLib.points,UniformsLib.fog]),vertexShader:ShaderChunk.points_vert,fragmentShader:ShaderChunk.points_frag},dashed:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ShaderChunk.linedashed_vert,fragmentShader:ShaderChunk.linedashed_frag},depth:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap]),vertexShader:ShaderChunk.depth_vert,fragmentShader:ShaderChunk.depth_frag},normal:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,{opacity:{value:1}}]),vertexShader:ShaderChunk.meshnormal_vert,fragmentShader:ShaderChunk.meshnormal_frag},sprite:{uniforms:mergeUniforms([UniformsLib.sprite,UniformsLib.fog]),vertexShader:ShaderChunk.sprite_vert,fragmentShader:ShaderChunk.sprite_frag},background:{uniforms:{uvTransform:{value:new Matrix3},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:ShaderChunk.background_vert,fragmentShader:ShaderChunk.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new Matrix3}},vertexShader:ShaderChunk.backgroundCube_vert,fragmentShader:ShaderChunk.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:ShaderChunk.cube_vert,fragmentShader:ShaderChunk.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ShaderChunk.equirect_vert,fragmentShader:ShaderChunk.equirect_frag},distanceRGBA:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap,{referencePosition:{value:new Vector3},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:ShaderChunk.distanceRGBA_vert,fragmentShader:ShaderChunk.distanceRGBA_frag},shadow:{uniforms:mergeUniforms([UniformsLib.lights,UniformsLib.fog,{color:{value:new Color$1(0)},opacity:{value:1}}]),vertexShader:ShaderChunk.shadow_vert,fragmentShader:ShaderChunk.shadow_frag}};ShaderLib.physical={uniforms:mergeUniforms([ShaderLib.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new Matrix3},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new Matrix3},clearcoatNormalScale:{value:new Vector2(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new Matrix3},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new Matrix3},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new Matrix3},sheen:{value:0},sheenColor:{value:new Color$1(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new Matrix3},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new Matrix3},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new Matrix3},transmissionSamplerSize:{value:new Vector2},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new Matrix3},attenuationDistance:{value:0},attenuationColor:{value:new Color$1(0)},specularColor:{value:new Color$1(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new Matrix3},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new Matrix3},anisotropyVector:{value:new Vector2},anisotropyMap:{value:null},anisotropyMapTransform:{value:new Matrix3}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag};const _rgb={r:0,b:0,g:0},_e1$1=new Euler,_m1$1=new Matrix4;function WebGLBackground(et,_,_e,tt,nt,rt,ot){const at=new Color$1(0);let lt=rt===!0?0:1,ut,dt,st=null,it=0,ct=null;function ft(_t){let vt=_t.isScene===!0?_t.background:null;return vt&&vt.isTexture&&(vt=(_t.backgroundBlurriness>0?_e:_).get(vt)),vt}function ht(_t){let vt=!1;const bt=ft(_t);bt===null?pt(at,lt):bt&&bt.isColor&&(pt(bt,1),vt=!0);const wt=et.xr.getEnvironmentBlendMode();wt==="additive"?tt.buffers.color.setClear(0,0,0,1,ot):wt==="alpha-blend"&&tt.buffers.color.setClear(0,0,0,0,ot),(et.autoClear||vt)&&(tt.buffers.depth.setTest(!0),tt.buffers.depth.setMask(!0),tt.buffers.color.setMask(!0),et.clear(et.autoClearColor,et.autoClearDepth,et.autoClearStencil))}function mt(_t,vt){const bt=ft(vt);bt&&(bt.isCubeTexture||bt.mapping===CubeUVReflectionMapping)?(dt===void 0&&(dt=new Mesh(new BoxGeometry(1,1,1),new ShaderMaterial({name:"BackgroundCubeMaterial",uniforms:cloneUniforms(ShaderLib.backgroundCube.uniforms),vertexShader:ShaderLib.backgroundCube.vertexShader,fragmentShader:ShaderLib.backgroundCube.fragmentShader,side:BackSide,depthTest:!1,depthWrite:!1,fog:!1})),dt.geometry.deleteAttribute("normal"),dt.geometry.deleteAttribute("uv"),dt.onBeforeRender=function(wt,xt,Mt){this.matrixWorld.copyPosition(Mt.matrixWorld)},Object.defineProperty(dt.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),nt.update(dt)),_e1$1.copy(vt.backgroundRotation),_e1$1.x*=-1,_e1$1.y*=-1,_e1$1.z*=-1,bt.isCubeTexture&&bt.isRenderTargetTexture===!1&&(_e1$1.y*=-1,_e1$1.z*=-1),dt.material.uniforms.envMap.value=bt,dt.material.uniforms.flipEnvMap.value=bt.isCubeTexture&&bt.isRenderTargetTexture===!1?-1:1,dt.material.uniforms.backgroundBlurriness.value=vt.backgroundBlurriness,dt.material.uniforms.backgroundIntensity.value=vt.backgroundIntensity,dt.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1)),dt.material.toneMapped=ColorManagement.getTransfer(bt.colorSpace)!==SRGBTransfer,(st!==bt||it!==bt.version||ct!==et.toneMapping)&&(dt.material.needsUpdate=!0,st=bt,it=bt.version,ct=et.toneMapping),dt.layers.enableAll(),_t.unshift(dt,dt.geometry,dt.material,0,0,null)):bt&&bt.isTexture&&(ut===void 0&&(ut=new Mesh(new PlaneGeometry(2,2),new ShaderMaterial({name:"BackgroundMaterial",uniforms:cloneUniforms(ShaderLib.background.uniforms),vertexShader:ShaderLib.background.vertexShader,fragmentShader:ShaderLib.background.fragmentShader,side:FrontSide,depthTest:!1,depthWrite:!1,fog:!1})),ut.geometry.deleteAttribute("normal"),Object.defineProperty(ut.material,"map",{get:function(){return this.uniforms.t2D.value}}),nt.update(ut)),ut.material.uniforms.t2D.value=bt,ut.material.uniforms.backgroundIntensity.value=vt.backgroundIntensity,ut.material.toneMapped=ColorManagement.getTransfer(bt.colorSpace)!==SRGBTransfer,bt.matrixAutoUpdate===!0&&bt.updateMatrix(),ut.material.uniforms.uvTransform.value.copy(bt.matrix),(st!==bt||it!==bt.version||ct!==et.toneMapping)&&(ut.material.needsUpdate=!0,st=bt,it=bt.version,ct=et.toneMapping),ut.layers.enableAll(),_t.unshift(ut,ut.geometry,ut.material,0,0,null))}function pt(_t,vt){_t.getRGB(_rgb,getUnlitUniformColorSpace(et)),tt.buffers.color.setClear(_rgb.r,_rgb.g,_rgb.b,vt,ot)}return{getClearColor:function(){return at},setClearColor:function(_t,vt=1){at.set(_t),lt=vt,pt(at,lt)},getClearAlpha:function(){return lt},setClearAlpha:function(_t){lt=_t,pt(at,lt)},render:ht,addToRenderList:mt}}function WebGLBindingStates(et,_){const _e=et.getParameter(et.MAX_VERTEX_ATTRIBS),tt={},nt=it(null);let rt=nt,ot=!1;function at(Tt,Ct,It,$t,Nt){let Bt=!1;const Ot=st($t,It,Ct);rt!==Ot&&(rt=Ot,ut(rt.object)),Bt=ct(Tt,$t,It,Nt),Bt&&ft(Tt,$t,It,Nt),Nt!==null&&_.update(Nt,et.ELEMENT_ARRAY_BUFFER),(Bt||ot)&&(ot=!1,bt(Tt,Ct,It,$t),Nt!==null&&et.bindBuffer(et.ELEMENT_ARRAY_BUFFER,_.get(Nt).buffer))}function lt(){return et.createVertexArray()}function ut(Tt){return et.bindVertexArray(Tt)}function dt(Tt){return et.deleteVertexArray(Tt)}function st(Tt,Ct,It){const $t=It.wireframe===!0;let Nt=tt[Tt.id];Nt===void 0&&(Nt={},tt[Tt.id]=Nt);let Bt=Nt[Ct.id];Bt===void 0&&(Bt={},Nt[Ct.id]=Bt);let Ot=Bt[$t];return Ot===void 0&&(Ot=it(lt()),Bt[$t]=Ot),Ot}function it(Tt){const Ct=[],It=[],$t=[];for(let Nt=0;Nt<_e;Nt++)Ct[Nt]=0,It[Nt]=0,$t[Nt]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:Ct,enabledAttributes:It,attributeDivisors:$t,object:Tt,attributes:{},index:null}}function ct(Tt,Ct,It,$t){const Nt=rt.attributes,Bt=Ct.attributes;let Ot=0;const Ut=It.getAttributes();for(const Lt in Ut)if(Ut[Lt].location>=0){const Yt=Nt[Lt];let en=Bt[Lt];if(en===void 0&&(Lt==="instanceMatrix"&&Tt.instanceMatrix&&(en=Tt.instanceMatrix),Lt==="instanceColor"&&Tt.instanceColor&&(en=Tt.instanceColor)),Yt===void 0||Yt.attribute!==en||en&&Yt.data!==en.data)return!0;Ot++}return rt.attributesNum!==Ot||rt.index!==$t}function ft(Tt,Ct,It,$t){const Nt={},Bt=Ct.attributes;let Ot=0;const Ut=It.getAttributes();for(const Lt in Ut)if(Ut[Lt].location>=0){let Yt=Bt[Lt];Yt===void 0&&(Lt==="instanceMatrix"&&Tt.instanceMatrix&&(Yt=Tt.instanceMatrix),Lt==="instanceColor"&&Tt.instanceColor&&(Yt=Tt.instanceColor));const en={};en.attribute=Yt,Yt&&Yt.data&&(en.data=Yt.data),Nt[Lt]=en,Ot++}rt.attributes=Nt,rt.attributesNum=Ot,rt.index=$t}function ht(){const Tt=rt.newAttributes;for(let Ct=0,It=Tt.length;Ct<It;Ct++)Tt[Ct]=0}function mt(Tt){pt(Tt,0)}function pt(Tt,Ct){const It=rt.newAttributes,$t=rt.enabledAttributes,Nt=rt.attributeDivisors;It[Tt]=1,$t[Tt]===0&&(et.enableVertexAttribArray(Tt),$t[Tt]=1),Nt[Tt]!==Ct&&(et.vertexAttribDivisor(Tt,Ct),Nt[Tt]=Ct)}function _t(){const Tt=rt.newAttributes,Ct=rt.enabledAttributes;for(let It=0,$t=Ct.length;It<$t;It++)Ct[It]!==Tt[It]&&(et.disableVertexAttribArray(It),Ct[It]=0)}function vt(Tt,Ct,It,$t,Nt,Bt,Ot){Ot===!0?et.vertexAttribIPointer(Tt,Ct,It,Nt,Bt):et.vertexAttribPointer(Tt,Ct,It,$t,Nt,Bt)}function bt(Tt,Ct,It,$t){ht();const Nt=$t.attributes,Bt=It.getAttributes(),Ot=Ct.defaultAttributeValues;for(const Ut in Bt){const Lt=Bt[Ut];if(Lt.location>=0){let zt=Nt[Ut];if(zt===void 0&&(Ut==="instanceMatrix"&&Tt.instanceMatrix&&(zt=Tt.instanceMatrix),Ut==="instanceColor"&&Tt.instanceColor&&(zt=Tt.instanceColor)),zt!==void 0){const Yt=zt.normalized,en=zt.itemSize,bn=_.get(zt);if(bn===void 0)continue;const Un=bn.buffer,mn=bn.type,vn=bn.bytesPerElement,In=mn===et.INT||mn===et.UNSIGNED_INT||zt.gpuType===IntType;if(zt.isInterleavedBufferAttribute){const Cn=zt.data,En=Cn.stride,jt=zt.offset;if(Cn.isInstancedInterleavedBuffer){for(let Kt=0;Kt<Lt.locationSize;Kt++)pt(Lt.location+Kt,Cn.meshPerAttribute);Tt.isInstancedMesh!==!0&&$t._maxInstanceCount===void 0&&($t._maxInstanceCount=Cn.meshPerAttribute*Cn.count)}else for(let Kt=0;Kt<Lt.locationSize;Kt++)mt(Lt.location+Kt);et.bindBuffer(et.ARRAY_BUFFER,Un);for(let Kt=0;Kt<Lt.locationSize;Kt++)vt(Lt.location+Kt,en/Lt.locationSize,mn,Yt,En*vn,(jt+en/Lt.locationSize*Kt)*vn,In)}else{if(zt.isInstancedBufferAttribute){for(let Cn=0;Cn<Lt.locationSize;Cn++)pt(Lt.location+Cn,zt.meshPerAttribute);Tt.isInstancedMesh!==!0&&$t._maxInstanceCount===void 0&&($t._maxInstanceCount=zt.meshPerAttribute*zt.count)}else for(let Cn=0;Cn<Lt.locationSize;Cn++)mt(Lt.location+Cn);et.bindBuffer(et.ARRAY_BUFFER,Un);for(let Cn=0;Cn<Lt.locationSize;Cn++)vt(Lt.location+Cn,en/Lt.locationSize,mn,Yt,en*vn,en/Lt.locationSize*Cn*vn,In)}}else if(Ot!==void 0){const Yt=Ot[Ut];if(Yt!==void 0)switch(Yt.length){case 2:et.vertexAttrib2fv(Lt.location,Yt);break;case 3:et.vertexAttrib3fv(Lt.location,Yt);break;case 4:et.vertexAttrib4fv(Lt.location,Yt);break;default:et.vertexAttrib1fv(Lt.location,Yt)}}}}_t()}function wt(){At();for(const Tt in tt){const Ct=tt[Tt];for(const It in Ct){const $t=Ct[It];for(const Nt in $t)dt($t[Nt].object),delete $t[Nt];delete Ct[It]}delete tt[Tt]}}function xt(Tt){if(tt[Tt.id]===void 0)return;const Ct=tt[Tt.id];for(const It in Ct){const $t=Ct[It];for(const Nt in $t)dt($t[Nt].object),delete $t[Nt];delete Ct[It]}delete tt[Tt.id]}function Mt(Tt){for(const Ct in tt){const It=tt[Ct];if(It[Tt.id]===void 0)continue;const $t=It[Tt.id];for(const Nt in $t)dt($t[Nt].object),delete $t[Nt];delete It[Tt.id]}}function At(){St(),ot=!0,rt!==nt&&(rt=nt,ut(rt.object))}function St(){nt.geometry=null,nt.program=null,nt.wireframe=!1}return{setup:at,reset:At,resetDefaultState:St,dispose:wt,releaseStatesOfGeometry:xt,releaseStatesOfProgram:Mt,initAttributes:ht,enableAttribute:mt,disableUnusedAttributes:_t}}function WebGLBufferRenderer(et,_,_e){let tt;function nt(ut){tt=ut}function rt(ut,dt){et.drawArrays(tt,ut,dt),_e.update(dt,tt,1)}function ot(ut,dt,st){st!==0&&(et.drawArraysInstanced(tt,ut,dt,st),_e.update(dt,tt,st))}function at(ut,dt,st){if(st===0)return;_.get("WEBGL_multi_draw").multiDrawArraysWEBGL(tt,ut,0,dt,0,st);let ct=0;for(let ft=0;ft<st;ft++)ct+=dt[ft];_e.update(ct,tt,1)}function lt(ut,dt,st,it){if(st===0)return;const ct=_.get("WEBGL_multi_draw");if(ct===null)for(let ft=0;ft<ut.length;ft++)ot(ut[ft],dt[ft],it[ft]);else{ct.multiDrawArraysInstancedWEBGL(tt,ut,0,dt,0,it,0,st);let ft=0;for(let ht=0;ht<st;ht++)ft+=dt[ht];for(let ht=0;ht<it.length;ht++)_e.update(ft,tt,it[ht])}}this.setMode=nt,this.render=rt,this.renderInstances=ot,this.renderMultiDraw=at,this.renderMultiDrawInstances=lt}function WebGLCapabilities(et,_,_e,tt){let nt;function rt(){if(nt!==void 0)return nt;if(_.has("EXT_texture_filter_anisotropic")===!0){const xt=_.get("EXT_texture_filter_anisotropic");nt=et.getParameter(xt.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else nt=0;return nt}function ot(xt){return!(xt!==RGBAFormat&&tt.convert(xt)!==et.getParameter(et.IMPLEMENTATION_COLOR_READ_FORMAT))}function at(xt){const Mt=xt===HalfFloatType&&(_.has("EXT_color_buffer_half_float")||_.has("EXT_color_buffer_float"));return!(xt!==UnsignedByteType&&tt.convert(xt)!==et.getParameter(et.IMPLEMENTATION_COLOR_READ_TYPE)&&xt!==FloatType&&!Mt)}function lt(xt){if(xt==="highp"){if(et.getShaderPrecisionFormat(et.VERTEX_SHADER,et.HIGH_FLOAT).precision>0&&et.getShaderPrecisionFormat(et.FRAGMENT_SHADER,et.HIGH_FLOAT).precision>0)return"highp";xt="mediump"}return xt==="mediump"&&et.getShaderPrecisionFormat(et.VERTEX_SHADER,et.MEDIUM_FLOAT).precision>0&&et.getShaderPrecisionFormat(et.FRAGMENT_SHADER,et.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let ut=_e.precision!==void 0?_e.precision:"highp";const dt=lt(ut);dt!==ut&&(console.warn("THREE.WebGLRenderer:",ut,"not supported, using",dt,"instead."),ut=dt);const st=_e.logarithmicDepthBuffer===!0,it=et.getParameter(et.MAX_TEXTURE_IMAGE_UNITS),ct=et.getParameter(et.MAX_VERTEX_TEXTURE_IMAGE_UNITS),ft=et.getParameter(et.MAX_TEXTURE_SIZE),ht=et.getParameter(et.MAX_CUBE_MAP_TEXTURE_SIZE),mt=et.getParameter(et.MAX_VERTEX_ATTRIBS),pt=et.getParameter(et.MAX_VERTEX_UNIFORM_VECTORS),_t=et.getParameter(et.MAX_VARYING_VECTORS),vt=et.getParameter(et.MAX_FRAGMENT_UNIFORM_VECTORS),bt=ct>0,wt=et.getParameter(et.MAX_SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:rt,getMaxPrecision:lt,textureFormatReadable:ot,textureTypeReadable:at,precision:ut,logarithmicDepthBuffer:st,maxTextures:it,maxVertexTextures:ct,maxTextureSize:ft,maxCubemapSize:ht,maxAttributes:mt,maxVertexUniforms:pt,maxVaryings:_t,maxFragmentUniforms:vt,vertexTextures:bt,maxSamples:wt}}function WebGLClipping(et){const _=this;let _e=null,tt=0,nt=!1,rt=!1;const ot=new Plane,at=new Matrix3,lt={value:null,needsUpdate:!1};this.uniform=lt,this.numPlanes=0,this.numIntersection=0,this.init=function(st,it){const ct=st.length!==0||it||tt!==0||nt;return nt=it,tt=st.length,ct},this.beginShadows=function(){rt=!0,dt(null)},this.endShadows=function(){rt=!1},this.setGlobalState=function(st,it){_e=dt(st,it,0)},this.setState=function(st,it,ct){const ft=st.clippingPlanes,ht=st.clipIntersection,mt=st.clipShadows,pt=et.get(st);if(!nt||ft===null||ft.length===0||rt&&!mt)rt?dt(null):ut();else{const _t=rt?0:tt,vt=_t*4;let bt=pt.clippingState||null;lt.value=bt,bt=dt(ft,it,vt,ct);for(let wt=0;wt!==vt;++wt)bt[wt]=_e[wt];pt.clippingState=bt,this.numIntersection=ht?this.numPlanes:0,this.numPlanes+=_t}};function ut(){lt.value!==_e&&(lt.value=_e,lt.needsUpdate=tt>0),_.numPlanes=tt,_.numIntersection=0}function dt(st,it,ct,ft){const ht=st!==null?st.length:0;let mt=null;if(ht!==0){if(mt=lt.value,ft!==!0||mt===null){const pt=ct+ht*4,_t=it.matrixWorldInverse;at.getNormalMatrix(_t),(mt===null||mt.length<pt)&&(mt=new Float32Array(pt));for(let vt=0,bt=ct;vt!==ht;++vt,bt+=4)ot.copy(st[vt]).applyMatrix4(_t,at),ot.normal.toArray(mt,bt),mt[bt+3]=ot.constant}lt.value=mt,lt.needsUpdate=!0}return _.numPlanes=ht,_.numIntersection=0,mt}}function WebGLCubeMaps(et){let _=new WeakMap;function _e(ot,at){return at===EquirectangularReflectionMapping?ot.mapping=CubeReflectionMapping:at===EquirectangularRefractionMapping&&(ot.mapping=CubeRefractionMapping),ot}function tt(ot){if(ot&&ot.isTexture){const at=ot.mapping;if(at===EquirectangularReflectionMapping||at===EquirectangularRefractionMapping)if(_.has(ot)){const lt=_.get(ot).texture;return _e(lt,ot.mapping)}else{const lt=ot.image;if(lt&&lt.height>0){const ut=new WebGLCubeRenderTarget(lt.height);return ut.fromEquirectangularTexture(et,ot),_.set(ot,ut),ot.addEventListener("dispose",nt),_e(ut.texture,ot.mapping)}else return null}}return ot}function nt(ot){const at=ot.target;at.removeEventListener("dispose",nt);const lt=_.get(at);lt!==void 0&&(_.delete(at),lt.dispose())}function rt(){_=new WeakMap}return{get:tt,dispose:rt}}let OrthographicCamera$1=class extends Camera{constructor(_=-1,_e=1,tt=1,nt=-1,rt=.1,ot=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=_,this.right=_e,this.top=tt,this.bottom=nt,this.near=rt,this.far=ot,this.updateProjectionMatrix()}copy(_,_e){return super.copy(_,_e),this.left=_.left,this.right=_.right,this.top=_.top,this.bottom=_.bottom,this.near=_.near,this.far=_.far,this.zoom=_.zoom,this.view=_.view===null?null:Object.assign({},_.view),this}setViewOffset(_,_e,tt,nt,rt,ot){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=_,this.view.fullHeight=_e,this.view.offsetX=tt,this.view.offsetY=nt,this.view.width=rt,this.view.height=ot,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const _=(this.right-this.left)/(2*this.zoom),_e=(this.top-this.bottom)/(2*this.zoom),tt=(this.right+this.left)/2,nt=(this.top+this.bottom)/2;let rt=tt-_,ot=tt+_,at=nt+_e,lt=nt-_e;if(this.view!==null&&this.view.enabled){const ut=(this.right-this.left)/this.view.fullWidth/this.zoom,dt=(this.top-this.bottom)/this.view.fullHeight/this.zoom;rt+=ut*this.view.offsetX,ot=rt+ut*this.view.width,at-=dt*this.view.offsetY,lt=at-dt*this.view.height}this.projectionMatrix.makeOrthographic(rt,ot,at,lt,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(_){const _e=super.toJSON(_);return _e.object.zoom=this.zoom,_e.object.left=this.left,_e.object.right=this.right,_e.object.top=this.top,_e.object.bottom=this.bottom,_e.object.near=this.near,_e.object.far=this.far,this.view!==null&&(_e.object.view=Object.assign({},this.view)),_e}};const LOD_MIN=4,EXTRA_LOD_SIGMA=[.125,.215,.35,.446,.526,.582],MAX_SAMPLES=20,_flatCamera=new OrthographicCamera$1,_clearColor=new Color$1;let _oldTarget=null,_oldActiveCubeFace=0,_oldActiveMipmapLevel=0,_oldXrEnabled=!1;const PHI=(1+Math.sqrt(5))/2,INV_PHI=1/PHI,_axisDirections=[new Vector3(-PHI,INV_PHI,0),new Vector3(PHI,INV_PHI,0),new Vector3(-INV_PHI,0,PHI),new Vector3(INV_PHI,0,PHI),new Vector3(0,PHI,-INV_PHI),new Vector3(0,PHI,INV_PHI),new Vector3(-1,1,-1),new Vector3(1,1,-1),new Vector3(-1,1,1),new Vector3(1,1,1)];class PMREMGenerator{constructor(_){this._renderer=_,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(_,_e=0,tt=.1,nt=100){_oldTarget=this._renderer.getRenderTarget(),_oldActiveCubeFace=this._renderer.getActiveCubeFace(),_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel(),_oldXrEnabled=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(256);const rt=this._allocateTargets();return rt.depthBuffer=!0,this._sceneToCubeUV(_,tt,nt,rt),_e>0&&this._blur(rt,0,0,_e),this._applyPMREM(rt),this._cleanup(rt),rt}fromEquirectangular(_,_e=null){return this._fromTexture(_,_e)}fromCubemap(_,_e=null){return this._fromTexture(_,_e)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=_getCubemapMaterial(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=_getEquirectMaterial(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(_){this._lodMax=Math.floor(Math.log2(_)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let _=0;_<this._lodPlanes.length;_++)this._lodPlanes[_].dispose()}_cleanup(_){this._renderer.setRenderTarget(_oldTarget,_oldActiveCubeFace,_oldActiveMipmapLevel),this._renderer.xr.enabled=_oldXrEnabled,_.scissorTest=!1,_setViewport(_,0,0,_.width,_.height)}_fromTexture(_,_e){_.mapping===CubeReflectionMapping||_.mapping===CubeRefractionMapping?this._setSize(_.image.length===0?16:_.image[0].width||_.image[0].image.width):this._setSize(_.image.width/4),_oldTarget=this._renderer.getRenderTarget(),_oldActiveCubeFace=this._renderer.getActiveCubeFace(),_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel(),_oldXrEnabled=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const tt=_e||this._allocateTargets();return this._textureToCubeUV(_,tt),this._applyPMREM(tt),this._cleanup(tt),tt}_allocateTargets(){const _=3*Math.max(this._cubeSize,112),_e=4*this._cubeSize,tt={magFilter:LinearFilter,minFilter:LinearFilter,generateMipmaps:!1,type:HalfFloatType,format:RGBAFormat,colorSpace:LinearSRGBColorSpace,depthBuffer:!1},nt=_createRenderTarget(_,_e,tt);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==_||this._pingPongRenderTarget.height!==_e){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=_createRenderTarget(_,_e,tt);const{_lodMax:rt}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=_createPlanes(rt)),this._blurMaterial=_getBlurShader(rt,_,_e)}return nt}_compileMaterial(_){const _e=new Mesh(this._lodPlanes[0],_);this._renderer.compile(_e,_flatCamera)}_sceneToCubeUV(_,_e,tt,nt){const at=new PerspectiveCamera(90,1,_e,tt),lt=[1,-1,1,1,1,1],ut=[1,1,1,-1,-1,-1],dt=this._renderer,st=dt.autoClear,it=dt.toneMapping;dt.getClearColor(_clearColor),dt.toneMapping=NoToneMapping,dt.autoClear=!1;const ct=new MeshBasicMaterial({name:"PMREM.Background",side:BackSide,depthWrite:!1,depthTest:!1}),ft=new Mesh(new BoxGeometry,ct);let ht=!1;const mt=_.background;mt?mt.isColor&&(ct.color.copy(mt),_.background=null,ht=!0):(ct.color.copy(_clearColor),ht=!0);for(let pt=0;pt<6;pt++){const _t=pt%3;_t===0?(at.up.set(0,lt[pt],0),at.lookAt(ut[pt],0,0)):_t===1?(at.up.set(0,0,lt[pt]),at.lookAt(0,ut[pt],0)):(at.up.set(0,lt[pt],0),at.lookAt(0,0,ut[pt]));const vt=this._cubeSize;_setViewport(nt,_t*vt,pt>2?vt:0,vt,vt),dt.setRenderTarget(nt),ht&&dt.render(ft,at),dt.render(_,at)}ft.geometry.dispose(),ft.material.dispose(),dt.toneMapping=it,dt.autoClear=st,_.background=mt}_textureToCubeUV(_,_e){const tt=this._renderer,nt=_.mapping===CubeReflectionMapping||_.mapping===CubeRefractionMapping;nt?(this._cubemapMaterial===null&&(this._cubemapMaterial=_getCubemapMaterial()),this._cubemapMaterial.uniforms.flipEnvMap.value=_.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=_getEquirectMaterial());const rt=nt?this._cubemapMaterial:this._equirectMaterial,ot=new Mesh(this._lodPlanes[0],rt),at=rt.uniforms;at.envMap.value=_;const lt=this._cubeSize;_setViewport(_e,0,0,3*lt,2*lt),tt.setRenderTarget(_e),tt.render(ot,_flatCamera)}_applyPMREM(_){const _e=this._renderer,tt=_e.autoClear;_e.autoClear=!1;const nt=this._lodPlanes.length;for(let rt=1;rt<nt;rt++){const ot=Math.sqrt(this._sigmas[rt]*this._sigmas[rt]-this._sigmas[rt-1]*this._sigmas[rt-1]),at=_axisDirections[(nt-rt-1)%_axisDirections.length];this._blur(_,rt-1,rt,ot,at)}_e.autoClear=tt}_blur(_,_e,tt,nt,rt){const ot=this._pingPongRenderTarget;this._halfBlur(_,ot,_e,tt,nt,"latitudinal",rt),this._halfBlur(ot,_,tt,tt,nt,"longitudinal",rt)}_halfBlur(_,_e,tt,nt,rt,ot,at){const lt=this._renderer,ut=this._blurMaterial;ot!=="latitudinal"&&ot!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const dt=3,st=new Mesh(this._lodPlanes[nt],ut),it=ut.uniforms,ct=this._sizeLods[tt]-1,ft=isFinite(rt)?Math.PI/(2*ct):2*Math.PI/(2*MAX_SAMPLES-1),ht=rt/ft,mt=isFinite(rt)?1+Math.floor(dt*ht):MAX_SAMPLES;mt>MAX_SAMPLES&&console.warn(`sigmaRadians, ${rt}, is too large and will clip, as it requested ${mt} samples when the maximum is set to ${MAX_SAMPLES}`);const pt=[];let _t=0;for(let Mt=0;Mt<MAX_SAMPLES;++Mt){const At=Mt/ht,St=Math.exp(-At*At/2);pt.push(St),Mt===0?_t+=St:Mt<mt&&(_t+=2*St)}for(let Mt=0;Mt<pt.length;Mt++)pt[Mt]=pt[Mt]/_t;it.envMap.value=_.texture,it.samples.value=mt,it.weights.value=pt,it.latitudinal.value=ot==="latitudinal",at&&(it.poleAxis.value=at);const{_lodMax:vt}=this;it.dTheta.value=ft,it.mipInt.value=vt-tt;const bt=this._sizeLods[nt],wt=3*bt*(nt>vt-LOD_MIN?nt-vt+LOD_MIN:0),xt=4*(this._cubeSize-bt);_setViewport(_e,wt,xt,3*bt,2*bt),lt.setRenderTarget(_e),lt.render(st,_flatCamera)}}function _createPlanes(et){const _=[],_e=[],tt=[];let nt=et;const rt=et-LOD_MIN+1+EXTRA_LOD_SIGMA.length;for(let ot=0;ot<rt;ot++){const at=Math.pow(2,nt);_e.push(at);let lt=1/at;ot>et-LOD_MIN?lt=EXTRA_LOD_SIGMA[ot-et+LOD_MIN-1]:ot===0&&(lt=0),tt.push(lt);const ut=1/(at-2),dt=-ut,st=1+ut,it=[dt,dt,st,dt,st,st,dt,dt,st,st,dt,st],ct=6,ft=6,ht=3,mt=2,pt=1,_t=new Float32Array(ht*ft*ct),vt=new Float32Array(mt*ft*ct),bt=new Float32Array(pt*ft*ct);for(let xt=0;xt<ct;xt++){const Mt=xt%3*2/3-1,At=xt>2?0:-1,St=[Mt,At,0,Mt+2/3,At,0,Mt+2/3,At+1,0,Mt,At,0,Mt+2/3,At+1,0,Mt,At+1,0];_t.set(St,ht*ft*xt),vt.set(it,mt*ft*xt);const Tt=[xt,xt,xt,xt,xt,xt];bt.set(Tt,pt*ft*xt)}const wt=new BufferGeometry;wt.setAttribute("position",new BufferAttribute(_t,ht)),wt.setAttribute("uv",new BufferAttribute(vt,mt)),wt.setAttribute("faceIndex",new BufferAttribute(bt,pt)),_.push(wt),nt>LOD_MIN&&nt--}return{lodPlanes:_,sizeLods:_e,sigmas:tt}}function _createRenderTarget(et,_,_e){const tt=new WebGLRenderTarget(et,_,_e);return tt.texture.mapping=CubeUVReflectionMapping,tt.texture.name="PMREM.cubeUv",tt.scissorTest=!0,tt}function _setViewport(et,_,_e,tt,nt){et.viewport.set(_,_e,tt,nt),et.scissor.set(_,_e,tt,nt)}function _getBlurShader(et,_,_e){const tt=new Float32Array(MAX_SAMPLES),nt=new Vector3(0,1,0);return new ShaderMaterial({name:"SphericalGaussianBlur",defines:{n:MAX_SAMPLES,CUBEUV_TEXEL_WIDTH:1/_,CUBEUV_TEXEL_HEIGHT:1/_e,CUBEUV_MAX_MIP:`${et}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:tt},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:nt}},vertexShader:_getCommonVertexShader(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:NoBlending,depthTest:!1,depthWrite:!1})}function _getEquirectMaterial(){return new ShaderMaterial({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:_getCommonVertexShader(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:NoBlending,depthTest:!1,depthWrite:!1})}function _getCubemapMaterial(){return new ShaderMaterial({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:_getCommonVertexShader(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:NoBlending,depthTest:!1,depthWrite:!1})}function _getCommonVertexShader(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function WebGLCubeUVMaps(et){let _=new WeakMap,_e=null;function tt(at){if(at&&at.isTexture){const lt=at.mapping,ut=lt===EquirectangularReflectionMapping||lt===EquirectangularRefractionMapping,dt=lt===CubeReflectionMapping||lt===CubeRefractionMapping;if(ut||dt){let st=_.get(at);const it=st!==void 0?st.texture.pmremVersion:0;if(at.isRenderTargetTexture&&at.pmremVersion!==it)return _e===null&&(_e=new PMREMGenerator(et)),st=ut?_e.fromEquirectangular(at,st):_e.fromCubemap(at,st),st.texture.pmremVersion=at.pmremVersion,_.set(at,st),st.texture;if(st!==void 0)return st.texture;{const ct=at.image;return ut&&ct&&ct.height>0||dt&&ct&&nt(ct)?(_e===null&&(_e=new PMREMGenerator(et)),st=ut?_e.fromEquirectangular(at):_e.fromCubemap(at),st.texture.pmremVersion=at.pmremVersion,_.set(at,st),at.addEventListener("dispose",rt),st.texture):null}}}return at}function nt(at){let lt=0;const ut=6;for(let dt=0;dt<ut;dt++)at[dt]!==void 0&&lt++;return lt===ut}function rt(at){const lt=at.target;lt.removeEventListener("dispose",rt);const ut=_.get(lt);ut!==void 0&&(_.delete(lt),ut.dispose())}function ot(){_=new WeakMap,_e!==null&&(_e.dispose(),_e=null)}return{get:tt,dispose:ot}}function WebGLExtensions(et){const _={};function _e(tt){if(_[tt]!==void 0)return _[tt];let nt;switch(tt){case"WEBGL_depth_texture":nt=et.getExtension("WEBGL_depth_texture")||et.getExtension("MOZ_WEBGL_depth_texture")||et.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":nt=et.getExtension("EXT_texture_filter_anisotropic")||et.getExtension("MOZ_EXT_texture_filter_anisotropic")||et.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":nt=et.getExtension("WEBGL_compressed_texture_s3tc")||et.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||et.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":nt=et.getExtension("WEBGL_compressed_texture_pvrtc")||et.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:nt=et.getExtension(tt)}return _[tt]=nt,nt}return{has:function(tt){return _e(tt)!==null},init:function(){_e("EXT_color_buffer_float"),_e("WEBGL_clip_cull_distance"),_e("OES_texture_float_linear"),_e("EXT_color_buffer_half_float"),_e("WEBGL_multisampled_render_to_texture"),_e("WEBGL_render_shared_exponent")},get:function(tt){const nt=_e(tt);return nt===null&&warnOnce("THREE.WebGLRenderer: "+tt+" extension not supported."),nt}}}function WebGLGeometries(et,_,_e,tt){const nt={},rt=new WeakMap;function ot(st){const it=st.target;it.index!==null&&_.remove(it.index);for(const ft in it.attributes)_.remove(it.attributes[ft]);for(const ft in it.morphAttributes){const ht=it.morphAttributes[ft];for(let mt=0,pt=ht.length;mt<pt;mt++)_.remove(ht[mt])}it.removeEventListener("dispose",ot),delete nt[it.id];const ct=rt.get(it);ct&&(_.remove(ct),rt.delete(it)),tt.releaseStatesOfGeometry(it),it.isInstancedBufferGeometry===!0&&delete it._maxInstanceCount,_e.memory.geometries--}function at(st,it){return nt[it.id]===!0||(it.addEventListener("dispose",ot),nt[it.id]=!0,_e.memory.geometries++),it}function lt(st){const it=st.attributes;for(const ft in it)_.update(it[ft],et.ARRAY_BUFFER);const ct=st.morphAttributes;for(const ft in ct){const ht=ct[ft];for(let mt=0,pt=ht.length;mt<pt;mt++)_.update(ht[mt],et.ARRAY_BUFFER)}}function ut(st){const it=[],ct=st.index,ft=st.attributes.position;let ht=0;if(ct!==null){const _t=ct.array;ht=ct.version;for(let vt=0,bt=_t.length;vt<bt;vt+=3){const wt=_t[vt+0],xt=_t[vt+1],Mt=_t[vt+2];it.push(wt,xt,xt,Mt,Mt,wt)}}else if(ft!==void 0){const _t=ft.array;ht=ft.version;for(let vt=0,bt=_t.length/3-1;vt<bt;vt+=3){const wt=vt+0,xt=vt+1,Mt=vt+2;it.push(wt,xt,xt,Mt,Mt,wt)}}else return;const mt=new(arrayNeedsUint32(it)?Uint32BufferAttribute:Uint16BufferAttribute)(it,1);mt.version=ht;const pt=rt.get(st);pt&&_.remove(pt),rt.set(st,mt)}function dt(st){const it=rt.get(st);if(it){const ct=st.index;ct!==null&&it.version<ct.version&&ut(st)}else ut(st);return rt.get(st)}return{get:at,update:lt,getWireframeAttribute:dt}}function WebGLIndexedBufferRenderer(et,_,_e){let tt;function nt(it){tt=it}let rt,ot;function at(it){rt=it.type,ot=it.bytesPerElement}function lt(it,ct){et.drawElements(tt,ct,rt,it*ot),_e.update(ct,tt,1)}function ut(it,ct,ft){ft!==0&&(et.drawElementsInstanced(tt,ct,rt,it*ot,ft),_e.update(ct,tt,ft))}function dt(it,ct,ft){if(ft===0)return;_.get("WEBGL_multi_draw").multiDrawElementsWEBGL(tt,ct,0,rt,it,0,ft);let mt=0;for(let pt=0;pt<ft;pt++)mt+=ct[pt];_e.update(mt,tt,1)}function st(it,ct,ft,ht){if(ft===0)return;const mt=_.get("WEBGL_multi_draw");if(mt===null)for(let pt=0;pt<it.length;pt++)ut(it[pt]/ot,ct[pt],ht[pt]);else{mt.multiDrawElementsInstancedWEBGL(tt,ct,0,rt,it,0,ht,0,ft);let pt=0;for(let _t=0;_t<ft;_t++)pt+=ct[_t];for(let _t=0;_t<ht.length;_t++)_e.update(pt,tt,ht[_t])}}this.setMode=nt,this.setIndex=at,this.render=lt,this.renderInstances=ut,this.renderMultiDraw=dt,this.renderMultiDrawInstances=st}function WebGLInfo(et){const _={geometries:0,textures:0},_e={frame:0,calls:0,triangles:0,points:0,lines:0};function tt(rt,ot,at){switch(_e.calls++,ot){case et.TRIANGLES:_e.triangles+=at*(rt/3);break;case et.LINES:_e.lines+=at*(rt/2);break;case et.LINE_STRIP:_e.lines+=at*(rt-1);break;case et.LINE_LOOP:_e.lines+=at*rt;break;case et.POINTS:_e.points+=at*rt;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",ot);break}}function nt(){_e.calls=0,_e.triangles=0,_e.points=0,_e.lines=0}return{memory:_,render:_e,programs:null,autoReset:!0,reset:nt,update:tt}}function WebGLMorphtargets(et,_,_e){const tt=new WeakMap,nt=new Vector4;function rt(ot,at,lt){const ut=ot.morphTargetInfluences,dt=at.morphAttributes.position||at.morphAttributes.normal||at.morphAttributes.color,st=dt!==void 0?dt.length:0;let it=tt.get(at);if(it===void 0||it.count!==st){let St=function(){Mt.dispose(),tt.delete(at),at.removeEventListener("dispose",St)};it!==void 0&&it.texture.dispose();const ct=at.morphAttributes.position!==void 0,ft=at.morphAttributes.normal!==void 0,ht=at.morphAttributes.color!==void 0,mt=at.morphAttributes.position||[],pt=at.morphAttributes.normal||[],_t=at.morphAttributes.color||[];let vt=0;ct===!0&&(vt=1),ft===!0&&(vt=2),ht===!0&&(vt=3);let bt=at.attributes.position.count*vt,wt=1;bt>_.maxTextureSize&&(wt=Math.ceil(bt/_.maxTextureSize),bt=_.maxTextureSize);const xt=new Float32Array(bt*wt*4*st),Mt=new DataArrayTexture(xt,bt,wt,st);Mt.type=FloatType,Mt.needsUpdate=!0;const At=vt*4;for(let Tt=0;Tt<st;Tt++){const Ct=mt[Tt],It=pt[Tt],$t=_t[Tt],Nt=bt*wt*4*Tt;for(let Bt=0;Bt<Ct.count;Bt++){const Ot=Bt*At;ct===!0&&(nt.fromBufferAttribute(Ct,Bt),xt[Nt+Ot+0]=nt.x,xt[Nt+Ot+1]=nt.y,xt[Nt+Ot+2]=nt.z,xt[Nt+Ot+3]=0),ft===!0&&(nt.fromBufferAttribute(It,Bt),xt[Nt+Ot+4]=nt.x,xt[Nt+Ot+5]=nt.y,xt[Nt+Ot+6]=nt.z,xt[Nt+Ot+7]=0),ht===!0&&(nt.fromBufferAttribute($t,Bt),xt[Nt+Ot+8]=nt.x,xt[Nt+Ot+9]=nt.y,xt[Nt+Ot+10]=nt.z,xt[Nt+Ot+11]=$t.itemSize===4?nt.w:1)}}it={count:st,texture:Mt,size:new Vector2(bt,wt)},tt.set(at,it),at.addEventListener("dispose",St)}if(ot.isInstancedMesh===!0&&ot.morphTexture!==null)lt.getUniforms().setValue(et,"morphTexture",ot.morphTexture,_e);else{let ct=0;for(let ht=0;ht<ut.length;ht++)ct+=ut[ht];const ft=at.morphTargetsRelative?1:1-ct;lt.getUniforms().setValue(et,"morphTargetBaseInfluence",ft),lt.getUniforms().setValue(et,"morphTargetInfluences",ut)}lt.getUniforms().setValue(et,"morphTargetsTexture",it.texture,_e),lt.getUniforms().setValue(et,"morphTargetsTextureSize",it.size)}return{update:rt}}function WebGLObjects(et,_,_e,tt){let nt=new WeakMap;function rt(lt){const ut=tt.render.frame,dt=lt.geometry,st=_.get(lt,dt);if(nt.get(st)!==ut&&(_.update(st),nt.set(st,ut)),lt.isInstancedMesh&&(lt.hasEventListener("dispose",at)===!1&&lt.addEventListener("dispose",at),nt.get(lt)!==ut&&(_e.update(lt.instanceMatrix,et.ARRAY_BUFFER),lt.instanceColor!==null&&_e.update(lt.instanceColor,et.ARRAY_BUFFER),nt.set(lt,ut))),lt.isSkinnedMesh){const it=lt.skeleton;nt.get(it)!==ut&&(it.update(),nt.set(it,ut))}return st}function ot(){nt=new WeakMap}function at(lt){const ut=lt.target;ut.removeEventListener("dispose",at),_e.remove(ut.instanceMatrix),ut.instanceColor!==null&&_e.remove(ut.instanceColor)}return{update:rt,dispose:ot}}class DepthTexture extends Texture{constructor(_,_e,tt,nt,rt,ot,at,lt,ut,dt=DepthFormat){if(dt!==DepthFormat&&dt!==DepthStencilFormat)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");tt===void 0&&dt===DepthFormat&&(tt=UnsignedIntType),tt===void 0&&dt===DepthStencilFormat&&(tt=UnsignedInt248Type),super(null,nt,rt,ot,at,lt,dt,tt,ut),this.isDepthTexture=!0,this.image={width:_,height:_e},this.magFilter=at!==void 0?at:NearestFilter,this.minFilter=lt!==void 0?lt:NearestFilter,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(_){return super.copy(_),this.compareFunction=_.compareFunction,this}toJSON(_){const _e=super.toJSON(_);return this.compareFunction!==null&&(_e.compareFunction=this.compareFunction),_e}}const emptyTexture=new Texture,emptyShadowTexture=new DepthTexture(1,1),emptyArrayTexture=new DataArrayTexture,empty3dTexture=new Data3DTexture,emptyCubeTexture=new CubeTexture,arrayCacheF32=[],arrayCacheI32=[],mat4array=new Float32Array(16),mat3array=new Float32Array(9),mat2array=new Float32Array(4);function flatten$1(et,_,_e){const tt=et[0];if(tt<=0||tt>0)return et;const nt=_*_e;let rt=arrayCacheF32[nt];if(rt===void 0&&(rt=new Float32Array(nt),arrayCacheF32[nt]=rt),_!==0){tt.toArray(rt,0);for(let ot=1,at=0;ot!==_;++ot)at+=_e,et[ot].toArray(rt,at)}return rt}function arraysEqual(et,_){if(et.length!==_.length)return!1;for(let _e=0,tt=et.length;_e<tt;_e++)if(et[_e]!==_[_e])return!1;return!0}function copyArray(et,_){for(let _e=0,tt=_.length;_e<tt;_e++)et[_e]=_[_e]}function allocTexUnits(et,_){let _e=arrayCacheI32[_];_e===void 0&&(_e=new Int32Array(_),arrayCacheI32[_]=_e);for(let tt=0;tt!==_;++tt)_e[tt]=et.allocateTextureUnit();return _e}function setValueV1f(et,_){const _e=this.cache;_e[0]!==_&&(et.uniform1f(this.addr,_),_e[0]=_)}function setValueV2f(et,_){const _e=this.cache;if(_.x!==void 0)(_e[0]!==_.x||_e[1]!==_.y)&&(et.uniform2f(this.addr,_.x,_.y),_e[0]=_.x,_e[1]=_.y);else{if(arraysEqual(_e,_))return;et.uniform2fv(this.addr,_),copyArray(_e,_)}}function setValueV3f(et,_){const _e=this.cache;if(_.x!==void 0)(_e[0]!==_.x||_e[1]!==_.y||_e[2]!==_.z)&&(et.uniform3f(this.addr,_.x,_.y,_.z),_e[0]=_.x,_e[1]=_.y,_e[2]=_.z);else if(_.r!==void 0)(_e[0]!==_.r||_e[1]!==_.g||_e[2]!==_.b)&&(et.uniform3f(this.addr,_.r,_.g,_.b),_e[0]=_.r,_e[1]=_.g,_e[2]=_.b);else{if(arraysEqual(_e,_))return;et.uniform3fv(this.addr,_),copyArray(_e,_)}}function setValueV4f(et,_){const _e=this.cache;if(_.x!==void 0)(_e[0]!==_.x||_e[1]!==_.y||_e[2]!==_.z||_e[3]!==_.w)&&(et.uniform4f(this.addr,_.x,_.y,_.z,_.w),_e[0]=_.x,_e[1]=_.y,_e[2]=_.z,_e[3]=_.w);else{if(arraysEqual(_e,_))return;et.uniform4fv(this.addr,_),copyArray(_e,_)}}function setValueM2(et,_){const _e=this.cache,tt=_.elements;if(tt===void 0){if(arraysEqual(_e,_))return;et.uniformMatrix2fv(this.addr,!1,_),copyArray(_e,_)}else{if(arraysEqual(_e,tt))return;mat2array.set(tt),et.uniformMatrix2fv(this.addr,!1,mat2array),copyArray(_e,tt)}}function setValueM3(et,_){const _e=this.cache,tt=_.elements;if(tt===void 0){if(arraysEqual(_e,_))return;et.uniformMatrix3fv(this.addr,!1,_),copyArray(_e,_)}else{if(arraysEqual(_e,tt))return;mat3array.set(tt),et.uniformMatrix3fv(this.addr,!1,mat3array),copyArray(_e,tt)}}function setValueM4(et,_){const _e=this.cache,tt=_.elements;if(tt===void 0){if(arraysEqual(_e,_))return;et.uniformMatrix4fv(this.addr,!1,_),copyArray(_e,_)}else{if(arraysEqual(_e,tt))return;mat4array.set(tt),et.uniformMatrix4fv(this.addr,!1,mat4array),copyArray(_e,tt)}}function setValueV1i(et,_){const _e=this.cache;_e[0]!==_&&(et.uniform1i(this.addr,_),_e[0]=_)}function setValueV2i(et,_){const _e=this.cache;if(_.x!==void 0)(_e[0]!==_.x||_e[1]!==_.y)&&(et.uniform2i(this.addr,_.x,_.y),_e[0]=_.x,_e[1]=_.y);else{if(arraysEqual(_e,_))return;et.uniform2iv(this.addr,_),copyArray(_e,_)}}function setValueV3i(et,_){const _e=this.cache;if(_.x!==void 0)(_e[0]!==_.x||_e[1]!==_.y||_e[2]!==_.z)&&(et.uniform3i(this.addr,_.x,_.y,_.z),_e[0]=_.x,_e[1]=_.y,_e[2]=_.z);else{if(arraysEqual(_e,_))return;et.uniform3iv(this.addr,_),copyArray(_e,_)}}function setValueV4i(et,_){const _e=this.cache;if(_.x!==void 0)(_e[0]!==_.x||_e[1]!==_.y||_e[2]!==_.z||_e[3]!==_.w)&&(et.uniform4i(this.addr,_.x,_.y,_.z,_.w),_e[0]=_.x,_e[1]=_.y,_e[2]=_.z,_e[3]=_.w);else{if(arraysEqual(_e,_))return;et.uniform4iv(this.addr,_),copyArray(_e,_)}}function setValueV1ui(et,_){const _e=this.cache;_e[0]!==_&&(et.uniform1ui(this.addr,_),_e[0]=_)}function setValueV2ui(et,_){const _e=this.cache;if(_.x!==void 0)(_e[0]!==_.x||_e[1]!==_.y)&&(et.uniform2ui(this.addr,_.x,_.y),_e[0]=_.x,_e[1]=_.y);else{if(arraysEqual(_e,_))return;et.uniform2uiv(this.addr,_),copyArray(_e,_)}}function setValueV3ui(et,_){const _e=this.cache;if(_.x!==void 0)(_e[0]!==_.x||_e[1]!==_.y||_e[2]!==_.z)&&(et.uniform3ui(this.addr,_.x,_.y,_.z),_e[0]=_.x,_e[1]=_.y,_e[2]=_.z);else{if(arraysEqual(_e,_))return;et.uniform3uiv(this.addr,_),copyArray(_e,_)}}function setValueV4ui(et,_){const _e=this.cache;if(_.x!==void 0)(_e[0]!==_.x||_e[1]!==_.y||_e[2]!==_.z||_e[3]!==_.w)&&(et.uniform4ui(this.addr,_.x,_.y,_.z,_.w),_e[0]=_.x,_e[1]=_.y,_e[2]=_.z,_e[3]=_.w);else{if(arraysEqual(_e,_))return;et.uniform4uiv(this.addr,_),copyArray(_e,_)}}function setValueT1(et,_,_e){const tt=this.cache,nt=_e.allocateTextureUnit();tt[0]!==nt&&(et.uniform1i(this.addr,nt),tt[0]=nt);let rt;this.type===et.SAMPLER_2D_SHADOW?(emptyShadowTexture.compareFunction=LessEqualCompare,rt=emptyShadowTexture):rt=emptyTexture,_e.setTexture2D(_||rt,nt)}function setValueT3D1(et,_,_e){const tt=this.cache,nt=_e.allocateTextureUnit();tt[0]!==nt&&(et.uniform1i(this.addr,nt),tt[0]=nt),_e.setTexture3D(_||empty3dTexture,nt)}function setValueT6(et,_,_e){const tt=this.cache,nt=_e.allocateTextureUnit();tt[0]!==nt&&(et.uniform1i(this.addr,nt),tt[0]=nt),_e.setTextureCube(_||emptyCubeTexture,nt)}function setValueT2DArray1(et,_,_e){const tt=this.cache,nt=_e.allocateTextureUnit();tt[0]!==nt&&(et.uniform1i(this.addr,nt),tt[0]=nt),_e.setTexture2DArray(_||emptyArrayTexture,nt)}function getSingularSetter(et){switch(et){case 5126:return setValueV1f;case 35664:return setValueV2f;case 35665:return setValueV3f;case 35666:return setValueV4f;case 35674:return setValueM2;case 35675:return setValueM3;case 35676:return setValueM4;case 5124:case 35670:return setValueV1i;case 35667:case 35671:return setValueV2i;case 35668:case 35672:return setValueV3i;case 35669:case 35673:return setValueV4i;case 5125:return setValueV1ui;case 36294:return setValueV2ui;case 36295:return setValueV3ui;case 36296:return setValueV4ui;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1;case 35679:case 36299:case 36307:return setValueT3D1;case 35680:case 36300:case 36308:case 36293:return setValueT6;case 36289:case 36303:case 36311:case 36292:return setValueT2DArray1}}function setValueV1fArray(et,_){et.uniform1fv(this.addr,_)}function setValueV2fArray(et,_){const _e=flatten$1(_,this.size,2);et.uniform2fv(this.addr,_e)}function setValueV3fArray(et,_){const _e=flatten$1(_,this.size,3);et.uniform3fv(this.addr,_e)}function setValueV4fArray(et,_){const _e=flatten$1(_,this.size,4);et.uniform4fv(this.addr,_e)}function setValueM2Array(et,_){const _e=flatten$1(_,this.size,4);et.uniformMatrix2fv(this.addr,!1,_e)}function setValueM3Array(et,_){const _e=flatten$1(_,this.size,9);et.uniformMatrix3fv(this.addr,!1,_e)}function setValueM4Array(et,_){const _e=flatten$1(_,this.size,16);et.uniformMatrix4fv(this.addr,!1,_e)}function setValueV1iArray(et,_){et.uniform1iv(this.addr,_)}function setValueV2iArray(et,_){et.uniform2iv(this.addr,_)}function setValueV3iArray(et,_){et.uniform3iv(this.addr,_)}function setValueV4iArray(et,_){et.uniform4iv(this.addr,_)}function setValueV1uiArray(et,_){et.uniform1uiv(this.addr,_)}function setValueV2uiArray(et,_){et.uniform2uiv(this.addr,_)}function setValueV3uiArray(et,_){et.uniform3uiv(this.addr,_)}function setValueV4uiArray(et,_){et.uniform4uiv(this.addr,_)}function setValueT1Array(et,_,_e){const tt=this.cache,nt=_.length,rt=allocTexUnits(_e,nt);arraysEqual(tt,rt)||(et.uniform1iv(this.addr,rt),copyArray(tt,rt));for(let ot=0;ot!==nt;++ot)_e.setTexture2D(_[ot]||emptyTexture,rt[ot])}function setValueT3DArray(et,_,_e){const tt=this.cache,nt=_.length,rt=allocTexUnits(_e,nt);arraysEqual(tt,rt)||(et.uniform1iv(this.addr,rt),copyArray(tt,rt));for(let ot=0;ot!==nt;++ot)_e.setTexture3D(_[ot]||empty3dTexture,rt[ot])}function setValueT6Array(et,_,_e){const tt=this.cache,nt=_.length,rt=allocTexUnits(_e,nt);arraysEqual(tt,rt)||(et.uniform1iv(this.addr,rt),copyArray(tt,rt));for(let ot=0;ot!==nt;++ot)_e.setTextureCube(_[ot]||emptyCubeTexture,rt[ot])}function setValueT2DArrayArray(et,_,_e){const tt=this.cache,nt=_.length,rt=allocTexUnits(_e,nt);arraysEqual(tt,rt)||(et.uniform1iv(this.addr,rt),copyArray(tt,rt));for(let ot=0;ot!==nt;++ot)_e.setTexture2DArray(_[ot]||emptyArrayTexture,rt[ot])}function getPureArraySetter(et){switch(et){case 5126:return setValueV1fArray;case 35664:return setValueV2fArray;case 35665:return setValueV3fArray;case 35666:return setValueV4fArray;case 35674:return setValueM2Array;case 35675:return setValueM3Array;case 35676:return setValueM4Array;case 5124:case 35670:return setValueV1iArray;case 35667:case 35671:return setValueV2iArray;case 35668:case 35672:return setValueV3iArray;case 35669:case 35673:return setValueV4iArray;case 5125:return setValueV1uiArray;case 36294:return setValueV2uiArray;case 36295:return setValueV3uiArray;case 36296:return setValueV4uiArray;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1Array;case 35679:case 36299:case 36307:return setValueT3DArray;case 35680:case 36300:case 36308:case 36293:return setValueT6Array;case 36289:case 36303:case 36311:case 36292:return setValueT2DArrayArray}}class SingleUniform{constructor(_,_e,tt){this.id=_,this.addr=tt,this.cache=[],this.type=_e.type,this.setValue=getSingularSetter(_e.type)}}class PureArrayUniform{constructor(_,_e,tt){this.id=_,this.addr=tt,this.cache=[],this.type=_e.type,this.size=_e.size,this.setValue=getPureArraySetter(_e.type)}}class StructuredUniform{constructor(_){this.id=_,this.seq=[],this.map={}}setValue(_,_e,tt){const nt=this.seq;for(let rt=0,ot=nt.length;rt!==ot;++rt){const at=nt[rt];at.setValue(_,_e[at.id],tt)}}}const RePathPart=/(\w+)(\])?(\[|\.)?/g;function addUniform(et,_){et.seq.push(_),et.map[_.id]=_}function parseUniform(et,_,_e){const tt=et.name,nt=tt.length;for(RePathPart.lastIndex=0;;){const rt=RePathPart.exec(tt),ot=RePathPart.lastIndex;let at=rt[1];const lt=rt[2]==="]",ut=rt[3];if(lt&&(at=at|0),ut===void 0||ut==="["&&ot+2===nt){addUniform(_e,ut===void 0?new SingleUniform(at,et,_):new PureArrayUniform(at,et,_));break}else{let st=_e.map[at];st===void 0&&(st=new StructuredUniform(at),addUniform(_e,st)),_e=st}}}class WebGLUniforms{constructor(_,_e){this.seq=[],this.map={};const tt=_.getProgramParameter(_e,_.ACTIVE_UNIFORMS);for(let nt=0;nt<tt;++nt){const rt=_.getActiveUniform(_e,nt),ot=_.getUniformLocation(_e,rt.name);parseUniform(rt,ot,this)}}setValue(_,_e,tt,nt){const rt=this.map[_e];rt!==void 0&&rt.setValue(_,tt,nt)}setOptional(_,_e,tt){const nt=_e[tt];nt!==void 0&&this.setValue(_,tt,nt)}static upload(_,_e,tt,nt){for(let rt=0,ot=_e.length;rt!==ot;++rt){const at=_e[rt],lt=tt[at.id];lt.needsUpdate!==!1&&at.setValue(_,lt.value,nt)}}static seqWithValue(_,_e){const tt=[];for(let nt=0,rt=_.length;nt!==rt;++nt){const ot=_[nt];ot.id in _e&&tt.push(ot)}return tt}}function WebGLShader(et,_,_e){const tt=et.createShader(_);return et.shaderSource(tt,_e),et.compileShader(tt),tt}const COMPLETION_STATUS_KHR=37297;let programIdCount=0;function handleSource(et,_){const _e=et.split(`
`),tt=[],nt=Math.max(_-6,0),rt=Math.min(_+6,_e.length);for(let ot=nt;ot<rt;ot++){const at=ot+1;tt.push(`${at===_?">":" "} ${at}: ${_e[ot]}`)}return tt.join(`
`)}function getEncodingComponents(et){const _=ColorManagement.getPrimaries(ColorManagement.workingColorSpace),_e=ColorManagement.getPrimaries(et);let tt;switch(_===_e?tt="":_===P3Primaries&&_e===Rec709Primaries?tt="LinearDisplayP3ToLinearSRGB":_===Rec709Primaries&&_e===P3Primaries&&(tt="LinearSRGBToLinearDisplayP3"),et){case LinearSRGBColorSpace:case LinearDisplayP3ColorSpace:return[tt,"LinearTransferOETF"];case SRGBColorSpace:case DisplayP3ColorSpace:return[tt,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",et),[tt,"LinearTransferOETF"]}}function getShaderErrors(et,_,_e){const tt=et.getShaderParameter(_,et.COMPILE_STATUS),nt=et.getShaderInfoLog(_).trim();if(tt&&nt==="")return"";const rt=/ERROR: 0:(\d+)/.exec(nt);if(rt){const ot=parseInt(rt[1]);return _e.toUpperCase()+`

`+nt+`

`+handleSource(et.getShaderSource(_),ot)}else return nt}function getTexelEncodingFunction(et,_){const _e=getEncodingComponents(_);return`vec4 ${et}( vec4 value ) { return ${_e[0]}( ${_e[1]}( value ) ); }`}function getToneMappingFunction(et,_){let _e;switch(_){case LinearToneMapping:_e="Linear";break;case ReinhardToneMapping:_e="Reinhard";break;case CineonToneMapping:_e="OptimizedCineon";break;case ACESFilmicToneMapping:_e="ACESFilmic";break;case AgXToneMapping:_e="AgX";break;case NeutralToneMapping:_e="Neutral";break;case CustomToneMapping:_e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",_),_e="Linear"}return"vec3 "+et+"( vec3 color ) { return "+_e+"ToneMapping( color ); }"}function generateVertexExtensions(et){return[et.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",et.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(filterEmptyLine).join(`
`)}function generateDefines(et){const _=[];for(const _e in et){const tt=et[_e];tt!==!1&&_.push("#define "+_e+" "+tt)}return _.join(`
`)}function fetchAttributeLocations(et,_){const _e={},tt=et.getProgramParameter(_,et.ACTIVE_ATTRIBUTES);for(let nt=0;nt<tt;nt++){const rt=et.getActiveAttrib(_,nt),ot=rt.name;let at=1;rt.type===et.FLOAT_MAT2&&(at=2),rt.type===et.FLOAT_MAT3&&(at=3),rt.type===et.FLOAT_MAT4&&(at=4),_e[ot]={type:rt.type,location:et.getAttribLocation(_,ot),locationSize:at}}return _e}function filterEmptyLine(et){return et!==""}function replaceLightNums(et,_){const _e=_.numSpotLightShadows+_.numSpotLightMaps-_.numSpotLightShadowsWithMaps;return et.replace(/NUM_DIR_LIGHTS/g,_.numDirLights).replace(/NUM_SPOT_LIGHTS/g,_.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,_.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,_e).replace(/NUM_RECT_AREA_LIGHTS/g,_.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,_.numPointLights).replace(/NUM_HEMI_LIGHTS/g,_.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,_.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,_.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,_.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,_.numPointLightShadows)}function replaceClippingPlaneNums(et,_){return et.replace(/NUM_CLIPPING_PLANES/g,_.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,_.numClippingPlanes-_.numClipIntersection)}const includePattern=/^[ \t]*#include +<([\w\d./]+)>/gm;function resolveIncludes(et){return et.replace(includePattern,includeReplacer)}const shaderChunkMap=new Map;function includeReplacer(et,_){let _e=ShaderChunk[_];if(_e===void 0){const tt=shaderChunkMap.get(_);if(tt!==void 0)_e=ShaderChunk[tt],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',_,tt);else throw new Error("Can not resolve #include <"+_+">")}return resolveIncludes(_e)}const unrollLoopPattern=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function unrollLoops(et){return et.replace(unrollLoopPattern,loopReplacer)}function loopReplacer(et,_,_e,tt){let nt="";for(let rt=parseInt(_);rt<parseInt(_e);rt++)nt+=tt.replace(/\[\s*i\s*\]/g,"[ "+rt+" ]").replace(/UNROLLED_LOOP_INDEX/g,rt);return nt}function generatePrecision(et){let _=`precision ${et.precision} float;
	precision ${et.precision} int;
	precision ${et.precision} sampler2D;
	precision ${et.precision} samplerCube;
	precision ${et.precision} sampler3D;
	precision ${et.precision} sampler2DArray;
	precision ${et.precision} sampler2DShadow;
	precision ${et.precision} samplerCubeShadow;
	precision ${et.precision} sampler2DArrayShadow;
	precision ${et.precision} isampler2D;
	precision ${et.precision} isampler3D;
	precision ${et.precision} isamplerCube;
	precision ${et.precision} isampler2DArray;
	precision ${et.precision} usampler2D;
	precision ${et.precision} usampler3D;
	precision ${et.precision} usamplerCube;
	precision ${et.precision} usampler2DArray;
	`;return et.precision==="highp"?_+=`
#define HIGH_PRECISION`:et.precision==="mediump"?_+=`
#define MEDIUM_PRECISION`:et.precision==="lowp"&&(_+=`
#define LOW_PRECISION`),_}function generateShadowMapTypeDefine(et){let _="SHADOWMAP_TYPE_BASIC";return et.shadowMapType===PCFShadowMap?_="SHADOWMAP_TYPE_PCF":et.shadowMapType===PCFSoftShadowMap?_="SHADOWMAP_TYPE_PCF_SOFT":et.shadowMapType===VSMShadowMap&&(_="SHADOWMAP_TYPE_VSM"),_}function generateEnvMapTypeDefine(et){let _="ENVMAP_TYPE_CUBE";if(et.envMap)switch(et.envMapMode){case CubeReflectionMapping:case CubeRefractionMapping:_="ENVMAP_TYPE_CUBE";break;case CubeUVReflectionMapping:_="ENVMAP_TYPE_CUBE_UV";break}return _}function generateEnvMapModeDefine(et){let _="ENVMAP_MODE_REFLECTION";if(et.envMap)switch(et.envMapMode){case CubeRefractionMapping:_="ENVMAP_MODE_REFRACTION";break}return _}function generateEnvMapBlendingDefine(et){let _="ENVMAP_BLENDING_NONE";if(et.envMap)switch(et.combine){case MultiplyOperation:_="ENVMAP_BLENDING_MULTIPLY";break;case MixOperation:_="ENVMAP_BLENDING_MIX";break;case AddOperation:_="ENVMAP_BLENDING_ADD";break}return _}function generateCubeUVSize(et){const _=et.envMapCubeUVHeight;if(_===null)return null;const _e=Math.log2(_)-2,tt=1/_;return{texelWidth:1/(3*Math.max(Math.pow(2,_e),7*16)),texelHeight:tt,maxMip:_e}}function WebGLProgram(et,_,_e,tt){const nt=et.getContext(),rt=_e.defines;let ot=_e.vertexShader,at=_e.fragmentShader;const lt=generateShadowMapTypeDefine(_e),ut=generateEnvMapTypeDefine(_e),dt=generateEnvMapModeDefine(_e),st=generateEnvMapBlendingDefine(_e),it=generateCubeUVSize(_e),ct=generateVertexExtensions(_e),ft=generateDefines(rt),ht=nt.createProgram();let mt,pt,_t=_e.glslVersion?"#version "+_e.glslVersion+`
`:"";_e.isRawShaderMaterial?(mt=["#define SHADER_TYPE "+_e.shaderType,"#define SHADER_NAME "+_e.shaderName,ft].filter(filterEmptyLine).join(`
`),mt.length>0&&(mt+=`
`),pt=["#define SHADER_TYPE "+_e.shaderType,"#define SHADER_NAME "+_e.shaderName,ft].filter(filterEmptyLine).join(`
`),pt.length>0&&(pt+=`
`)):(mt=[generatePrecision(_e),"#define SHADER_TYPE "+_e.shaderType,"#define SHADER_NAME "+_e.shaderName,ft,_e.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",_e.batching?"#define USE_BATCHING":"",_e.batchingColor?"#define USE_BATCHING_COLOR":"",_e.instancing?"#define USE_INSTANCING":"",_e.instancingColor?"#define USE_INSTANCING_COLOR":"",_e.instancingMorph?"#define USE_INSTANCING_MORPH":"",_e.useFog&&_e.fog?"#define USE_FOG":"",_e.useFog&&_e.fogExp2?"#define FOG_EXP2":"",_e.map?"#define USE_MAP":"",_e.envMap?"#define USE_ENVMAP":"",_e.envMap?"#define "+dt:"",_e.lightMap?"#define USE_LIGHTMAP":"",_e.aoMap?"#define USE_AOMAP":"",_e.bumpMap?"#define USE_BUMPMAP":"",_e.normalMap?"#define USE_NORMALMAP":"",_e.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",_e.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",_e.displacementMap?"#define USE_DISPLACEMENTMAP":"",_e.emissiveMap?"#define USE_EMISSIVEMAP":"",_e.anisotropy?"#define USE_ANISOTROPY":"",_e.anisotropyMap?"#define USE_ANISOTROPYMAP":"",_e.clearcoatMap?"#define USE_CLEARCOATMAP":"",_e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",_e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",_e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",_e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",_e.specularMap?"#define USE_SPECULARMAP":"",_e.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",_e.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",_e.roughnessMap?"#define USE_ROUGHNESSMAP":"",_e.metalnessMap?"#define USE_METALNESSMAP":"",_e.alphaMap?"#define USE_ALPHAMAP":"",_e.alphaHash?"#define USE_ALPHAHASH":"",_e.transmission?"#define USE_TRANSMISSION":"",_e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",_e.thicknessMap?"#define USE_THICKNESSMAP":"",_e.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",_e.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",_e.mapUv?"#define MAP_UV "+_e.mapUv:"",_e.alphaMapUv?"#define ALPHAMAP_UV "+_e.alphaMapUv:"",_e.lightMapUv?"#define LIGHTMAP_UV "+_e.lightMapUv:"",_e.aoMapUv?"#define AOMAP_UV "+_e.aoMapUv:"",_e.emissiveMapUv?"#define EMISSIVEMAP_UV "+_e.emissiveMapUv:"",_e.bumpMapUv?"#define BUMPMAP_UV "+_e.bumpMapUv:"",_e.normalMapUv?"#define NORMALMAP_UV "+_e.normalMapUv:"",_e.displacementMapUv?"#define DISPLACEMENTMAP_UV "+_e.displacementMapUv:"",_e.metalnessMapUv?"#define METALNESSMAP_UV "+_e.metalnessMapUv:"",_e.roughnessMapUv?"#define ROUGHNESSMAP_UV "+_e.roughnessMapUv:"",_e.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+_e.anisotropyMapUv:"",_e.clearcoatMapUv?"#define CLEARCOATMAP_UV "+_e.clearcoatMapUv:"",_e.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+_e.clearcoatNormalMapUv:"",_e.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+_e.clearcoatRoughnessMapUv:"",_e.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+_e.iridescenceMapUv:"",_e.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+_e.iridescenceThicknessMapUv:"",_e.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+_e.sheenColorMapUv:"",_e.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+_e.sheenRoughnessMapUv:"",_e.specularMapUv?"#define SPECULARMAP_UV "+_e.specularMapUv:"",_e.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+_e.specularColorMapUv:"",_e.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+_e.specularIntensityMapUv:"",_e.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+_e.transmissionMapUv:"",_e.thicknessMapUv?"#define THICKNESSMAP_UV "+_e.thicknessMapUv:"",_e.vertexTangents&&_e.flatShading===!1?"#define USE_TANGENT":"",_e.vertexColors?"#define USE_COLOR":"",_e.vertexAlphas?"#define USE_COLOR_ALPHA":"",_e.vertexUv1s?"#define USE_UV1":"",_e.vertexUv2s?"#define USE_UV2":"",_e.vertexUv3s?"#define USE_UV3":"",_e.pointsUvs?"#define USE_POINTS_UV":"",_e.flatShading?"#define FLAT_SHADED":"",_e.skinning?"#define USE_SKINNING":"",_e.morphTargets?"#define USE_MORPHTARGETS":"",_e.morphNormals&&_e.flatShading===!1?"#define USE_MORPHNORMALS":"",_e.morphColors?"#define USE_MORPHCOLORS":"",_e.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+_e.morphTextureStride:"",_e.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+_e.morphTargetsCount:"",_e.doubleSided?"#define DOUBLE_SIDED":"",_e.flipSided?"#define FLIP_SIDED":"",_e.shadowMapEnabled?"#define USE_SHADOWMAP":"",_e.shadowMapEnabled?"#define "+lt:"",_e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",_e.numLightProbes>0?"#define USE_LIGHT_PROBES":"",_e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(filterEmptyLine).join(`
`),pt=[generatePrecision(_e),"#define SHADER_TYPE "+_e.shaderType,"#define SHADER_NAME "+_e.shaderName,ft,_e.useFog&&_e.fog?"#define USE_FOG":"",_e.useFog&&_e.fogExp2?"#define FOG_EXP2":"",_e.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",_e.map?"#define USE_MAP":"",_e.matcap?"#define USE_MATCAP":"",_e.envMap?"#define USE_ENVMAP":"",_e.envMap?"#define "+ut:"",_e.envMap?"#define "+dt:"",_e.envMap?"#define "+st:"",it?"#define CUBEUV_TEXEL_WIDTH "+it.texelWidth:"",it?"#define CUBEUV_TEXEL_HEIGHT "+it.texelHeight:"",it?"#define CUBEUV_MAX_MIP "+it.maxMip+".0":"",_e.lightMap?"#define USE_LIGHTMAP":"",_e.aoMap?"#define USE_AOMAP":"",_e.bumpMap?"#define USE_BUMPMAP":"",_e.normalMap?"#define USE_NORMALMAP":"",_e.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",_e.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",_e.emissiveMap?"#define USE_EMISSIVEMAP":"",_e.anisotropy?"#define USE_ANISOTROPY":"",_e.anisotropyMap?"#define USE_ANISOTROPYMAP":"",_e.clearcoat?"#define USE_CLEARCOAT":"",_e.clearcoatMap?"#define USE_CLEARCOATMAP":"",_e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",_e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",_e.dispersion?"#define USE_DISPERSION":"",_e.iridescence?"#define USE_IRIDESCENCE":"",_e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",_e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",_e.specularMap?"#define USE_SPECULARMAP":"",_e.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",_e.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",_e.roughnessMap?"#define USE_ROUGHNESSMAP":"",_e.metalnessMap?"#define USE_METALNESSMAP":"",_e.alphaMap?"#define USE_ALPHAMAP":"",_e.alphaTest?"#define USE_ALPHATEST":"",_e.alphaHash?"#define USE_ALPHAHASH":"",_e.sheen?"#define USE_SHEEN":"",_e.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",_e.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",_e.transmission?"#define USE_TRANSMISSION":"",_e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",_e.thicknessMap?"#define USE_THICKNESSMAP":"",_e.vertexTangents&&_e.flatShading===!1?"#define USE_TANGENT":"",_e.vertexColors||_e.instancingColor||_e.batchingColor?"#define USE_COLOR":"",_e.vertexAlphas?"#define USE_COLOR_ALPHA":"",_e.vertexUv1s?"#define USE_UV1":"",_e.vertexUv2s?"#define USE_UV2":"",_e.vertexUv3s?"#define USE_UV3":"",_e.pointsUvs?"#define USE_POINTS_UV":"",_e.gradientMap?"#define USE_GRADIENTMAP":"",_e.flatShading?"#define FLAT_SHADED":"",_e.doubleSided?"#define DOUBLE_SIDED":"",_e.flipSided?"#define FLIP_SIDED":"",_e.shadowMapEnabled?"#define USE_SHADOWMAP":"",_e.shadowMapEnabled?"#define "+lt:"",_e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",_e.numLightProbes>0?"#define USE_LIGHT_PROBES":"",_e.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",_e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",_e.toneMapping!==NoToneMapping?"#define TONE_MAPPING":"",_e.toneMapping!==NoToneMapping?ShaderChunk.tonemapping_pars_fragment:"",_e.toneMapping!==NoToneMapping?getToneMappingFunction("toneMapping",_e.toneMapping):"",_e.dithering?"#define DITHERING":"",_e.opaque?"#define OPAQUE":"",ShaderChunk.colorspace_pars_fragment,getTexelEncodingFunction("linearToOutputTexel",_e.outputColorSpace),_e.useDepthPacking?"#define DEPTH_PACKING "+_e.depthPacking:"",`
`].filter(filterEmptyLine).join(`
`)),ot=resolveIncludes(ot),ot=replaceLightNums(ot,_e),ot=replaceClippingPlaneNums(ot,_e),at=resolveIncludes(at),at=replaceLightNums(at,_e),at=replaceClippingPlaneNums(at,_e),ot=unrollLoops(ot),at=unrollLoops(at),_e.isRawShaderMaterial!==!0&&(_t=`#version 300 es
`,mt=[ct,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+mt,pt=["#define varying in",_e.glslVersion===GLSL3?"":"layout(location = 0) out highp vec4 pc_fragColor;",_e.glslVersion===GLSL3?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+pt);const vt=_t+mt+ot,bt=_t+pt+at,wt=WebGLShader(nt,nt.VERTEX_SHADER,vt),xt=WebGLShader(nt,nt.FRAGMENT_SHADER,bt);nt.attachShader(ht,wt),nt.attachShader(ht,xt),_e.index0AttributeName!==void 0?nt.bindAttribLocation(ht,0,_e.index0AttributeName):_e.morphTargets===!0&&nt.bindAttribLocation(ht,0,"position"),nt.linkProgram(ht);function Mt(Ct){if(et.debug.checkShaderErrors){const It=nt.getProgramInfoLog(ht).trim(),$t=nt.getShaderInfoLog(wt).trim(),Nt=nt.getShaderInfoLog(xt).trim();let Bt=!0,Ot=!0;if(nt.getProgramParameter(ht,nt.LINK_STATUS)===!1)if(Bt=!1,typeof et.debug.onShaderError=="function")et.debug.onShaderError(nt,ht,wt,xt);else{const Ut=getShaderErrors(nt,wt,"vertex"),Lt=getShaderErrors(nt,xt,"fragment");console.error("THREE.WebGLProgram: Shader Error "+nt.getError()+" - VALIDATE_STATUS "+nt.getProgramParameter(ht,nt.VALIDATE_STATUS)+`

Material Name: `+Ct.name+`
Material Type: `+Ct.type+`

Program Info Log: `+It+`
`+Ut+`
`+Lt)}else It!==""?console.warn("THREE.WebGLProgram: Program Info Log:",It):($t===""||Nt==="")&&(Ot=!1);Ot&&(Ct.diagnostics={runnable:Bt,programLog:It,vertexShader:{log:$t,prefix:mt},fragmentShader:{log:Nt,prefix:pt}})}nt.deleteShader(wt),nt.deleteShader(xt),At=new WebGLUniforms(nt,ht),St=fetchAttributeLocations(nt,ht)}let At;this.getUniforms=function(){return At===void 0&&Mt(this),At};let St;this.getAttributes=function(){return St===void 0&&Mt(this),St};let Tt=_e.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return Tt===!1&&(Tt=nt.getProgramParameter(ht,COMPLETION_STATUS_KHR)),Tt},this.destroy=function(){tt.releaseStatesOfProgram(this),nt.deleteProgram(ht),this.program=void 0},this.type=_e.shaderType,this.name=_e.shaderName,this.id=programIdCount++,this.cacheKey=_,this.usedTimes=1,this.program=ht,this.vertexShader=wt,this.fragmentShader=xt,this}let _id$1=0;class WebGLShaderCache{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(_){const _e=_.vertexShader,tt=_.fragmentShader,nt=this._getShaderStage(_e),rt=this._getShaderStage(tt),ot=this._getShaderCacheForMaterial(_);return ot.has(nt)===!1&&(ot.add(nt),nt.usedTimes++),ot.has(rt)===!1&&(ot.add(rt),rt.usedTimes++),this}remove(_){const _e=this.materialCache.get(_);for(const tt of _e)tt.usedTimes--,tt.usedTimes===0&&this.shaderCache.delete(tt.code);return this.materialCache.delete(_),this}getVertexShaderID(_){return this._getShaderStage(_.vertexShader).id}getFragmentShaderID(_){return this._getShaderStage(_.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(_){const _e=this.materialCache;let tt=_e.get(_);return tt===void 0&&(tt=new Set,_e.set(_,tt)),tt}_getShaderStage(_){const _e=this.shaderCache;let tt=_e.get(_);return tt===void 0&&(tt=new WebGLShaderStage(_),_e.set(_,tt)),tt}}class WebGLShaderStage{constructor(_){this.id=_id$1++,this.code=_,this.usedTimes=0}}function WebGLPrograms(et,_,_e,tt,nt,rt,ot){const at=new Layers,lt=new WebGLShaderCache,ut=new Set,dt=[],st=nt.logarithmicDepthBuffer,it=nt.vertexTextures;let ct=nt.precision;const ft={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function ht(St){return ut.add(St),St===0?"uv":`uv${St}`}function mt(St,Tt,Ct,It,$t){const Nt=It.fog,Bt=$t.geometry,Ot=St.isMeshStandardMaterial?It.environment:null,Ut=(St.isMeshStandardMaterial?_e:_).get(St.envMap||Ot),Lt=Ut&&Ut.mapping===CubeUVReflectionMapping?Ut.image.height:null,zt=ft[St.type];St.precision!==null&&(ct=nt.getMaxPrecision(St.precision),ct!==St.precision&&console.warn("THREE.WebGLProgram.getParameters:",St.precision,"not supported, using",ct,"instead."));const Yt=Bt.morphAttributes.position||Bt.morphAttributes.normal||Bt.morphAttributes.color,en=Yt!==void 0?Yt.length:0;let bn=0;Bt.morphAttributes.position!==void 0&&(bn=1),Bt.morphAttributes.normal!==void 0&&(bn=2),Bt.morphAttributes.color!==void 0&&(bn=3);let Un,mn,vn,In;if(zt){const wr=ShaderLib[zt];Un=wr.vertexShader,mn=wr.fragmentShader}else Un=St.vertexShader,mn=St.fragmentShader,lt.update(St),vn=lt.getVertexShaderID(St),In=lt.getFragmentShaderID(St);const Cn=et.getRenderTarget(),En=$t.isInstancedMesh===!0,jt=$t.isBatchedMesh===!0,Kt=!!St.map,nn=!!St.matcap,Vt=!!Ut,on=!!St.aoMap,dn=!!St.lightMap,Ln=!!St.bumpMap,Sn=!!St.normalMap,Xn=!!St.displacementMap,Vn=!!St.emissiveMap,Hn=!!St.metalnessMap,Zt=!!St.roughnessMap,Gt=St.anisotropy>0,fn=St.clearcoat>0,hn=St.dispersion>0,xn=St.iridescence>0,Tn=St.sheen>0,sr=St.transmission>0,Wn=Gt&&!!St.anisotropyMap,or=fn&&!!St.clearcoatMap,fr=fn&&!!St.clearcoatNormalMap,Gn=fn&&!!St.clearcoatRoughnessMap,nr=xn&&!!St.iridescenceMap,mr=xn&&!!St.iridescenceThicknessMap,hr=Tn&&!!St.sheenColorMap,Bn=Tn&&!!St.sheenRoughnessMap,cn=!!St.specularMap,Fn=!!St.specularColorMap,ir=!!St.specularIntensityMap,ln=sr&&!!St.transmissionMap,On=sr&&!!St.thicknessMap,Dn=!!St.gradientMap,$n=!!St.alphaMap,Jn=St.alphaTest>0,qn=!!St.alphaHash,Kn=!!St.extensions;let ar=NoToneMapping;St.toneMapped&&(Cn===null||Cn.isXRRenderTarget===!0)&&(ar=et.toneMapping);const Ur={shaderID:zt,shaderType:St.type,shaderName:St.name,vertexShader:Un,fragmentShader:mn,defines:St.defines,customVertexShaderID:vn,customFragmentShaderID:In,isRawShaderMaterial:St.isRawShaderMaterial===!0,glslVersion:St.glslVersion,precision:ct,batching:jt,batchingColor:jt&&$t._colorsTexture!==null,instancing:En,instancingColor:En&&$t.instanceColor!==null,instancingMorph:En&&$t.morphTexture!==null,supportsVertexTextures:it,outputColorSpace:Cn===null?et.outputColorSpace:Cn.isXRRenderTarget===!0?Cn.texture.colorSpace:LinearSRGBColorSpace,alphaToCoverage:!!St.alphaToCoverage,map:Kt,matcap:nn,envMap:Vt,envMapMode:Vt&&Ut.mapping,envMapCubeUVHeight:Lt,aoMap:on,lightMap:dn,bumpMap:Ln,normalMap:Sn,displacementMap:it&&Xn,emissiveMap:Vn,normalMapObjectSpace:Sn&&St.normalMapType===ObjectSpaceNormalMap,normalMapTangentSpace:Sn&&St.normalMapType===TangentSpaceNormalMap,metalnessMap:Hn,roughnessMap:Zt,anisotropy:Gt,anisotropyMap:Wn,clearcoat:fn,clearcoatMap:or,clearcoatNormalMap:fr,clearcoatRoughnessMap:Gn,dispersion:hn,iridescence:xn,iridescenceMap:nr,iridescenceThicknessMap:mr,sheen:Tn,sheenColorMap:hr,sheenRoughnessMap:Bn,specularMap:cn,specularColorMap:Fn,specularIntensityMap:ir,transmission:sr,transmissionMap:ln,thicknessMap:On,gradientMap:Dn,opaque:St.transparent===!1&&St.blending===NormalBlending&&St.alphaToCoverage===!1,alphaMap:$n,alphaTest:Jn,alphaHash:qn,combine:St.combine,mapUv:Kt&&ht(St.map.channel),aoMapUv:on&&ht(St.aoMap.channel),lightMapUv:dn&&ht(St.lightMap.channel),bumpMapUv:Ln&&ht(St.bumpMap.channel),normalMapUv:Sn&&ht(St.normalMap.channel),displacementMapUv:Xn&&ht(St.displacementMap.channel),emissiveMapUv:Vn&&ht(St.emissiveMap.channel),metalnessMapUv:Hn&&ht(St.metalnessMap.channel),roughnessMapUv:Zt&&ht(St.roughnessMap.channel),anisotropyMapUv:Wn&&ht(St.anisotropyMap.channel),clearcoatMapUv:or&&ht(St.clearcoatMap.channel),clearcoatNormalMapUv:fr&&ht(St.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:Gn&&ht(St.clearcoatRoughnessMap.channel),iridescenceMapUv:nr&&ht(St.iridescenceMap.channel),iridescenceThicknessMapUv:mr&&ht(St.iridescenceThicknessMap.channel),sheenColorMapUv:hr&&ht(St.sheenColorMap.channel),sheenRoughnessMapUv:Bn&&ht(St.sheenRoughnessMap.channel),specularMapUv:cn&&ht(St.specularMap.channel),specularColorMapUv:Fn&&ht(St.specularColorMap.channel),specularIntensityMapUv:ir&&ht(St.specularIntensityMap.channel),transmissionMapUv:ln&&ht(St.transmissionMap.channel),thicknessMapUv:On&&ht(St.thicknessMap.channel),alphaMapUv:$n&&ht(St.alphaMap.channel),vertexTangents:!!Bt.attributes.tangent&&(Sn||Gt),vertexColors:St.vertexColors,vertexAlphas:St.vertexColors===!0&&!!Bt.attributes.color&&Bt.attributes.color.itemSize===4,pointsUvs:$t.isPoints===!0&&!!Bt.attributes.uv&&(Kt||$n),fog:!!Nt,useFog:St.fog===!0,fogExp2:!!Nt&&Nt.isFogExp2,flatShading:St.flatShading===!0,sizeAttenuation:St.sizeAttenuation===!0,logarithmicDepthBuffer:st,skinning:$t.isSkinnedMesh===!0,morphTargets:Bt.morphAttributes.position!==void 0,morphNormals:Bt.morphAttributes.normal!==void 0,morphColors:Bt.morphAttributes.color!==void 0,morphTargetsCount:en,morphTextureStride:bn,numDirLights:Tt.directional.length,numPointLights:Tt.point.length,numSpotLights:Tt.spot.length,numSpotLightMaps:Tt.spotLightMap.length,numRectAreaLights:Tt.rectArea.length,numHemiLights:Tt.hemi.length,numDirLightShadows:Tt.directionalShadowMap.length,numPointLightShadows:Tt.pointShadowMap.length,numSpotLightShadows:Tt.spotShadowMap.length,numSpotLightShadowsWithMaps:Tt.numSpotLightShadowsWithMaps,numLightProbes:Tt.numLightProbes,numClippingPlanes:ot.numPlanes,numClipIntersection:ot.numIntersection,dithering:St.dithering,shadowMapEnabled:et.shadowMap.enabled&&Ct.length>0,shadowMapType:et.shadowMap.type,toneMapping:ar,decodeVideoTexture:Kt&&St.map.isVideoTexture===!0&&ColorManagement.getTransfer(St.map.colorSpace)===SRGBTransfer,premultipliedAlpha:St.premultipliedAlpha,doubleSided:St.side===DoubleSide,flipSided:St.side===BackSide,useDepthPacking:St.depthPacking>=0,depthPacking:St.depthPacking||0,index0AttributeName:St.index0AttributeName,extensionClipCullDistance:Kn&&St.extensions.clipCullDistance===!0&&tt.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(Kn&&St.extensions.multiDraw===!0||jt)&&tt.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:tt.has("KHR_parallel_shader_compile"),customProgramCacheKey:St.customProgramCacheKey()};return Ur.vertexUv1s=ut.has(1),Ur.vertexUv2s=ut.has(2),Ur.vertexUv3s=ut.has(3),ut.clear(),Ur}function pt(St){const Tt=[];if(St.shaderID?Tt.push(St.shaderID):(Tt.push(St.customVertexShaderID),Tt.push(St.customFragmentShaderID)),St.defines!==void 0)for(const Ct in St.defines)Tt.push(Ct),Tt.push(St.defines[Ct]);return St.isRawShaderMaterial===!1&&(_t(Tt,St),vt(Tt,St),Tt.push(et.outputColorSpace)),Tt.push(St.customProgramCacheKey),Tt.join()}function _t(St,Tt){St.push(Tt.precision),St.push(Tt.outputColorSpace),St.push(Tt.envMapMode),St.push(Tt.envMapCubeUVHeight),St.push(Tt.mapUv),St.push(Tt.alphaMapUv),St.push(Tt.lightMapUv),St.push(Tt.aoMapUv),St.push(Tt.bumpMapUv),St.push(Tt.normalMapUv),St.push(Tt.displacementMapUv),St.push(Tt.emissiveMapUv),St.push(Tt.metalnessMapUv),St.push(Tt.roughnessMapUv),St.push(Tt.anisotropyMapUv),St.push(Tt.clearcoatMapUv),St.push(Tt.clearcoatNormalMapUv),St.push(Tt.clearcoatRoughnessMapUv),St.push(Tt.iridescenceMapUv),St.push(Tt.iridescenceThicknessMapUv),St.push(Tt.sheenColorMapUv),St.push(Tt.sheenRoughnessMapUv),St.push(Tt.specularMapUv),St.push(Tt.specularColorMapUv),St.push(Tt.specularIntensityMapUv),St.push(Tt.transmissionMapUv),St.push(Tt.thicknessMapUv),St.push(Tt.combine),St.push(Tt.fogExp2),St.push(Tt.sizeAttenuation),St.push(Tt.morphTargetsCount),St.push(Tt.morphAttributeCount),St.push(Tt.numDirLights),St.push(Tt.numPointLights),St.push(Tt.numSpotLights),St.push(Tt.numSpotLightMaps),St.push(Tt.numHemiLights),St.push(Tt.numRectAreaLights),St.push(Tt.numDirLightShadows),St.push(Tt.numPointLightShadows),St.push(Tt.numSpotLightShadows),St.push(Tt.numSpotLightShadowsWithMaps),St.push(Tt.numLightProbes),St.push(Tt.shadowMapType),St.push(Tt.toneMapping),St.push(Tt.numClippingPlanes),St.push(Tt.numClipIntersection),St.push(Tt.depthPacking)}function vt(St,Tt){at.disableAll(),Tt.supportsVertexTextures&&at.enable(0),Tt.instancing&&at.enable(1),Tt.instancingColor&&at.enable(2),Tt.instancingMorph&&at.enable(3),Tt.matcap&&at.enable(4),Tt.envMap&&at.enable(5),Tt.normalMapObjectSpace&&at.enable(6),Tt.normalMapTangentSpace&&at.enable(7),Tt.clearcoat&&at.enable(8),Tt.iridescence&&at.enable(9),Tt.alphaTest&&at.enable(10),Tt.vertexColors&&at.enable(11),Tt.vertexAlphas&&at.enable(12),Tt.vertexUv1s&&at.enable(13),Tt.vertexUv2s&&at.enable(14),Tt.vertexUv3s&&at.enable(15),Tt.vertexTangents&&at.enable(16),Tt.anisotropy&&at.enable(17),Tt.alphaHash&&at.enable(18),Tt.batching&&at.enable(19),Tt.dispersion&&at.enable(20),Tt.batchingColor&&at.enable(21),St.push(at.mask),at.disableAll(),Tt.fog&&at.enable(0),Tt.useFog&&at.enable(1),Tt.flatShading&&at.enable(2),Tt.logarithmicDepthBuffer&&at.enable(3),Tt.skinning&&at.enable(4),Tt.morphTargets&&at.enable(5),Tt.morphNormals&&at.enable(6),Tt.morphColors&&at.enable(7),Tt.premultipliedAlpha&&at.enable(8),Tt.shadowMapEnabled&&at.enable(9),Tt.doubleSided&&at.enable(10),Tt.flipSided&&at.enable(11),Tt.useDepthPacking&&at.enable(12),Tt.dithering&&at.enable(13),Tt.transmission&&at.enable(14),Tt.sheen&&at.enable(15),Tt.opaque&&at.enable(16),Tt.pointsUvs&&at.enable(17),Tt.decodeVideoTexture&&at.enable(18),Tt.alphaToCoverage&&at.enable(19),St.push(at.mask)}function bt(St){const Tt=ft[St.type];let Ct;if(Tt){const It=ShaderLib[Tt];Ct=UniformsUtils.clone(It.uniforms)}else Ct=St.uniforms;return Ct}function wt(St,Tt){let Ct;for(let It=0,$t=dt.length;It<$t;It++){const Nt=dt[It];if(Nt.cacheKey===Tt){Ct=Nt,++Ct.usedTimes;break}}return Ct===void 0&&(Ct=new WebGLProgram(et,Tt,St,rt),dt.push(Ct)),Ct}function xt(St){if(--St.usedTimes===0){const Tt=dt.indexOf(St);dt[Tt]=dt[dt.length-1],dt.pop(),St.destroy()}}function Mt(St){lt.remove(St)}function At(){lt.dispose()}return{getParameters:mt,getProgramCacheKey:pt,getUniforms:bt,acquireProgram:wt,releaseProgram:xt,releaseShaderCache:Mt,programs:dt,dispose:At}}function WebGLProperties(){let et=new WeakMap;function _(rt){let ot=et.get(rt);return ot===void 0&&(ot={},et.set(rt,ot)),ot}function _e(rt){et.delete(rt)}function tt(rt,ot,at){et.get(rt)[ot]=at}function nt(){et=new WeakMap}return{get:_,remove:_e,update:tt,dispose:nt}}function painterSortStable(et,_){return et.groupOrder!==_.groupOrder?et.groupOrder-_.groupOrder:et.renderOrder!==_.renderOrder?et.renderOrder-_.renderOrder:et.material.id!==_.material.id?et.material.id-_.material.id:et.z!==_.z?et.z-_.z:et.id-_.id}function reversePainterSortStable(et,_){return et.groupOrder!==_.groupOrder?et.groupOrder-_.groupOrder:et.renderOrder!==_.renderOrder?et.renderOrder-_.renderOrder:et.z!==_.z?_.z-et.z:et.id-_.id}function WebGLRenderList(){const et=[];let _=0;const _e=[],tt=[],nt=[];function rt(){_=0,_e.length=0,tt.length=0,nt.length=0}function ot(st,it,ct,ft,ht,mt){let pt=et[_];return pt===void 0?(pt={id:st.id,object:st,geometry:it,material:ct,groupOrder:ft,renderOrder:st.renderOrder,z:ht,group:mt},et[_]=pt):(pt.id=st.id,pt.object=st,pt.geometry=it,pt.material=ct,pt.groupOrder=ft,pt.renderOrder=st.renderOrder,pt.z=ht,pt.group=mt),_++,pt}function at(st,it,ct,ft,ht,mt){const pt=ot(st,it,ct,ft,ht,mt);ct.transmission>0?tt.push(pt):ct.transparent===!0?nt.push(pt):_e.push(pt)}function lt(st,it,ct,ft,ht,mt){const pt=ot(st,it,ct,ft,ht,mt);ct.transmission>0?tt.unshift(pt):ct.transparent===!0?nt.unshift(pt):_e.unshift(pt)}function ut(st,it){_e.length>1&&_e.sort(st||painterSortStable),tt.length>1&&tt.sort(it||reversePainterSortStable),nt.length>1&&nt.sort(it||reversePainterSortStable)}function dt(){for(let st=_,it=et.length;st<it;st++){const ct=et[st];if(ct.id===null)break;ct.id=null,ct.object=null,ct.geometry=null,ct.material=null,ct.group=null}}return{opaque:_e,transmissive:tt,transparent:nt,init:rt,push:at,unshift:lt,finish:dt,sort:ut}}function WebGLRenderLists(){let et=new WeakMap;function _(tt,nt){const rt=et.get(tt);let ot;return rt===void 0?(ot=new WebGLRenderList,et.set(tt,[ot])):nt>=rt.length?(ot=new WebGLRenderList,rt.push(ot)):ot=rt[nt],ot}function _e(){et=new WeakMap}return{get:_,dispose:_e}}function UniformsCache(){const et={};return{get:function(_){if(et[_.id]!==void 0)return et[_.id];let _e;switch(_.type){case"DirectionalLight":_e={direction:new Vector3,color:new Color$1};break;case"SpotLight":_e={position:new Vector3,direction:new Vector3,color:new Color$1,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":_e={position:new Vector3,color:new Color$1,distance:0,decay:0};break;case"HemisphereLight":_e={direction:new Vector3,skyColor:new Color$1,groundColor:new Color$1};break;case"RectAreaLight":_e={color:new Color$1,position:new Vector3,halfWidth:new Vector3,halfHeight:new Vector3};break}return et[_.id]=_e,_e}}}function ShadowUniformsCache(){const et={};return{get:function(_){if(et[_.id]!==void 0)return et[_.id];let _e;switch(_.type){case"DirectionalLight":_e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case"SpotLight":_e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case"PointLight":_e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2,shadowCameraNear:1,shadowCameraFar:1e3};break}return et[_.id]=_e,_e}}}let nextVersion=0;function shadowCastingAndTexturingLightsFirst(et,_){return(_.castShadow?2:0)-(et.castShadow?2:0)+(_.map?1:0)-(et.map?1:0)}function WebGLLights(et){const _=new UniformsCache,_e=ShadowUniformsCache(),tt={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let ut=0;ut<9;ut++)tt.probe.push(new Vector3);const nt=new Vector3,rt=new Matrix4,ot=new Matrix4;function at(ut){let dt=0,st=0,it=0;for(let St=0;St<9;St++)tt.probe[St].set(0,0,0);let ct=0,ft=0,ht=0,mt=0,pt=0,_t=0,vt=0,bt=0,wt=0,xt=0,Mt=0;ut.sort(shadowCastingAndTexturingLightsFirst);for(let St=0,Tt=ut.length;St<Tt;St++){const Ct=ut[St],It=Ct.color,$t=Ct.intensity,Nt=Ct.distance,Bt=Ct.shadow&&Ct.shadow.map?Ct.shadow.map.texture:null;if(Ct.isAmbientLight)dt+=It.r*$t,st+=It.g*$t,it+=It.b*$t;else if(Ct.isLightProbe){for(let Ot=0;Ot<9;Ot++)tt.probe[Ot].addScaledVector(Ct.sh.coefficients[Ot],$t);Mt++}else if(Ct.isDirectionalLight){const Ot=_.get(Ct);if(Ot.color.copy(Ct.color).multiplyScalar(Ct.intensity),Ct.castShadow){const Ut=Ct.shadow,Lt=_e.get(Ct);Lt.shadowIntensity=Ut.intensity,Lt.shadowBias=Ut.bias,Lt.shadowNormalBias=Ut.normalBias,Lt.shadowRadius=Ut.radius,Lt.shadowMapSize=Ut.mapSize,tt.directionalShadow[ct]=Lt,tt.directionalShadowMap[ct]=Bt,tt.directionalShadowMatrix[ct]=Ct.shadow.matrix,_t++}tt.directional[ct]=Ot,ct++}else if(Ct.isSpotLight){const Ot=_.get(Ct);Ot.position.setFromMatrixPosition(Ct.matrixWorld),Ot.color.copy(It).multiplyScalar($t),Ot.distance=Nt,Ot.coneCos=Math.cos(Ct.angle),Ot.penumbraCos=Math.cos(Ct.angle*(1-Ct.penumbra)),Ot.decay=Ct.decay,tt.spot[ht]=Ot;const Ut=Ct.shadow;if(Ct.map&&(tt.spotLightMap[wt]=Ct.map,wt++,Ut.updateMatrices(Ct),Ct.castShadow&&xt++),tt.spotLightMatrix[ht]=Ut.matrix,Ct.castShadow){const Lt=_e.get(Ct);Lt.shadowIntensity=Ut.intensity,Lt.shadowBias=Ut.bias,Lt.shadowNormalBias=Ut.normalBias,Lt.shadowRadius=Ut.radius,Lt.shadowMapSize=Ut.mapSize,tt.spotShadow[ht]=Lt,tt.spotShadowMap[ht]=Bt,bt++}ht++}else if(Ct.isRectAreaLight){const Ot=_.get(Ct);Ot.color.copy(It).multiplyScalar($t),Ot.halfWidth.set(Ct.width*.5,0,0),Ot.halfHeight.set(0,Ct.height*.5,0),tt.rectArea[mt]=Ot,mt++}else if(Ct.isPointLight){const Ot=_.get(Ct);if(Ot.color.copy(Ct.color).multiplyScalar(Ct.intensity),Ot.distance=Ct.distance,Ot.decay=Ct.decay,Ct.castShadow){const Ut=Ct.shadow,Lt=_e.get(Ct);Lt.shadowIntensity=Ut.intensity,Lt.shadowBias=Ut.bias,Lt.shadowNormalBias=Ut.normalBias,Lt.shadowRadius=Ut.radius,Lt.shadowMapSize=Ut.mapSize,Lt.shadowCameraNear=Ut.camera.near,Lt.shadowCameraFar=Ut.camera.far,tt.pointShadow[ft]=Lt,tt.pointShadowMap[ft]=Bt,tt.pointShadowMatrix[ft]=Ct.shadow.matrix,vt++}tt.point[ft]=Ot,ft++}else if(Ct.isHemisphereLight){const Ot=_.get(Ct);Ot.skyColor.copy(Ct.color).multiplyScalar($t),Ot.groundColor.copy(Ct.groundColor).multiplyScalar($t),tt.hemi[pt]=Ot,pt++}}mt>0&&(et.has("OES_texture_float_linear")===!0?(tt.rectAreaLTC1=UniformsLib.LTC_FLOAT_1,tt.rectAreaLTC2=UniformsLib.LTC_FLOAT_2):(tt.rectAreaLTC1=UniformsLib.LTC_HALF_1,tt.rectAreaLTC2=UniformsLib.LTC_HALF_2)),tt.ambient[0]=dt,tt.ambient[1]=st,tt.ambient[2]=it;const At=tt.hash;(At.directionalLength!==ct||At.pointLength!==ft||At.spotLength!==ht||At.rectAreaLength!==mt||At.hemiLength!==pt||At.numDirectionalShadows!==_t||At.numPointShadows!==vt||At.numSpotShadows!==bt||At.numSpotMaps!==wt||At.numLightProbes!==Mt)&&(tt.directional.length=ct,tt.spot.length=ht,tt.rectArea.length=mt,tt.point.length=ft,tt.hemi.length=pt,tt.directionalShadow.length=_t,tt.directionalShadowMap.length=_t,tt.pointShadow.length=vt,tt.pointShadowMap.length=vt,tt.spotShadow.length=bt,tt.spotShadowMap.length=bt,tt.directionalShadowMatrix.length=_t,tt.pointShadowMatrix.length=vt,tt.spotLightMatrix.length=bt+wt-xt,tt.spotLightMap.length=wt,tt.numSpotLightShadowsWithMaps=xt,tt.numLightProbes=Mt,At.directionalLength=ct,At.pointLength=ft,At.spotLength=ht,At.rectAreaLength=mt,At.hemiLength=pt,At.numDirectionalShadows=_t,At.numPointShadows=vt,At.numSpotShadows=bt,At.numSpotMaps=wt,At.numLightProbes=Mt,tt.version=nextVersion++)}function lt(ut,dt){let st=0,it=0,ct=0,ft=0,ht=0;const mt=dt.matrixWorldInverse;for(let pt=0,_t=ut.length;pt<_t;pt++){const vt=ut[pt];if(vt.isDirectionalLight){const bt=tt.directional[st];bt.direction.setFromMatrixPosition(vt.matrixWorld),nt.setFromMatrixPosition(vt.target.matrixWorld),bt.direction.sub(nt),bt.direction.transformDirection(mt),st++}else if(vt.isSpotLight){const bt=tt.spot[ct];bt.position.setFromMatrixPosition(vt.matrixWorld),bt.position.applyMatrix4(mt),bt.direction.setFromMatrixPosition(vt.matrixWorld),nt.setFromMatrixPosition(vt.target.matrixWorld),bt.direction.sub(nt),bt.direction.transformDirection(mt),ct++}else if(vt.isRectAreaLight){const bt=tt.rectArea[ft];bt.position.setFromMatrixPosition(vt.matrixWorld),bt.position.applyMatrix4(mt),ot.identity(),rt.copy(vt.matrixWorld),rt.premultiply(mt),ot.extractRotation(rt),bt.halfWidth.set(vt.width*.5,0,0),bt.halfHeight.set(0,vt.height*.5,0),bt.halfWidth.applyMatrix4(ot),bt.halfHeight.applyMatrix4(ot),ft++}else if(vt.isPointLight){const bt=tt.point[it];bt.position.setFromMatrixPosition(vt.matrixWorld),bt.position.applyMatrix4(mt),it++}else if(vt.isHemisphereLight){const bt=tt.hemi[ht];bt.direction.setFromMatrixPosition(vt.matrixWorld),bt.direction.transformDirection(mt),ht++}}}return{setup:at,setupView:lt,state:tt}}function WebGLRenderState(et){const _=new WebGLLights(et),_e=[],tt=[];function nt(dt){ut.camera=dt,_e.length=0,tt.length=0}function rt(dt){_e.push(dt)}function ot(dt){tt.push(dt)}function at(){_.setup(_e)}function lt(dt){_.setupView(_e,dt)}const ut={lightsArray:_e,shadowsArray:tt,camera:null,lights:_,transmissionRenderTarget:{}};return{init:nt,state:ut,setupLights:at,setupLightsView:lt,pushLight:rt,pushShadow:ot}}function WebGLRenderStates(et){let _=new WeakMap;function _e(nt,rt=0){const ot=_.get(nt);let at;return ot===void 0?(at=new WebGLRenderState(et),_.set(nt,[at])):rt>=ot.length?(at=new WebGLRenderState(et),ot.push(at)):at=ot[rt],at}function tt(){_=new WeakMap}return{get:_e,dispose:tt}}class MeshDepthMaterial extends Material{constructor(_){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=BasicDepthPacking,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(_)}copy(_){return super.copy(_),this.depthPacking=_.depthPacking,this.map=_.map,this.alphaMap=_.alphaMap,this.displacementMap=_.displacementMap,this.displacementScale=_.displacementScale,this.displacementBias=_.displacementBias,this.wireframe=_.wireframe,this.wireframeLinewidth=_.wireframeLinewidth,this}}class MeshDistanceMaterial extends Material{constructor(_){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(_)}copy(_){return super.copy(_),this.map=_.map,this.alphaMap=_.alphaMap,this.displacementMap=_.displacementMap,this.displacementScale=_.displacementScale,this.displacementBias=_.displacementBias,this}}const vertex=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,fragment=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function WebGLShadowMap(et,_,_e){let tt=new Frustum;const nt=new Vector2,rt=new Vector2,ot=new Vector4,at=new MeshDepthMaterial({depthPacking:RGBADepthPacking}),lt=new MeshDistanceMaterial,ut={},dt=_e.maxTextureSize,st={[FrontSide]:BackSide,[BackSide]:FrontSide,[DoubleSide]:DoubleSide},it=new ShaderMaterial({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Vector2},radius:{value:4}},vertexShader:vertex,fragmentShader:fragment}),ct=it.clone();ct.defines.HORIZONTAL_PASS=1;const ft=new BufferGeometry;ft.setAttribute("position",new BufferAttribute(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const ht=new Mesh(ft,it),mt=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=PCFShadowMap;let pt=this.type;this.render=function(xt,Mt,At){if(mt.enabled===!1||mt.autoUpdate===!1&&mt.needsUpdate===!1||xt.length===0)return;const St=et.getRenderTarget(),Tt=et.getActiveCubeFace(),Ct=et.getActiveMipmapLevel(),It=et.state;It.setBlending(NoBlending),It.buffers.color.setClear(1,1,1,1),It.buffers.depth.setTest(!0),It.setScissorTest(!1);const $t=pt!==VSMShadowMap&&this.type===VSMShadowMap,Nt=pt===VSMShadowMap&&this.type!==VSMShadowMap;for(let Bt=0,Ot=xt.length;Bt<Ot;Bt++){const Ut=xt[Bt],Lt=Ut.shadow;if(Lt===void 0){console.warn("THREE.WebGLShadowMap:",Ut,"has no shadow.");continue}if(Lt.autoUpdate===!1&&Lt.needsUpdate===!1)continue;nt.copy(Lt.mapSize);const zt=Lt.getFrameExtents();if(nt.multiply(zt),rt.copy(Lt.mapSize),(nt.x>dt||nt.y>dt)&&(nt.x>dt&&(rt.x=Math.floor(dt/zt.x),nt.x=rt.x*zt.x,Lt.mapSize.x=rt.x),nt.y>dt&&(rt.y=Math.floor(dt/zt.y),nt.y=rt.y*zt.y,Lt.mapSize.y=rt.y)),Lt.map===null||$t===!0||Nt===!0){const en=this.type!==VSMShadowMap?{minFilter:NearestFilter,magFilter:NearestFilter}:{};Lt.map!==null&&Lt.map.dispose(),Lt.map=new WebGLRenderTarget(nt.x,nt.y,en),Lt.map.texture.name=Ut.name+".shadowMap",Lt.camera.updateProjectionMatrix()}et.setRenderTarget(Lt.map),et.clear();const Yt=Lt.getViewportCount();for(let en=0;en<Yt;en++){const bn=Lt.getViewport(en);ot.set(rt.x*bn.x,rt.y*bn.y,rt.x*bn.z,rt.y*bn.w),It.viewport(ot),Lt.updateMatrices(Ut,en),tt=Lt.getFrustum(),bt(Mt,At,Lt.camera,Ut,this.type)}Lt.isPointLightShadow!==!0&&this.type===VSMShadowMap&&_t(Lt,At),Lt.needsUpdate=!1}pt=this.type,mt.needsUpdate=!1,et.setRenderTarget(St,Tt,Ct)};function _t(xt,Mt){const At=_.update(ht);it.defines.VSM_SAMPLES!==xt.blurSamples&&(it.defines.VSM_SAMPLES=xt.blurSamples,ct.defines.VSM_SAMPLES=xt.blurSamples,it.needsUpdate=!0,ct.needsUpdate=!0),xt.mapPass===null&&(xt.mapPass=new WebGLRenderTarget(nt.x,nt.y)),it.uniforms.shadow_pass.value=xt.map.texture,it.uniforms.resolution.value=xt.mapSize,it.uniforms.radius.value=xt.radius,et.setRenderTarget(xt.mapPass),et.clear(),et.renderBufferDirect(Mt,null,At,it,ht,null),ct.uniforms.shadow_pass.value=xt.mapPass.texture,ct.uniforms.resolution.value=xt.mapSize,ct.uniforms.radius.value=xt.radius,et.setRenderTarget(xt.map),et.clear(),et.renderBufferDirect(Mt,null,At,ct,ht,null)}function vt(xt,Mt,At,St){let Tt=null;const Ct=At.isPointLight===!0?xt.customDistanceMaterial:xt.customDepthMaterial;if(Ct!==void 0)Tt=Ct;else if(Tt=At.isPointLight===!0?lt:at,et.localClippingEnabled&&Mt.clipShadows===!0&&Array.isArray(Mt.clippingPlanes)&&Mt.clippingPlanes.length!==0||Mt.displacementMap&&Mt.displacementScale!==0||Mt.alphaMap&&Mt.alphaTest>0||Mt.map&&Mt.alphaTest>0){const It=Tt.uuid,$t=Mt.uuid;let Nt=ut[It];Nt===void 0&&(Nt={},ut[It]=Nt);let Bt=Nt[$t];Bt===void 0&&(Bt=Tt.clone(),Nt[$t]=Bt,Mt.addEventListener("dispose",wt)),Tt=Bt}if(Tt.visible=Mt.visible,Tt.wireframe=Mt.wireframe,St===VSMShadowMap?Tt.side=Mt.shadowSide!==null?Mt.shadowSide:Mt.side:Tt.side=Mt.shadowSide!==null?Mt.shadowSide:st[Mt.side],Tt.alphaMap=Mt.alphaMap,Tt.alphaTest=Mt.alphaTest,Tt.map=Mt.map,Tt.clipShadows=Mt.clipShadows,Tt.clippingPlanes=Mt.clippingPlanes,Tt.clipIntersection=Mt.clipIntersection,Tt.displacementMap=Mt.displacementMap,Tt.displacementScale=Mt.displacementScale,Tt.displacementBias=Mt.displacementBias,Tt.wireframeLinewidth=Mt.wireframeLinewidth,Tt.linewidth=Mt.linewidth,At.isPointLight===!0&&Tt.isMeshDistanceMaterial===!0){const It=et.properties.get(Tt);It.light=At}return Tt}function bt(xt,Mt,At,St,Tt){if(xt.visible===!1)return;if(xt.layers.test(Mt.layers)&&(xt.isMesh||xt.isLine||xt.isPoints)&&(xt.castShadow||xt.receiveShadow&&Tt===VSMShadowMap)&&(!xt.frustumCulled||tt.intersectsObject(xt))){xt.modelViewMatrix.multiplyMatrices(At.matrixWorldInverse,xt.matrixWorld);const $t=_.update(xt),Nt=xt.material;if(Array.isArray(Nt)){const Bt=$t.groups;for(let Ot=0,Ut=Bt.length;Ot<Ut;Ot++){const Lt=Bt[Ot],zt=Nt[Lt.materialIndex];if(zt&&zt.visible){const Yt=vt(xt,zt,St,Tt);xt.onBeforeShadow(et,xt,Mt,At,$t,Yt,Lt),et.renderBufferDirect(At,null,$t,Yt,xt,Lt),xt.onAfterShadow(et,xt,Mt,At,$t,Yt,Lt)}}}else if(Nt.visible){const Bt=vt(xt,Nt,St,Tt);xt.onBeforeShadow(et,xt,Mt,At,$t,Bt,null),et.renderBufferDirect(At,null,$t,Bt,xt,null),xt.onAfterShadow(et,xt,Mt,At,$t,Bt,null)}}const It=xt.children;for(let $t=0,Nt=It.length;$t<Nt;$t++)bt(It[$t],Mt,At,St,Tt)}function wt(xt){xt.target.removeEventListener("dispose",wt);for(const At in ut){const St=ut[At],Tt=xt.target.uuid;Tt in St&&(St[Tt].dispose(),delete St[Tt])}}}function WebGLState(et){function _(){let ln=!1;const On=new Vector4;let Dn=null;const $n=new Vector4(0,0,0,0);return{setMask:function(Jn){Dn!==Jn&&!ln&&(et.colorMask(Jn,Jn,Jn,Jn),Dn=Jn)},setLocked:function(Jn){ln=Jn},setClear:function(Jn,qn,Kn,ar,Ur){Ur===!0&&(Jn*=ar,qn*=ar,Kn*=ar),On.set(Jn,qn,Kn,ar),$n.equals(On)===!1&&(et.clearColor(Jn,qn,Kn,ar),$n.copy(On))},reset:function(){ln=!1,Dn=null,$n.set(-1,0,0,0)}}}function _e(){let ln=!1,On=null,Dn=null,$n=null;return{setTest:function(Jn){Jn?In(et.DEPTH_TEST):Cn(et.DEPTH_TEST)},setMask:function(Jn){On!==Jn&&!ln&&(et.depthMask(Jn),On=Jn)},setFunc:function(Jn){if(Dn!==Jn){switch(Jn){case NeverDepth:et.depthFunc(et.NEVER);break;case AlwaysDepth:et.depthFunc(et.ALWAYS);break;case LessDepth:et.depthFunc(et.LESS);break;case LessEqualDepth:et.depthFunc(et.LEQUAL);break;case EqualDepth:et.depthFunc(et.EQUAL);break;case GreaterEqualDepth:et.depthFunc(et.GEQUAL);break;case GreaterDepth:et.depthFunc(et.GREATER);break;case NotEqualDepth:et.depthFunc(et.NOTEQUAL);break;default:et.depthFunc(et.LEQUAL)}Dn=Jn}},setLocked:function(Jn){ln=Jn},setClear:function(Jn){$n!==Jn&&(et.clearDepth(Jn),$n=Jn)},reset:function(){ln=!1,On=null,Dn=null,$n=null}}}function tt(){let ln=!1,On=null,Dn=null,$n=null,Jn=null,qn=null,Kn=null,ar=null,Ur=null;return{setTest:function(wr){ln||(wr?In(et.STENCIL_TEST):Cn(et.STENCIL_TEST))},setMask:function(wr){On!==wr&&!ln&&(et.stencilMask(wr),On=wr)},setFunc:function(wr,Hr,Wr){(Dn!==wr||$n!==Hr||Jn!==Wr)&&(et.stencilFunc(wr,Hr,Wr),Dn=wr,$n=Hr,Jn=Wr)},setOp:function(wr,Hr,Wr){(qn!==wr||Kn!==Hr||ar!==Wr)&&(et.stencilOp(wr,Hr,Wr),qn=wr,Kn=Hr,ar=Wr)},setLocked:function(wr){ln=wr},setClear:function(wr){Ur!==wr&&(et.clearStencil(wr),Ur=wr)},reset:function(){ln=!1,On=null,Dn=null,$n=null,Jn=null,qn=null,Kn=null,ar=null,Ur=null}}}const nt=new _,rt=new _e,ot=new tt,at=new WeakMap,lt=new WeakMap;let ut={},dt={},st=new WeakMap,it=[],ct=null,ft=!1,ht=null,mt=null,pt=null,_t=null,vt=null,bt=null,wt=null,xt=new Color$1(0,0,0),Mt=0,At=!1,St=null,Tt=null,Ct=null,It=null,$t=null;const Nt=et.getParameter(et.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let Bt=!1,Ot=0;const Ut=et.getParameter(et.VERSION);Ut.indexOf("WebGL")!==-1?(Ot=parseFloat(/^WebGL (\d)/.exec(Ut)[1]),Bt=Ot>=1):Ut.indexOf("OpenGL ES")!==-1&&(Ot=parseFloat(/^OpenGL ES (\d)/.exec(Ut)[1]),Bt=Ot>=2);let Lt=null,zt={};const Yt=et.getParameter(et.SCISSOR_BOX),en=et.getParameter(et.VIEWPORT),bn=new Vector4().fromArray(Yt),Un=new Vector4().fromArray(en);function mn(ln,On,Dn,$n){const Jn=new Uint8Array(4),qn=et.createTexture();et.bindTexture(ln,qn),et.texParameteri(ln,et.TEXTURE_MIN_FILTER,et.NEAREST),et.texParameteri(ln,et.TEXTURE_MAG_FILTER,et.NEAREST);for(let Kn=0;Kn<Dn;Kn++)ln===et.TEXTURE_3D||ln===et.TEXTURE_2D_ARRAY?et.texImage3D(On,0,et.RGBA,1,1,$n,0,et.RGBA,et.UNSIGNED_BYTE,Jn):et.texImage2D(On+Kn,0,et.RGBA,1,1,0,et.RGBA,et.UNSIGNED_BYTE,Jn);return qn}const vn={};vn[et.TEXTURE_2D]=mn(et.TEXTURE_2D,et.TEXTURE_2D,1),vn[et.TEXTURE_CUBE_MAP]=mn(et.TEXTURE_CUBE_MAP,et.TEXTURE_CUBE_MAP_POSITIVE_X,6),vn[et.TEXTURE_2D_ARRAY]=mn(et.TEXTURE_2D_ARRAY,et.TEXTURE_2D_ARRAY,1,1),vn[et.TEXTURE_3D]=mn(et.TEXTURE_3D,et.TEXTURE_3D,1,1),nt.setClear(0,0,0,1),rt.setClear(1),ot.setClear(0),In(et.DEPTH_TEST),rt.setFunc(LessEqualDepth),Ln(!1),Sn(CullFaceBack),In(et.CULL_FACE),on(NoBlending);function In(ln){ut[ln]!==!0&&(et.enable(ln),ut[ln]=!0)}function Cn(ln){ut[ln]!==!1&&(et.disable(ln),ut[ln]=!1)}function En(ln,On){return dt[ln]!==On?(et.bindFramebuffer(ln,On),dt[ln]=On,ln===et.DRAW_FRAMEBUFFER&&(dt[et.FRAMEBUFFER]=On),ln===et.FRAMEBUFFER&&(dt[et.DRAW_FRAMEBUFFER]=On),!0):!1}function jt(ln,On){let Dn=it,$n=!1;if(ln){Dn=st.get(On),Dn===void 0&&(Dn=[],st.set(On,Dn));const Jn=ln.textures;if(Dn.length!==Jn.length||Dn[0]!==et.COLOR_ATTACHMENT0){for(let qn=0,Kn=Jn.length;qn<Kn;qn++)Dn[qn]=et.COLOR_ATTACHMENT0+qn;Dn.length=Jn.length,$n=!0}}else Dn[0]!==et.BACK&&(Dn[0]=et.BACK,$n=!0);$n&&et.drawBuffers(Dn)}function Kt(ln){return ct!==ln?(et.useProgram(ln),ct=ln,!0):!1}const nn={[AddEquation]:et.FUNC_ADD,[SubtractEquation]:et.FUNC_SUBTRACT,[ReverseSubtractEquation]:et.FUNC_REVERSE_SUBTRACT};nn[MinEquation]=et.MIN,nn[MaxEquation]=et.MAX;const Vt={[ZeroFactor]:et.ZERO,[OneFactor]:et.ONE,[SrcColorFactor]:et.SRC_COLOR,[SrcAlphaFactor]:et.SRC_ALPHA,[SrcAlphaSaturateFactor]:et.SRC_ALPHA_SATURATE,[DstColorFactor]:et.DST_COLOR,[DstAlphaFactor]:et.DST_ALPHA,[OneMinusSrcColorFactor]:et.ONE_MINUS_SRC_COLOR,[OneMinusSrcAlphaFactor]:et.ONE_MINUS_SRC_ALPHA,[OneMinusDstColorFactor]:et.ONE_MINUS_DST_COLOR,[OneMinusDstAlphaFactor]:et.ONE_MINUS_DST_ALPHA,[ConstantColorFactor]:et.CONSTANT_COLOR,[OneMinusConstantColorFactor]:et.ONE_MINUS_CONSTANT_COLOR,[ConstantAlphaFactor]:et.CONSTANT_ALPHA,[OneMinusConstantAlphaFactor]:et.ONE_MINUS_CONSTANT_ALPHA};function on(ln,On,Dn,$n,Jn,qn,Kn,ar,Ur,wr){if(ln===NoBlending){ft===!0&&(Cn(et.BLEND),ft=!1);return}if(ft===!1&&(In(et.BLEND),ft=!0),ln!==CustomBlending){if(ln!==ht||wr!==At){if((mt!==AddEquation||vt!==AddEquation)&&(et.blendEquation(et.FUNC_ADD),mt=AddEquation,vt=AddEquation),wr)switch(ln){case NormalBlending:et.blendFuncSeparate(et.ONE,et.ONE_MINUS_SRC_ALPHA,et.ONE,et.ONE_MINUS_SRC_ALPHA);break;case AdditiveBlending:et.blendFunc(et.ONE,et.ONE);break;case SubtractiveBlending:et.blendFuncSeparate(et.ZERO,et.ONE_MINUS_SRC_COLOR,et.ZERO,et.ONE);break;case MultiplyBlending:et.blendFuncSeparate(et.ZERO,et.SRC_COLOR,et.ZERO,et.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",ln);break}else switch(ln){case NormalBlending:et.blendFuncSeparate(et.SRC_ALPHA,et.ONE_MINUS_SRC_ALPHA,et.ONE,et.ONE_MINUS_SRC_ALPHA);break;case AdditiveBlending:et.blendFunc(et.SRC_ALPHA,et.ONE);break;case SubtractiveBlending:et.blendFuncSeparate(et.ZERO,et.ONE_MINUS_SRC_COLOR,et.ZERO,et.ONE);break;case MultiplyBlending:et.blendFunc(et.ZERO,et.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",ln);break}pt=null,_t=null,bt=null,wt=null,xt.set(0,0,0),Mt=0,ht=ln,At=wr}return}Jn=Jn||On,qn=qn||Dn,Kn=Kn||$n,(On!==mt||Jn!==vt)&&(et.blendEquationSeparate(nn[On],nn[Jn]),mt=On,vt=Jn),(Dn!==pt||$n!==_t||qn!==bt||Kn!==wt)&&(et.blendFuncSeparate(Vt[Dn],Vt[$n],Vt[qn],Vt[Kn]),pt=Dn,_t=$n,bt=qn,wt=Kn),(ar.equals(xt)===!1||Ur!==Mt)&&(et.blendColor(ar.r,ar.g,ar.b,Ur),xt.copy(ar),Mt=Ur),ht=ln,At=!1}function dn(ln,On){ln.side===DoubleSide?Cn(et.CULL_FACE):In(et.CULL_FACE);let Dn=ln.side===BackSide;On&&(Dn=!Dn),Ln(Dn),ln.blending===NormalBlending&&ln.transparent===!1?on(NoBlending):on(ln.blending,ln.blendEquation,ln.blendSrc,ln.blendDst,ln.blendEquationAlpha,ln.blendSrcAlpha,ln.blendDstAlpha,ln.blendColor,ln.blendAlpha,ln.premultipliedAlpha),rt.setFunc(ln.depthFunc),rt.setTest(ln.depthTest),rt.setMask(ln.depthWrite),nt.setMask(ln.colorWrite);const $n=ln.stencilWrite;ot.setTest($n),$n&&(ot.setMask(ln.stencilWriteMask),ot.setFunc(ln.stencilFunc,ln.stencilRef,ln.stencilFuncMask),ot.setOp(ln.stencilFail,ln.stencilZFail,ln.stencilZPass)),Vn(ln.polygonOffset,ln.polygonOffsetFactor,ln.polygonOffsetUnits),ln.alphaToCoverage===!0?In(et.SAMPLE_ALPHA_TO_COVERAGE):Cn(et.SAMPLE_ALPHA_TO_COVERAGE)}function Ln(ln){St!==ln&&(ln?et.frontFace(et.CW):et.frontFace(et.CCW),St=ln)}function Sn(ln){ln!==CullFaceNone?(In(et.CULL_FACE),ln!==Tt&&(ln===CullFaceBack?et.cullFace(et.BACK):ln===CullFaceFront?et.cullFace(et.FRONT):et.cullFace(et.FRONT_AND_BACK))):Cn(et.CULL_FACE),Tt=ln}function Xn(ln){ln!==Ct&&(Bt&&et.lineWidth(ln),Ct=ln)}function Vn(ln,On,Dn){ln?(In(et.POLYGON_OFFSET_FILL),(It!==On||$t!==Dn)&&(et.polygonOffset(On,Dn),It=On,$t=Dn)):Cn(et.POLYGON_OFFSET_FILL)}function Hn(ln){ln?In(et.SCISSOR_TEST):Cn(et.SCISSOR_TEST)}function Zt(ln){ln===void 0&&(ln=et.TEXTURE0+Nt-1),Lt!==ln&&(et.activeTexture(ln),Lt=ln)}function Gt(ln,On,Dn){Dn===void 0&&(Lt===null?Dn=et.TEXTURE0+Nt-1:Dn=Lt);let $n=zt[Dn];$n===void 0&&($n={type:void 0,texture:void 0},zt[Dn]=$n),($n.type!==ln||$n.texture!==On)&&(Lt!==Dn&&(et.activeTexture(Dn),Lt=Dn),et.bindTexture(ln,On||vn[ln]),$n.type=ln,$n.texture=On)}function fn(){const ln=zt[Lt];ln!==void 0&&ln.type!==void 0&&(et.bindTexture(ln.type,null),ln.type=void 0,ln.texture=void 0)}function hn(){try{et.compressedTexImage2D.apply(et,arguments)}catch(ln){console.error("THREE.WebGLState:",ln)}}function xn(){try{et.compressedTexImage3D.apply(et,arguments)}catch(ln){console.error("THREE.WebGLState:",ln)}}function Tn(){try{et.texSubImage2D.apply(et,arguments)}catch(ln){console.error("THREE.WebGLState:",ln)}}function sr(){try{et.texSubImage3D.apply(et,arguments)}catch(ln){console.error("THREE.WebGLState:",ln)}}function Wn(){try{et.compressedTexSubImage2D.apply(et,arguments)}catch(ln){console.error("THREE.WebGLState:",ln)}}function or(){try{et.compressedTexSubImage3D.apply(et,arguments)}catch(ln){console.error("THREE.WebGLState:",ln)}}function fr(){try{et.texStorage2D.apply(et,arguments)}catch(ln){console.error("THREE.WebGLState:",ln)}}function Gn(){try{et.texStorage3D.apply(et,arguments)}catch(ln){console.error("THREE.WebGLState:",ln)}}function nr(){try{et.texImage2D.apply(et,arguments)}catch(ln){console.error("THREE.WebGLState:",ln)}}function mr(){try{et.texImage3D.apply(et,arguments)}catch(ln){console.error("THREE.WebGLState:",ln)}}function hr(ln){bn.equals(ln)===!1&&(et.scissor(ln.x,ln.y,ln.z,ln.w),bn.copy(ln))}function Bn(ln){Un.equals(ln)===!1&&(et.viewport(ln.x,ln.y,ln.z,ln.w),Un.copy(ln))}function cn(ln,On){let Dn=lt.get(On);Dn===void 0&&(Dn=new WeakMap,lt.set(On,Dn));let $n=Dn.get(ln);$n===void 0&&($n=et.getUniformBlockIndex(On,ln.name),Dn.set(ln,$n))}function Fn(ln,On){const $n=lt.get(On).get(ln);at.get(On)!==$n&&(et.uniformBlockBinding(On,$n,ln.__bindingPointIndex),at.set(On,$n))}function ir(){et.disable(et.BLEND),et.disable(et.CULL_FACE),et.disable(et.DEPTH_TEST),et.disable(et.POLYGON_OFFSET_FILL),et.disable(et.SCISSOR_TEST),et.disable(et.STENCIL_TEST),et.disable(et.SAMPLE_ALPHA_TO_COVERAGE),et.blendEquation(et.FUNC_ADD),et.blendFunc(et.ONE,et.ZERO),et.blendFuncSeparate(et.ONE,et.ZERO,et.ONE,et.ZERO),et.blendColor(0,0,0,0),et.colorMask(!0,!0,!0,!0),et.clearColor(0,0,0,0),et.depthMask(!0),et.depthFunc(et.LESS),et.clearDepth(1),et.stencilMask(4294967295),et.stencilFunc(et.ALWAYS,0,4294967295),et.stencilOp(et.KEEP,et.KEEP,et.KEEP),et.clearStencil(0),et.cullFace(et.BACK),et.frontFace(et.CCW),et.polygonOffset(0,0),et.activeTexture(et.TEXTURE0),et.bindFramebuffer(et.FRAMEBUFFER,null),et.bindFramebuffer(et.DRAW_FRAMEBUFFER,null),et.bindFramebuffer(et.READ_FRAMEBUFFER,null),et.useProgram(null),et.lineWidth(1),et.scissor(0,0,et.canvas.width,et.canvas.height),et.viewport(0,0,et.canvas.width,et.canvas.height),ut={},Lt=null,zt={},dt={},st=new WeakMap,it=[],ct=null,ft=!1,ht=null,mt=null,pt=null,_t=null,vt=null,bt=null,wt=null,xt=new Color$1(0,0,0),Mt=0,At=!1,St=null,Tt=null,Ct=null,It=null,$t=null,bn.set(0,0,et.canvas.width,et.canvas.height),Un.set(0,0,et.canvas.width,et.canvas.height),nt.reset(),rt.reset(),ot.reset()}return{buffers:{color:nt,depth:rt,stencil:ot},enable:In,disable:Cn,bindFramebuffer:En,drawBuffers:jt,useProgram:Kt,setBlending:on,setMaterial:dn,setFlipSided:Ln,setCullFace:Sn,setLineWidth:Xn,setPolygonOffset:Vn,setScissorTest:Hn,activeTexture:Zt,bindTexture:Gt,unbindTexture:fn,compressedTexImage2D:hn,compressedTexImage3D:xn,texImage2D:nr,texImage3D:mr,updateUBOMapping:cn,uniformBlockBinding:Fn,texStorage2D:fr,texStorage3D:Gn,texSubImage2D:Tn,texSubImage3D:sr,compressedTexSubImage2D:Wn,compressedTexSubImage3D:or,scissor:hr,viewport:Bn,reset:ir}}function contain(et,_){const _e=et.image&&et.image.width?et.image.width/et.image.height:1;return _e>_?(et.repeat.x=1,et.repeat.y=_e/_,et.offset.x=0,et.offset.y=(1-et.repeat.y)/2):(et.repeat.x=_/_e,et.repeat.y=1,et.offset.x=(1-et.repeat.x)/2,et.offset.y=0),et}function cover(et,_){const _e=et.image&&et.image.width?et.image.width/et.image.height:1;return _e>_?(et.repeat.x=_/_e,et.repeat.y=1,et.offset.x=(1-et.repeat.x)/2,et.offset.y=0):(et.repeat.x=1,et.repeat.y=_e/_,et.offset.x=0,et.offset.y=(1-et.repeat.y)/2),et}function fill(et){return et.repeat.x=1,et.repeat.y=1,et.offset.x=0,et.offset.y=0,et}function getByteLength(et,_,_e,tt){const nt=getTextureTypeByteLength(tt);switch(_e){case AlphaFormat:return et*_;case LuminanceFormat:return et*_;case LuminanceAlphaFormat:return et*_*2;case RedFormat:return et*_/nt.components*nt.byteLength;case RedIntegerFormat:return et*_/nt.components*nt.byteLength;case RGFormat:return et*_*2/nt.components*nt.byteLength;case RGIntegerFormat:return et*_*2/nt.components*nt.byteLength;case RGBFormat:return et*_*3/nt.components*nt.byteLength;case RGBAFormat:return et*_*4/nt.components*nt.byteLength;case RGBAIntegerFormat:return et*_*4/nt.components*nt.byteLength;case RGB_S3TC_DXT1_Format:case RGBA_S3TC_DXT1_Format:return Math.floor((et+3)/4)*Math.floor((_+3)/4)*8;case RGBA_S3TC_DXT3_Format:case RGBA_S3TC_DXT5_Format:return Math.floor((et+3)/4)*Math.floor((_+3)/4)*16;case RGB_PVRTC_2BPPV1_Format:case RGBA_PVRTC_2BPPV1_Format:return Math.max(et,16)*Math.max(_,8)/4;case RGB_PVRTC_4BPPV1_Format:case RGBA_PVRTC_4BPPV1_Format:return Math.max(et,8)*Math.max(_,8)/2;case RGB_ETC1_Format:case RGB_ETC2_Format:return Math.floor((et+3)/4)*Math.floor((_+3)/4)*8;case RGBA_ETC2_EAC_Format:return Math.floor((et+3)/4)*Math.floor((_+3)/4)*16;case RGBA_ASTC_4x4_Format:return Math.floor((et+3)/4)*Math.floor((_+3)/4)*16;case RGBA_ASTC_5x4_Format:return Math.floor((et+4)/5)*Math.floor((_+3)/4)*16;case RGBA_ASTC_5x5_Format:return Math.floor((et+4)/5)*Math.floor((_+4)/5)*16;case RGBA_ASTC_6x5_Format:return Math.floor((et+5)/6)*Math.floor((_+4)/5)*16;case RGBA_ASTC_6x6_Format:return Math.floor((et+5)/6)*Math.floor((_+5)/6)*16;case RGBA_ASTC_8x5_Format:return Math.floor((et+7)/8)*Math.floor((_+4)/5)*16;case RGBA_ASTC_8x6_Format:return Math.floor((et+7)/8)*Math.floor((_+5)/6)*16;case RGBA_ASTC_8x8_Format:return Math.floor((et+7)/8)*Math.floor((_+7)/8)*16;case RGBA_ASTC_10x5_Format:return Math.floor((et+9)/10)*Math.floor((_+4)/5)*16;case RGBA_ASTC_10x6_Format:return Math.floor((et+9)/10)*Math.floor((_+5)/6)*16;case RGBA_ASTC_10x8_Format:return Math.floor((et+9)/10)*Math.floor((_+7)/8)*16;case RGBA_ASTC_10x10_Format:return Math.floor((et+9)/10)*Math.floor((_+9)/10)*16;case RGBA_ASTC_12x10_Format:return Math.floor((et+11)/12)*Math.floor((_+9)/10)*16;case RGBA_ASTC_12x12_Format:return Math.floor((et+11)/12)*Math.floor((_+11)/12)*16;case RGBA_BPTC_Format:case RGB_BPTC_SIGNED_Format:case RGB_BPTC_UNSIGNED_Format:return Math.ceil(et/4)*Math.ceil(_/4)*16;case RED_RGTC1_Format:case SIGNED_RED_RGTC1_Format:return Math.ceil(et/4)*Math.ceil(_/4)*8;case RED_GREEN_RGTC2_Format:case SIGNED_RED_GREEN_RGTC2_Format:return Math.ceil(et/4)*Math.ceil(_/4)*16}throw new Error(`Unable to determine texture byte length for ${_e} format.`)}function getTextureTypeByteLength(et){switch(et){case UnsignedByteType:case ByteType:return{byteLength:1,components:1};case UnsignedShortType:case ShortType:case HalfFloatType:return{byteLength:2,components:1};case UnsignedShort4444Type:case UnsignedShort5551Type:return{byteLength:2,components:4};case UnsignedIntType:case IntType:case FloatType:return{byteLength:4,components:1};case UnsignedInt5999Type:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${et}.`)}const TextureUtils={contain,cover,fill,getByteLength};function WebGLTextures(et,_,_e,tt,nt,rt,ot){const at=_.has("WEBGL_multisampled_render_to_texture")?_.get("WEBGL_multisampled_render_to_texture"):null,lt=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),ut=new Vector2,dt=new WeakMap;let st;const it=new WeakMap;let ct=!1;try{ct=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function ft(Zt,Gt){return ct?new OffscreenCanvas(Zt,Gt):createElementNS("canvas")}function ht(Zt,Gt,fn){let hn=1;const xn=Hn(Zt);if((xn.width>fn||xn.height>fn)&&(hn=fn/Math.max(xn.width,xn.height)),hn<1)if(typeof HTMLImageElement<"u"&&Zt instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&Zt instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&Zt instanceof ImageBitmap||typeof VideoFrame<"u"&&Zt instanceof VideoFrame){const Tn=Math.floor(hn*xn.width),sr=Math.floor(hn*xn.height);st===void 0&&(st=ft(Tn,sr));const Wn=Gt?ft(Tn,sr):st;return Wn.width=Tn,Wn.height=sr,Wn.getContext("2d").drawImage(Zt,0,0,Tn,sr),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+xn.width+"x"+xn.height+") to ("+Tn+"x"+sr+")."),Wn}else return"data"in Zt&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+xn.width+"x"+xn.height+")."),Zt;return Zt}function mt(Zt){return Zt.generateMipmaps&&Zt.minFilter!==NearestFilter&&Zt.minFilter!==LinearFilter}function pt(Zt){et.generateMipmap(Zt)}function _t(Zt,Gt,fn,hn,xn=!1){if(Zt!==null){if(et[Zt]!==void 0)return et[Zt];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+Zt+"'")}let Tn=Gt;if(Gt===et.RED&&(fn===et.FLOAT&&(Tn=et.R32F),fn===et.HALF_FLOAT&&(Tn=et.R16F),fn===et.UNSIGNED_BYTE&&(Tn=et.R8)),Gt===et.RED_INTEGER&&(fn===et.UNSIGNED_BYTE&&(Tn=et.R8UI),fn===et.UNSIGNED_SHORT&&(Tn=et.R16UI),fn===et.UNSIGNED_INT&&(Tn=et.R32UI),fn===et.BYTE&&(Tn=et.R8I),fn===et.SHORT&&(Tn=et.R16I),fn===et.INT&&(Tn=et.R32I)),Gt===et.RG&&(fn===et.FLOAT&&(Tn=et.RG32F),fn===et.HALF_FLOAT&&(Tn=et.RG16F),fn===et.UNSIGNED_BYTE&&(Tn=et.RG8)),Gt===et.RG_INTEGER&&(fn===et.UNSIGNED_BYTE&&(Tn=et.RG8UI),fn===et.UNSIGNED_SHORT&&(Tn=et.RG16UI),fn===et.UNSIGNED_INT&&(Tn=et.RG32UI),fn===et.BYTE&&(Tn=et.RG8I),fn===et.SHORT&&(Tn=et.RG16I),fn===et.INT&&(Tn=et.RG32I)),Gt===et.RGB&&fn===et.UNSIGNED_INT_5_9_9_9_REV&&(Tn=et.RGB9_E5),Gt===et.RGBA){const sr=xn?LinearTransfer:ColorManagement.getTransfer(hn);fn===et.FLOAT&&(Tn=et.RGBA32F),fn===et.HALF_FLOAT&&(Tn=et.RGBA16F),fn===et.UNSIGNED_BYTE&&(Tn=sr===SRGBTransfer?et.SRGB8_ALPHA8:et.RGBA8),fn===et.UNSIGNED_SHORT_4_4_4_4&&(Tn=et.RGBA4),fn===et.UNSIGNED_SHORT_5_5_5_1&&(Tn=et.RGB5_A1)}return(Tn===et.R16F||Tn===et.R32F||Tn===et.RG16F||Tn===et.RG32F||Tn===et.RGBA16F||Tn===et.RGBA32F)&&_.get("EXT_color_buffer_float"),Tn}function vt(Zt,Gt){let fn;return Zt?Gt===null||Gt===UnsignedIntType||Gt===UnsignedInt248Type?fn=et.DEPTH24_STENCIL8:Gt===FloatType?fn=et.DEPTH32F_STENCIL8:Gt===UnsignedShortType&&(fn=et.DEPTH24_STENCIL8,console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):Gt===null||Gt===UnsignedIntType||Gt===UnsignedInt248Type?fn=et.DEPTH_COMPONENT24:Gt===FloatType?fn=et.DEPTH_COMPONENT32F:Gt===UnsignedShortType&&(fn=et.DEPTH_COMPONENT16),fn}function bt(Zt,Gt){return mt(Zt)===!0||Zt.isFramebufferTexture&&Zt.minFilter!==NearestFilter&&Zt.minFilter!==LinearFilter?Math.log2(Math.max(Gt.width,Gt.height))+1:Zt.mipmaps!==void 0&&Zt.mipmaps.length>0?Zt.mipmaps.length:Zt.isCompressedTexture&&Array.isArray(Zt.image)?Gt.mipmaps.length:1}function wt(Zt){const Gt=Zt.target;Gt.removeEventListener("dispose",wt),Mt(Gt),Gt.isVideoTexture&&dt.delete(Gt)}function xt(Zt){const Gt=Zt.target;Gt.removeEventListener("dispose",xt),St(Gt)}function Mt(Zt){const Gt=tt.get(Zt);if(Gt.__webglInit===void 0)return;const fn=Zt.source,hn=it.get(fn);if(hn){const xn=hn[Gt.__cacheKey];xn.usedTimes--,xn.usedTimes===0&&At(Zt),Object.keys(hn).length===0&&it.delete(fn)}tt.remove(Zt)}function At(Zt){const Gt=tt.get(Zt);et.deleteTexture(Gt.__webglTexture);const fn=Zt.source,hn=it.get(fn);delete hn[Gt.__cacheKey],ot.memory.textures--}function St(Zt){const Gt=tt.get(Zt);if(Zt.depthTexture&&Zt.depthTexture.dispose(),Zt.isWebGLCubeRenderTarget)for(let hn=0;hn<6;hn++){if(Array.isArray(Gt.__webglFramebuffer[hn]))for(let xn=0;xn<Gt.__webglFramebuffer[hn].length;xn++)et.deleteFramebuffer(Gt.__webglFramebuffer[hn][xn]);else et.deleteFramebuffer(Gt.__webglFramebuffer[hn]);Gt.__webglDepthbuffer&&et.deleteRenderbuffer(Gt.__webglDepthbuffer[hn])}else{if(Array.isArray(Gt.__webglFramebuffer))for(let hn=0;hn<Gt.__webglFramebuffer.length;hn++)et.deleteFramebuffer(Gt.__webglFramebuffer[hn]);else et.deleteFramebuffer(Gt.__webglFramebuffer);if(Gt.__webglDepthbuffer&&et.deleteRenderbuffer(Gt.__webglDepthbuffer),Gt.__webglMultisampledFramebuffer&&et.deleteFramebuffer(Gt.__webglMultisampledFramebuffer),Gt.__webglColorRenderbuffer)for(let hn=0;hn<Gt.__webglColorRenderbuffer.length;hn++)Gt.__webglColorRenderbuffer[hn]&&et.deleteRenderbuffer(Gt.__webglColorRenderbuffer[hn]);Gt.__webglDepthRenderbuffer&&et.deleteRenderbuffer(Gt.__webglDepthRenderbuffer)}const fn=Zt.textures;for(let hn=0,xn=fn.length;hn<xn;hn++){const Tn=tt.get(fn[hn]);Tn.__webglTexture&&(et.deleteTexture(Tn.__webglTexture),ot.memory.textures--),tt.remove(fn[hn])}tt.remove(Zt)}let Tt=0;function Ct(){Tt=0}function It(){const Zt=Tt;return Zt>=nt.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+Zt+" texture units while this GPU supports only "+nt.maxTextures),Tt+=1,Zt}function $t(Zt){const Gt=[];return Gt.push(Zt.wrapS),Gt.push(Zt.wrapT),Gt.push(Zt.wrapR||0),Gt.push(Zt.magFilter),Gt.push(Zt.minFilter),Gt.push(Zt.anisotropy),Gt.push(Zt.internalFormat),Gt.push(Zt.format),Gt.push(Zt.type),Gt.push(Zt.generateMipmaps),Gt.push(Zt.premultiplyAlpha),Gt.push(Zt.flipY),Gt.push(Zt.unpackAlignment),Gt.push(Zt.colorSpace),Gt.join()}function Nt(Zt,Gt){const fn=tt.get(Zt);if(Zt.isVideoTexture&&Xn(Zt),Zt.isRenderTargetTexture===!1&&Zt.version>0&&fn.__version!==Zt.version){const hn=Zt.image;if(hn===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(hn.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Un(fn,Zt,Gt);return}}_e.bindTexture(et.TEXTURE_2D,fn.__webglTexture,et.TEXTURE0+Gt)}function Bt(Zt,Gt){const fn=tt.get(Zt);if(Zt.version>0&&fn.__version!==Zt.version){Un(fn,Zt,Gt);return}_e.bindTexture(et.TEXTURE_2D_ARRAY,fn.__webglTexture,et.TEXTURE0+Gt)}function Ot(Zt,Gt){const fn=tt.get(Zt);if(Zt.version>0&&fn.__version!==Zt.version){Un(fn,Zt,Gt);return}_e.bindTexture(et.TEXTURE_3D,fn.__webglTexture,et.TEXTURE0+Gt)}function Ut(Zt,Gt){const fn=tt.get(Zt);if(Zt.version>0&&fn.__version!==Zt.version){mn(fn,Zt,Gt);return}_e.bindTexture(et.TEXTURE_CUBE_MAP,fn.__webglTexture,et.TEXTURE0+Gt)}const Lt={[RepeatWrapping]:et.REPEAT,[ClampToEdgeWrapping]:et.CLAMP_TO_EDGE,[MirroredRepeatWrapping]:et.MIRRORED_REPEAT},zt={[NearestFilter]:et.NEAREST,[NearestMipmapNearestFilter]:et.NEAREST_MIPMAP_NEAREST,[NearestMipmapLinearFilter]:et.NEAREST_MIPMAP_LINEAR,[LinearFilter]:et.LINEAR,[LinearMipmapNearestFilter]:et.LINEAR_MIPMAP_NEAREST,[LinearMipmapLinearFilter]:et.LINEAR_MIPMAP_LINEAR},Yt={[NeverCompare]:et.NEVER,[AlwaysCompare]:et.ALWAYS,[LessCompare]:et.LESS,[LessEqualCompare]:et.LEQUAL,[EqualCompare]:et.EQUAL,[GreaterEqualCompare]:et.GEQUAL,[GreaterCompare]:et.GREATER,[NotEqualCompare]:et.NOTEQUAL};function en(Zt,Gt){if(Gt.type===FloatType&&_.has("OES_texture_float_linear")===!1&&(Gt.magFilter===LinearFilter||Gt.magFilter===LinearMipmapNearestFilter||Gt.magFilter===NearestMipmapLinearFilter||Gt.magFilter===LinearMipmapLinearFilter||Gt.minFilter===LinearFilter||Gt.minFilter===LinearMipmapNearestFilter||Gt.minFilter===NearestMipmapLinearFilter||Gt.minFilter===LinearMipmapLinearFilter)&&console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),et.texParameteri(Zt,et.TEXTURE_WRAP_S,Lt[Gt.wrapS]),et.texParameteri(Zt,et.TEXTURE_WRAP_T,Lt[Gt.wrapT]),(Zt===et.TEXTURE_3D||Zt===et.TEXTURE_2D_ARRAY)&&et.texParameteri(Zt,et.TEXTURE_WRAP_R,Lt[Gt.wrapR]),et.texParameteri(Zt,et.TEXTURE_MAG_FILTER,zt[Gt.magFilter]),et.texParameteri(Zt,et.TEXTURE_MIN_FILTER,zt[Gt.minFilter]),Gt.compareFunction&&(et.texParameteri(Zt,et.TEXTURE_COMPARE_MODE,et.COMPARE_REF_TO_TEXTURE),et.texParameteri(Zt,et.TEXTURE_COMPARE_FUNC,Yt[Gt.compareFunction])),_.has("EXT_texture_filter_anisotropic")===!0){if(Gt.magFilter===NearestFilter||Gt.minFilter!==NearestMipmapLinearFilter&&Gt.minFilter!==LinearMipmapLinearFilter||Gt.type===FloatType&&_.has("OES_texture_float_linear")===!1)return;if(Gt.anisotropy>1||tt.get(Gt).__currentAnisotropy){const fn=_.get("EXT_texture_filter_anisotropic");et.texParameterf(Zt,fn.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(Gt.anisotropy,nt.getMaxAnisotropy())),tt.get(Gt).__currentAnisotropy=Gt.anisotropy}}}function bn(Zt,Gt){let fn=!1;Zt.__webglInit===void 0&&(Zt.__webglInit=!0,Gt.addEventListener("dispose",wt));const hn=Gt.source;let xn=it.get(hn);xn===void 0&&(xn={},it.set(hn,xn));const Tn=$t(Gt);if(Tn!==Zt.__cacheKey){xn[Tn]===void 0&&(xn[Tn]={texture:et.createTexture(),usedTimes:0},ot.memory.textures++,fn=!0),xn[Tn].usedTimes++;const sr=xn[Zt.__cacheKey];sr!==void 0&&(xn[Zt.__cacheKey].usedTimes--,sr.usedTimes===0&&At(Gt)),Zt.__cacheKey=Tn,Zt.__webglTexture=xn[Tn].texture}return fn}function Un(Zt,Gt,fn){let hn=et.TEXTURE_2D;(Gt.isDataArrayTexture||Gt.isCompressedArrayTexture)&&(hn=et.TEXTURE_2D_ARRAY),Gt.isData3DTexture&&(hn=et.TEXTURE_3D);const xn=bn(Zt,Gt),Tn=Gt.source;_e.bindTexture(hn,Zt.__webglTexture,et.TEXTURE0+fn);const sr=tt.get(Tn);if(Tn.version!==sr.__version||xn===!0){_e.activeTexture(et.TEXTURE0+fn);const Wn=ColorManagement.getPrimaries(ColorManagement.workingColorSpace),or=Gt.colorSpace===NoColorSpace?null:ColorManagement.getPrimaries(Gt.colorSpace),fr=Gt.colorSpace===NoColorSpace||Wn===or?et.NONE:et.BROWSER_DEFAULT_WEBGL;et.pixelStorei(et.UNPACK_FLIP_Y_WEBGL,Gt.flipY),et.pixelStorei(et.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Gt.premultiplyAlpha),et.pixelStorei(et.UNPACK_ALIGNMENT,Gt.unpackAlignment),et.pixelStorei(et.UNPACK_COLORSPACE_CONVERSION_WEBGL,fr);let Gn=ht(Gt.image,!1,nt.maxTextureSize);Gn=Vn(Gt,Gn);const nr=rt.convert(Gt.format,Gt.colorSpace),mr=rt.convert(Gt.type);let hr=_t(Gt.internalFormat,nr,mr,Gt.colorSpace,Gt.isVideoTexture);en(hn,Gt);let Bn;const cn=Gt.mipmaps,Fn=Gt.isVideoTexture!==!0,ir=sr.__version===void 0||xn===!0,ln=Tn.dataReady,On=bt(Gt,Gn);if(Gt.isDepthTexture)hr=vt(Gt.format===DepthStencilFormat,Gt.type),ir&&(Fn?_e.texStorage2D(et.TEXTURE_2D,1,hr,Gn.width,Gn.height):_e.texImage2D(et.TEXTURE_2D,0,hr,Gn.width,Gn.height,0,nr,mr,null));else if(Gt.isDataTexture)if(cn.length>0){Fn&&ir&&_e.texStorage2D(et.TEXTURE_2D,On,hr,cn[0].width,cn[0].height);for(let Dn=0,$n=cn.length;Dn<$n;Dn++)Bn=cn[Dn],Fn?ln&&_e.texSubImage2D(et.TEXTURE_2D,Dn,0,0,Bn.width,Bn.height,nr,mr,Bn.data):_e.texImage2D(et.TEXTURE_2D,Dn,hr,Bn.width,Bn.height,0,nr,mr,Bn.data);Gt.generateMipmaps=!1}else Fn?(ir&&_e.texStorage2D(et.TEXTURE_2D,On,hr,Gn.width,Gn.height),ln&&_e.texSubImage2D(et.TEXTURE_2D,0,0,0,Gn.width,Gn.height,nr,mr,Gn.data)):_e.texImage2D(et.TEXTURE_2D,0,hr,Gn.width,Gn.height,0,nr,mr,Gn.data);else if(Gt.isCompressedTexture)if(Gt.isCompressedArrayTexture){Fn&&ir&&_e.texStorage3D(et.TEXTURE_2D_ARRAY,On,hr,cn[0].width,cn[0].height,Gn.depth);for(let Dn=0,$n=cn.length;Dn<$n;Dn++)if(Bn=cn[Dn],Gt.format!==RGBAFormat)if(nr!==null)if(Fn){if(ln)if(Gt.layerUpdates.size>0){const Jn=getByteLength(Bn.width,Bn.height,Gt.format,Gt.type);for(const qn of Gt.layerUpdates){const Kn=Bn.data.subarray(qn*Jn/Bn.data.BYTES_PER_ELEMENT,(qn+1)*Jn/Bn.data.BYTES_PER_ELEMENT);_e.compressedTexSubImage3D(et.TEXTURE_2D_ARRAY,Dn,0,0,qn,Bn.width,Bn.height,1,nr,Kn,0,0)}Gt.clearLayerUpdates()}else _e.compressedTexSubImage3D(et.TEXTURE_2D_ARRAY,Dn,0,0,0,Bn.width,Bn.height,Gn.depth,nr,Bn.data,0,0)}else _e.compressedTexImage3D(et.TEXTURE_2D_ARRAY,Dn,hr,Bn.width,Bn.height,Gn.depth,0,Bn.data,0,0);else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else Fn?ln&&_e.texSubImage3D(et.TEXTURE_2D_ARRAY,Dn,0,0,0,Bn.width,Bn.height,Gn.depth,nr,mr,Bn.data):_e.texImage3D(et.TEXTURE_2D_ARRAY,Dn,hr,Bn.width,Bn.height,Gn.depth,0,nr,mr,Bn.data)}else{Fn&&ir&&_e.texStorage2D(et.TEXTURE_2D,On,hr,cn[0].width,cn[0].height);for(let Dn=0,$n=cn.length;Dn<$n;Dn++)Bn=cn[Dn],Gt.format!==RGBAFormat?nr!==null?Fn?ln&&_e.compressedTexSubImage2D(et.TEXTURE_2D,Dn,0,0,Bn.width,Bn.height,nr,Bn.data):_e.compressedTexImage2D(et.TEXTURE_2D,Dn,hr,Bn.width,Bn.height,0,Bn.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Fn?ln&&_e.texSubImage2D(et.TEXTURE_2D,Dn,0,0,Bn.width,Bn.height,nr,mr,Bn.data):_e.texImage2D(et.TEXTURE_2D,Dn,hr,Bn.width,Bn.height,0,nr,mr,Bn.data)}else if(Gt.isDataArrayTexture)if(Fn){if(ir&&_e.texStorage3D(et.TEXTURE_2D_ARRAY,On,hr,Gn.width,Gn.height,Gn.depth),ln)if(Gt.layerUpdates.size>0){const Dn=getByteLength(Gn.width,Gn.height,Gt.format,Gt.type);for(const $n of Gt.layerUpdates){const Jn=Gn.data.subarray($n*Dn/Gn.data.BYTES_PER_ELEMENT,($n+1)*Dn/Gn.data.BYTES_PER_ELEMENT);_e.texSubImage3D(et.TEXTURE_2D_ARRAY,0,0,0,$n,Gn.width,Gn.height,1,nr,mr,Jn)}Gt.clearLayerUpdates()}else _e.texSubImage3D(et.TEXTURE_2D_ARRAY,0,0,0,0,Gn.width,Gn.height,Gn.depth,nr,mr,Gn.data)}else _e.texImage3D(et.TEXTURE_2D_ARRAY,0,hr,Gn.width,Gn.height,Gn.depth,0,nr,mr,Gn.data);else if(Gt.isData3DTexture)Fn?(ir&&_e.texStorage3D(et.TEXTURE_3D,On,hr,Gn.width,Gn.height,Gn.depth),ln&&_e.texSubImage3D(et.TEXTURE_3D,0,0,0,0,Gn.width,Gn.height,Gn.depth,nr,mr,Gn.data)):_e.texImage3D(et.TEXTURE_3D,0,hr,Gn.width,Gn.height,Gn.depth,0,nr,mr,Gn.data);else if(Gt.isFramebufferTexture){if(ir)if(Fn)_e.texStorage2D(et.TEXTURE_2D,On,hr,Gn.width,Gn.height);else{let Dn=Gn.width,$n=Gn.height;for(let Jn=0;Jn<On;Jn++)_e.texImage2D(et.TEXTURE_2D,Jn,hr,Dn,$n,0,nr,mr,null),Dn>>=1,$n>>=1}}else if(cn.length>0){if(Fn&&ir){const Dn=Hn(cn[0]);_e.texStorage2D(et.TEXTURE_2D,On,hr,Dn.width,Dn.height)}for(let Dn=0,$n=cn.length;Dn<$n;Dn++)Bn=cn[Dn],Fn?ln&&_e.texSubImage2D(et.TEXTURE_2D,Dn,0,0,nr,mr,Bn):_e.texImage2D(et.TEXTURE_2D,Dn,hr,nr,mr,Bn);Gt.generateMipmaps=!1}else if(Fn){if(ir){const Dn=Hn(Gn);_e.texStorage2D(et.TEXTURE_2D,On,hr,Dn.width,Dn.height)}ln&&_e.texSubImage2D(et.TEXTURE_2D,0,0,0,nr,mr,Gn)}else _e.texImage2D(et.TEXTURE_2D,0,hr,nr,mr,Gn);mt(Gt)&&pt(hn),sr.__version=Tn.version,Gt.onUpdate&&Gt.onUpdate(Gt)}Zt.__version=Gt.version}function mn(Zt,Gt,fn){if(Gt.image.length!==6)return;const hn=bn(Zt,Gt),xn=Gt.source;_e.bindTexture(et.TEXTURE_CUBE_MAP,Zt.__webglTexture,et.TEXTURE0+fn);const Tn=tt.get(xn);if(xn.version!==Tn.__version||hn===!0){_e.activeTexture(et.TEXTURE0+fn);const sr=ColorManagement.getPrimaries(ColorManagement.workingColorSpace),Wn=Gt.colorSpace===NoColorSpace?null:ColorManagement.getPrimaries(Gt.colorSpace),or=Gt.colorSpace===NoColorSpace||sr===Wn?et.NONE:et.BROWSER_DEFAULT_WEBGL;et.pixelStorei(et.UNPACK_FLIP_Y_WEBGL,Gt.flipY),et.pixelStorei(et.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Gt.premultiplyAlpha),et.pixelStorei(et.UNPACK_ALIGNMENT,Gt.unpackAlignment),et.pixelStorei(et.UNPACK_COLORSPACE_CONVERSION_WEBGL,or);const fr=Gt.isCompressedTexture||Gt.image[0].isCompressedTexture,Gn=Gt.image[0]&&Gt.image[0].isDataTexture,nr=[];for(let $n=0;$n<6;$n++)!fr&&!Gn?nr[$n]=ht(Gt.image[$n],!0,nt.maxCubemapSize):nr[$n]=Gn?Gt.image[$n].image:Gt.image[$n],nr[$n]=Vn(Gt,nr[$n]);const mr=nr[0],hr=rt.convert(Gt.format,Gt.colorSpace),Bn=rt.convert(Gt.type),cn=_t(Gt.internalFormat,hr,Bn,Gt.colorSpace),Fn=Gt.isVideoTexture!==!0,ir=Tn.__version===void 0||hn===!0,ln=xn.dataReady;let On=bt(Gt,mr);en(et.TEXTURE_CUBE_MAP,Gt);let Dn;if(fr){Fn&&ir&&_e.texStorage2D(et.TEXTURE_CUBE_MAP,On,cn,mr.width,mr.height);for(let $n=0;$n<6;$n++){Dn=nr[$n].mipmaps;for(let Jn=0;Jn<Dn.length;Jn++){const qn=Dn[Jn];Gt.format!==RGBAFormat?hr!==null?Fn?ln&&_e.compressedTexSubImage2D(et.TEXTURE_CUBE_MAP_POSITIVE_X+$n,Jn,0,0,qn.width,qn.height,hr,qn.data):_e.compressedTexImage2D(et.TEXTURE_CUBE_MAP_POSITIVE_X+$n,Jn,cn,qn.width,qn.height,0,qn.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Fn?ln&&_e.texSubImage2D(et.TEXTURE_CUBE_MAP_POSITIVE_X+$n,Jn,0,0,qn.width,qn.height,hr,Bn,qn.data):_e.texImage2D(et.TEXTURE_CUBE_MAP_POSITIVE_X+$n,Jn,cn,qn.width,qn.height,0,hr,Bn,qn.data)}}}else{if(Dn=Gt.mipmaps,Fn&&ir){Dn.length>0&&On++;const $n=Hn(nr[0]);_e.texStorage2D(et.TEXTURE_CUBE_MAP,On,cn,$n.width,$n.height)}for(let $n=0;$n<6;$n++)if(Gn){Fn?ln&&_e.texSubImage2D(et.TEXTURE_CUBE_MAP_POSITIVE_X+$n,0,0,0,nr[$n].width,nr[$n].height,hr,Bn,nr[$n].data):_e.texImage2D(et.TEXTURE_CUBE_MAP_POSITIVE_X+$n,0,cn,nr[$n].width,nr[$n].height,0,hr,Bn,nr[$n].data);for(let Jn=0;Jn<Dn.length;Jn++){const Kn=Dn[Jn].image[$n].image;Fn?ln&&_e.texSubImage2D(et.TEXTURE_CUBE_MAP_POSITIVE_X+$n,Jn+1,0,0,Kn.width,Kn.height,hr,Bn,Kn.data):_e.texImage2D(et.TEXTURE_CUBE_MAP_POSITIVE_X+$n,Jn+1,cn,Kn.width,Kn.height,0,hr,Bn,Kn.data)}}else{Fn?ln&&_e.texSubImage2D(et.TEXTURE_CUBE_MAP_POSITIVE_X+$n,0,0,0,hr,Bn,nr[$n]):_e.texImage2D(et.TEXTURE_CUBE_MAP_POSITIVE_X+$n,0,cn,hr,Bn,nr[$n]);for(let Jn=0;Jn<Dn.length;Jn++){const qn=Dn[Jn];Fn?ln&&_e.texSubImage2D(et.TEXTURE_CUBE_MAP_POSITIVE_X+$n,Jn+1,0,0,hr,Bn,qn.image[$n]):_e.texImage2D(et.TEXTURE_CUBE_MAP_POSITIVE_X+$n,Jn+1,cn,hr,Bn,qn.image[$n])}}}mt(Gt)&&pt(et.TEXTURE_CUBE_MAP),Tn.__version=xn.version,Gt.onUpdate&&Gt.onUpdate(Gt)}Zt.__version=Gt.version}function vn(Zt,Gt,fn,hn,xn,Tn){const sr=rt.convert(fn.format,fn.colorSpace),Wn=rt.convert(fn.type),or=_t(fn.internalFormat,sr,Wn,fn.colorSpace);if(!tt.get(Gt).__hasExternalTextures){const Gn=Math.max(1,Gt.width>>Tn),nr=Math.max(1,Gt.height>>Tn);xn===et.TEXTURE_3D||xn===et.TEXTURE_2D_ARRAY?_e.texImage3D(xn,Tn,or,Gn,nr,Gt.depth,0,sr,Wn,null):_e.texImage2D(xn,Tn,or,Gn,nr,0,sr,Wn,null)}_e.bindFramebuffer(et.FRAMEBUFFER,Zt),Sn(Gt)?at.framebufferTexture2DMultisampleEXT(et.FRAMEBUFFER,hn,xn,tt.get(fn).__webglTexture,0,Ln(Gt)):(xn===et.TEXTURE_2D||xn>=et.TEXTURE_CUBE_MAP_POSITIVE_X&&xn<=et.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&et.framebufferTexture2D(et.FRAMEBUFFER,hn,xn,tt.get(fn).__webglTexture,Tn),_e.bindFramebuffer(et.FRAMEBUFFER,null)}function In(Zt,Gt,fn){if(et.bindRenderbuffer(et.RENDERBUFFER,Zt),Gt.depthBuffer){const hn=Gt.depthTexture,xn=hn&&hn.isDepthTexture?hn.type:null,Tn=vt(Gt.stencilBuffer,xn),sr=Gt.stencilBuffer?et.DEPTH_STENCIL_ATTACHMENT:et.DEPTH_ATTACHMENT,Wn=Ln(Gt);Sn(Gt)?at.renderbufferStorageMultisampleEXT(et.RENDERBUFFER,Wn,Tn,Gt.width,Gt.height):fn?et.renderbufferStorageMultisample(et.RENDERBUFFER,Wn,Tn,Gt.width,Gt.height):et.renderbufferStorage(et.RENDERBUFFER,Tn,Gt.width,Gt.height),et.framebufferRenderbuffer(et.FRAMEBUFFER,sr,et.RENDERBUFFER,Zt)}else{const hn=Gt.textures;for(let xn=0;xn<hn.length;xn++){const Tn=hn[xn],sr=rt.convert(Tn.format,Tn.colorSpace),Wn=rt.convert(Tn.type),or=_t(Tn.internalFormat,sr,Wn,Tn.colorSpace),fr=Ln(Gt);fn&&Sn(Gt)===!1?et.renderbufferStorageMultisample(et.RENDERBUFFER,fr,or,Gt.width,Gt.height):Sn(Gt)?at.renderbufferStorageMultisampleEXT(et.RENDERBUFFER,fr,or,Gt.width,Gt.height):et.renderbufferStorage(et.RENDERBUFFER,or,Gt.width,Gt.height)}}et.bindRenderbuffer(et.RENDERBUFFER,null)}function Cn(Zt,Gt){if(Gt&&Gt.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(_e.bindFramebuffer(et.FRAMEBUFFER,Zt),!(Gt.depthTexture&&Gt.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!tt.get(Gt.depthTexture).__webglTexture||Gt.depthTexture.image.width!==Gt.width||Gt.depthTexture.image.height!==Gt.height)&&(Gt.depthTexture.image.width=Gt.width,Gt.depthTexture.image.height=Gt.height,Gt.depthTexture.needsUpdate=!0),Nt(Gt.depthTexture,0);const hn=tt.get(Gt.depthTexture).__webglTexture,xn=Ln(Gt);if(Gt.depthTexture.format===DepthFormat)Sn(Gt)?at.framebufferTexture2DMultisampleEXT(et.FRAMEBUFFER,et.DEPTH_ATTACHMENT,et.TEXTURE_2D,hn,0,xn):et.framebufferTexture2D(et.FRAMEBUFFER,et.DEPTH_ATTACHMENT,et.TEXTURE_2D,hn,0);else if(Gt.depthTexture.format===DepthStencilFormat)Sn(Gt)?at.framebufferTexture2DMultisampleEXT(et.FRAMEBUFFER,et.DEPTH_STENCIL_ATTACHMENT,et.TEXTURE_2D,hn,0,xn):et.framebufferTexture2D(et.FRAMEBUFFER,et.DEPTH_STENCIL_ATTACHMENT,et.TEXTURE_2D,hn,0);else throw new Error("Unknown depthTexture format")}function En(Zt){const Gt=tt.get(Zt),fn=Zt.isWebGLCubeRenderTarget===!0;if(Zt.depthTexture&&!Gt.__autoAllocateDepthBuffer){if(fn)throw new Error("target.depthTexture not supported in Cube render targets");Cn(Gt.__webglFramebuffer,Zt)}else if(fn){Gt.__webglDepthbuffer=[];for(let hn=0;hn<6;hn++)_e.bindFramebuffer(et.FRAMEBUFFER,Gt.__webglFramebuffer[hn]),Gt.__webglDepthbuffer[hn]=et.createRenderbuffer(),In(Gt.__webglDepthbuffer[hn],Zt,!1)}else _e.bindFramebuffer(et.FRAMEBUFFER,Gt.__webglFramebuffer),Gt.__webglDepthbuffer=et.createRenderbuffer(),In(Gt.__webglDepthbuffer,Zt,!1);_e.bindFramebuffer(et.FRAMEBUFFER,null)}function jt(Zt,Gt,fn){const hn=tt.get(Zt);Gt!==void 0&&vn(hn.__webglFramebuffer,Zt,Zt.texture,et.COLOR_ATTACHMENT0,et.TEXTURE_2D,0),fn!==void 0&&En(Zt)}function Kt(Zt){const Gt=Zt.texture,fn=tt.get(Zt),hn=tt.get(Gt);Zt.addEventListener("dispose",xt);const xn=Zt.textures,Tn=Zt.isWebGLCubeRenderTarget===!0,sr=xn.length>1;if(sr||(hn.__webglTexture===void 0&&(hn.__webglTexture=et.createTexture()),hn.__version=Gt.version,ot.memory.textures++),Tn){fn.__webglFramebuffer=[];for(let Wn=0;Wn<6;Wn++)if(Gt.mipmaps&&Gt.mipmaps.length>0){fn.__webglFramebuffer[Wn]=[];for(let or=0;or<Gt.mipmaps.length;or++)fn.__webglFramebuffer[Wn][or]=et.createFramebuffer()}else fn.__webglFramebuffer[Wn]=et.createFramebuffer()}else{if(Gt.mipmaps&&Gt.mipmaps.length>0){fn.__webglFramebuffer=[];for(let Wn=0;Wn<Gt.mipmaps.length;Wn++)fn.__webglFramebuffer[Wn]=et.createFramebuffer()}else fn.__webglFramebuffer=et.createFramebuffer();if(sr)for(let Wn=0,or=xn.length;Wn<or;Wn++){const fr=tt.get(xn[Wn]);fr.__webglTexture===void 0&&(fr.__webglTexture=et.createTexture(),ot.memory.textures++)}if(Zt.samples>0&&Sn(Zt)===!1){fn.__webglMultisampledFramebuffer=et.createFramebuffer(),fn.__webglColorRenderbuffer=[],_e.bindFramebuffer(et.FRAMEBUFFER,fn.__webglMultisampledFramebuffer);for(let Wn=0;Wn<xn.length;Wn++){const or=xn[Wn];fn.__webglColorRenderbuffer[Wn]=et.createRenderbuffer(),et.bindRenderbuffer(et.RENDERBUFFER,fn.__webglColorRenderbuffer[Wn]);const fr=rt.convert(or.format,or.colorSpace),Gn=rt.convert(or.type),nr=_t(or.internalFormat,fr,Gn,or.colorSpace,Zt.isXRRenderTarget===!0),mr=Ln(Zt);et.renderbufferStorageMultisample(et.RENDERBUFFER,mr,nr,Zt.width,Zt.height),et.framebufferRenderbuffer(et.FRAMEBUFFER,et.COLOR_ATTACHMENT0+Wn,et.RENDERBUFFER,fn.__webglColorRenderbuffer[Wn])}et.bindRenderbuffer(et.RENDERBUFFER,null),Zt.depthBuffer&&(fn.__webglDepthRenderbuffer=et.createRenderbuffer(),In(fn.__webglDepthRenderbuffer,Zt,!0)),_e.bindFramebuffer(et.FRAMEBUFFER,null)}}if(Tn){_e.bindTexture(et.TEXTURE_CUBE_MAP,hn.__webglTexture),en(et.TEXTURE_CUBE_MAP,Gt);for(let Wn=0;Wn<6;Wn++)if(Gt.mipmaps&&Gt.mipmaps.length>0)for(let or=0;or<Gt.mipmaps.length;or++)vn(fn.__webglFramebuffer[Wn][or],Zt,Gt,et.COLOR_ATTACHMENT0,et.TEXTURE_CUBE_MAP_POSITIVE_X+Wn,or);else vn(fn.__webglFramebuffer[Wn],Zt,Gt,et.COLOR_ATTACHMENT0,et.TEXTURE_CUBE_MAP_POSITIVE_X+Wn,0);mt(Gt)&&pt(et.TEXTURE_CUBE_MAP),_e.unbindTexture()}else if(sr){for(let Wn=0,or=xn.length;Wn<or;Wn++){const fr=xn[Wn],Gn=tt.get(fr);_e.bindTexture(et.TEXTURE_2D,Gn.__webglTexture),en(et.TEXTURE_2D,fr),vn(fn.__webglFramebuffer,Zt,fr,et.COLOR_ATTACHMENT0+Wn,et.TEXTURE_2D,0),mt(fr)&&pt(et.TEXTURE_2D)}_e.unbindTexture()}else{let Wn=et.TEXTURE_2D;if((Zt.isWebGL3DRenderTarget||Zt.isWebGLArrayRenderTarget)&&(Wn=Zt.isWebGL3DRenderTarget?et.TEXTURE_3D:et.TEXTURE_2D_ARRAY),_e.bindTexture(Wn,hn.__webglTexture),en(Wn,Gt),Gt.mipmaps&&Gt.mipmaps.length>0)for(let or=0;or<Gt.mipmaps.length;or++)vn(fn.__webglFramebuffer[or],Zt,Gt,et.COLOR_ATTACHMENT0,Wn,or);else vn(fn.__webglFramebuffer,Zt,Gt,et.COLOR_ATTACHMENT0,Wn,0);mt(Gt)&&pt(Wn),_e.unbindTexture()}Zt.depthBuffer&&En(Zt)}function nn(Zt){const Gt=Zt.textures;for(let fn=0,hn=Gt.length;fn<hn;fn++){const xn=Gt[fn];if(mt(xn)){const Tn=Zt.isWebGLCubeRenderTarget?et.TEXTURE_CUBE_MAP:et.TEXTURE_2D,sr=tt.get(xn).__webglTexture;_e.bindTexture(Tn,sr),pt(Tn),_e.unbindTexture()}}}const Vt=[],on=[];function dn(Zt){if(Zt.samples>0){if(Sn(Zt)===!1){const Gt=Zt.textures,fn=Zt.width,hn=Zt.height;let xn=et.COLOR_BUFFER_BIT;const Tn=Zt.stencilBuffer?et.DEPTH_STENCIL_ATTACHMENT:et.DEPTH_ATTACHMENT,sr=tt.get(Zt),Wn=Gt.length>1;if(Wn)for(let or=0;or<Gt.length;or++)_e.bindFramebuffer(et.FRAMEBUFFER,sr.__webglMultisampledFramebuffer),et.framebufferRenderbuffer(et.FRAMEBUFFER,et.COLOR_ATTACHMENT0+or,et.RENDERBUFFER,null),_e.bindFramebuffer(et.FRAMEBUFFER,sr.__webglFramebuffer),et.framebufferTexture2D(et.DRAW_FRAMEBUFFER,et.COLOR_ATTACHMENT0+or,et.TEXTURE_2D,null,0);_e.bindFramebuffer(et.READ_FRAMEBUFFER,sr.__webglMultisampledFramebuffer),_e.bindFramebuffer(et.DRAW_FRAMEBUFFER,sr.__webglFramebuffer);for(let or=0;or<Gt.length;or++){if(Zt.resolveDepthBuffer&&(Zt.depthBuffer&&(xn|=et.DEPTH_BUFFER_BIT),Zt.stencilBuffer&&Zt.resolveStencilBuffer&&(xn|=et.STENCIL_BUFFER_BIT)),Wn){et.framebufferRenderbuffer(et.READ_FRAMEBUFFER,et.COLOR_ATTACHMENT0,et.RENDERBUFFER,sr.__webglColorRenderbuffer[or]);const fr=tt.get(Gt[or]).__webglTexture;et.framebufferTexture2D(et.DRAW_FRAMEBUFFER,et.COLOR_ATTACHMENT0,et.TEXTURE_2D,fr,0)}et.blitFramebuffer(0,0,fn,hn,0,0,fn,hn,xn,et.NEAREST),lt===!0&&(Vt.length=0,on.length=0,Vt.push(et.COLOR_ATTACHMENT0+or),Zt.depthBuffer&&Zt.resolveDepthBuffer===!1&&(Vt.push(Tn),on.push(Tn),et.invalidateFramebuffer(et.DRAW_FRAMEBUFFER,on)),et.invalidateFramebuffer(et.READ_FRAMEBUFFER,Vt))}if(_e.bindFramebuffer(et.READ_FRAMEBUFFER,null),_e.bindFramebuffer(et.DRAW_FRAMEBUFFER,null),Wn)for(let or=0;or<Gt.length;or++){_e.bindFramebuffer(et.FRAMEBUFFER,sr.__webglMultisampledFramebuffer),et.framebufferRenderbuffer(et.FRAMEBUFFER,et.COLOR_ATTACHMENT0+or,et.RENDERBUFFER,sr.__webglColorRenderbuffer[or]);const fr=tt.get(Gt[or]).__webglTexture;_e.bindFramebuffer(et.FRAMEBUFFER,sr.__webglFramebuffer),et.framebufferTexture2D(et.DRAW_FRAMEBUFFER,et.COLOR_ATTACHMENT0+or,et.TEXTURE_2D,fr,0)}_e.bindFramebuffer(et.DRAW_FRAMEBUFFER,sr.__webglMultisampledFramebuffer)}else if(Zt.depthBuffer&&Zt.resolveDepthBuffer===!1&&lt){const Gt=Zt.stencilBuffer?et.DEPTH_STENCIL_ATTACHMENT:et.DEPTH_ATTACHMENT;et.invalidateFramebuffer(et.DRAW_FRAMEBUFFER,[Gt])}}}function Ln(Zt){return Math.min(nt.maxSamples,Zt.samples)}function Sn(Zt){const Gt=tt.get(Zt);return Zt.samples>0&&_.has("WEBGL_multisampled_render_to_texture")===!0&&Gt.__useRenderToTexture!==!1}function Xn(Zt){const Gt=ot.render.frame;dt.get(Zt)!==Gt&&(dt.set(Zt,Gt),Zt.update())}function Vn(Zt,Gt){const fn=Zt.colorSpace,hn=Zt.format,xn=Zt.type;return Zt.isCompressedTexture===!0||Zt.isVideoTexture===!0||fn!==LinearSRGBColorSpace&&fn!==NoColorSpace&&(ColorManagement.getTransfer(fn)===SRGBTransfer?(hn!==RGBAFormat||xn!==UnsignedByteType)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",fn)),Gt}function Hn(Zt){return typeof HTMLImageElement<"u"&&Zt instanceof HTMLImageElement?(ut.width=Zt.naturalWidth||Zt.width,ut.height=Zt.naturalHeight||Zt.height):typeof VideoFrame<"u"&&Zt instanceof VideoFrame?(ut.width=Zt.displayWidth,ut.height=Zt.displayHeight):(ut.width=Zt.width,ut.height=Zt.height),ut}this.allocateTextureUnit=It,this.resetTextureUnits=Ct,this.setTexture2D=Nt,this.setTexture2DArray=Bt,this.setTexture3D=Ot,this.setTextureCube=Ut,this.rebindTextures=jt,this.setupRenderTarget=Kt,this.updateRenderTargetMipmap=nn,this.updateMultisampleRenderTarget=dn,this.setupDepthRenderbuffer=En,this.setupFrameBufferTexture=vn,this.useMultisampledRTT=Sn}function WebGLUtils(et,_){function _e(tt,nt=NoColorSpace){let rt;const ot=ColorManagement.getTransfer(nt);if(tt===UnsignedByteType)return et.UNSIGNED_BYTE;if(tt===UnsignedShort4444Type)return et.UNSIGNED_SHORT_4_4_4_4;if(tt===UnsignedShort5551Type)return et.UNSIGNED_SHORT_5_5_5_1;if(tt===UnsignedInt5999Type)return et.UNSIGNED_INT_5_9_9_9_REV;if(tt===ByteType)return et.BYTE;if(tt===ShortType)return et.SHORT;if(tt===UnsignedShortType)return et.UNSIGNED_SHORT;if(tt===IntType)return et.INT;if(tt===UnsignedIntType)return et.UNSIGNED_INT;if(tt===FloatType)return et.FLOAT;if(tt===HalfFloatType)return et.HALF_FLOAT;if(tt===AlphaFormat)return et.ALPHA;if(tt===RGBFormat)return et.RGB;if(tt===RGBAFormat)return et.RGBA;if(tt===LuminanceFormat)return et.LUMINANCE;if(tt===LuminanceAlphaFormat)return et.LUMINANCE_ALPHA;if(tt===DepthFormat)return et.DEPTH_COMPONENT;if(tt===DepthStencilFormat)return et.DEPTH_STENCIL;if(tt===RedFormat)return et.RED;if(tt===RedIntegerFormat)return et.RED_INTEGER;if(tt===RGFormat)return et.RG;if(tt===RGIntegerFormat)return et.RG_INTEGER;if(tt===RGBAIntegerFormat)return et.RGBA_INTEGER;if(tt===RGB_S3TC_DXT1_Format||tt===RGBA_S3TC_DXT1_Format||tt===RGBA_S3TC_DXT3_Format||tt===RGBA_S3TC_DXT5_Format)if(ot===SRGBTransfer)if(rt=_.get("WEBGL_compressed_texture_s3tc_srgb"),rt!==null){if(tt===RGB_S3TC_DXT1_Format)return rt.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(tt===RGBA_S3TC_DXT1_Format)return rt.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(tt===RGBA_S3TC_DXT3_Format)return rt.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(tt===RGBA_S3TC_DXT5_Format)return rt.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(rt=_.get("WEBGL_compressed_texture_s3tc"),rt!==null){if(tt===RGB_S3TC_DXT1_Format)return rt.COMPRESSED_RGB_S3TC_DXT1_EXT;if(tt===RGBA_S3TC_DXT1_Format)return rt.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(tt===RGBA_S3TC_DXT3_Format)return rt.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(tt===RGBA_S3TC_DXT5_Format)return rt.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(tt===RGB_PVRTC_4BPPV1_Format||tt===RGB_PVRTC_2BPPV1_Format||tt===RGBA_PVRTC_4BPPV1_Format||tt===RGBA_PVRTC_2BPPV1_Format)if(rt=_.get("WEBGL_compressed_texture_pvrtc"),rt!==null){if(tt===RGB_PVRTC_4BPPV1_Format)return rt.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(tt===RGB_PVRTC_2BPPV1_Format)return rt.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(tt===RGBA_PVRTC_4BPPV1_Format)return rt.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(tt===RGBA_PVRTC_2BPPV1_Format)return rt.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(tt===RGB_ETC1_Format||tt===RGB_ETC2_Format||tt===RGBA_ETC2_EAC_Format)if(rt=_.get("WEBGL_compressed_texture_etc"),rt!==null){if(tt===RGB_ETC1_Format||tt===RGB_ETC2_Format)return ot===SRGBTransfer?rt.COMPRESSED_SRGB8_ETC2:rt.COMPRESSED_RGB8_ETC2;if(tt===RGBA_ETC2_EAC_Format)return ot===SRGBTransfer?rt.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:rt.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(tt===RGBA_ASTC_4x4_Format||tt===RGBA_ASTC_5x4_Format||tt===RGBA_ASTC_5x5_Format||tt===RGBA_ASTC_6x5_Format||tt===RGBA_ASTC_6x6_Format||tt===RGBA_ASTC_8x5_Format||tt===RGBA_ASTC_8x6_Format||tt===RGBA_ASTC_8x8_Format||tt===RGBA_ASTC_10x5_Format||tt===RGBA_ASTC_10x6_Format||tt===RGBA_ASTC_10x8_Format||tt===RGBA_ASTC_10x10_Format||tt===RGBA_ASTC_12x10_Format||tt===RGBA_ASTC_12x12_Format)if(rt=_.get("WEBGL_compressed_texture_astc"),rt!==null){if(tt===RGBA_ASTC_4x4_Format)return ot===SRGBTransfer?rt.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:rt.COMPRESSED_RGBA_ASTC_4x4_KHR;if(tt===RGBA_ASTC_5x4_Format)return ot===SRGBTransfer?rt.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:rt.COMPRESSED_RGBA_ASTC_5x4_KHR;if(tt===RGBA_ASTC_5x5_Format)return ot===SRGBTransfer?rt.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:rt.COMPRESSED_RGBA_ASTC_5x5_KHR;if(tt===RGBA_ASTC_6x5_Format)return ot===SRGBTransfer?rt.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:rt.COMPRESSED_RGBA_ASTC_6x5_KHR;if(tt===RGBA_ASTC_6x6_Format)return ot===SRGBTransfer?rt.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:rt.COMPRESSED_RGBA_ASTC_6x6_KHR;if(tt===RGBA_ASTC_8x5_Format)return ot===SRGBTransfer?rt.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:rt.COMPRESSED_RGBA_ASTC_8x5_KHR;if(tt===RGBA_ASTC_8x6_Format)return ot===SRGBTransfer?rt.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:rt.COMPRESSED_RGBA_ASTC_8x6_KHR;if(tt===RGBA_ASTC_8x8_Format)return ot===SRGBTransfer?rt.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:rt.COMPRESSED_RGBA_ASTC_8x8_KHR;if(tt===RGBA_ASTC_10x5_Format)return ot===SRGBTransfer?rt.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:rt.COMPRESSED_RGBA_ASTC_10x5_KHR;if(tt===RGBA_ASTC_10x6_Format)return ot===SRGBTransfer?rt.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:rt.COMPRESSED_RGBA_ASTC_10x6_KHR;if(tt===RGBA_ASTC_10x8_Format)return ot===SRGBTransfer?rt.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:rt.COMPRESSED_RGBA_ASTC_10x8_KHR;if(tt===RGBA_ASTC_10x10_Format)return ot===SRGBTransfer?rt.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:rt.COMPRESSED_RGBA_ASTC_10x10_KHR;if(tt===RGBA_ASTC_12x10_Format)return ot===SRGBTransfer?rt.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:rt.COMPRESSED_RGBA_ASTC_12x10_KHR;if(tt===RGBA_ASTC_12x12_Format)return ot===SRGBTransfer?rt.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:rt.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(tt===RGBA_BPTC_Format||tt===RGB_BPTC_SIGNED_Format||tt===RGB_BPTC_UNSIGNED_Format)if(rt=_.get("EXT_texture_compression_bptc"),rt!==null){if(tt===RGBA_BPTC_Format)return ot===SRGBTransfer?rt.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:rt.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(tt===RGB_BPTC_SIGNED_Format)return rt.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(tt===RGB_BPTC_UNSIGNED_Format)return rt.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(tt===RED_RGTC1_Format||tt===SIGNED_RED_RGTC1_Format||tt===RED_GREEN_RGTC2_Format||tt===SIGNED_RED_GREEN_RGTC2_Format)if(rt=_.get("EXT_texture_compression_rgtc"),rt!==null){if(tt===RGBA_BPTC_Format)return rt.COMPRESSED_RED_RGTC1_EXT;if(tt===SIGNED_RED_RGTC1_Format)return rt.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(tt===RED_GREEN_RGTC2_Format)return rt.COMPRESSED_RED_GREEN_RGTC2_EXT;if(tt===SIGNED_RED_GREEN_RGTC2_Format)return rt.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return tt===UnsignedInt248Type?et.UNSIGNED_INT_24_8:et[tt]!==void 0?et[tt]:null}return{convert:_e}}class ArrayCamera extends PerspectiveCamera{constructor(_=[]){super(),this.isArrayCamera=!0,this.cameras=_}}class Group extends Object3D{constructor(){super(),this.isGroup=!0,this.type="Group"}}const _moveEvent={type:"move"};class WebXRController{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Group,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Group,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Vector3,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Vector3),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Group,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Vector3,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Vector3),this._grip}dispatchEvent(_){return this._targetRay!==null&&this._targetRay.dispatchEvent(_),this._grip!==null&&this._grip.dispatchEvent(_),this._hand!==null&&this._hand.dispatchEvent(_),this}connect(_){if(_&&_.hand){const _e=this._hand;if(_e)for(const tt of _.hand.values())this._getHandJoint(_e,tt)}return this.dispatchEvent({type:"connected",data:_}),this}disconnect(_){return this.dispatchEvent({type:"disconnected",data:_}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(_,_e,tt){let nt=null,rt=null,ot=null;const at=this._targetRay,lt=this._grip,ut=this._hand;if(_&&_e.session.visibilityState!=="visible-blurred"){if(ut&&_.hand){ot=!0;for(const ht of _.hand.values()){const mt=_e.getJointPose(ht,tt),pt=this._getHandJoint(ut,ht);mt!==null&&(pt.matrix.fromArray(mt.transform.matrix),pt.matrix.decompose(pt.position,pt.rotation,pt.scale),pt.matrixWorldNeedsUpdate=!0,pt.jointRadius=mt.radius),pt.visible=mt!==null}const dt=ut.joints["index-finger-tip"],st=ut.joints["thumb-tip"],it=dt.position.distanceTo(st.position),ct=.02,ft=.005;ut.inputState.pinching&&it>ct+ft?(ut.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:_.handedness,target:this})):!ut.inputState.pinching&&it<=ct-ft&&(ut.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:_.handedness,target:this}))}else lt!==null&&_.gripSpace&&(rt=_e.getPose(_.gripSpace,tt),rt!==null&&(lt.matrix.fromArray(rt.transform.matrix),lt.matrix.decompose(lt.position,lt.rotation,lt.scale),lt.matrixWorldNeedsUpdate=!0,rt.linearVelocity?(lt.hasLinearVelocity=!0,lt.linearVelocity.copy(rt.linearVelocity)):lt.hasLinearVelocity=!1,rt.angularVelocity?(lt.hasAngularVelocity=!0,lt.angularVelocity.copy(rt.angularVelocity)):lt.hasAngularVelocity=!1));at!==null&&(nt=_e.getPose(_.targetRaySpace,tt),nt===null&&rt!==null&&(nt=rt),nt!==null&&(at.matrix.fromArray(nt.transform.matrix),at.matrix.decompose(at.position,at.rotation,at.scale),at.matrixWorldNeedsUpdate=!0,nt.linearVelocity?(at.hasLinearVelocity=!0,at.linearVelocity.copy(nt.linearVelocity)):at.hasLinearVelocity=!1,nt.angularVelocity?(at.hasAngularVelocity=!0,at.angularVelocity.copy(nt.angularVelocity)):at.hasAngularVelocity=!1,this.dispatchEvent(_moveEvent)))}return at!==null&&(at.visible=nt!==null),lt!==null&&(lt.visible=rt!==null),ut!==null&&(ut.visible=ot!==null),this}_getHandJoint(_,_e){if(_.joints[_e.jointName]===void 0){const tt=new Group;tt.matrixAutoUpdate=!1,tt.visible=!1,_.joints[_e.jointName]=tt,_.add(tt)}return _.joints[_e.jointName]}}const _occlusion_vertex=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,_occlusion_fragment=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class WebXRDepthSensing{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(_,_e,tt){if(this.texture===null){const nt=new Texture,rt=_.properties.get(nt);rt.__webglTexture=_e.texture,(_e.depthNear!=tt.depthNear||_e.depthFar!=tt.depthFar)&&(this.depthNear=_e.depthNear,this.depthFar=_e.depthFar),this.texture=nt}}getMesh(_){if(this.texture!==null&&this.mesh===null){const _e=_.cameras[0].viewport,tt=new ShaderMaterial({vertexShader:_occlusion_vertex,fragmentShader:_occlusion_fragment,uniforms:{depthColor:{value:this.texture},depthWidth:{value:_e.z},depthHeight:{value:_e.w}}});this.mesh=new Mesh(new PlaneGeometry(20,20),tt)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class WebXRManager extends EventDispatcher{constructor(_,_e){super();const tt=this;let nt=null,rt=1,ot=null,at="local-floor",lt=1,ut=null,dt=null,st=null,it=null,ct=null,ft=null;const ht=new WebXRDepthSensing,mt=_e.getContextAttributes();let pt=null,_t=null;const vt=[],bt=[],wt=new Vector2;let xt=null;const Mt=new PerspectiveCamera;Mt.layers.enable(1),Mt.viewport=new Vector4;const At=new PerspectiveCamera;At.layers.enable(2),At.viewport=new Vector4;const St=[Mt,At],Tt=new ArrayCamera;Tt.layers.enable(1),Tt.layers.enable(2);let Ct=null,It=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(mn){let vn=vt[mn];return vn===void 0&&(vn=new WebXRController,vt[mn]=vn),vn.getTargetRaySpace()},this.getControllerGrip=function(mn){let vn=vt[mn];return vn===void 0&&(vn=new WebXRController,vt[mn]=vn),vn.getGripSpace()},this.getHand=function(mn){let vn=vt[mn];return vn===void 0&&(vn=new WebXRController,vt[mn]=vn),vn.getHandSpace()};function $t(mn){const vn=bt.indexOf(mn.inputSource);if(vn===-1)return;const In=vt[vn];In!==void 0&&(In.update(mn.inputSource,mn.frame,ut||ot),In.dispatchEvent({type:mn.type,data:mn.inputSource}))}function Nt(){nt.removeEventListener("select",$t),nt.removeEventListener("selectstart",$t),nt.removeEventListener("selectend",$t),nt.removeEventListener("squeeze",$t),nt.removeEventListener("squeezestart",$t),nt.removeEventListener("squeezeend",$t),nt.removeEventListener("end",Nt),nt.removeEventListener("inputsourceschange",Bt);for(let mn=0;mn<vt.length;mn++){const vn=bt[mn];vn!==null&&(bt[mn]=null,vt[mn].disconnect(vn))}Ct=null,It=null,ht.reset(),_.setRenderTarget(pt),ct=null,it=null,st=null,nt=null,_t=null,Un.stop(),tt.isPresenting=!1,_.setPixelRatio(xt),_.setSize(wt.width,wt.height,!1),tt.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(mn){rt=mn,tt.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(mn){at=mn,tt.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return ut||ot},this.setReferenceSpace=function(mn){ut=mn},this.getBaseLayer=function(){return it!==null?it:ct},this.getBinding=function(){return st},this.getFrame=function(){return ft},this.getSession=function(){return nt},this.setSession=async function(mn){if(nt=mn,nt!==null){if(pt=_.getRenderTarget(),nt.addEventListener("select",$t),nt.addEventListener("selectstart",$t),nt.addEventListener("selectend",$t),nt.addEventListener("squeeze",$t),nt.addEventListener("squeezestart",$t),nt.addEventListener("squeezeend",$t),nt.addEventListener("end",Nt),nt.addEventListener("inputsourceschange",Bt),mt.xrCompatible!==!0&&await _e.makeXRCompatible(),xt=_.getPixelRatio(),_.getSize(wt),nt.renderState.layers===void 0){const vn={antialias:mt.antialias,alpha:!0,depth:mt.depth,stencil:mt.stencil,framebufferScaleFactor:rt};ct=new XRWebGLLayer(nt,_e,vn),nt.updateRenderState({baseLayer:ct}),_.setPixelRatio(1),_.setSize(ct.framebufferWidth,ct.framebufferHeight,!1),_t=new WebGLRenderTarget(ct.framebufferWidth,ct.framebufferHeight,{format:RGBAFormat,type:UnsignedByteType,colorSpace:_.outputColorSpace,stencilBuffer:mt.stencil})}else{let vn=null,In=null,Cn=null;mt.depth&&(Cn=mt.stencil?_e.DEPTH24_STENCIL8:_e.DEPTH_COMPONENT24,vn=mt.stencil?DepthStencilFormat:DepthFormat,In=mt.stencil?UnsignedInt248Type:UnsignedIntType);const En={colorFormat:_e.RGBA8,depthFormat:Cn,scaleFactor:rt};st=new XRWebGLBinding(nt,_e),it=st.createProjectionLayer(En),nt.updateRenderState({layers:[it]}),_.setPixelRatio(1),_.setSize(it.textureWidth,it.textureHeight,!1),_t=new WebGLRenderTarget(it.textureWidth,it.textureHeight,{format:RGBAFormat,type:UnsignedByteType,depthTexture:new DepthTexture(it.textureWidth,it.textureHeight,In,void 0,void 0,void 0,void 0,void 0,void 0,vn),stencilBuffer:mt.stencil,colorSpace:_.outputColorSpace,samples:mt.antialias?4:0,resolveDepthBuffer:it.ignoreDepthValues===!1})}_t.isXRRenderTarget=!0,this.setFoveation(lt),ut=null,ot=await nt.requestReferenceSpace(at),Un.setContext(nt),Un.start(),tt.isPresenting=!0,tt.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(nt!==null)return nt.environmentBlendMode},this.getDepthTexture=function(){return ht.getDepthTexture()};function Bt(mn){for(let vn=0;vn<mn.removed.length;vn++){const In=mn.removed[vn],Cn=bt.indexOf(In);Cn>=0&&(bt[Cn]=null,vt[Cn].disconnect(In))}for(let vn=0;vn<mn.added.length;vn++){const In=mn.added[vn];let Cn=bt.indexOf(In);if(Cn===-1){for(let jt=0;jt<vt.length;jt++)if(jt>=bt.length){bt.push(In),Cn=jt;break}else if(bt[jt]===null){bt[jt]=In,Cn=jt;break}if(Cn===-1)break}const En=vt[Cn];En&&En.connect(In)}}const Ot=new Vector3,Ut=new Vector3;function Lt(mn,vn,In){Ot.setFromMatrixPosition(vn.matrixWorld),Ut.setFromMatrixPosition(In.matrixWorld);const Cn=Ot.distanceTo(Ut),En=vn.projectionMatrix.elements,jt=In.projectionMatrix.elements,Kt=En[14]/(En[10]-1),nn=En[14]/(En[10]+1),Vt=(En[9]+1)/En[5],on=(En[9]-1)/En[5],dn=(En[8]-1)/En[0],Ln=(jt[8]+1)/jt[0],Sn=Kt*dn,Xn=Kt*Ln,Vn=Cn/(-dn+Ln),Hn=Vn*-dn;vn.matrixWorld.decompose(mn.position,mn.quaternion,mn.scale),mn.translateX(Hn),mn.translateZ(Vn),mn.matrixWorld.compose(mn.position,mn.quaternion,mn.scale),mn.matrixWorldInverse.copy(mn.matrixWorld).invert();const Zt=Kt+Vn,Gt=nn+Vn,fn=Sn-Hn,hn=Xn+(Cn-Hn),xn=Vt*nn/Gt*Zt,Tn=on*nn/Gt*Zt;mn.projectionMatrix.makePerspective(fn,hn,xn,Tn,Zt,Gt),mn.projectionMatrixInverse.copy(mn.projectionMatrix).invert()}function zt(mn,vn){vn===null?mn.matrixWorld.copy(mn.matrix):mn.matrixWorld.multiplyMatrices(vn.matrixWorld,mn.matrix),mn.matrixWorldInverse.copy(mn.matrixWorld).invert()}this.updateCamera=function(mn){if(nt===null)return;ht.texture!==null&&(mn.near=ht.depthNear,mn.far=ht.depthFar),Tt.near=At.near=Mt.near=mn.near,Tt.far=At.far=Mt.far=mn.far,(Ct!==Tt.near||It!==Tt.far)&&(nt.updateRenderState({depthNear:Tt.near,depthFar:Tt.far}),Ct=Tt.near,It=Tt.far,Mt.near=Ct,Mt.far=It,At.near=Ct,At.far=It,Mt.updateProjectionMatrix(),At.updateProjectionMatrix(),mn.updateProjectionMatrix());const vn=mn.parent,In=Tt.cameras;zt(Tt,vn);for(let Cn=0;Cn<In.length;Cn++)zt(In[Cn],vn);In.length===2?Lt(Tt,Mt,At):Tt.projectionMatrix.copy(Mt.projectionMatrix),Yt(mn,Tt,vn)};function Yt(mn,vn,In){In===null?mn.matrix.copy(vn.matrixWorld):(mn.matrix.copy(In.matrixWorld),mn.matrix.invert(),mn.matrix.multiply(vn.matrixWorld)),mn.matrix.decompose(mn.position,mn.quaternion,mn.scale),mn.updateMatrixWorld(!0),mn.projectionMatrix.copy(vn.projectionMatrix),mn.projectionMatrixInverse.copy(vn.projectionMatrixInverse),mn.isPerspectiveCamera&&(mn.fov=RAD2DEG*2*Math.atan(1/mn.projectionMatrix.elements[5]),mn.zoom=1)}this.getCamera=function(){return Tt},this.getFoveation=function(){if(!(it===null&&ct===null))return lt},this.setFoveation=function(mn){lt=mn,it!==null&&(it.fixedFoveation=mn),ct!==null&&ct.fixedFoveation!==void 0&&(ct.fixedFoveation=mn)},this.hasDepthSensing=function(){return ht.texture!==null},this.getDepthSensingMesh=function(){return ht.getMesh(Tt)};let en=null;function bn(mn,vn){if(dt=vn.getViewerPose(ut||ot),ft=vn,dt!==null){const In=dt.views;ct!==null&&(_.setRenderTargetFramebuffer(_t,ct.framebuffer),_.setRenderTarget(_t));let Cn=!1;In.length!==Tt.cameras.length&&(Tt.cameras.length=0,Cn=!0);for(let jt=0;jt<In.length;jt++){const Kt=In[jt];let nn=null;if(ct!==null)nn=ct.getViewport(Kt);else{const on=st.getViewSubImage(it,Kt);nn=on.viewport,jt===0&&(_.setRenderTargetTextures(_t,on.colorTexture,it.ignoreDepthValues?void 0:on.depthStencilTexture),_.setRenderTarget(_t))}let Vt=St[jt];Vt===void 0&&(Vt=new PerspectiveCamera,Vt.layers.enable(jt),Vt.viewport=new Vector4,St[jt]=Vt),Vt.matrix.fromArray(Kt.transform.matrix),Vt.matrix.decompose(Vt.position,Vt.quaternion,Vt.scale),Vt.projectionMatrix.fromArray(Kt.projectionMatrix),Vt.projectionMatrixInverse.copy(Vt.projectionMatrix).invert(),Vt.viewport.set(nn.x,nn.y,nn.width,nn.height),jt===0&&(Tt.matrix.copy(Vt.matrix),Tt.matrix.decompose(Tt.position,Tt.quaternion,Tt.scale)),Cn===!0&&Tt.cameras.push(Vt)}const En=nt.enabledFeatures;if(En&&En.includes("depth-sensing")){const jt=st.getDepthInformation(In[0]);jt&&jt.isValid&&jt.texture&&ht.init(_,jt,nt.renderState)}}for(let In=0;In<vt.length;In++){const Cn=bt[In],En=vt[In];Cn!==null&&En!==void 0&&En.update(Cn,vn,ut||ot)}en&&en(mn,vn),vn.detectedPlanes&&tt.dispatchEvent({type:"planesdetected",data:vn}),ft=null}const Un=new WebGLAnimation;Un.setAnimationLoop(bn),this.setAnimationLoop=function(mn){en=mn},this.dispose=function(){}}}const _e1=new Euler,_m1$5=new Matrix4;function WebGLMaterials(et,_){function _e(mt,pt){mt.matrixAutoUpdate===!0&&mt.updateMatrix(),pt.value.copy(mt.matrix)}function tt(mt,pt){pt.color.getRGB(mt.fogColor.value,getUnlitUniformColorSpace(et)),pt.isFog?(mt.fogNear.value=pt.near,mt.fogFar.value=pt.far):pt.isFogExp2&&(mt.fogDensity.value=pt.density)}function nt(mt,pt,_t,vt,bt){pt.isMeshBasicMaterial||pt.isMeshLambertMaterial?rt(mt,pt):pt.isMeshToonMaterial?(rt(mt,pt),st(mt,pt)):pt.isMeshPhongMaterial?(rt(mt,pt),dt(mt,pt)):pt.isMeshStandardMaterial?(rt(mt,pt),it(mt,pt),pt.isMeshPhysicalMaterial&&ct(mt,pt,bt)):pt.isMeshMatcapMaterial?(rt(mt,pt),ft(mt,pt)):pt.isMeshDepthMaterial?rt(mt,pt):pt.isMeshDistanceMaterial?(rt(mt,pt),ht(mt,pt)):pt.isMeshNormalMaterial?rt(mt,pt):pt.isLineBasicMaterial?(ot(mt,pt),pt.isLineDashedMaterial&&at(mt,pt)):pt.isPointsMaterial?lt(mt,pt,_t,vt):pt.isSpriteMaterial?ut(mt,pt):pt.isShadowMaterial?(mt.color.value.copy(pt.color),mt.opacity.value=pt.opacity):pt.isShaderMaterial&&(pt.uniformsNeedUpdate=!1)}function rt(mt,pt){mt.opacity.value=pt.opacity,pt.color&&mt.diffuse.value.copy(pt.color),pt.emissive&&mt.emissive.value.copy(pt.emissive).multiplyScalar(pt.emissiveIntensity),pt.map&&(mt.map.value=pt.map,_e(pt.map,mt.mapTransform)),pt.alphaMap&&(mt.alphaMap.value=pt.alphaMap,_e(pt.alphaMap,mt.alphaMapTransform)),pt.bumpMap&&(mt.bumpMap.value=pt.bumpMap,_e(pt.bumpMap,mt.bumpMapTransform),mt.bumpScale.value=pt.bumpScale,pt.side===BackSide&&(mt.bumpScale.value*=-1)),pt.normalMap&&(mt.normalMap.value=pt.normalMap,_e(pt.normalMap,mt.normalMapTransform),mt.normalScale.value.copy(pt.normalScale),pt.side===BackSide&&mt.normalScale.value.negate()),pt.displacementMap&&(mt.displacementMap.value=pt.displacementMap,_e(pt.displacementMap,mt.displacementMapTransform),mt.displacementScale.value=pt.displacementScale,mt.displacementBias.value=pt.displacementBias),pt.emissiveMap&&(mt.emissiveMap.value=pt.emissiveMap,_e(pt.emissiveMap,mt.emissiveMapTransform)),pt.specularMap&&(mt.specularMap.value=pt.specularMap,_e(pt.specularMap,mt.specularMapTransform)),pt.alphaTest>0&&(mt.alphaTest.value=pt.alphaTest);const _t=_.get(pt),vt=_t.envMap,bt=_t.envMapRotation;vt&&(mt.envMap.value=vt,_e1.copy(bt),_e1.x*=-1,_e1.y*=-1,_e1.z*=-1,vt.isCubeTexture&&vt.isRenderTargetTexture===!1&&(_e1.y*=-1,_e1.z*=-1),mt.envMapRotation.value.setFromMatrix4(_m1$5.makeRotationFromEuler(_e1)),mt.flipEnvMap.value=vt.isCubeTexture&&vt.isRenderTargetTexture===!1?-1:1,mt.reflectivity.value=pt.reflectivity,mt.ior.value=pt.ior,mt.refractionRatio.value=pt.refractionRatio),pt.lightMap&&(mt.lightMap.value=pt.lightMap,mt.lightMapIntensity.value=pt.lightMapIntensity,_e(pt.lightMap,mt.lightMapTransform)),pt.aoMap&&(mt.aoMap.value=pt.aoMap,mt.aoMapIntensity.value=pt.aoMapIntensity,_e(pt.aoMap,mt.aoMapTransform))}function ot(mt,pt){mt.diffuse.value.copy(pt.color),mt.opacity.value=pt.opacity,pt.map&&(mt.map.value=pt.map,_e(pt.map,mt.mapTransform))}function at(mt,pt){mt.dashSize.value=pt.dashSize,mt.totalSize.value=pt.dashSize+pt.gapSize,mt.scale.value=pt.scale}function lt(mt,pt,_t,vt){mt.diffuse.value.copy(pt.color),mt.opacity.value=pt.opacity,mt.size.value=pt.size*_t,mt.scale.value=vt*.5,pt.map&&(mt.map.value=pt.map,_e(pt.map,mt.uvTransform)),pt.alphaMap&&(mt.alphaMap.value=pt.alphaMap,_e(pt.alphaMap,mt.alphaMapTransform)),pt.alphaTest>0&&(mt.alphaTest.value=pt.alphaTest)}function ut(mt,pt){mt.diffuse.value.copy(pt.color),mt.opacity.value=pt.opacity,mt.rotation.value=pt.rotation,pt.map&&(mt.map.value=pt.map,_e(pt.map,mt.mapTransform)),pt.alphaMap&&(mt.alphaMap.value=pt.alphaMap,_e(pt.alphaMap,mt.alphaMapTransform)),pt.alphaTest>0&&(mt.alphaTest.value=pt.alphaTest)}function dt(mt,pt){mt.specular.value.copy(pt.specular),mt.shininess.value=Math.max(pt.shininess,1e-4)}function st(mt,pt){pt.gradientMap&&(mt.gradientMap.value=pt.gradientMap)}function it(mt,pt){mt.metalness.value=pt.metalness,pt.metalnessMap&&(mt.metalnessMap.value=pt.metalnessMap,_e(pt.metalnessMap,mt.metalnessMapTransform)),mt.roughness.value=pt.roughness,pt.roughnessMap&&(mt.roughnessMap.value=pt.roughnessMap,_e(pt.roughnessMap,mt.roughnessMapTransform)),pt.envMap&&(mt.envMapIntensity.value=pt.envMapIntensity)}function ct(mt,pt,_t){mt.ior.value=pt.ior,pt.sheen>0&&(mt.sheenColor.value.copy(pt.sheenColor).multiplyScalar(pt.sheen),mt.sheenRoughness.value=pt.sheenRoughness,pt.sheenColorMap&&(mt.sheenColorMap.value=pt.sheenColorMap,_e(pt.sheenColorMap,mt.sheenColorMapTransform)),pt.sheenRoughnessMap&&(mt.sheenRoughnessMap.value=pt.sheenRoughnessMap,_e(pt.sheenRoughnessMap,mt.sheenRoughnessMapTransform))),pt.clearcoat>0&&(mt.clearcoat.value=pt.clearcoat,mt.clearcoatRoughness.value=pt.clearcoatRoughness,pt.clearcoatMap&&(mt.clearcoatMap.value=pt.clearcoatMap,_e(pt.clearcoatMap,mt.clearcoatMapTransform)),pt.clearcoatRoughnessMap&&(mt.clearcoatRoughnessMap.value=pt.clearcoatRoughnessMap,_e(pt.clearcoatRoughnessMap,mt.clearcoatRoughnessMapTransform)),pt.clearcoatNormalMap&&(mt.clearcoatNormalMap.value=pt.clearcoatNormalMap,_e(pt.clearcoatNormalMap,mt.clearcoatNormalMapTransform),mt.clearcoatNormalScale.value.copy(pt.clearcoatNormalScale),pt.side===BackSide&&mt.clearcoatNormalScale.value.negate())),pt.dispersion>0&&(mt.dispersion.value=pt.dispersion),pt.iridescence>0&&(mt.iridescence.value=pt.iridescence,mt.iridescenceIOR.value=pt.iridescenceIOR,mt.iridescenceThicknessMinimum.value=pt.iridescenceThicknessRange[0],mt.iridescenceThicknessMaximum.value=pt.iridescenceThicknessRange[1],pt.iridescenceMap&&(mt.iridescenceMap.value=pt.iridescenceMap,_e(pt.iridescenceMap,mt.iridescenceMapTransform)),pt.iridescenceThicknessMap&&(mt.iridescenceThicknessMap.value=pt.iridescenceThicknessMap,_e(pt.iridescenceThicknessMap,mt.iridescenceThicknessMapTransform))),pt.transmission>0&&(mt.transmission.value=pt.transmission,mt.transmissionSamplerMap.value=_t.texture,mt.transmissionSamplerSize.value.set(_t.width,_t.height),pt.transmissionMap&&(mt.transmissionMap.value=pt.transmissionMap,_e(pt.transmissionMap,mt.transmissionMapTransform)),mt.thickness.value=pt.thickness,pt.thicknessMap&&(mt.thicknessMap.value=pt.thicknessMap,_e(pt.thicknessMap,mt.thicknessMapTransform)),mt.attenuationDistance.value=pt.attenuationDistance,mt.attenuationColor.value.copy(pt.attenuationColor)),pt.anisotropy>0&&(mt.anisotropyVector.value.set(pt.anisotropy*Math.cos(pt.anisotropyRotation),pt.anisotropy*Math.sin(pt.anisotropyRotation)),pt.anisotropyMap&&(mt.anisotropyMap.value=pt.anisotropyMap,_e(pt.anisotropyMap,mt.anisotropyMapTransform))),mt.specularIntensity.value=pt.specularIntensity,mt.specularColor.value.copy(pt.specularColor),pt.specularColorMap&&(mt.specularColorMap.value=pt.specularColorMap,_e(pt.specularColorMap,mt.specularColorMapTransform)),pt.specularIntensityMap&&(mt.specularIntensityMap.value=pt.specularIntensityMap,_e(pt.specularIntensityMap,mt.specularIntensityMapTransform))}function ft(mt,pt){pt.matcap&&(mt.matcap.value=pt.matcap)}function ht(mt,pt){const _t=_.get(pt).light;mt.referencePosition.value.setFromMatrixPosition(_t.matrixWorld),mt.nearDistance.value=_t.shadow.camera.near,mt.farDistance.value=_t.shadow.camera.far}return{refreshFogUniforms:tt,refreshMaterialUniforms:nt}}function WebGLUniformsGroups(et,_,_e,tt){let nt={},rt={},ot=[];const at=et.getParameter(et.MAX_UNIFORM_BUFFER_BINDINGS);function lt(_t,vt){const bt=vt.program;tt.uniformBlockBinding(_t,bt)}function ut(_t,vt){let bt=nt[_t.id];bt===void 0&&(ft(_t),bt=dt(_t),nt[_t.id]=bt,_t.addEventListener("dispose",mt));const wt=vt.program;tt.updateUBOMapping(_t,wt);const xt=_.render.frame;rt[_t.id]!==xt&&(it(_t),rt[_t.id]=xt)}function dt(_t){const vt=st();_t.__bindingPointIndex=vt;const bt=et.createBuffer(),wt=_t.__size,xt=_t.usage;return et.bindBuffer(et.UNIFORM_BUFFER,bt),et.bufferData(et.UNIFORM_BUFFER,wt,xt),et.bindBuffer(et.UNIFORM_BUFFER,null),et.bindBufferBase(et.UNIFORM_BUFFER,vt,bt),bt}function st(){for(let _t=0;_t<at;_t++)if(ot.indexOf(_t)===-1)return ot.push(_t),_t;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function it(_t){const vt=nt[_t.id],bt=_t.uniforms,wt=_t.__cache;et.bindBuffer(et.UNIFORM_BUFFER,vt);for(let xt=0,Mt=bt.length;xt<Mt;xt++){const At=Array.isArray(bt[xt])?bt[xt]:[bt[xt]];for(let St=0,Tt=At.length;St<Tt;St++){const Ct=At[St];if(ct(Ct,xt,St,wt)===!0){const It=Ct.__offset,$t=Array.isArray(Ct.value)?Ct.value:[Ct.value];let Nt=0;for(let Bt=0;Bt<$t.length;Bt++){const Ot=$t[Bt],Ut=ht(Ot);typeof Ot=="number"||typeof Ot=="boolean"?(Ct.__data[0]=Ot,et.bufferSubData(et.UNIFORM_BUFFER,It+Nt,Ct.__data)):Ot.isMatrix3?(Ct.__data[0]=Ot.elements[0],Ct.__data[1]=Ot.elements[1],Ct.__data[2]=Ot.elements[2],Ct.__data[3]=0,Ct.__data[4]=Ot.elements[3],Ct.__data[5]=Ot.elements[4],Ct.__data[6]=Ot.elements[5],Ct.__data[7]=0,Ct.__data[8]=Ot.elements[6],Ct.__data[9]=Ot.elements[7],Ct.__data[10]=Ot.elements[8],Ct.__data[11]=0):(Ot.toArray(Ct.__data,Nt),Nt+=Ut.storage/Float32Array.BYTES_PER_ELEMENT)}et.bufferSubData(et.UNIFORM_BUFFER,It,Ct.__data)}}}et.bindBuffer(et.UNIFORM_BUFFER,null)}function ct(_t,vt,bt,wt){const xt=_t.value,Mt=vt+"_"+bt;if(wt[Mt]===void 0)return typeof xt=="number"||typeof xt=="boolean"?wt[Mt]=xt:wt[Mt]=xt.clone(),!0;{const At=wt[Mt];if(typeof xt=="number"||typeof xt=="boolean"){if(At!==xt)return wt[Mt]=xt,!0}else if(At.equals(xt)===!1)return At.copy(xt),!0}return!1}function ft(_t){const vt=_t.uniforms;let bt=0;const wt=16;for(let Mt=0,At=vt.length;Mt<At;Mt++){const St=Array.isArray(vt[Mt])?vt[Mt]:[vt[Mt]];for(let Tt=0,Ct=St.length;Tt<Ct;Tt++){const It=St[Tt],$t=Array.isArray(It.value)?It.value:[It.value];for(let Nt=0,Bt=$t.length;Nt<Bt;Nt++){const Ot=$t[Nt],Ut=ht(Ot),Lt=bt%wt;Lt!==0&&wt-Lt<Ut.boundary&&(bt+=wt-Lt),It.__data=new Float32Array(Ut.storage/Float32Array.BYTES_PER_ELEMENT),It.__offset=bt,bt+=Ut.storage}}}const xt=bt%wt;return xt>0&&(bt+=wt-xt),_t.__size=bt,_t.__cache={},this}function ht(_t){const vt={boundary:0,storage:0};return typeof _t=="number"||typeof _t=="boolean"?(vt.boundary=4,vt.storage=4):_t.isVector2?(vt.boundary=8,vt.storage=8):_t.isVector3||_t.isColor?(vt.boundary=16,vt.storage=12):_t.isVector4?(vt.boundary=16,vt.storage=16):_t.isMatrix3?(vt.boundary=48,vt.storage=48):_t.isMatrix4?(vt.boundary=64,vt.storage=64):_t.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",_t),vt}function mt(_t){const vt=_t.target;vt.removeEventListener("dispose",mt);const bt=ot.indexOf(vt.__bindingPointIndex);ot.splice(bt,1),et.deleteBuffer(nt[vt.id]),delete nt[vt.id],delete rt[vt.id]}function pt(){for(const _t in nt)et.deleteBuffer(nt[_t]);ot=[],nt={},rt={}}return{bind:lt,update:ut,dispose:pt}}class WebGLRenderer{constructor(_={}){const{canvas:_e=createCanvasElement(),context:tt=null,depth:nt=!0,stencil:rt=!1,alpha:ot=!1,antialias:at=!1,premultipliedAlpha:lt=!0,preserveDrawingBuffer:ut=!1,powerPreference:dt="default",failIfMajorPerformanceCaveat:st=!1}=_;this.isWebGLRenderer=!0;let it;if(tt!==null){if(typeof WebGLRenderingContext<"u"&&tt instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");it=tt.getContextAttributes().alpha}else it=ot;const ct=new Uint32Array(4),ft=new Int32Array(4);let ht=null,mt=null;const pt=[],_t=[];this.domElement=_e,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=SRGBColorSpace,this.toneMapping=NoToneMapping,this.toneMappingExposure=1;const vt=this;let bt=!1,wt=0,xt=0,Mt=null,At=-1,St=null;const Tt=new Vector4,Ct=new Vector4;let It=null;const $t=new Color$1(0);let Nt=0,Bt=_e.width,Ot=_e.height,Ut=1,Lt=null,zt=null;const Yt=new Vector4(0,0,Bt,Ot),en=new Vector4(0,0,Bt,Ot);let bn=!1;const Un=new Frustum;let mn=!1,vn=!1;const In=new Matrix4,Cn=new Vector3,En=new Vector4,jt={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let Kt=!1;function nn(){return Mt===null?Ut:1}let Vt=tt;function on(Dt,Xt){return _e.getContext(Dt,Xt)}try{const Dt={alpha:!0,depth:nt,stencil:rt,antialias:at,premultipliedAlpha:lt,preserveDrawingBuffer:ut,powerPreference:dt,failIfMajorPerformanceCaveat:st};if("setAttribute"in _e&&_e.setAttribute("data-engine",`three.js r${REVISION}`),_e.addEventListener("webglcontextlost",Dn,!1),_e.addEventListener("webglcontextrestored",$n,!1),_e.addEventListener("webglcontextcreationerror",Jn,!1),Vt===null){const Xt="webgl2";if(Vt=on(Xt,Dt),Vt===null)throw on(Xt)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(Dt){throw console.error("THREE.WebGLRenderer: "+Dt.message),Dt}let dn,Ln,Sn,Xn,Vn,Hn,Zt,Gt,fn,hn,xn,Tn,sr,Wn,or,fr,Gn,nr,mr,hr,Bn,cn,Fn,ir;function ln(){dn=new WebGLExtensions(Vt),dn.init(),cn=new WebGLUtils(Vt,dn),Ln=new WebGLCapabilities(Vt,dn,_,cn),Sn=new WebGLState(Vt),Xn=new WebGLInfo(Vt),Vn=new WebGLProperties,Hn=new WebGLTextures(Vt,dn,Sn,Vn,Ln,cn,Xn),Zt=new WebGLCubeMaps(vt),Gt=new WebGLCubeUVMaps(vt),fn=new WebGLAttributes(Vt),Fn=new WebGLBindingStates(Vt,fn),hn=new WebGLGeometries(Vt,fn,Xn,Fn),xn=new WebGLObjects(Vt,hn,fn,Xn),mr=new WebGLMorphtargets(Vt,Ln,Hn),fr=new WebGLClipping(Vn),Tn=new WebGLPrograms(vt,Zt,Gt,dn,Ln,Fn,fr),sr=new WebGLMaterials(vt,Vn),Wn=new WebGLRenderLists,or=new WebGLRenderStates(dn),nr=new WebGLBackground(vt,Zt,Gt,Sn,xn,it,lt),Gn=new WebGLShadowMap(vt,xn,Ln),ir=new WebGLUniformsGroups(Vt,Xn,Ln,Sn),hr=new WebGLBufferRenderer(Vt,dn,Xn),Bn=new WebGLIndexedBufferRenderer(Vt,dn,Xn),Xn.programs=Tn.programs,vt.capabilities=Ln,vt.extensions=dn,vt.properties=Vn,vt.renderLists=Wn,vt.shadowMap=Gn,vt.state=Sn,vt.info=Xn}ln();const On=new WebXRManager(vt,Vt);this.xr=On,this.getContext=function(){return Vt},this.getContextAttributes=function(){return Vt.getContextAttributes()},this.forceContextLoss=function(){const Dt=dn.get("WEBGL_lose_context");Dt&&Dt.loseContext()},this.forceContextRestore=function(){const Dt=dn.get("WEBGL_lose_context");Dt&&Dt.restoreContext()},this.getPixelRatio=function(){return Ut},this.setPixelRatio=function(Dt){Dt!==void 0&&(Ut=Dt,this.setSize(Bt,Ot,!1))},this.getSize=function(Dt){return Dt.set(Bt,Ot)},this.setSize=function(Dt,Xt,Jt=!0){if(On.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}Bt=Dt,Ot=Xt,_e.width=Math.floor(Dt*Ut),_e.height=Math.floor(Xt*Ut),Jt===!0&&(_e.style.width=Dt+"px",_e.style.height=Xt+"px"),this.setViewport(0,0,Dt,Xt)},this.getDrawingBufferSize=function(Dt){return Dt.set(Bt*Ut,Ot*Ut).floor()},this.setDrawingBufferSize=function(Dt,Xt,Jt){Bt=Dt,Ot=Xt,Ut=Jt,_e.width=Math.floor(Dt*Jt),_e.height=Math.floor(Xt*Jt),this.setViewport(0,0,Dt,Xt)},this.getCurrentViewport=function(Dt){return Dt.copy(Tt)},this.getViewport=function(Dt){return Dt.copy(Yt)},this.setViewport=function(Dt,Xt,Jt,sn){Dt.isVector4?Yt.set(Dt.x,Dt.y,Dt.z,Dt.w):Yt.set(Dt,Xt,Jt,sn),Sn.viewport(Tt.copy(Yt).multiplyScalar(Ut).round())},this.getScissor=function(Dt){return Dt.copy(en)},this.setScissor=function(Dt,Xt,Jt,sn){Dt.isVector4?en.set(Dt.x,Dt.y,Dt.z,Dt.w):en.set(Dt,Xt,Jt,sn),Sn.scissor(Ct.copy(en).multiplyScalar(Ut).round())},this.getScissorTest=function(){return bn},this.setScissorTest=function(Dt){Sn.setScissorTest(bn=Dt)},this.setOpaqueSort=function(Dt){Lt=Dt},this.setTransparentSort=function(Dt){zt=Dt},this.getClearColor=function(Dt){return Dt.copy(nr.getClearColor())},this.setClearColor=function(){nr.setClearColor.apply(nr,arguments)},this.getClearAlpha=function(){return nr.getClearAlpha()},this.setClearAlpha=function(){nr.setClearAlpha.apply(nr,arguments)},this.clear=function(Dt=!0,Xt=!0,Jt=!0){let sn=0;if(Dt){let an=!1;if(Mt!==null){const Mn=Mt.texture.format;an=Mn===RGBAIntegerFormat||Mn===RGIntegerFormat||Mn===RedIntegerFormat}if(an){const Mn=Mt.texture.type,zn=Mn===UnsignedByteType||Mn===UnsignedIntType||Mn===UnsignedShortType||Mn===UnsignedInt248Type||Mn===UnsignedShort4444Type||Mn===UnsignedShort5551Type,Qn=nr.getClearColor(),rr=nr.getClearAlpha(),cr=Qn.r,_n=Qn.g,Zn=Qn.b;zn?(ct[0]=cr,ct[1]=_n,ct[2]=Zn,ct[3]=rr,Vt.clearBufferuiv(Vt.COLOR,0,ct)):(ft[0]=cr,ft[1]=_n,ft[2]=Zn,ft[3]=rr,Vt.clearBufferiv(Vt.COLOR,0,ft))}else sn|=Vt.COLOR_BUFFER_BIT}Xt&&(sn|=Vt.DEPTH_BUFFER_BIT),Jt&&(sn|=Vt.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),Vt.clear(sn)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){_e.removeEventListener("webglcontextlost",Dn,!1),_e.removeEventListener("webglcontextrestored",$n,!1),_e.removeEventListener("webglcontextcreationerror",Jn,!1),Wn.dispose(),or.dispose(),Vn.dispose(),Zt.dispose(),Gt.dispose(),xn.dispose(),Fn.dispose(),ir.dispose(),Tn.dispose(),On.dispose(),On.removeEventListener("sessionstart",Wr),On.removeEventListener("sessionend",jo),go.stop()};function Dn(Dt){Dt.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),bt=!0}function $n(){console.log("THREE.WebGLRenderer: Context Restored."),bt=!1;const Dt=Xn.autoReset,Xt=Gn.enabled,Jt=Gn.autoUpdate,sn=Gn.needsUpdate,an=Gn.type;ln(),Xn.autoReset=Dt,Gn.enabled=Xt,Gn.autoUpdate=Jt,Gn.needsUpdate=sn,Gn.type=an}function Jn(Dt){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",Dt.statusMessage)}function qn(Dt){const Xt=Dt.target;Xt.removeEventListener("dispose",qn),Kn(Xt)}function Kn(Dt){ar(Dt),Vn.remove(Dt)}function ar(Dt){const Xt=Vn.get(Dt).programs;Xt!==void 0&&(Xt.forEach(function(Jt){Tn.releaseProgram(Jt)}),Dt.isShaderMaterial&&Tn.releaseShaderCache(Dt))}this.renderBufferDirect=function(Dt,Xt,Jt,sn,an,Mn){Xt===null&&(Xt=jt);const zn=an.isMesh&&an.matrixWorld.determinant()<0,Qn=Wt(Dt,Xt,Jt,sn,an);Sn.setMaterial(sn,zn);let rr=Jt.index,cr=1;if(sn.wireframe===!0){if(rr=hn.getWireframeAttribute(Jt),rr===void 0)return;cr=2}const _n=Jt.drawRange,Zn=Jt.attributes.position;let _r=_n.start*cr,Ir=(_n.start+_n.count)*cr;Mn!==null&&(_r=Math.max(_r,Mn.start*cr),Ir=Math.min(Ir,(Mn.start+Mn.count)*cr)),rr!==null?(_r=Math.max(_r,0),Ir=Math.min(Ir,rr.count)):Zn!=null&&(_r=Math.max(_r,0),Ir=Math.min(Ir,Zn.count));const Lr=Ir-_r;if(Lr<0||Lr===1/0)return;Fn.setup(an,sn,Qn,Jt,rr);let jr,gr=hr;if(rr!==null&&(jr=fn.get(rr),gr=Bn,gr.setIndex(jr)),an.isMesh)sn.wireframe===!0?(Sn.setLineWidth(sn.wireframeLinewidth*nn()),gr.setMode(Vt.LINES)):gr.setMode(Vt.TRIANGLES);else if(an.isLine){let tr=sn.linewidth;tr===void 0&&(tr=1),Sn.setLineWidth(tr*nn()),an.isLineSegments?gr.setMode(Vt.LINES):an.isLineLoop?gr.setMode(Vt.LINE_LOOP):gr.setMode(Vt.LINE_STRIP)}else an.isPoints?gr.setMode(Vt.POINTS):an.isSprite&&gr.setMode(Vt.TRIANGLES);if(an.isBatchedMesh)if(an._multiDrawInstances!==null)gr.renderMultiDrawInstances(an._multiDrawStarts,an._multiDrawCounts,an._multiDrawCount,an._multiDrawInstances);else if(dn.get("WEBGL_multi_draw"))gr.renderMultiDraw(an._multiDrawStarts,an._multiDrawCounts,an._multiDrawCount);else{const tr=an._multiDrawStarts,Pr=an._multiDrawCounts,br=an._multiDrawCount,zr=rr?fn.get(rr).bytesPerElement:1,ao=Vn.get(sn).currentProgram.getUniforms();for(let Yr=0;Yr<br;Yr++)ao.setValue(Vt,"_gl_DrawID",Yr),gr.render(tr[Yr]/zr,Pr[Yr])}else if(an.isInstancedMesh)gr.renderInstances(_r,Lr,an.count);else if(Jt.isInstancedBufferGeometry){const tr=Jt._maxInstanceCount!==void 0?Jt._maxInstanceCount:1/0,Pr=Math.min(Jt.instanceCount,tr);gr.renderInstances(_r,Lr,Pr)}else gr.render(_r,Lr)};function Ur(Dt,Xt,Jt){Dt.transparent===!0&&Dt.side===DoubleSide&&Dt.forceSinglePass===!1?(Dt.side=BackSide,Dt.needsUpdate=!0,Oo(Dt,Xt,Jt),Dt.side=FrontSide,Dt.needsUpdate=!0,Oo(Dt,Xt,Jt),Dt.side=DoubleSide):Oo(Dt,Xt,Jt)}this.compile=function(Dt,Xt,Jt=null){Jt===null&&(Jt=Dt),mt=or.get(Jt),mt.init(Xt),_t.push(mt),Jt.traverseVisible(function(an){an.isLight&&an.layers.test(Xt.layers)&&(mt.pushLight(an),an.castShadow&&mt.pushShadow(an))}),Dt!==Jt&&Dt.traverseVisible(function(an){an.isLight&&an.layers.test(Xt.layers)&&(mt.pushLight(an),an.castShadow&&mt.pushShadow(an))}),mt.setupLights();const sn=new Set;return Dt.traverse(function(an){const Mn=an.material;if(Mn)if(Array.isArray(Mn))for(let zn=0;zn<Mn.length;zn++){const Qn=Mn[zn];Ur(Qn,Jt,an),sn.add(Qn)}else Ur(Mn,Jt,an),sn.add(Mn)}),_t.pop(),mt=null,sn},this.compileAsync=function(Dt,Xt,Jt=null){const sn=this.compile(Dt,Xt,Jt);return new Promise(an=>{function Mn(){if(sn.forEach(function(zn){Vn.get(zn).currentProgram.isReady()&&sn.delete(zn)}),sn.size===0){an(Dt);return}setTimeout(Mn,10)}dn.get("KHR_parallel_shader_compile")!==null?Mn():setTimeout(Mn,10)})};let wr=null;function Hr(Dt){wr&&wr(Dt)}function Wr(){go.stop()}function jo(){go.start()}const go=new WebGLAnimation;go.setAnimationLoop(Hr),typeof self<"u"&&go.setContext(self),this.setAnimationLoop=function(Dt){wr=Dt,On.setAnimationLoop(Dt),Dt===null?go.stop():go.start()},On.addEventListener("sessionstart",Wr),On.addEventListener("sessionend",jo),this.render=function(Dt,Xt){if(Xt!==void 0&&Xt.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(bt===!0)return;if(Dt.matrixWorldAutoUpdate===!0&&Dt.updateMatrixWorld(),Xt.parent===null&&Xt.matrixWorldAutoUpdate===!0&&Xt.updateMatrixWorld(),On.enabled===!0&&On.isPresenting===!0&&(On.cameraAutoUpdate===!0&&On.updateCamera(Xt),Xt=On.getCamera()),Dt.isScene===!0&&Dt.onBeforeRender(vt,Dt,Xt,Mt),mt=or.get(Dt,_t.length),mt.init(Xt),_t.push(mt),In.multiplyMatrices(Xt.projectionMatrix,Xt.matrixWorldInverse),Un.setFromProjectionMatrix(In),vn=this.localClippingEnabled,mn=fr.init(this.clippingPlanes,vn),ht=Wn.get(Dt,pt.length),ht.init(),pt.push(ht),On.enabled===!0&&On.isPresenting===!0){const Mn=vt.xr.getDepthSensingMesh();Mn!==null&&Uo(Mn,Xt,-1/0,vt.sortObjects)}Uo(Dt,Xt,0,vt.sortObjects),ht.finish(),vt.sortObjects===!0&&ht.sort(Lt,zt),Kt=On.enabled===!1||On.isPresenting===!1||On.hasDepthSensing()===!1,Kt&&nr.addToRenderList(ht,Dt),this.info.render.frame++,mn===!0&&fr.beginShadows();const Jt=mt.state.shadowsArray;Gn.render(Jt,Dt,Xt),mn===!0&&fr.endShadows(),this.info.autoReset===!0&&this.info.reset();const sn=ht.opaque,an=ht.transmissive;if(mt.setupLights(),Xt.isArrayCamera){const Mn=Xt.cameras;if(an.length>0)for(let zn=0,Qn=Mn.length;zn<Qn;zn++){const rr=Mn[zn];Co(sn,an,Dt,rr)}Kt&&nr.render(Dt);for(let zn=0,Qn=Mn.length;zn<Qn;zn++){const rr=Mn[zn];zo(ht,Dt,rr,rr.viewport)}}else an.length>0&&Co(sn,an,Dt,Xt),Kt&&nr.render(Dt),zo(ht,Dt,Xt);Mt!==null&&(Hn.updateMultisampleRenderTarget(Mt),Hn.updateRenderTargetMipmap(Mt)),Dt.isScene===!0&&Dt.onAfterRender(vt,Dt,Xt),Fn.resetDefaultState(),At=-1,St=null,_t.pop(),_t.length>0?(mt=_t[_t.length-1],mn===!0&&fr.setGlobalState(vt.clippingPlanes,mt.state.camera)):mt=null,pt.pop(),pt.length>0?ht=pt[pt.length-1]:ht=null};function Uo(Dt,Xt,Jt,sn){if(Dt.visible===!1)return;if(Dt.layers.test(Xt.layers)){if(Dt.isGroup)Jt=Dt.renderOrder;else if(Dt.isLOD)Dt.autoUpdate===!0&&Dt.update(Xt);else if(Dt.isLight)mt.pushLight(Dt),Dt.castShadow&&mt.pushShadow(Dt);else if(Dt.isSprite){if(!Dt.frustumCulled||Un.intersectsSprite(Dt)){sn&&En.setFromMatrixPosition(Dt.matrixWorld).applyMatrix4(In);const zn=xn.update(Dt),Qn=Dt.material;Qn.visible&&ht.push(Dt,zn,Qn,Jt,En.z,null)}}else if((Dt.isMesh||Dt.isLine||Dt.isPoints)&&(!Dt.frustumCulled||Un.intersectsObject(Dt))){const zn=xn.update(Dt),Qn=Dt.material;if(sn&&(Dt.boundingSphere!==void 0?(Dt.boundingSphere===null&&Dt.computeBoundingSphere(),En.copy(Dt.boundingSphere.center)):(zn.boundingSphere===null&&zn.computeBoundingSphere(),En.copy(zn.boundingSphere.center)),En.applyMatrix4(Dt.matrixWorld).applyMatrix4(In)),Array.isArray(Qn)){const rr=zn.groups;for(let cr=0,_n=rr.length;cr<_n;cr++){const Zn=rr[cr],_r=Qn[Zn.materialIndex];_r&&_r.visible&&ht.push(Dt,zn,_r,Jt,En.z,Zn)}}else Qn.visible&&ht.push(Dt,zn,Qn,Jt,En.z,null)}}const Mn=Dt.children;for(let zn=0,Qn=Mn.length;zn<Qn;zn++)Uo(Mn[zn],Xt,Jt,sn)}function zo(Dt,Xt,Jt,sn){const an=Dt.opaque,Mn=Dt.transmissive,zn=Dt.transparent;mt.setupLightsView(Jt),mn===!0&&fr.setGlobalState(vt.clippingPlanes,Jt),sn&&Sn.viewport(Tt.copy(sn)),an.length>0&&Ro(an,Xt,Jt),Mn.length>0&&Ro(Mn,Xt,Jt),zn.length>0&&Ro(zn,Xt,Jt),Sn.buffers.depth.setTest(!0),Sn.buffers.depth.setMask(!0),Sn.buffers.color.setMask(!0),Sn.setPolygonOffset(!1)}function Co(Dt,Xt,Jt,sn){if((Jt.isScene===!0?Jt.overrideMaterial:null)!==null)return;mt.state.transmissionRenderTarget[sn.id]===void 0&&(mt.state.transmissionRenderTarget[sn.id]=new WebGLRenderTarget(1,1,{generateMipmaps:!0,type:dn.has("EXT_color_buffer_half_float")||dn.has("EXT_color_buffer_float")?HalfFloatType:UnsignedByteType,minFilter:LinearMipmapLinearFilter,samples:4,stencilBuffer:rt,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:ColorManagement.workingColorSpace}));const Mn=mt.state.transmissionRenderTarget[sn.id],zn=sn.viewport||Tt;Mn.setSize(zn.z,zn.w);const Qn=vt.getRenderTarget();vt.setRenderTarget(Mn),vt.getClearColor($t),Nt=vt.getClearAlpha(),Nt<1&&vt.setClearColor(16777215,.5),Kt?nr.render(Jt):vt.clear();const rr=vt.toneMapping;vt.toneMapping=NoToneMapping;const cr=sn.viewport;if(sn.viewport!==void 0&&(sn.viewport=void 0),mt.setupLightsView(sn),mn===!0&&fr.setGlobalState(vt.clippingPlanes,sn),Ro(Dt,Jt,sn),Hn.updateMultisampleRenderTarget(Mn),Hn.updateRenderTargetMipmap(Mn),dn.has("WEBGL_multisampled_render_to_texture")===!1){let _n=!1;for(let Zn=0,_r=Xt.length;Zn<_r;Zn++){const Ir=Xt[Zn],Lr=Ir.object,jr=Ir.geometry,gr=Ir.material,tr=Ir.group;if(gr.side===DoubleSide&&Lr.layers.test(sn.layers)){const Pr=gr.side;gr.side=BackSide,gr.needsUpdate=!0,vo(Lr,Jt,sn,jr,gr,tr),gr.side=Pr,gr.needsUpdate=!0,_n=!0}}_n===!0&&(Hn.updateMultisampleRenderTarget(Mn),Hn.updateRenderTargetMipmap(Mn))}vt.setRenderTarget(Qn),vt.setClearColor($t,Nt),cr!==void 0&&(sn.viewport=cr),vt.toneMapping=rr}function Ro(Dt,Xt,Jt){const sn=Xt.isScene===!0?Xt.overrideMaterial:null;for(let an=0,Mn=Dt.length;an<Mn;an++){const zn=Dt[an],Qn=zn.object,rr=zn.geometry,cr=sn===null?zn.material:sn,_n=zn.group;Qn.layers.test(Jt.layers)&&vo(Qn,Xt,Jt,rr,cr,_n)}}function vo(Dt,Xt,Jt,sn,an,Mn){Dt.onBeforeRender(vt,Xt,Jt,sn,an,Mn),Dt.modelViewMatrix.multiplyMatrices(Jt.matrixWorldInverse,Dt.matrixWorld),Dt.normalMatrix.getNormalMatrix(Dt.modelViewMatrix),an.transparent===!0&&an.side===DoubleSide&&an.forceSinglePass===!1?(an.side=BackSide,an.needsUpdate=!0,vt.renderBufferDirect(Jt,Xt,sn,an,Dt,Mn),an.side=FrontSide,an.needsUpdate=!0,vt.renderBufferDirect(Jt,Xt,sn,an,Dt,Mn),an.side=DoubleSide):vt.renderBufferDirect(Jt,Xt,sn,an,Dt,Mn),Dt.onAfterRender(vt,Xt,Jt,sn,an,Mn)}function Oo(Dt,Xt,Jt){Xt.isScene!==!0&&(Xt=jt);const sn=Vn.get(Dt),an=mt.state.lights,Mn=mt.state.shadowsArray,zn=an.state.version,Qn=Tn.getParameters(Dt,an.state,Mn,Xt,Jt),rr=Tn.getProgramCacheKey(Qn);let cr=sn.programs;sn.environment=Dt.isMeshStandardMaterial?Xt.environment:null,sn.fog=Xt.fog,sn.envMap=(Dt.isMeshStandardMaterial?Gt:Zt).get(Dt.envMap||sn.environment),sn.envMapRotation=sn.environment!==null&&Dt.envMap===null?Xt.environmentRotation:Dt.envMapRotation,cr===void 0&&(Dt.addEventListener("dispose",qn),cr=new Map,sn.programs=cr);let _n=cr.get(rr);if(_n!==void 0){if(sn.currentProgram===_n&&sn.lightsStateVersion===zn)return Wo(Dt,Qn),_n}else Qn.uniforms=Tn.getUniforms(Dt),Dt.onBeforeCompile(Qn,vt),_n=Tn.acquireProgram(Qn,rr),cr.set(rr,_n),sn.uniforms=Qn.uniforms;const Zn=sn.uniforms;return(!Dt.isShaderMaterial&&!Dt.isRawShaderMaterial||Dt.clipping===!0)&&(Zn.clippingPlanes=fr.uniform),Wo(Dt,Qn),sn.needsLights=pn(Dt),sn.lightsStateVersion=zn,sn.needsLights&&(Zn.ambientLightColor.value=an.state.ambient,Zn.lightProbe.value=an.state.probe,Zn.directionalLights.value=an.state.directional,Zn.directionalLightShadows.value=an.state.directionalShadow,Zn.spotLights.value=an.state.spot,Zn.spotLightShadows.value=an.state.spotShadow,Zn.rectAreaLights.value=an.state.rectArea,Zn.ltc_1.value=an.state.rectAreaLTC1,Zn.ltc_2.value=an.state.rectAreaLTC2,Zn.pointLights.value=an.state.point,Zn.pointLightShadows.value=an.state.pointShadow,Zn.hemisphereLights.value=an.state.hemi,Zn.directionalShadowMap.value=an.state.directionalShadowMap,Zn.directionalShadowMatrix.value=an.state.directionalShadowMatrix,Zn.spotShadowMap.value=an.state.spotShadowMap,Zn.spotLightMatrix.value=an.state.spotLightMatrix,Zn.spotLightMap.value=an.state.spotLightMap,Zn.pointShadowMap.value=an.state.pointShadowMap,Zn.pointShadowMatrix.value=an.state.pointShadowMatrix),sn.currentProgram=_n,sn.uniformsList=null,_n}function Ho(Dt){if(Dt.uniformsList===null){const Xt=Dt.currentProgram.getUniforms();Dt.uniformsList=WebGLUniforms.seqWithValue(Xt.seq,Dt.uniforms)}return Dt.uniformsList}function Wo(Dt,Xt){const Jt=Vn.get(Dt);Jt.outputColorSpace=Xt.outputColorSpace,Jt.batching=Xt.batching,Jt.batchingColor=Xt.batchingColor,Jt.instancing=Xt.instancing,Jt.instancingColor=Xt.instancingColor,Jt.instancingMorph=Xt.instancingMorph,Jt.skinning=Xt.skinning,Jt.morphTargets=Xt.morphTargets,Jt.morphNormals=Xt.morphNormals,Jt.morphColors=Xt.morphColors,Jt.morphTargetsCount=Xt.morphTargetsCount,Jt.numClippingPlanes=Xt.numClippingPlanes,Jt.numIntersection=Xt.numClipIntersection,Jt.vertexAlphas=Xt.vertexAlphas,Jt.vertexTangents=Xt.vertexTangents,Jt.toneMapping=Xt.toneMapping}function Wt(Dt,Xt,Jt,sn,an){Xt.isScene!==!0&&(Xt=jt),Hn.resetTextureUnits();const Mn=Xt.fog,zn=sn.isMeshStandardMaterial?Xt.environment:null,Qn=Mt===null?vt.outputColorSpace:Mt.isXRRenderTarget===!0?Mt.texture.colorSpace:LinearSRGBColorSpace,rr=(sn.isMeshStandardMaterial?Gt:Zt).get(sn.envMap||zn),cr=sn.vertexColors===!0&&!!Jt.attributes.color&&Jt.attributes.color.itemSize===4,_n=!!Jt.attributes.tangent&&(!!sn.normalMap||sn.anisotropy>0),Zn=!!Jt.morphAttributes.position,_r=!!Jt.morphAttributes.normal,Ir=!!Jt.morphAttributes.color;let Lr=NoToneMapping;sn.toneMapped&&(Mt===null||Mt.isXRRenderTarget===!0)&&(Lr=vt.toneMapping);const jr=Jt.morphAttributes.position||Jt.morphAttributes.normal||Jt.morphAttributes.color,gr=jr!==void 0?jr.length:0,tr=Vn.get(sn),Pr=mt.state.lights;if(mn===!0&&(vn===!0||Dt!==St)){const to=Dt===St&&sn.id===At;fr.setState(sn,Dt,to)}let br=!1;sn.version===tr.__version?(tr.needsLights&&tr.lightsStateVersion!==Pr.state.version||tr.outputColorSpace!==Qn||an.isBatchedMesh&&tr.batching===!1||!an.isBatchedMesh&&tr.batching===!0||an.isBatchedMesh&&tr.batchingColor===!0&&an.colorTexture===null||an.isBatchedMesh&&tr.batchingColor===!1&&an.colorTexture!==null||an.isInstancedMesh&&tr.instancing===!1||!an.isInstancedMesh&&tr.instancing===!0||an.isSkinnedMesh&&tr.skinning===!1||!an.isSkinnedMesh&&tr.skinning===!0||an.isInstancedMesh&&tr.instancingColor===!0&&an.instanceColor===null||an.isInstancedMesh&&tr.instancingColor===!1&&an.instanceColor!==null||an.isInstancedMesh&&tr.instancingMorph===!0&&an.morphTexture===null||an.isInstancedMesh&&tr.instancingMorph===!1&&an.morphTexture!==null||tr.envMap!==rr||sn.fog===!0&&tr.fog!==Mn||tr.numClippingPlanes!==void 0&&(tr.numClippingPlanes!==fr.numPlanes||tr.numIntersection!==fr.numIntersection)||tr.vertexAlphas!==cr||tr.vertexTangents!==_n||tr.morphTargets!==Zn||tr.morphNormals!==_r||tr.morphColors!==Ir||tr.toneMapping!==Lr||tr.morphTargetsCount!==gr)&&(br=!0):(br=!0,tr.__version=sn.version);let zr=tr.currentProgram;br===!0&&(zr=Oo(sn,Xt,an));let ao=!1,Yr=!1,eo=!1;const Vr=zr.getUniforms(),co=tr.uniforms;if(Sn.useProgram(zr.program)&&(ao=!0,Yr=!0,eo=!0),sn.id!==At&&(At=sn.id,Yr=!0),ao||St!==Dt){Vr.setValue(Vt,"projectionMatrix",Dt.projectionMatrix),Vr.setValue(Vt,"viewMatrix",Dt.matrixWorldInverse);const to=Vr.map.cameraPosition;to!==void 0&&to.setValue(Vt,Cn.setFromMatrixPosition(Dt.matrixWorld)),Ln.logarithmicDepthBuffer&&Vr.setValue(Vt,"logDepthBufFC",2/(Math.log(Dt.far+1)/Math.LN2)),(sn.isMeshPhongMaterial||sn.isMeshToonMaterial||sn.isMeshLambertMaterial||sn.isMeshBasicMaterial||sn.isMeshStandardMaterial||sn.isShaderMaterial)&&Vr.setValue(Vt,"isOrthographic",Dt.isOrthographicCamera===!0),St!==Dt&&(St=Dt,Yr=!0,eo=!0)}if(an.isSkinnedMesh){Vr.setOptional(Vt,an,"bindMatrix"),Vr.setOptional(Vt,an,"bindMatrixInverse");const to=an.skeleton;to&&(to.boneTexture===null&&to.computeBoneTexture(),Vr.setValue(Vt,"boneTexture",to.boneTexture,Hn))}an.isBatchedMesh&&(Vr.setOptional(Vt,an,"batchingTexture"),Vr.setValue(Vt,"batchingTexture",an._matricesTexture,Hn),Vr.setOptional(Vt,an,"batchingIdTexture"),Vr.setValue(Vt,"batchingIdTexture",an._indirectTexture,Hn),Vr.setOptional(Vt,an,"batchingColorTexture"),an._colorsTexture!==null&&Vr.setValue(Vt,"batchingColorTexture",an._colorsTexture,Hn));const qo=Jt.morphAttributes;if((qo.position!==void 0||qo.normal!==void 0||qo.color!==void 0)&&mr.update(an,Jt,zr),(Yr||tr.receiveShadow!==an.receiveShadow)&&(tr.receiveShadow=an.receiveShadow,Vr.setValue(Vt,"receiveShadow",an.receiveShadow)),sn.isMeshGouraudMaterial&&sn.envMap!==null&&(co.envMap.value=rr,co.flipEnvMap.value=rr.isCubeTexture&&rr.isRenderTargetTexture===!1?-1:1),sn.isMeshStandardMaterial&&sn.envMap===null&&Xt.environment!==null&&(co.envMapIntensity.value=Xt.environmentIntensity),Yr&&(Vr.setValue(Vt,"toneMappingExposure",vt.toneMappingExposure),tr.needsLights&&rn(co,eo),Mn&&sn.fog===!0&&sr.refreshFogUniforms(co,Mn),sr.refreshMaterialUniforms(co,sn,Ut,Ot,mt.state.transmissionRenderTarget[Dt.id]),WebGLUniforms.upload(Vt,Ho(tr),co,Hn)),sn.isShaderMaterial&&sn.uniformsNeedUpdate===!0&&(WebGLUniforms.upload(Vt,Ho(tr),co,Hn),sn.uniformsNeedUpdate=!1),sn.isSpriteMaterial&&Vr.setValue(Vt,"center",an.center),Vr.setValue(Vt,"modelViewMatrix",an.modelViewMatrix),Vr.setValue(Vt,"normalMatrix",an.normalMatrix),Vr.setValue(Vt,"modelMatrix",an.matrixWorld),sn.isShaderMaterial||sn.isRawShaderMaterial){const to=sn.uniformsGroups;for(let Jo=0,uo=to.length;Jo<uo;Jo++){const gs=to[Jo];ir.update(gs,zr),ir.bind(gs,zr)}}return zr}function rn(Dt,Xt){Dt.ambientLightColor.needsUpdate=Xt,Dt.lightProbe.needsUpdate=Xt,Dt.directionalLights.needsUpdate=Xt,Dt.directionalLightShadows.needsUpdate=Xt,Dt.pointLights.needsUpdate=Xt,Dt.pointLightShadows.needsUpdate=Xt,Dt.spotLights.needsUpdate=Xt,Dt.spotLightShadows.needsUpdate=Xt,Dt.rectAreaLights.needsUpdate=Xt,Dt.hemisphereLights.needsUpdate=Xt}function pn(Dt){return Dt.isMeshLambertMaterial||Dt.isMeshToonMaterial||Dt.isMeshPhongMaterial||Dt.isMeshStandardMaterial||Dt.isShadowMaterial||Dt.isShaderMaterial&&Dt.lights===!0}this.getActiveCubeFace=function(){return wt},this.getActiveMipmapLevel=function(){return xt},this.getRenderTarget=function(){return Mt},this.setRenderTargetTextures=function(Dt,Xt,Jt){Vn.get(Dt.texture).__webglTexture=Xt,Vn.get(Dt.depthTexture).__webglTexture=Jt;const sn=Vn.get(Dt);sn.__hasExternalTextures=!0,sn.__autoAllocateDepthBuffer=Jt===void 0,sn.__autoAllocateDepthBuffer||dn.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),sn.__useRenderToTexture=!1)},this.setRenderTargetFramebuffer=function(Dt,Xt){const Jt=Vn.get(Dt);Jt.__webglFramebuffer=Xt,Jt.__useDefaultFramebuffer=Xt===void 0},this.setRenderTarget=function(Dt,Xt=0,Jt=0){Mt=Dt,wt=Xt,xt=Jt;let sn=!0,an=null,Mn=!1,zn=!1;if(Dt){const rr=Vn.get(Dt);rr.__useDefaultFramebuffer!==void 0?(Sn.bindFramebuffer(Vt.FRAMEBUFFER,null),sn=!1):rr.__webglFramebuffer===void 0?Hn.setupRenderTarget(Dt):rr.__hasExternalTextures&&Hn.rebindTextures(Dt,Vn.get(Dt.texture).__webglTexture,Vn.get(Dt.depthTexture).__webglTexture);const cr=Dt.texture;(cr.isData3DTexture||cr.isDataArrayTexture||cr.isCompressedArrayTexture)&&(zn=!0);const _n=Vn.get(Dt).__webglFramebuffer;Dt.isWebGLCubeRenderTarget?(Array.isArray(_n[Xt])?an=_n[Xt][Jt]:an=_n[Xt],Mn=!0):Dt.samples>0&&Hn.useMultisampledRTT(Dt)===!1?an=Vn.get(Dt).__webglMultisampledFramebuffer:Array.isArray(_n)?an=_n[Jt]:an=_n,Tt.copy(Dt.viewport),Ct.copy(Dt.scissor),It=Dt.scissorTest}else Tt.copy(Yt).multiplyScalar(Ut).floor(),Ct.copy(en).multiplyScalar(Ut).floor(),It=bn;if(Sn.bindFramebuffer(Vt.FRAMEBUFFER,an)&&sn&&Sn.drawBuffers(Dt,an),Sn.viewport(Tt),Sn.scissor(Ct),Sn.setScissorTest(It),Mn){const rr=Vn.get(Dt.texture);Vt.framebufferTexture2D(Vt.FRAMEBUFFER,Vt.COLOR_ATTACHMENT0,Vt.TEXTURE_CUBE_MAP_POSITIVE_X+Xt,rr.__webglTexture,Jt)}else if(zn){const rr=Vn.get(Dt.texture),cr=Xt||0;Vt.framebufferTextureLayer(Vt.FRAMEBUFFER,Vt.COLOR_ATTACHMENT0,rr.__webglTexture,Jt||0,cr)}At=-1},this.readRenderTargetPixels=function(Dt,Xt,Jt,sn,an,Mn,zn){if(!(Dt&&Dt.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Qn=Vn.get(Dt).__webglFramebuffer;if(Dt.isWebGLCubeRenderTarget&&zn!==void 0&&(Qn=Qn[zn]),Qn){Sn.bindFramebuffer(Vt.FRAMEBUFFER,Qn);try{const rr=Dt.texture,cr=rr.format,_n=rr.type;if(!Ln.textureFormatReadable(cr)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!Ln.textureTypeReadable(_n)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}Xt>=0&&Xt<=Dt.width-sn&&Jt>=0&&Jt<=Dt.height-an&&Vt.readPixels(Xt,Jt,sn,an,cn.convert(cr),cn.convert(_n),Mn)}finally{const rr=Mt!==null?Vn.get(Mt).__webglFramebuffer:null;Sn.bindFramebuffer(Vt.FRAMEBUFFER,rr)}}},this.readRenderTargetPixelsAsync=async function(Dt,Xt,Jt,sn,an,Mn,zn){if(!(Dt&&Dt.isWebGLRenderTarget))throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let Qn=Vn.get(Dt).__webglFramebuffer;if(Dt.isWebGLCubeRenderTarget&&zn!==void 0&&(Qn=Qn[zn]),Qn){Sn.bindFramebuffer(Vt.FRAMEBUFFER,Qn);try{const rr=Dt.texture,cr=rr.format,_n=rr.type;if(!Ln.textureFormatReadable(cr))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!Ln.textureTypeReadable(_n))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");if(Xt>=0&&Xt<=Dt.width-sn&&Jt>=0&&Jt<=Dt.height-an){const Zn=Vt.createBuffer();Vt.bindBuffer(Vt.PIXEL_PACK_BUFFER,Zn),Vt.bufferData(Vt.PIXEL_PACK_BUFFER,Mn.byteLength,Vt.STREAM_READ),Vt.readPixels(Xt,Jt,sn,an,cn.convert(cr),cn.convert(_n),0),Vt.flush();const _r=Vt.fenceSync(Vt.SYNC_GPU_COMMANDS_COMPLETE,0);await probeAsync(Vt,_r,4);try{Vt.bindBuffer(Vt.PIXEL_PACK_BUFFER,Zn),Vt.getBufferSubData(Vt.PIXEL_PACK_BUFFER,0,Mn)}finally{Vt.deleteBuffer(Zn),Vt.deleteSync(_r)}return Mn}}finally{const rr=Mt!==null?Vn.get(Mt).__webglFramebuffer:null;Sn.bindFramebuffer(Vt.FRAMEBUFFER,rr)}}},this.copyFramebufferToTexture=function(Dt,Xt=null,Jt=0){Dt.isTexture!==!0&&(console.warn("WebGLRenderer: copyFramebufferToTexture function signature has changed."),Xt=arguments[0]||null,Dt=arguments[1]);const sn=Math.pow(2,-Jt),an=Math.floor(Dt.image.width*sn),Mn=Math.floor(Dt.image.height*sn),zn=Xt!==null?Xt.x:0,Qn=Xt!==null?Xt.y:0;Hn.setTexture2D(Dt,0),Vt.copyTexSubImage2D(Vt.TEXTURE_2D,Jt,0,0,zn,Qn,an,Mn),Sn.unbindTexture()},this.copyTextureToTexture=function(Dt,Xt,Jt=null,sn=null,an=0){Dt.isTexture!==!0&&(console.warn("WebGLRenderer: copyTextureToTexture function signature has changed."),sn=arguments[0]||null,Dt=arguments[1],Xt=arguments[2],an=arguments[3]||0,Jt=null);let Mn,zn,Qn,rr,cr,_n;Jt!==null?(Mn=Jt.max.x-Jt.min.x,zn=Jt.max.y-Jt.min.y,Qn=Jt.min.x,rr=Jt.min.y):(Mn=Dt.image.width,zn=Dt.image.height,Qn=0,rr=0),sn!==null?(cr=sn.x,_n=sn.y):(cr=0,_n=0);const Zn=cn.convert(Xt.format),_r=cn.convert(Xt.type);Hn.setTexture2D(Xt,0),Vt.pixelStorei(Vt.UNPACK_FLIP_Y_WEBGL,Xt.flipY),Vt.pixelStorei(Vt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Xt.premultiplyAlpha),Vt.pixelStorei(Vt.UNPACK_ALIGNMENT,Xt.unpackAlignment);const Ir=Vt.getParameter(Vt.UNPACK_ROW_LENGTH),Lr=Vt.getParameter(Vt.UNPACK_IMAGE_HEIGHT),jr=Vt.getParameter(Vt.UNPACK_SKIP_PIXELS),gr=Vt.getParameter(Vt.UNPACK_SKIP_ROWS),tr=Vt.getParameter(Vt.UNPACK_SKIP_IMAGES),Pr=Dt.isCompressedTexture?Dt.mipmaps[an]:Dt.image;Vt.pixelStorei(Vt.UNPACK_ROW_LENGTH,Pr.width),Vt.pixelStorei(Vt.UNPACK_IMAGE_HEIGHT,Pr.height),Vt.pixelStorei(Vt.UNPACK_SKIP_PIXELS,Qn),Vt.pixelStorei(Vt.UNPACK_SKIP_ROWS,rr),Dt.isDataTexture?Vt.texSubImage2D(Vt.TEXTURE_2D,an,cr,_n,Mn,zn,Zn,_r,Pr.data):Dt.isCompressedTexture?Vt.compressedTexSubImage2D(Vt.TEXTURE_2D,an,cr,_n,Pr.width,Pr.height,Zn,Pr.data):Vt.texSubImage2D(Vt.TEXTURE_2D,an,cr,_n,Mn,zn,Zn,_r,Pr),Vt.pixelStorei(Vt.UNPACK_ROW_LENGTH,Ir),Vt.pixelStorei(Vt.UNPACK_IMAGE_HEIGHT,Lr),Vt.pixelStorei(Vt.UNPACK_SKIP_PIXELS,jr),Vt.pixelStorei(Vt.UNPACK_SKIP_ROWS,gr),Vt.pixelStorei(Vt.UNPACK_SKIP_IMAGES,tr),an===0&&Xt.generateMipmaps&&Vt.generateMipmap(Vt.TEXTURE_2D),Sn.unbindTexture()},this.copyTextureToTexture3D=function(Dt,Xt,Jt=null,sn=null,an=0){Dt.isTexture!==!0&&(console.warn("WebGLRenderer: copyTextureToTexture3D function signature has changed."),Jt=arguments[0]||null,sn=arguments[1]||null,Dt=arguments[2],Xt=arguments[3],an=arguments[4]||0);let Mn,zn,Qn,rr,cr,_n,Zn,_r,Ir;const Lr=Dt.isCompressedTexture?Dt.mipmaps[an]:Dt.image;Jt!==null?(Mn=Jt.max.x-Jt.min.x,zn=Jt.max.y-Jt.min.y,Qn=Jt.max.z-Jt.min.z,rr=Jt.min.x,cr=Jt.min.y,_n=Jt.min.z):(Mn=Lr.width,zn=Lr.height,Qn=Lr.depth,rr=0,cr=0,_n=0),sn!==null?(Zn=sn.x,_r=sn.y,Ir=sn.z):(Zn=0,_r=0,Ir=0);const jr=cn.convert(Xt.format),gr=cn.convert(Xt.type);let tr;if(Xt.isData3DTexture)Hn.setTexture3D(Xt,0),tr=Vt.TEXTURE_3D;else if(Xt.isDataArrayTexture||Xt.isCompressedArrayTexture)Hn.setTexture2DArray(Xt,0),tr=Vt.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}Vt.pixelStorei(Vt.UNPACK_FLIP_Y_WEBGL,Xt.flipY),Vt.pixelStorei(Vt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Xt.premultiplyAlpha),Vt.pixelStorei(Vt.UNPACK_ALIGNMENT,Xt.unpackAlignment);const Pr=Vt.getParameter(Vt.UNPACK_ROW_LENGTH),br=Vt.getParameter(Vt.UNPACK_IMAGE_HEIGHT),zr=Vt.getParameter(Vt.UNPACK_SKIP_PIXELS),ao=Vt.getParameter(Vt.UNPACK_SKIP_ROWS),Yr=Vt.getParameter(Vt.UNPACK_SKIP_IMAGES);Vt.pixelStorei(Vt.UNPACK_ROW_LENGTH,Lr.width),Vt.pixelStorei(Vt.UNPACK_IMAGE_HEIGHT,Lr.height),Vt.pixelStorei(Vt.UNPACK_SKIP_PIXELS,rr),Vt.pixelStorei(Vt.UNPACK_SKIP_ROWS,cr),Vt.pixelStorei(Vt.UNPACK_SKIP_IMAGES,_n),Dt.isDataTexture||Dt.isData3DTexture?Vt.texSubImage3D(tr,an,Zn,_r,Ir,Mn,zn,Qn,jr,gr,Lr.data):Xt.isCompressedArrayTexture?Vt.compressedTexSubImage3D(tr,an,Zn,_r,Ir,Mn,zn,Qn,jr,Lr.data):Vt.texSubImage3D(tr,an,Zn,_r,Ir,Mn,zn,Qn,jr,gr,Lr),Vt.pixelStorei(Vt.UNPACK_ROW_LENGTH,Pr),Vt.pixelStorei(Vt.UNPACK_IMAGE_HEIGHT,br),Vt.pixelStorei(Vt.UNPACK_SKIP_PIXELS,zr),Vt.pixelStorei(Vt.UNPACK_SKIP_ROWS,ao),Vt.pixelStorei(Vt.UNPACK_SKIP_IMAGES,Yr),an===0&&Xt.generateMipmaps&&Vt.generateMipmap(tr),Sn.unbindTexture()},this.initRenderTarget=function(Dt){Vn.get(Dt).__webglFramebuffer===void 0&&Hn.setupRenderTarget(Dt)},this.initTexture=function(Dt){Dt.isCubeTexture?Hn.setTextureCube(Dt,0):Dt.isData3DTexture?Hn.setTexture3D(Dt,0):Dt.isDataArrayTexture||Dt.isCompressedArrayTexture?Hn.setTexture2DArray(Dt,0):Hn.setTexture2D(Dt,0),Sn.unbindTexture()},this.resetState=function(){wt=0,xt=0,Mt=null,Sn.reset(),Fn.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return WebGLCoordinateSystem}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(_){this._outputColorSpace=_;const _e=this.getContext();_e.drawingBufferColorSpace=_===DisplayP3ColorSpace?"display-p3":"srgb",_e.unpackColorSpace=ColorManagement.workingColorSpace===LinearDisplayP3ColorSpace?"display-p3":"srgb"}}class FogExp2{constructor(_,_e=25e-5){this.isFogExp2=!0,this.name="",this.color=new Color$1(_),this.density=_e}clone(){return new FogExp2(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class Fog{constructor(_,_e=1,tt=1e3){this.isFog=!0,this.name="",this.color=new Color$1(_),this.near=_e,this.far=tt}clone(){return new Fog(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}let Scene$1=class extends Object3D{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new Euler,this.environmentIntensity=1,this.environmentRotation=new Euler,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(_,_e){return super.copy(_,_e),_.background!==null&&(this.background=_.background.clone()),_.environment!==null&&(this.environment=_.environment.clone()),_.fog!==null&&(this.fog=_.fog.clone()),this.backgroundBlurriness=_.backgroundBlurriness,this.backgroundIntensity=_.backgroundIntensity,this.backgroundRotation.copy(_.backgroundRotation),this.environmentIntensity=_.environmentIntensity,this.environmentRotation.copy(_.environmentRotation),_.overrideMaterial!==null&&(this.overrideMaterial=_.overrideMaterial.clone()),this.matrixAutoUpdate=_.matrixAutoUpdate,this}toJSON(_){const _e=super.toJSON(_);return this.fog!==null&&(_e.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(_e.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(_e.object.backgroundIntensity=this.backgroundIntensity),_e.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(_e.object.environmentIntensity=this.environmentIntensity),_e.object.environmentRotation=this.environmentRotation.toArray(),_e}};class InterleavedBuffer{constructor(_,_e){this.isInterleavedBuffer=!0,this.array=_,this.stride=_e,this.count=_!==void 0?_.length/_e:0,this.usage=StaticDrawUsage,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.version=0,this.uuid=generateUUID()}onUploadCallback(){}set needsUpdate(_){_===!0&&this.version++}get updateRange(){return warnOnce("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(_){return this.usage=_,this}addUpdateRange(_,_e){this.updateRanges.push({start:_,count:_e})}clearUpdateRanges(){this.updateRanges.length=0}copy(_){return this.array=new _.array.constructor(_.array),this.count=_.count,this.stride=_.stride,this.usage=_.usage,this}copyAt(_,_e,tt){_*=this.stride,tt*=_e.stride;for(let nt=0,rt=this.stride;nt<rt;nt++)this.array[_+nt]=_e.array[tt+nt];return this}set(_,_e=0){return this.array.set(_,_e),this}clone(_){_.arrayBuffers===void 0&&(_.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=generateUUID()),_.arrayBuffers[this.array.buffer._uuid]===void 0&&(_.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const _e=new this.array.constructor(_.arrayBuffers[this.array.buffer._uuid]),tt=new this.constructor(_e,this.stride);return tt.setUsage(this.usage),tt}onUpload(_){return this.onUploadCallback=_,this}toJSON(_){return _.arrayBuffers===void 0&&(_.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=generateUUID()),_.arrayBuffers[this.array.buffer._uuid]===void 0&&(_.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const _vector$6=new Vector3;class InterleavedBufferAttribute{constructor(_,_e,tt,nt=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=_,this.itemSize=_e,this.offset=tt,this.normalized=nt}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(_){this.data.needsUpdate=_}applyMatrix4(_){for(let _e=0,tt=this.data.count;_e<tt;_e++)_vector$6.fromBufferAttribute(this,_e),_vector$6.applyMatrix4(_),this.setXYZ(_e,_vector$6.x,_vector$6.y,_vector$6.z);return this}applyNormalMatrix(_){for(let _e=0,tt=this.count;_e<tt;_e++)_vector$6.fromBufferAttribute(this,_e),_vector$6.applyNormalMatrix(_),this.setXYZ(_e,_vector$6.x,_vector$6.y,_vector$6.z);return this}transformDirection(_){for(let _e=0,tt=this.count;_e<tt;_e++)_vector$6.fromBufferAttribute(this,_e),_vector$6.transformDirection(_),this.setXYZ(_e,_vector$6.x,_vector$6.y,_vector$6.z);return this}getComponent(_,_e){let tt=this.array[_*this.data.stride+this.offset+_e];return this.normalized&&(tt=denormalize(tt,this.array)),tt}setComponent(_,_e,tt){return this.normalized&&(tt=normalize$5(tt,this.array)),this.data.array[_*this.data.stride+this.offset+_e]=tt,this}setX(_,_e){return this.normalized&&(_e=normalize$5(_e,this.array)),this.data.array[_*this.data.stride+this.offset]=_e,this}setY(_,_e){return this.normalized&&(_e=normalize$5(_e,this.array)),this.data.array[_*this.data.stride+this.offset+1]=_e,this}setZ(_,_e){return this.normalized&&(_e=normalize$5(_e,this.array)),this.data.array[_*this.data.stride+this.offset+2]=_e,this}setW(_,_e){return this.normalized&&(_e=normalize$5(_e,this.array)),this.data.array[_*this.data.stride+this.offset+3]=_e,this}getX(_){let _e=this.data.array[_*this.data.stride+this.offset];return this.normalized&&(_e=denormalize(_e,this.array)),_e}getY(_){let _e=this.data.array[_*this.data.stride+this.offset+1];return this.normalized&&(_e=denormalize(_e,this.array)),_e}getZ(_){let _e=this.data.array[_*this.data.stride+this.offset+2];return this.normalized&&(_e=denormalize(_e,this.array)),_e}getW(_){let _e=this.data.array[_*this.data.stride+this.offset+3];return this.normalized&&(_e=denormalize(_e,this.array)),_e}setXY(_,_e,tt){return _=_*this.data.stride+this.offset,this.normalized&&(_e=normalize$5(_e,this.array),tt=normalize$5(tt,this.array)),this.data.array[_+0]=_e,this.data.array[_+1]=tt,this}setXYZ(_,_e,tt,nt){return _=_*this.data.stride+this.offset,this.normalized&&(_e=normalize$5(_e,this.array),tt=normalize$5(tt,this.array),nt=normalize$5(nt,this.array)),this.data.array[_+0]=_e,this.data.array[_+1]=tt,this.data.array[_+2]=nt,this}setXYZW(_,_e,tt,nt,rt){return _=_*this.data.stride+this.offset,this.normalized&&(_e=normalize$5(_e,this.array),tt=normalize$5(tt,this.array),nt=normalize$5(nt,this.array),rt=normalize$5(rt,this.array)),this.data.array[_+0]=_e,this.data.array[_+1]=tt,this.data.array[_+2]=nt,this.data.array[_+3]=rt,this}clone(_){if(_===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const _e=[];for(let tt=0;tt<this.count;tt++){const nt=tt*this.data.stride+this.offset;for(let rt=0;rt<this.itemSize;rt++)_e.push(this.data.array[nt+rt])}return new BufferAttribute(new this.array.constructor(_e),this.itemSize,this.normalized)}else return _.interleavedBuffers===void 0&&(_.interleavedBuffers={}),_.interleavedBuffers[this.data.uuid]===void 0&&(_.interleavedBuffers[this.data.uuid]=this.data.clone(_)),new InterleavedBufferAttribute(_.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(_){if(_===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const _e=[];for(let tt=0;tt<this.count;tt++){const nt=tt*this.data.stride+this.offset;for(let rt=0;rt<this.itemSize;rt++)_e.push(this.data.array[nt+rt])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:_e,normalized:this.normalized}}else return _.interleavedBuffers===void 0&&(_.interleavedBuffers={}),_.interleavedBuffers[this.data.uuid]===void 0&&(_.interleavedBuffers[this.data.uuid]=this.data.toJSON(_)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class SpriteMaterial extends Material{constructor(_){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new Color$1(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(_)}copy(_){return super.copy(_),this.color.copy(_.color),this.map=_.map,this.alphaMap=_.alphaMap,this.rotation=_.rotation,this.sizeAttenuation=_.sizeAttenuation,this.fog=_.fog,this}}let _geometry;const _intersectPoint=new Vector3,_worldScale=new Vector3,_mvPosition=new Vector3,_alignedPosition=new Vector2,_rotatedPosition=new Vector2,_viewWorldMatrix=new Matrix4,_vA=new Vector3,_vB=new Vector3,_vC=new Vector3,_uvA=new Vector2,_uvB=new Vector2,_uvC=new Vector2;class Sprite extends Object3D{constructor(_=new SpriteMaterial){if(super(),this.isSprite=!0,this.type="Sprite",_geometry===void 0){_geometry=new BufferGeometry;const _e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),tt=new InterleavedBuffer(_e,5);_geometry.setIndex([0,1,2,0,2,3]),_geometry.setAttribute("position",new InterleavedBufferAttribute(tt,3,0,!1)),_geometry.setAttribute("uv",new InterleavedBufferAttribute(tt,2,3,!1))}this.geometry=_geometry,this.material=_,this.center=new Vector2(.5,.5)}raycast(_,_e){_.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),_worldScale.setFromMatrixScale(this.matrixWorld),_viewWorldMatrix.copy(_.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(_.camera.matrixWorldInverse,this.matrixWorld),_mvPosition.setFromMatrixPosition(this.modelViewMatrix),_.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&_worldScale.multiplyScalar(-_mvPosition.z);const tt=this.material.rotation;let nt,rt;tt!==0&&(rt=Math.cos(tt),nt=Math.sin(tt));const ot=this.center;transformVertex(_vA.set(-.5,-.5,0),_mvPosition,ot,_worldScale,nt,rt),transformVertex(_vB.set(.5,-.5,0),_mvPosition,ot,_worldScale,nt,rt),transformVertex(_vC.set(.5,.5,0),_mvPosition,ot,_worldScale,nt,rt),_uvA.set(0,0),_uvB.set(1,0),_uvC.set(1,1);let at=_.ray.intersectTriangle(_vA,_vB,_vC,!1,_intersectPoint);if(at===null&&(transformVertex(_vB.set(-.5,.5,0),_mvPosition,ot,_worldScale,nt,rt),_uvB.set(0,1),at=_.ray.intersectTriangle(_vA,_vC,_vB,!1,_intersectPoint),at===null))return;const lt=_.ray.origin.distanceTo(_intersectPoint);lt<_.near||lt>_.far||_e.push({distance:lt,point:_intersectPoint.clone(),uv:Triangle.getInterpolation(_intersectPoint,_vA,_vB,_vC,_uvA,_uvB,_uvC,new Vector2),face:null,object:this})}copy(_,_e){return super.copy(_,_e),_.center!==void 0&&this.center.copy(_.center),this.material=_.material,this}}function transformVertex(et,_,_e,tt,nt,rt){_alignedPosition.subVectors(et,_e).addScalar(.5).multiply(tt),nt!==void 0?(_rotatedPosition.x=rt*_alignedPosition.x-nt*_alignedPosition.y,_rotatedPosition.y=nt*_alignedPosition.x+rt*_alignedPosition.y):_rotatedPosition.copy(_alignedPosition),et.copy(_),et.x+=_rotatedPosition.x,et.y+=_rotatedPosition.y,et.applyMatrix4(_viewWorldMatrix)}const _v1$2=new Vector3,_v2$1=new Vector3;class LOD extends Object3D{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(_){super.copy(_,!1);const _e=_.levels;for(let tt=0,nt=_e.length;tt<nt;tt++){const rt=_e[tt];this.addLevel(rt.object.clone(),rt.distance,rt.hysteresis)}return this.autoUpdate=_.autoUpdate,this}addLevel(_,_e=0,tt=0){_e=Math.abs(_e);const nt=this.levels;let rt;for(rt=0;rt<nt.length&&!(_e<nt[rt].distance);rt++);return nt.splice(rt,0,{distance:_e,hysteresis:tt,object:_}),this.add(_),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(_){const _e=this.levels;if(_e.length>0){let tt,nt;for(tt=1,nt=_e.length;tt<nt;tt++){let rt=_e[tt].distance;if(_e[tt].object.visible&&(rt-=rt*_e[tt].hysteresis),_<rt)break}return _e[tt-1].object}return null}raycast(_,_e){if(this.levels.length>0){_v1$2.setFromMatrixPosition(this.matrixWorld);const nt=_.ray.origin.distanceTo(_v1$2);this.getObjectForDistance(nt).raycast(_,_e)}}update(_){const _e=this.levels;if(_e.length>1){_v1$2.setFromMatrixPosition(_.matrixWorld),_v2$1.setFromMatrixPosition(this.matrixWorld);const tt=_v1$2.distanceTo(_v2$1)/_.zoom;_e[0].object.visible=!0;let nt,rt;for(nt=1,rt=_e.length;nt<rt;nt++){let ot=_e[nt].distance;if(_e[nt].object.visible&&(ot-=ot*_e[nt].hysteresis),tt>=ot)_e[nt-1].object.visible=!1,_e[nt].object.visible=!0;else break}for(this._currentLevel=nt-1;nt<rt;nt++)_e[nt].object.visible=!1}}toJSON(_){const _e=super.toJSON(_);this.autoUpdate===!1&&(_e.object.autoUpdate=!1),_e.object.levels=[];const tt=this.levels;for(let nt=0,rt=tt.length;nt<rt;nt++){const ot=tt[nt];_e.object.levels.push({object:ot.object.uuid,distance:ot.distance,hysteresis:ot.hysteresis})}return _e}}const _basePosition=new Vector3,_skinIndex=new Vector4,_skinWeight=new Vector4,_vector3=new Vector3,_matrix4=new Matrix4,_vertex=new Vector3,_sphere$4=new Sphere,_inverseMatrix$2=new Matrix4,_ray$2=new Ray;class SkinnedMesh extends Mesh{constructor(_,_e){super(_,_e),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=AttachedBindMode,this.bindMatrix=new Matrix4,this.bindMatrixInverse=new Matrix4,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const _=this.geometry;this.boundingBox===null&&(this.boundingBox=new Box3),this.boundingBox.makeEmpty();const _e=_.getAttribute("position");for(let tt=0;tt<_e.count;tt++)this.getVertexPosition(tt,_vertex),this.boundingBox.expandByPoint(_vertex)}computeBoundingSphere(){const _=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new Sphere),this.boundingSphere.makeEmpty();const _e=_.getAttribute("position");for(let tt=0;tt<_e.count;tt++)this.getVertexPosition(tt,_vertex),this.boundingSphere.expandByPoint(_vertex)}copy(_,_e){return super.copy(_,_e),this.bindMode=_.bindMode,this.bindMatrix.copy(_.bindMatrix),this.bindMatrixInverse.copy(_.bindMatrixInverse),this.skeleton=_.skeleton,_.boundingBox!==null&&(this.boundingBox=_.boundingBox.clone()),_.boundingSphere!==null&&(this.boundingSphere=_.boundingSphere.clone()),this}raycast(_,_e){const tt=this.material,nt=this.matrixWorld;tt!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),_sphere$4.copy(this.boundingSphere),_sphere$4.applyMatrix4(nt),_.ray.intersectsSphere(_sphere$4)!==!1&&(_inverseMatrix$2.copy(nt).invert(),_ray$2.copy(_.ray).applyMatrix4(_inverseMatrix$2),!(this.boundingBox!==null&&_ray$2.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(_,_e,_ray$2)))}getVertexPosition(_,_e){return super.getVertexPosition(_,_e),this.applyBoneTransform(_,_e),_e}bind(_,_e){this.skeleton=_,_e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),_e=this.matrixWorld),this.bindMatrix.copy(_e),this.bindMatrixInverse.copy(_e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const _=new Vector4,_e=this.geometry.attributes.skinWeight;for(let tt=0,nt=_e.count;tt<nt;tt++){_.fromBufferAttribute(_e,tt);const rt=1/_.manhattanLength();rt!==1/0?_.multiplyScalar(rt):_.set(1,0,0,0),_e.setXYZW(tt,_.x,_.y,_.z,_.w)}}updateMatrixWorld(_){super.updateMatrixWorld(_),this.bindMode===AttachedBindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===DetachedBindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(_,_e){const tt=this.skeleton,nt=this.geometry;_skinIndex.fromBufferAttribute(nt.attributes.skinIndex,_),_skinWeight.fromBufferAttribute(nt.attributes.skinWeight,_),_basePosition.copy(_e).applyMatrix4(this.bindMatrix),_e.set(0,0,0);for(let rt=0;rt<4;rt++){const ot=_skinWeight.getComponent(rt);if(ot!==0){const at=_skinIndex.getComponent(rt);_matrix4.multiplyMatrices(tt.bones[at].matrixWorld,tt.boneInverses[at]),_e.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4),ot)}}return _e.applyMatrix4(this.bindMatrixInverse)}}class Bone extends Object3D{constructor(){super(),this.isBone=!0,this.type="Bone"}}class DataTexture extends Texture{constructor(_=null,_e=1,tt=1,nt,rt,ot,at,lt,ut=NearestFilter,dt=NearestFilter,st,it){super(null,ot,at,lt,ut,dt,nt,rt,st,it),this.isDataTexture=!0,this.image={data:_,width:_e,height:tt},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const _offsetMatrix=new Matrix4,_identityMatrix$1=new Matrix4;class Skeleton{constructor(_=[],_e=[]){this.uuid=generateUUID(),this.bones=_.slice(0),this.boneInverses=_e,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const _=this.bones,_e=this.boneInverses;if(this.boneMatrices=new Float32Array(_.length*16),_e.length===0)this.calculateInverses();else if(_.length!==_e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let tt=0,nt=this.bones.length;tt<nt;tt++)this.boneInverses.push(new Matrix4)}}calculateInverses(){this.boneInverses.length=0;for(let _=0,_e=this.bones.length;_<_e;_++){const tt=new Matrix4;this.bones[_]&&tt.copy(this.bones[_].matrixWorld).invert(),this.boneInverses.push(tt)}}pose(){for(let _=0,_e=this.bones.length;_<_e;_++){const tt=this.bones[_];tt&&tt.matrixWorld.copy(this.boneInverses[_]).invert()}for(let _=0,_e=this.bones.length;_<_e;_++){const tt=this.bones[_];tt&&(tt.parent&&tt.parent.isBone?(tt.matrix.copy(tt.parent.matrixWorld).invert(),tt.matrix.multiply(tt.matrixWorld)):tt.matrix.copy(tt.matrixWorld),tt.matrix.decompose(tt.position,tt.quaternion,tt.scale))}}update(){const _=this.bones,_e=this.boneInverses,tt=this.boneMatrices,nt=this.boneTexture;for(let rt=0,ot=_.length;rt<ot;rt++){const at=_[rt]?_[rt].matrixWorld:_identityMatrix$1;_offsetMatrix.multiplyMatrices(at,_e[rt]),_offsetMatrix.toArray(tt,rt*16)}nt!==null&&(nt.needsUpdate=!0)}clone(){return new Skeleton(this.bones,this.boneInverses)}computeBoneTexture(){let _=Math.sqrt(this.bones.length*4);_=Math.ceil(_/4)*4,_=Math.max(_,4);const _e=new Float32Array(_*_*4);_e.set(this.boneMatrices);const tt=new DataTexture(_e,_,_,RGBAFormat,FloatType);return tt.needsUpdate=!0,this.boneMatrices=_e,this.boneTexture=tt,this}getBoneByName(_){for(let _e=0,tt=this.bones.length;_e<tt;_e++){const nt=this.bones[_e];if(nt.name===_)return nt}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(_,_e){this.uuid=_.uuid;for(let tt=0,nt=_.bones.length;tt<nt;tt++){const rt=_.bones[tt];let ot=_e[rt];ot===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",rt),ot=new Bone),this.bones.push(ot),this.boneInverses.push(new Matrix4().fromArray(_.boneInverses[tt]))}return this.init(),this}toJSON(){const _={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};_.uuid=this.uuid;const _e=this.bones,tt=this.boneInverses;for(let nt=0,rt=_e.length;nt<rt;nt++){const ot=_e[nt];_.bones.push(ot.uuid);const at=tt[nt];_.boneInverses.push(at.toArray())}return _}}class InstancedBufferAttribute extends BufferAttribute{constructor(_,_e,tt,nt=1){super(_,_e,tt),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=nt}copy(_){return super.copy(_),this.meshPerAttribute=_.meshPerAttribute,this}toJSON(){const _=super.toJSON();return _.meshPerAttribute=this.meshPerAttribute,_.isInstancedBufferAttribute=!0,_}}const _instanceLocalMatrix=new Matrix4,_instanceWorldMatrix=new Matrix4,_instanceIntersects=[],_box3=new Box3,_identity=new Matrix4,_mesh$1=new Mesh,_sphere$3=new Sphere;class InstancedMesh extends Mesh{constructor(_,_e,tt){super(_,_e),this.isInstancedMesh=!0,this.instanceMatrix=new InstancedBufferAttribute(new Float32Array(tt*16),16),this.instanceColor=null,this.morphTexture=null,this.count=tt,this.boundingBox=null,this.boundingSphere=null;for(let nt=0;nt<tt;nt++)this.setMatrixAt(nt,_identity)}computeBoundingBox(){const _=this.geometry,_e=this.count;this.boundingBox===null&&(this.boundingBox=new Box3),_.boundingBox===null&&_.computeBoundingBox(),this.boundingBox.makeEmpty();for(let tt=0;tt<_e;tt++)this.getMatrixAt(tt,_instanceLocalMatrix),_box3.copy(_.boundingBox).applyMatrix4(_instanceLocalMatrix),this.boundingBox.union(_box3)}computeBoundingSphere(){const _=this.geometry,_e=this.count;this.boundingSphere===null&&(this.boundingSphere=new Sphere),_.boundingSphere===null&&_.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let tt=0;tt<_e;tt++)this.getMatrixAt(tt,_instanceLocalMatrix),_sphere$3.copy(_.boundingSphere).applyMatrix4(_instanceLocalMatrix),this.boundingSphere.union(_sphere$3)}copy(_,_e){return super.copy(_,_e),this.instanceMatrix.copy(_.instanceMatrix),_.morphTexture!==null&&(this.morphTexture=_.morphTexture.clone()),_.instanceColor!==null&&(this.instanceColor=_.instanceColor.clone()),this.count=_.count,_.boundingBox!==null&&(this.boundingBox=_.boundingBox.clone()),_.boundingSphere!==null&&(this.boundingSphere=_.boundingSphere.clone()),this}getColorAt(_,_e){_e.fromArray(this.instanceColor.array,_*3)}getMatrixAt(_,_e){_e.fromArray(this.instanceMatrix.array,_*16)}getMorphAt(_,_e){const tt=_e.morphTargetInfluences,nt=this.morphTexture.source.data.data,rt=tt.length+1,ot=_*rt+1;for(let at=0;at<tt.length;at++)tt[at]=nt[ot+at]}raycast(_,_e){const tt=this.matrixWorld,nt=this.count;if(_mesh$1.geometry=this.geometry,_mesh$1.material=this.material,_mesh$1.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),_sphere$3.copy(this.boundingSphere),_sphere$3.applyMatrix4(tt),_.ray.intersectsSphere(_sphere$3)!==!1))for(let rt=0;rt<nt;rt++){this.getMatrixAt(rt,_instanceLocalMatrix),_instanceWorldMatrix.multiplyMatrices(tt,_instanceLocalMatrix),_mesh$1.matrixWorld=_instanceWorldMatrix,_mesh$1.raycast(_,_instanceIntersects);for(let ot=0,at=_instanceIntersects.length;ot<at;ot++){const lt=_instanceIntersects[ot];lt.instanceId=rt,lt.object=this,_e.push(lt)}_instanceIntersects.length=0}}setColorAt(_,_e){this.instanceColor===null&&(this.instanceColor=new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count*3),3)),_e.toArray(this.instanceColor.array,_*3)}setMatrixAt(_,_e){_e.toArray(this.instanceMatrix.array,_*16)}setMorphAt(_,_e){const tt=_e.morphTargetInfluences,nt=tt.length+1;this.morphTexture===null&&(this.morphTexture=new DataTexture(new Float32Array(nt*this.count),nt,this.count,RedFormat,FloatType));const rt=this.morphTexture.source.data.data;let ot=0;for(let ut=0;ut<tt.length;ut++)ot+=tt[ut];const at=this.geometry.morphTargetsRelative?1:1-ot,lt=nt*_;rt[lt]=at,rt.set(tt,lt+1)}updateMorphTargets(){}dispose(){return this.dispatchEvent({type:"dispose"}),this.morphTexture!==null&&(this.morphTexture.dispose(),this.morphTexture=null),this}}function sortOpaque(et,_){return et.z-_.z}function sortTransparent(et,_){return _.z-et.z}class MultiDrawRenderList{constructor(){this.index=0,this.pool=[],this.list=[]}push(_,_e,tt){const nt=this.pool,rt=this.list;this.index>=nt.length&&nt.push({start:-1,count:-1,z:-1,index:-1});const ot=nt[this.index];rt.push(ot),this.index++,ot.start=_.start,ot.count=_.count,ot.z=_e,ot.index=tt}reset(){this.list.length=0,this.index=0}}const _matrix$1=new Matrix4,_invMatrixWorld=new Matrix4,_identityMatrix=new Matrix4,_whiteColor=new Color$1(1,1,1),_projScreenMatrix$2=new Matrix4,_frustum=new Frustum,_box$1=new Box3,_sphere$2=new Sphere,_vector$5=new Vector3,_forward=new Vector3,_temp=new Vector3,_renderList=new MultiDrawRenderList,_mesh=new Mesh,_batchIntersects=[];function copyAttributeData(et,_,_e=0){const tt=_.itemSize;if(et.isInterleavedBufferAttribute||et.array.constructor!==_.array.constructor){const nt=et.count;for(let rt=0;rt<nt;rt++)for(let ot=0;ot<tt;ot++)_.setComponent(rt+_e,ot,et.getComponent(rt,ot))}else _.array.set(et.array,_e*tt);_.needsUpdate=!0}class BatchedMesh extends Mesh{get maxInstanceCount(){return this._maxInstanceCount}constructor(_,_e,tt=_e*2,nt){super(new BufferGeometry,nt),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._drawInfo=[],this._drawRanges=[],this._reservedRanges=[],this._bounds=[],this._maxInstanceCount=_,this._maxVertexCount=_e,this._maxIndexCount=tt,this._geometryInitialized=!1,this._geometryCount=0,this._multiDrawCounts=new Int32Array(_),this._multiDrawStarts=new Int32Array(_),this._multiDrawCount=0,this._multiDrawInstances=null,this._visibilityChanged=!0,this._matricesTexture=null,this._indirectTexture=null,this._colorsTexture=null,this._initMatricesTexture(),this._initIndirectTexture()}_initMatricesTexture(){let _=Math.sqrt(this._maxInstanceCount*4);_=Math.ceil(_/4)*4,_=Math.max(_,4);const _e=new Float32Array(_*_*4),tt=new DataTexture(_e,_,_,RGBAFormat,FloatType);this._matricesTexture=tt}_initIndirectTexture(){let _=Math.sqrt(this._maxInstanceCount);_=Math.ceil(_);const _e=new Uint32Array(_*_),tt=new DataTexture(_e,_,_,RedIntegerFormat,UnsignedIntType);this._indirectTexture=tt}_initColorsTexture(){let _=Math.sqrt(this._maxIndexCount);_=Math.ceil(_);const _e=new Float32Array(_*_*4).fill(1),tt=new DataTexture(_e,_,_,RGBAFormat,FloatType);tt.colorSpace=ColorManagement.workingColorSpace,this._colorsTexture=tt}_initializeGeometry(_){const _e=this.geometry,tt=this._maxVertexCount,nt=this._maxIndexCount;if(this._geometryInitialized===!1){for(const rt in _.attributes){const ot=_.getAttribute(rt),{array:at,itemSize:lt,normalized:ut}=ot,dt=new at.constructor(tt*lt),st=new BufferAttribute(dt,lt,ut);_e.setAttribute(rt,st)}if(_.getIndex()!==null){const rt=tt>65535?new Uint32Array(nt):new Uint16Array(nt);_e.setIndex(new BufferAttribute(rt,1))}this._geometryInitialized=!0}}_validateGeometry(_){const _e=this.geometry;if(!!_.getIndex()!=!!_e.getIndex())throw new Error('BatchedMesh: All geometries must consistently have "index".');for(const tt in _e.attributes){if(!_.hasAttribute(tt))throw new Error(`BatchedMesh: Added geometry missing "${tt}". All geometries must have consistent attributes.`);const nt=_.getAttribute(tt),rt=_e.getAttribute(tt);if(nt.itemSize!==rt.itemSize||nt.normalized!==rt.normalized)throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}setCustomSort(_){return this.customSort=_,this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Box3);const _=this._geometryCount,_e=this.boundingBox,tt=this._drawInfo;_e.makeEmpty();for(let nt=0;nt<_;nt++){if(tt[nt].active===!1)continue;const rt=tt[nt].geometryIndex;this.getMatrixAt(nt,_matrix$1),this.getBoundingBoxAt(rt,_box$1).applyMatrix4(_matrix$1),_e.union(_box$1)}}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Sphere);const _=this.boundingSphere,_e=this._drawInfo;_.makeEmpty();for(let tt=0,nt=_e.length;tt<nt;tt++){if(_e[tt].active===!1)continue;const rt=_e[tt].geometryIndex;this.getMatrixAt(tt,_matrix$1),this.getBoundingSphereAt(rt,_sphere$2).applyMatrix4(_matrix$1),_.union(_sphere$2)}}addInstance(_){if(this._drawInfo.length>=this._maxInstanceCount)throw new Error("BatchedMesh: Maximum item count reached.");this._drawInfo.push({visible:!0,active:!0,geometryIndex:_});const _e=this._drawInfo.length-1,tt=this._matricesTexture,nt=tt.image.data;_identityMatrix.toArray(nt,_e*16),tt.needsUpdate=!0;const rt=this._colorsTexture;return rt&&(_whiteColor.toArray(rt.image.data,_e*4),rt.needsUpdate=!0),_e}addGeometry(_,_e=-1,tt=-1){if(this._initializeGeometry(_),this._validateGeometry(_),this._drawInfo.length>=this._maxInstanceCount)throw new Error("BatchedMesh: Maximum item count reached.");const nt={vertexStart:-1,vertexCount:-1,indexStart:-1,indexCount:-1};let rt=null;const ot=this._reservedRanges,at=this._drawRanges,lt=this._bounds;this._geometryCount!==0&&(rt=ot[ot.length-1]),_e===-1?nt.vertexCount=_.getAttribute("position").count:nt.vertexCount=_e,rt===null?nt.vertexStart=0:nt.vertexStart=rt.vertexStart+rt.vertexCount;const ut=_.getIndex(),dt=ut!==null;if(dt&&(tt===-1?nt.indexCount=ut.count:nt.indexCount=tt,rt===null?nt.indexStart=0:nt.indexStart=rt.indexStart+rt.indexCount),nt.indexStart!==-1&&nt.indexStart+nt.indexCount>this._maxIndexCount||nt.vertexStart+nt.vertexCount>this._maxVertexCount)throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");const st=this._geometryCount;return this._geometryCount++,ot.push(nt),at.push({start:dt?nt.indexStart:nt.vertexStart,count:-1}),lt.push({boxInitialized:!1,box:new Box3,sphereInitialized:!1,sphere:new Sphere}),this.setGeometryAt(st,_),st}setGeometryAt(_,_e){if(_>=this._geometryCount)throw new Error("BatchedMesh: Maximum geometry count reached.");this._validateGeometry(_e);const tt=this.geometry,nt=tt.getIndex()!==null,rt=tt.getIndex(),ot=_e.getIndex(),at=this._reservedRanges[_];if(nt&&ot.count>at.indexCount||_e.attributes.position.count>at.vertexCount)throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");const lt=at.vertexStart,ut=at.vertexCount;for(const ct in tt.attributes){const ft=_e.getAttribute(ct),ht=tt.getAttribute(ct);copyAttributeData(ft,ht,lt);const mt=ft.itemSize;for(let pt=ft.count,_t=ut;pt<_t;pt++){const vt=lt+pt;for(let bt=0;bt<mt;bt++)ht.setComponent(vt,bt,0)}ht.needsUpdate=!0,ht.addUpdateRange(lt*mt,ut*mt)}if(nt){const ct=at.indexStart;for(let ft=0;ft<ot.count;ft++)rt.setX(ct+ft,lt+ot.getX(ft));for(let ft=ot.count,ht=at.indexCount;ft<ht;ft++)rt.setX(ct+ft,lt);rt.needsUpdate=!0,rt.addUpdateRange(ct,at.indexCount)}const dt=this._bounds[_];_e.boundingBox!==null?(dt.box.copy(_e.boundingBox),dt.boxInitialized=!0):dt.boxInitialized=!1,_e.boundingSphere!==null?(dt.sphere.copy(_e.boundingSphere),dt.sphereInitialized=!0):dt.sphereInitialized=!1;const st=this._drawRanges[_],it=_e.getAttribute("position");return st.count=nt?ot.count:it.count,this._visibilityChanged=!0,_}getBoundingBoxAt(_,_e){if(_>=this._geometryCount)return null;const tt=this._bounds[_],nt=tt.box,rt=this.geometry;if(tt.boxInitialized===!1){nt.makeEmpty();const ot=rt.index,at=rt.attributes.position,lt=this._drawRanges[_];for(let ut=lt.start,dt=lt.start+lt.count;ut<dt;ut++){let st=ut;ot&&(st=ot.getX(st)),nt.expandByPoint(_vector$5.fromBufferAttribute(at,st))}tt.boxInitialized=!0}return _e.copy(nt),_e}getBoundingSphereAt(_,_e){if(_>=this._geometryCount)return null;const tt=this._bounds[_],nt=tt.sphere,rt=this.geometry;if(tt.sphereInitialized===!1){nt.makeEmpty(),this.getBoundingBoxAt(_,_box$1),_box$1.getCenter(nt.center);const ot=rt.index,at=rt.attributes.position,lt=this._drawRanges[_];let ut=0;for(let dt=lt.start,st=lt.start+lt.count;dt<st;dt++){let it=dt;ot&&(it=ot.getX(it)),_vector$5.fromBufferAttribute(at,it),ut=Math.max(ut,nt.center.distanceToSquared(_vector$5))}nt.radius=Math.sqrt(ut),tt.sphereInitialized=!0}return _e.copy(nt),_e}setMatrixAt(_,_e){const tt=this._drawInfo,nt=this._matricesTexture,rt=this._matricesTexture.image.data;return _>=tt.length||tt[_].active===!1?this:(_e.toArray(rt,_*16),nt.needsUpdate=!0,this)}getMatrixAt(_,_e){const tt=this._drawInfo,nt=this._matricesTexture.image.data;return _>=tt.length||tt[_].active===!1?null:_e.fromArray(nt,_*16)}setColorAt(_,_e){this._colorsTexture===null&&this._initColorsTexture();const tt=this._colorsTexture,nt=this._colorsTexture.image.data,rt=this._drawInfo;return _>=rt.length||rt[_].active===!1?this:(_e.toArray(nt,_*4),tt.needsUpdate=!0,this)}getColorAt(_,_e){const tt=this._colorsTexture.image.data,nt=this._drawInfo;return _>=nt.length||nt[_].active===!1?null:_e.fromArray(tt,_*4)}setVisibleAt(_,_e){const tt=this._drawInfo;return _>=tt.length||tt[_].active===!1||tt[_].visible===_e?this:(tt[_].visible=_e,this._visibilityChanged=!0,this)}getVisibleAt(_){const _e=this._drawInfo;return _>=_e.length||_e[_].active===!1?!1:_e[_].visible}raycast(_,_e){const tt=this._drawInfo,nt=this._drawRanges,rt=this.matrixWorld,ot=this.geometry;_mesh.material=this.material,_mesh.geometry.index=ot.index,_mesh.geometry.attributes=ot.attributes,_mesh.geometry.boundingBox===null&&(_mesh.geometry.boundingBox=new Box3),_mesh.geometry.boundingSphere===null&&(_mesh.geometry.boundingSphere=new Sphere);for(let at=0,lt=tt.length;at<lt;at++){if(!tt[at].visible||!tt[at].active)continue;const ut=tt[at].geometryIndex,dt=nt[ut];_mesh.geometry.setDrawRange(dt.start,dt.count),this.getMatrixAt(at,_mesh.matrixWorld).premultiply(rt),this.getBoundingBoxAt(ut,_mesh.geometry.boundingBox),this.getBoundingSphereAt(ut,_mesh.geometry.boundingSphere),_mesh.raycast(_,_batchIntersects);for(let st=0,it=_batchIntersects.length;st<it;st++){const ct=_batchIntersects[st];ct.object=this,ct.batchId=at,_e.push(ct)}_batchIntersects.length=0}_mesh.material=null,_mesh.geometry.index=null,_mesh.geometry.attributes={},_mesh.geometry.setDrawRange(0,1/0)}copy(_){return super.copy(_),this.geometry=_.geometry.clone(),this.perObjectFrustumCulled=_.perObjectFrustumCulled,this.sortObjects=_.sortObjects,this.boundingBox=_.boundingBox!==null?_.boundingBox.clone():null,this.boundingSphere=_.boundingSphere!==null?_.boundingSphere.clone():null,this._drawRanges=_._drawRanges.map(_e=>({..._e})),this._reservedRanges=_._reservedRanges.map(_e=>({..._e})),this._drawInfo=_._drawInfo.map(_e=>({..._e})),this._bounds=_._bounds.map(_e=>({boxInitialized:_e.boxInitialized,box:_e.box.clone(),sphereInitialized:_e.sphereInitialized,sphere:_e.sphere.clone()})),this._maxInstanceCount=_._maxInstanceCount,this._maxVertexCount=_._maxVertexCount,this._maxIndexCount=_._maxIndexCount,this._geometryInitialized=_._geometryInitialized,this._geometryCount=_._geometryCount,this._multiDrawCounts=_._multiDrawCounts.slice(),this._multiDrawStarts=_._multiDrawStarts.slice(),this._matricesTexture=_._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.slice(),this._colorsTexture!==null&&(this._colorsTexture=_._colorsTexture.clone(),this._colorsTexture.image.data=this._colorsTexture.image.slice()),this}dispose(){return this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this._indirectTexture.dispose(),this._indirectTexture=null,this._colorsTexture!==null&&(this._colorsTexture.dispose(),this._colorsTexture=null),this}onBeforeRender(_,_e,tt,nt,rt){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const ot=nt.getIndex(),at=ot===null?1:ot.array.BYTES_PER_ELEMENT,lt=this._drawInfo,ut=this._multiDrawStarts,dt=this._multiDrawCounts,st=this._drawRanges,it=this.perObjectFrustumCulled,ct=this._indirectTexture,ft=ct.image.data;it&&(_projScreenMatrix$2.multiplyMatrices(tt.projectionMatrix,tt.matrixWorldInverse).multiply(this.matrixWorld),_frustum.setFromProjectionMatrix(_projScreenMatrix$2,_.coordinateSystem));let ht=0;if(this.sortObjects){_invMatrixWorld.copy(this.matrixWorld).invert(),_vector$5.setFromMatrixPosition(tt.matrixWorld).applyMatrix4(_invMatrixWorld),_forward.set(0,0,-1).transformDirection(tt.matrixWorld).transformDirection(_invMatrixWorld);for(let _t=0,vt=lt.length;_t<vt;_t++)if(lt[_t].visible&&lt[_t].active){const bt=lt[_t].geometryIndex;this.getMatrixAt(_t,_matrix$1),this.getBoundingSphereAt(bt,_sphere$2).applyMatrix4(_matrix$1);let wt=!1;if(it&&(wt=!_frustum.intersectsSphere(_sphere$2)),!wt){const xt=_temp.subVectors(_sphere$2.center,_vector$5).dot(_forward);_renderList.push(st[bt],xt,_t)}}const mt=_renderList.list,pt=this.customSort;pt===null?mt.sort(rt.transparent?sortTransparent:sortOpaque):pt.call(this,mt,tt);for(let _t=0,vt=mt.length;_t<vt;_t++){const bt=mt[_t];ut[ht]=bt.start*at,dt[ht]=bt.count,ft[ht]=bt.index,ht++}_renderList.reset()}else for(let mt=0,pt=lt.length;mt<pt;mt++)if(lt[mt].visible&&lt[mt].active){const _t=lt[mt].geometryIndex;let vt=!1;if(it&&(this.getMatrixAt(mt,_matrix$1),this.getBoundingSphereAt(_t,_sphere$2).applyMatrix4(_matrix$1),vt=!_frustum.intersectsSphere(_sphere$2)),!vt){const bt=st[_t];ut[ht]=bt.start*at,dt[ht]=bt.count,ft[ht]=mt,ht++}}ct.needsUpdate=!0,this._multiDrawCount=ht,this._visibilityChanged=!1}onBeforeShadow(_,_e,tt,nt,rt,ot){this.onBeforeRender(_,null,nt,rt,ot)}}class LineBasicMaterial extends Material{constructor(_){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Color$1(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(_)}copy(_){return super.copy(_),this.color.copy(_.color),this.map=_.map,this.linewidth=_.linewidth,this.linecap=_.linecap,this.linejoin=_.linejoin,this.fog=_.fog,this}}const _vStart=new Vector3,_vEnd=new Vector3,_inverseMatrix$1=new Matrix4,_ray$1=new Ray,_sphere$1=new Sphere,_intersectPointOnRay=new Vector3,_intersectPointOnSegment=new Vector3;class Line extends Object3D{constructor(_=new BufferGeometry,_e=new LineBasicMaterial){super(),this.isLine=!0,this.type="Line",this.geometry=_,this.material=_e,this.updateMorphTargets()}copy(_,_e){return super.copy(_,_e),this.material=Array.isArray(_.material)?_.material.slice():_.material,this.geometry=_.geometry,this}computeLineDistances(){const _=this.geometry;if(_.index===null){const _e=_.attributes.position,tt=[0];for(let nt=1,rt=_e.count;nt<rt;nt++)_vStart.fromBufferAttribute(_e,nt-1),_vEnd.fromBufferAttribute(_e,nt),tt[nt]=tt[nt-1],tt[nt]+=_vStart.distanceTo(_vEnd);_.setAttribute("lineDistance",new Float32BufferAttribute(tt,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(_,_e){const tt=this.geometry,nt=this.matrixWorld,rt=_.params.Line.threshold,ot=tt.drawRange;if(tt.boundingSphere===null&&tt.computeBoundingSphere(),_sphere$1.copy(tt.boundingSphere),_sphere$1.applyMatrix4(nt),_sphere$1.radius+=rt,_.ray.intersectsSphere(_sphere$1)===!1)return;_inverseMatrix$1.copy(nt).invert(),_ray$1.copy(_.ray).applyMatrix4(_inverseMatrix$1);const at=rt/((this.scale.x+this.scale.y+this.scale.z)/3),lt=at*at,ut=this.isLineSegments?2:1,dt=tt.index,it=tt.attributes.position;if(dt!==null){const ct=Math.max(0,ot.start),ft=Math.min(dt.count,ot.start+ot.count);for(let ht=ct,mt=ft-1;ht<mt;ht+=ut){const pt=dt.getX(ht),_t=dt.getX(ht+1),vt=checkIntersection(this,_,_ray$1,lt,pt,_t);vt&&_e.push(vt)}if(this.isLineLoop){const ht=dt.getX(ft-1),mt=dt.getX(ct),pt=checkIntersection(this,_,_ray$1,lt,ht,mt);pt&&_e.push(pt)}}else{const ct=Math.max(0,ot.start),ft=Math.min(it.count,ot.start+ot.count);for(let ht=ct,mt=ft-1;ht<mt;ht+=ut){const pt=checkIntersection(this,_,_ray$1,lt,ht,ht+1);pt&&_e.push(pt)}if(this.isLineLoop){const ht=checkIntersection(this,_,_ray$1,lt,ft-1,ct);ht&&_e.push(ht)}}}updateMorphTargets(){const _e=this.geometry.morphAttributes,tt=Object.keys(_e);if(tt.length>0){const nt=_e[tt[0]];if(nt!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let rt=0,ot=nt.length;rt<ot;rt++){const at=nt[rt].name||String(rt);this.morphTargetInfluences.push(0),this.morphTargetDictionary[at]=rt}}}}}function checkIntersection(et,_,_e,tt,nt,rt){const ot=et.geometry.attributes.position;if(_vStart.fromBufferAttribute(ot,nt),_vEnd.fromBufferAttribute(ot,rt),_e.distanceSqToSegment(_vStart,_vEnd,_intersectPointOnRay,_intersectPointOnSegment)>tt)return;_intersectPointOnRay.applyMatrix4(et.matrixWorld);const lt=_.ray.origin.distanceTo(_intersectPointOnRay);if(!(lt<_.near||lt>_.far))return{distance:lt,point:_intersectPointOnSegment.clone().applyMatrix4(et.matrixWorld),index:nt,face:null,faceIndex:null,object:et}}const _start=new Vector3,_end=new Vector3;class LineSegments extends Line{constructor(_,_e){super(_,_e),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const _=this.geometry;if(_.index===null){const _e=_.attributes.position,tt=[];for(let nt=0,rt=_e.count;nt<rt;nt+=2)_start.fromBufferAttribute(_e,nt),_end.fromBufferAttribute(_e,nt+1),tt[nt]=nt===0?0:tt[nt-1],tt[nt+1]=tt[nt]+_start.distanceTo(_end);_.setAttribute("lineDistance",new Float32BufferAttribute(tt,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class LineLoop extends Line{constructor(_,_e){super(_,_e),this.isLineLoop=!0,this.type="LineLoop"}}class PointsMaterial extends Material{constructor(_){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new Color$1(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(_)}copy(_){return super.copy(_),this.color.copy(_.color),this.map=_.map,this.alphaMap=_.alphaMap,this.size=_.size,this.sizeAttenuation=_.sizeAttenuation,this.fog=_.fog,this}}const _inverseMatrix=new Matrix4,_ray$4=new Ray,_sphere=new Sphere,_position$2=new Vector3;class Points extends Object3D{constructor(_=new BufferGeometry,_e=new PointsMaterial){super(),this.isPoints=!0,this.type="Points",this.geometry=_,this.material=_e,this.updateMorphTargets()}copy(_,_e){return super.copy(_,_e),this.material=Array.isArray(_.material)?_.material.slice():_.material,this.geometry=_.geometry,this}raycast(_,_e){const tt=this.geometry,nt=this.matrixWorld,rt=_.params.Points.threshold,ot=tt.drawRange;if(tt.boundingSphere===null&&tt.computeBoundingSphere(),_sphere.copy(tt.boundingSphere),_sphere.applyMatrix4(nt),_sphere.radius+=rt,_.ray.intersectsSphere(_sphere)===!1)return;_inverseMatrix.copy(nt).invert(),_ray$4.copy(_.ray).applyMatrix4(_inverseMatrix);const at=rt/((this.scale.x+this.scale.y+this.scale.z)/3),lt=at*at,ut=tt.index,st=tt.attributes.position;if(ut!==null){const it=Math.max(0,ot.start),ct=Math.min(ut.count,ot.start+ot.count);for(let ft=it,ht=ct;ft<ht;ft++){const mt=ut.getX(ft);_position$2.fromBufferAttribute(st,mt),testPoint(_position$2,mt,lt,nt,_,_e,this)}}else{const it=Math.max(0,ot.start),ct=Math.min(st.count,ot.start+ot.count);for(let ft=it,ht=ct;ft<ht;ft++)_position$2.fromBufferAttribute(st,ft),testPoint(_position$2,ft,lt,nt,_,_e,this)}}updateMorphTargets(){const _e=this.geometry.morphAttributes,tt=Object.keys(_e);if(tt.length>0){const nt=_e[tt[0]];if(nt!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let rt=0,ot=nt.length;rt<ot;rt++){const at=nt[rt].name||String(rt);this.morphTargetInfluences.push(0),this.morphTargetDictionary[at]=rt}}}}}function testPoint(et,_,_e,tt,nt,rt,ot){const at=_ray$4.distanceSqToPoint(et);if(at<_e){const lt=new Vector3;_ray$4.closestPointToPoint(et,lt),lt.applyMatrix4(tt);const ut=nt.ray.origin.distanceTo(lt);if(ut<nt.near||ut>nt.far)return;rt.push({distance:ut,distanceToRay:Math.sqrt(at),point:lt,index:_,face:null,object:ot})}}class VideoTexture extends Texture{constructor(_,_e,tt,nt,rt,ot,at,lt,ut){super(_,_e,tt,nt,rt,ot,at,lt,ut),this.isVideoTexture=!0,this.minFilter=ot!==void 0?ot:LinearFilter,this.magFilter=rt!==void 0?rt:LinearFilter,this.generateMipmaps=!1;const dt=this;function st(){dt.needsUpdate=!0,_.requestVideoFrameCallback(st)}"requestVideoFrameCallback"in _&&_.requestVideoFrameCallback(st)}clone(){return new this.constructor(this.image).copy(this)}update(){const _=this.image;"requestVideoFrameCallback"in _===!1&&_.readyState>=_.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class FramebufferTexture extends Texture{constructor(_,_e){super({width:_,height:_e}),this.isFramebufferTexture=!0,this.magFilter=NearestFilter,this.minFilter=NearestFilter,this.generateMipmaps=!1,this.needsUpdate=!0}}class CompressedTexture extends Texture{constructor(_,_e,tt,nt,rt,ot,at,lt,ut,dt,st,it){super(null,ot,at,lt,ut,dt,nt,rt,st,it),this.isCompressedTexture=!0,this.image={width:_e,height:tt},this.mipmaps=_,this.flipY=!1,this.generateMipmaps=!1}}class CompressedArrayTexture extends CompressedTexture{constructor(_,_e,tt,nt,rt,ot){super(_,_e,tt,rt,ot),this.isCompressedArrayTexture=!0,this.image.depth=nt,this.wrapR=ClampToEdgeWrapping,this.layerUpdates=new Set}addLayerUpdate(_){this.layerUpdates.add(_)}clearLayerUpdates(){this.layerUpdates.clear()}}class CompressedCubeTexture extends CompressedTexture{constructor(_,_e,tt){super(void 0,_[0].width,_[0].height,_e,tt,CubeReflectionMapping),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=_}}class CanvasTexture extends Texture{constructor(_,_e,tt,nt,rt,ot,at,lt,ut){super(_,_e,tt,nt,rt,ot,at,lt,ut),this.isCanvasTexture=!0,this.needsUpdate=!0}}class Curve{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(_,_e){const tt=this.getUtoTmapping(_);return this.getPoint(tt,_e)}getPoints(_=5){const _e=[];for(let tt=0;tt<=_;tt++)_e.push(this.getPoint(tt/_));return _e}getSpacedPoints(_=5){const _e=[];for(let tt=0;tt<=_;tt++)_e.push(this.getPointAt(tt/_));return _e}getLength(){const _=this.getLengths();return _[_.length-1]}getLengths(_=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===_+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const _e=[];let tt,nt=this.getPoint(0),rt=0;_e.push(0);for(let ot=1;ot<=_;ot++)tt=this.getPoint(ot/_),rt+=tt.distanceTo(nt),_e.push(rt),nt=tt;return this.cacheArcLengths=_e,_e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(_,_e){const tt=this.getLengths();let nt=0;const rt=tt.length;let ot;_e?ot=_e:ot=_*tt[rt-1];let at=0,lt=rt-1,ut;for(;at<=lt;)if(nt=Math.floor(at+(lt-at)/2),ut=tt[nt]-ot,ut<0)at=nt+1;else if(ut>0)lt=nt-1;else{lt=nt;break}if(nt=lt,tt[nt]===ot)return nt/(rt-1);const dt=tt[nt],it=tt[nt+1]-dt,ct=(ot-dt)/it;return(nt+ct)/(rt-1)}getTangent(_,_e){let nt=_-1e-4,rt=_+1e-4;nt<0&&(nt=0),rt>1&&(rt=1);const ot=this.getPoint(nt),at=this.getPoint(rt),lt=_e||(ot.isVector2?new Vector2:new Vector3);return lt.copy(at).sub(ot).normalize(),lt}getTangentAt(_,_e){const tt=this.getUtoTmapping(_);return this.getTangent(tt,_e)}computeFrenetFrames(_,_e){const tt=new Vector3,nt=[],rt=[],ot=[],at=new Vector3,lt=new Matrix4;for(let ct=0;ct<=_;ct++){const ft=ct/_;nt[ct]=this.getTangentAt(ft,new Vector3)}rt[0]=new Vector3,ot[0]=new Vector3;let ut=Number.MAX_VALUE;const dt=Math.abs(nt[0].x),st=Math.abs(nt[0].y),it=Math.abs(nt[0].z);dt<=ut&&(ut=dt,tt.set(1,0,0)),st<=ut&&(ut=st,tt.set(0,1,0)),it<=ut&&tt.set(0,0,1),at.crossVectors(nt[0],tt).normalize(),rt[0].crossVectors(nt[0],at),ot[0].crossVectors(nt[0],rt[0]);for(let ct=1;ct<=_;ct++){if(rt[ct]=rt[ct-1].clone(),ot[ct]=ot[ct-1].clone(),at.crossVectors(nt[ct-1],nt[ct]),at.length()>Number.EPSILON){at.normalize();const ft=Math.acos(clamp$4(nt[ct-1].dot(nt[ct]),-1,1));rt[ct].applyMatrix4(lt.makeRotationAxis(at,ft))}ot[ct].crossVectors(nt[ct],rt[ct])}if(_e===!0){let ct=Math.acos(clamp$4(rt[0].dot(rt[_]),-1,1));ct/=_,nt[0].dot(at.crossVectors(rt[0],rt[_]))>0&&(ct=-ct);for(let ft=1;ft<=_;ft++)rt[ft].applyMatrix4(lt.makeRotationAxis(nt[ft],ct*ft)),ot[ft].crossVectors(nt[ft],rt[ft])}return{tangents:nt,normals:rt,binormals:ot}}clone(){return new this.constructor().copy(this)}copy(_){return this.arcLengthDivisions=_.arcLengthDivisions,this}toJSON(){const _={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return _.arcLengthDivisions=this.arcLengthDivisions,_.type=this.type,_}fromJSON(_){return this.arcLengthDivisions=_.arcLengthDivisions,this}}class EllipseCurve extends Curve{constructor(_=0,_e=0,tt=1,nt=1,rt=0,ot=Math.PI*2,at=!1,lt=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=_,this.aY=_e,this.xRadius=tt,this.yRadius=nt,this.aStartAngle=rt,this.aEndAngle=ot,this.aClockwise=at,this.aRotation=lt}getPoint(_,_e=new Vector2){const tt=_e,nt=Math.PI*2;let rt=this.aEndAngle-this.aStartAngle;const ot=Math.abs(rt)<Number.EPSILON;for(;rt<0;)rt+=nt;for(;rt>nt;)rt-=nt;rt<Number.EPSILON&&(ot?rt=0:rt=nt),this.aClockwise===!0&&!ot&&(rt===nt?rt=-nt:rt=rt-nt);const at=this.aStartAngle+_*rt;let lt=this.aX+this.xRadius*Math.cos(at),ut=this.aY+this.yRadius*Math.sin(at);if(this.aRotation!==0){const dt=Math.cos(this.aRotation),st=Math.sin(this.aRotation),it=lt-this.aX,ct=ut-this.aY;lt=it*dt-ct*st+this.aX,ut=it*st+ct*dt+this.aY}return tt.set(lt,ut)}copy(_){return super.copy(_),this.aX=_.aX,this.aY=_.aY,this.xRadius=_.xRadius,this.yRadius=_.yRadius,this.aStartAngle=_.aStartAngle,this.aEndAngle=_.aEndAngle,this.aClockwise=_.aClockwise,this.aRotation=_.aRotation,this}toJSON(){const _=super.toJSON();return _.aX=this.aX,_.aY=this.aY,_.xRadius=this.xRadius,_.yRadius=this.yRadius,_.aStartAngle=this.aStartAngle,_.aEndAngle=this.aEndAngle,_.aClockwise=this.aClockwise,_.aRotation=this.aRotation,_}fromJSON(_){return super.fromJSON(_),this.aX=_.aX,this.aY=_.aY,this.xRadius=_.xRadius,this.yRadius=_.yRadius,this.aStartAngle=_.aStartAngle,this.aEndAngle=_.aEndAngle,this.aClockwise=_.aClockwise,this.aRotation=_.aRotation,this}}class ArcCurve extends EllipseCurve{constructor(_,_e,tt,nt,rt,ot){super(_,_e,tt,tt,nt,rt,ot),this.isArcCurve=!0,this.type="ArcCurve"}}function CubicPoly(){let et=0,_=0,_e=0,tt=0;function nt(rt,ot,at,lt){et=rt,_=at,_e=-3*rt+3*ot-2*at-lt,tt=2*rt-2*ot+at+lt}return{initCatmullRom:function(rt,ot,at,lt,ut){nt(ot,at,ut*(at-rt),ut*(lt-ot))},initNonuniformCatmullRom:function(rt,ot,at,lt,ut,dt,st){let it=(ot-rt)/ut-(at-rt)/(ut+dt)+(at-ot)/dt,ct=(at-ot)/dt-(lt-ot)/(dt+st)+(lt-at)/st;it*=dt,ct*=dt,nt(ot,at,it,ct)},calc:function(rt){const ot=rt*rt,at=ot*rt;return et+_*rt+_e*ot+tt*at}}}const tmp=new Vector3,px=new CubicPoly,py=new CubicPoly,pz=new CubicPoly;class CatmullRomCurve3 extends Curve{constructor(_=[],_e=!1,tt="centripetal",nt=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=_,this.closed=_e,this.curveType=tt,this.tension=nt}getPoint(_,_e=new Vector3){const tt=_e,nt=this.points,rt=nt.length,ot=(rt-(this.closed?0:1))*_;let at=Math.floor(ot),lt=ot-at;this.closed?at+=at>0?0:(Math.floor(Math.abs(at)/rt)+1)*rt:lt===0&&at===rt-1&&(at=rt-2,lt=1);let ut,dt;this.closed||at>0?ut=nt[(at-1)%rt]:(tmp.subVectors(nt[0],nt[1]).add(nt[0]),ut=tmp);const st=nt[at%rt],it=nt[(at+1)%rt];if(this.closed||at+2<rt?dt=nt[(at+2)%rt]:(tmp.subVectors(nt[rt-1],nt[rt-2]).add(nt[rt-1]),dt=tmp),this.curveType==="centripetal"||this.curveType==="chordal"){const ct=this.curveType==="chordal"?.5:.25;let ft=Math.pow(ut.distanceToSquared(st),ct),ht=Math.pow(st.distanceToSquared(it),ct),mt=Math.pow(it.distanceToSquared(dt),ct);ht<1e-4&&(ht=1),ft<1e-4&&(ft=ht),mt<1e-4&&(mt=ht),px.initNonuniformCatmullRom(ut.x,st.x,it.x,dt.x,ft,ht,mt),py.initNonuniformCatmullRom(ut.y,st.y,it.y,dt.y,ft,ht,mt),pz.initNonuniformCatmullRom(ut.z,st.z,it.z,dt.z,ft,ht,mt)}else this.curveType==="catmullrom"&&(px.initCatmullRom(ut.x,st.x,it.x,dt.x,this.tension),py.initCatmullRom(ut.y,st.y,it.y,dt.y,this.tension),pz.initCatmullRom(ut.z,st.z,it.z,dt.z,this.tension));return tt.set(px.calc(lt),py.calc(lt),pz.calc(lt)),tt}copy(_){super.copy(_),this.points=[];for(let _e=0,tt=_.points.length;_e<tt;_e++){const nt=_.points[_e];this.points.push(nt.clone())}return this.closed=_.closed,this.curveType=_.curveType,this.tension=_.tension,this}toJSON(){const _=super.toJSON();_.points=[];for(let _e=0,tt=this.points.length;_e<tt;_e++){const nt=this.points[_e];_.points.push(nt.toArray())}return _.closed=this.closed,_.curveType=this.curveType,_.tension=this.tension,_}fromJSON(_){super.fromJSON(_),this.points=[];for(let _e=0,tt=_.points.length;_e<tt;_e++){const nt=_.points[_e];this.points.push(new Vector3().fromArray(nt))}return this.closed=_.closed,this.curveType=_.curveType,this.tension=_.tension,this}}function CatmullRom(et,_,_e,tt,nt){const rt=(tt-_)*.5,ot=(nt-_e)*.5,at=et*et,lt=et*at;return(2*_e-2*tt+rt+ot)*lt+(-3*_e+3*tt-2*rt-ot)*at+rt*et+_e}function QuadraticBezierP0(et,_){const _e=1-et;return _e*_e*_}function QuadraticBezierP1(et,_){return 2*(1-et)*et*_}function QuadraticBezierP2(et,_){return et*et*_}function QuadraticBezier(et,_,_e,tt){return QuadraticBezierP0(et,_)+QuadraticBezierP1(et,_e)+QuadraticBezierP2(et,tt)}function CubicBezierP0(et,_){const _e=1-et;return _e*_e*_e*_}function CubicBezierP1(et,_){const _e=1-et;return 3*_e*_e*et*_}function CubicBezierP2(et,_){return 3*(1-et)*et*et*_}function CubicBezierP3(et,_){return et*et*et*_}function CubicBezier(et,_,_e,tt,nt){return CubicBezierP0(et,_)+CubicBezierP1(et,_e)+CubicBezierP2(et,tt)+CubicBezierP3(et,nt)}class CubicBezierCurve extends Curve{constructor(_=new Vector2,_e=new Vector2,tt=new Vector2,nt=new Vector2){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=_,this.v1=_e,this.v2=tt,this.v3=nt}getPoint(_,_e=new Vector2){const tt=_e,nt=this.v0,rt=this.v1,ot=this.v2,at=this.v3;return tt.set(CubicBezier(_,nt.x,rt.x,ot.x,at.x),CubicBezier(_,nt.y,rt.y,ot.y,at.y)),tt}copy(_){return super.copy(_),this.v0.copy(_.v0),this.v1.copy(_.v1),this.v2.copy(_.v2),this.v3.copy(_.v3),this}toJSON(){const _=super.toJSON();return _.v0=this.v0.toArray(),_.v1=this.v1.toArray(),_.v2=this.v2.toArray(),_.v3=this.v3.toArray(),_}fromJSON(_){return super.fromJSON(_),this.v0.fromArray(_.v0),this.v1.fromArray(_.v1),this.v2.fromArray(_.v2),this.v3.fromArray(_.v3),this}}class CubicBezierCurve3 extends Curve{constructor(_=new Vector3,_e=new Vector3,tt=new Vector3,nt=new Vector3){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=_,this.v1=_e,this.v2=tt,this.v3=nt}getPoint(_,_e=new Vector3){const tt=_e,nt=this.v0,rt=this.v1,ot=this.v2,at=this.v3;return tt.set(CubicBezier(_,nt.x,rt.x,ot.x,at.x),CubicBezier(_,nt.y,rt.y,ot.y,at.y),CubicBezier(_,nt.z,rt.z,ot.z,at.z)),tt}copy(_){return super.copy(_),this.v0.copy(_.v0),this.v1.copy(_.v1),this.v2.copy(_.v2),this.v3.copy(_.v3),this}toJSON(){const _=super.toJSON();return _.v0=this.v0.toArray(),_.v1=this.v1.toArray(),_.v2=this.v2.toArray(),_.v3=this.v3.toArray(),_}fromJSON(_){return super.fromJSON(_),this.v0.fromArray(_.v0),this.v1.fromArray(_.v1),this.v2.fromArray(_.v2),this.v3.fromArray(_.v3),this}}class LineCurve extends Curve{constructor(_=new Vector2,_e=new Vector2){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=_,this.v2=_e}getPoint(_,_e=new Vector2){const tt=_e;return _===1?tt.copy(this.v2):(tt.copy(this.v2).sub(this.v1),tt.multiplyScalar(_).add(this.v1)),tt}getPointAt(_,_e){return this.getPoint(_,_e)}getTangent(_,_e=new Vector2){return _e.subVectors(this.v2,this.v1).normalize()}getTangentAt(_,_e){return this.getTangent(_,_e)}copy(_){return super.copy(_),this.v1.copy(_.v1),this.v2.copy(_.v2),this}toJSON(){const _=super.toJSON();return _.v1=this.v1.toArray(),_.v2=this.v2.toArray(),_}fromJSON(_){return super.fromJSON(_),this.v1.fromArray(_.v1),this.v2.fromArray(_.v2),this}}class LineCurve3 extends Curve{constructor(_=new Vector3,_e=new Vector3){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=_,this.v2=_e}getPoint(_,_e=new Vector3){const tt=_e;return _===1?tt.copy(this.v2):(tt.copy(this.v2).sub(this.v1),tt.multiplyScalar(_).add(this.v1)),tt}getPointAt(_,_e){return this.getPoint(_,_e)}getTangent(_,_e=new Vector3){return _e.subVectors(this.v2,this.v1).normalize()}getTangentAt(_,_e){return this.getTangent(_,_e)}copy(_){return super.copy(_),this.v1.copy(_.v1),this.v2.copy(_.v2),this}toJSON(){const _=super.toJSON();return _.v1=this.v1.toArray(),_.v2=this.v2.toArray(),_}fromJSON(_){return super.fromJSON(_),this.v1.fromArray(_.v1),this.v2.fromArray(_.v2),this}}class QuadraticBezierCurve extends Curve{constructor(_=new Vector2,_e=new Vector2,tt=new Vector2){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=_,this.v1=_e,this.v2=tt}getPoint(_,_e=new Vector2){const tt=_e,nt=this.v0,rt=this.v1,ot=this.v2;return tt.set(QuadraticBezier(_,nt.x,rt.x,ot.x),QuadraticBezier(_,nt.y,rt.y,ot.y)),tt}copy(_){return super.copy(_),this.v0.copy(_.v0),this.v1.copy(_.v1),this.v2.copy(_.v2),this}toJSON(){const _=super.toJSON();return _.v0=this.v0.toArray(),_.v1=this.v1.toArray(),_.v2=this.v2.toArray(),_}fromJSON(_){return super.fromJSON(_),this.v0.fromArray(_.v0),this.v1.fromArray(_.v1),this.v2.fromArray(_.v2),this}}class QuadraticBezierCurve3 extends Curve{constructor(_=new Vector3,_e=new Vector3,tt=new Vector3){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=_,this.v1=_e,this.v2=tt}getPoint(_,_e=new Vector3){const tt=_e,nt=this.v0,rt=this.v1,ot=this.v2;return tt.set(QuadraticBezier(_,nt.x,rt.x,ot.x),QuadraticBezier(_,nt.y,rt.y,ot.y),QuadraticBezier(_,nt.z,rt.z,ot.z)),tt}copy(_){return super.copy(_),this.v0.copy(_.v0),this.v1.copy(_.v1),this.v2.copy(_.v2),this}toJSON(){const _=super.toJSON();return _.v0=this.v0.toArray(),_.v1=this.v1.toArray(),_.v2=this.v2.toArray(),_}fromJSON(_){return super.fromJSON(_),this.v0.fromArray(_.v0),this.v1.fromArray(_.v1),this.v2.fromArray(_.v2),this}}class SplineCurve extends Curve{constructor(_=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=_}getPoint(_,_e=new Vector2){const tt=_e,nt=this.points,rt=(nt.length-1)*_,ot=Math.floor(rt),at=rt-ot,lt=nt[ot===0?ot:ot-1],ut=nt[ot],dt=nt[ot>nt.length-2?nt.length-1:ot+1],st=nt[ot>nt.length-3?nt.length-1:ot+2];return tt.set(CatmullRom(at,lt.x,ut.x,dt.x,st.x),CatmullRom(at,lt.y,ut.y,dt.y,st.y)),tt}copy(_){super.copy(_),this.points=[];for(let _e=0,tt=_.points.length;_e<tt;_e++){const nt=_.points[_e];this.points.push(nt.clone())}return this}toJSON(){const _=super.toJSON();_.points=[];for(let _e=0,tt=this.points.length;_e<tt;_e++){const nt=this.points[_e];_.points.push(nt.toArray())}return _}fromJSON(_){super.fromJSON(_),this.points=[];for(let _e=0,tt=_.points.length;_e<tt;_e++){const nt=_.points[_e];this.points.push(new Vector2().fromArray(nt))}return this}}var Curves=Object.freeze({__proto__:null,ArcCurve,CatmullRomCurve3,CubicBezierCurve,CubicBezierCurve3,EllipseCurve,LineCurve,LineCurve3,QuadraticBezierCurve,QuadraticBezierCurve3,SplineCurve});class CurvePath extends Curve{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(_){this.curves.push(_)}closePath(){const _=this.curves[0].getPoint(0),_e=this.curves[this.curves.length-1].getPoint(1);if(!_.equals(_e)){const tt=_.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new Curves[tt](_e,_))}return this}getPoint(_,_e){const tt=_*this.getLength(),nt=this.getCurveLengths();let rt=0;for(;rt<nt.length;){if(nt[rt]>=tt){const ot=nt[rt]-tt,at=this.curves[rt],lt=at.getLength(),ut=lt===0?0:1-ot/lt;return at.getPointAt(ut,_e)}rt++}return null}getLength(){const _=this.getCurveLengths();return _[_.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const _=[];let _e=0;for(let tt=0,nt=this.curves.length;tt<nt;tt++)_e+=this.curves[tt].getLength(),_.push(_e);return this.cacheLengths=_,_}getSpacedPoints(_=40){const _e=[];for(let tt=0;tt<=_;tt++)_e.push(this.getPoint(tt/_));return this.autoClose&&_e.push(_e[0]),_e}getPoints(_=12){const _e=[];let tt;for(let nt=0,rt=this.curves;nt<rt.length;nt++){const ot=rt[nt],at=ot.isEllipseCurve?_*2:ot.isLineCurve||ot.isLineCurve3?1:ot.isSplineCurve?_*ot.points.length:_,lt=ot.getPoints(at);for(let ut=0;ut<lt.length;ut++){const dt=lt[ut];tt&&tt.equals(dt)||(_e.push(dt),tt=dt)}}return this.autoClose&&_e.length>1&&!_e[_e.length-1].equals(_e[0])&&_e.push(_e[0]),_e}copy(_){super.copy(_),this.curves=[];for(let _e=0,tt=_.curves.length;_e<tt;_e++){const nt=_.curves[_e];this.curves.push(nt.clone())}return this.autoClose=_.autoClose,this}toJSON(){const _=super.toJSON();_.autoClose=this.autoClose,_.curves=[];for(let _e=0,tt=this.curves.length;_e<tt;_e++){const nt=this.curves[_e];_.curves.push(nt.toJSON())}return _}fromJSON(_){super.fromJSON(_),this.autoClose=_.autoClose,this.curves=[];for(let _e=0,tt=_.curves.length;_e<tt;_e++){const nt=_.curves[_e];this.curves.push(new Curves[nt.type]().fromJSON(nt))}return this}}class Path extends CurvePath{constructor(_){super(),this.type="Path",this.currentPoint=new Vector2,_&&this.setFromPoints(_)}setFromPoints(_){this.moveTo(_[0].x,_[0].y);for(let _e=1,tt=_.length;_e<tt;_e++)this.lineTo(_[_e].x,_[_e].y);return this}moveTo(_,_e){return this.currentPoint.set(_,_e),this}lineTo(_,_e){const tt=new LineCurve(this.currentPoint.clone(),new Vector2(_,_e));return this.curves.push(tt),this.currentPoint.set(_,_e),this}quadraticCurveTo(_,_e,tt,nt){const rt=new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(_,_e),new Vector2(tt,nt));return this.curves.push(rt),this.currentPoint.set(tt,nt),this}bezierCurveTo(_,_e,tt,nt,rt,ot){const at=new CubicBezierCurve(this.currentPoint.clone(),new Vector2(_,_e),new Vector2(tt,nt),new Vector2(rt,ot));return this.curves.push(at),this.currentPoint.set(rt,ot),this}splineThru(_){const _e=[this.currentPoint.clone()].concat(_),tt=new SplineCurve(_e);return this.curves.push(tt),this.currentPoint.copy(_[_.length-1]),this}arc(_,_e,tt,nt,rt,ot){const at=this.currentPoint.x,lt=this.currentPoint.y;return this.absarc(_+at,_e+lt,tt,nt,rt,ot),this}absarc(_,_e,tt,nt,rt,ot){return this.absellipse(_,_e,tt,tt,nt,rt,ot),this}ellipse(_,_e,tt,nt,rt,ot,at,lt){const ut=this.currentPoint.x,dt=this.currentPoint.y;return this.absellipse(_+ut,_e+dt,tt,nt,rt,ot,at,lt),this}absellipse(_,_e,tt,nt,rt,ot,at,lt){const ut=new EllipseCurve(_,_e,tt,nt,rt,ot,at,lt);if(this.curves.length>0){const st=ut.getPoint(0);st.equals(this.currentPoint)||this.lineTo(st.x,st.y)}this.curves.push(ut);const dt=ut.getPoint(1);return this.currentPoint.copy(dt),this}copy(_){return super.copy(_),this.currentPoint.copy(_.currentPoint),this}toJSON(){const _=super.toJSON();return _.currentPoint=this.currentPoint.toArray(),_}fromJSON(_){return super.fromJSON(_),this.currentPoint.fromArray(_.currentPoint),this}}class LatheGeometry extends BufferGeometry{constructor(_=[new Vector2(0,-.5),new Vector2(.5,0),new Vector2(0,.5)],_e=12,tt=0,nt=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:_,segments:_e,phiStart:tt,phiLength:nt},_e=Math.floor(_e),nt=clamp$4(nt,0,Math.PI*2);const rt=[],ot=[],at=[],lt=[],ut=[],dt=1/_e,st=new Vector3,it=new Vector2,ct=new Vector3,ft=new Vector3,ht=new Vector3;let mt=0,pt=0;for(let _t=0;_t<=_.length-1;_t++)switch(_t){case 0:mt=_[_t+1].x-_[_t].x,pt=_[_t+1].y-_[_t].y,ct.x=pt*1,ct.y=-mt,ct.z=pt*0,ht.copy(ct),ct.normalize(),lt.push(ct.x,ct.y,ct.z);break;case _.length-1:lt.push(ht.x,ht.y,ht.z);break;default:mt=_[_t+1].x-_[_t].x,pt=_[_t+1].y-_[_t].y,ct.x=pt*1,ct.y=-mt,ct.z=pt*0,ft.copy(ct),ct.x+=ht.x,ct.y+=ht.y,ct.z+=ht.z,ct.normalize(),lt.push(ct.x,ct.y,ct.z),ht.copy(ft)}for(let _t=0;_t<=_e;_t++){const vt=tt+_t*dt*nt,bt=Math.sin(vt),wt=Math.cos(vt);for(let xt=0;xt<=_.length-1;xt++){st.x=_[xt].x*bt,st.y=_[xt].y,st.z=_[xt].x*wt,ot.push(st.x,st.y,st.z),it.x=_t/_e,it.y=xt/(_.length-1),at.push(it.x,it.y);const Mt=lt[3*xt+0]*bt,At=lt[3*xt+1],St=lt[3*xt+0]*wt;ut.push(Mt,At,St)}}for(let _t=0;_t<_e;_t++)for(let vt=0;vt<_.length-1;vt++){const bt=vt+_t*_.length,wt=bt,xt=bt+_.length,Mt=bt+_.length+1,At=bt+1;rt.push(wt,xt,At),rt.push(Mt,At,xt)}this.setIndex(rt),this.setAttribute("position",new Float32BufferAttribute(ot,3)),this.setAttribute("uv",new Float32BufferAttribute(at,2)),this.setAttribute("normal",new Float32BufferAttribute(ut,3))}copy(_){return super.copy(_),this.parameters=Object.assign({},_.parameters),this}static fromJSON(_){return new LatheGeometry(_.points,_.segments,_.phiStart,_.phiLength)}}class CapsuleGeometry extends LatheGeometry{constructor(_=1,_e=1,tt=4,nt=8){const rt=new Path;rt.absarc(0,-_e/2,_,Math.PI*1.5,0),rt.absarc(0,_e/2,_,0,Math.PI*.5),super(rt.getPoints(tt),nt),this.type="CapsuleGeometry",this.parameters={radius:_,length:_e,capSegments:tt,radialSegments:nt}}static fromJSON(_){return new CapsuleGeometry(_.radius,_.length,_.capSegments,_.radialSegments)}}class CircleGeometry extends BufferGeometry{constructor(_=1,_e=32,tt=0,nt=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:_,segments:_e,thetaStart:tt,thetaLength:nt},_e=Math.max(3,_e);const rt=[],ot=[],at=[],lt=[],ut=new Vector3,dt=new Vector2;ot.push(0,0,0),at.push(0,0,1),lt.push(.5,.5);for(let st=0,it=3;st<=_e;st++,it+=3){const ct=tt+st/_e*nt;ut.x=_*Math.cos(ct),ut.y=_*Math.sin(ct),ot.push(ut.x,ut.y,ut.z),at.push(0,0,1),dt.x=(ot[it]/_+1)/2,dt.y=(ot[it+1]/_+1)/2,lt.push(dt.x,dt.y)}for(let st=1;st<=_e;st++)rt.push(st,st+1,0);this.setIndex(rt),this.setAttribute("position",new Float32BufferAttribute(ot,3)),this.setAttribute("normal",new Float32BufferAttribute(at,3)),this.setAttribute("uv",new Float32BufferAttribute(lt,2))}copy(_){return super.copy(_),this.parameters=Object.assign({},_.parameters),this}static fromJSON(_){return new CircleGeometry(_.radius,_.segments,_.thetaStart,_.thetaLength)}}class CylinderGeometry extends BufferGeometry{constructor(_=1,_e=1,tt=1,nt=32,rt=1,ot=!1,at=0,lt=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:_,radiusBottom:_e,height:tt,radialSegments:nt,heightSegments:rt,openEnded:ot,thetaStart:at,thetaLength:lt};const ut=this;nt=Math.floor(nt),rt=Math.floor(rt);const dt=[],st=[],it=[],ct=[];let ft=0;const ht=[],mt=tt/2;let pt=0;_t(),ot===!1&&(_>0&&vt(!0),_e>0&&vt(!1)),this.setIndex(dt),this.setAttribute("position",new Float32BufferAttribute(st,3)),this.setAttribute("normal",new Float32BufferAttribute(it,3)),this.setAttribute("uv",new Float32BufferAttribute(ct,2));function _t(){const bt=new Vector3,wt=new Vector3;let xt=0;const Mt=(_e-_)/tt;for(let At=0;At<=rt;At++){const St=[],Tt=At/rt,Ct=Tt*(_e-_)+_;for(let It=0;It<=nt;It++){const $t=It/nt,Nt=$t*lt+at,Bt=Math.sin(Nt),Ot=Math.cos(Nt);wt.x=Ct*Bt,wt.y=-Tt*tt+mt,wt.z=Ct*Ot,st.push(wt.x,wt.y,wt.z),bt.set(Bt,Mt,Ot).normalize(),it.push(bt.x,bt.y,bt.z),ct.push($t,1-Tt),St.push(ft++)}ht.push(St)}for(let At=0;At<nt;At++)for(let St=0;St<rt;St++){const Tt=ht[St][At],Ct=ht[St+1][At],It=ht[St+1][At+1],$t=ht[St][At+1];dt.push(Tt,Ct,$t),dt.push(Ct,It,$t),xt+=6}ut.addGroup(pt,xt,0),pt+=xt}function vt(bt){const wt=ft,xt=new Vector2,Mt=new Vector3;let At=0;const St=bt===!0?_:_e,Tt=bt===!0?1:-1;for(let It=1;It<=nt;It++)st.push(0,mt*Tt,0),it.push(0,Tt,0),ct.push(.5,.5),ft++;const Ct=ft;for(let It=0;It<=nt;It++){const Nt=It/nt*lt+at,Bt=Math.cos(Nt),Ot=Math.sin(Nt);Mt.x=St*Ot,Mt.y=mt*Tt,Mt.z=St*Bt,st.push(Mt.x,Mt.y,Mt.z),it.push(0,Tt,0),xt.x=Bt*.5+.5,xt.y=Ot*.5*Tt+.5,ct.push(xt.x,xt.y),ft++}for(let It=0;It<nt;It++){const $t=wt+It,Nt=Ct+It;bt===!0?dt.push(Nt,Nt+1,$t):dt.push(Nt+1,Nt,$t),At+=3}ut.addGroup(pt,At,bt===!0?1:2),pt+=At}}copy(_){return super.copy(_),this.parameters=Object.assign({},_.parameters),this}static fromJSON(_){return new CylinderGeometry(_.radiusTop,_.radiusBottom,_.height,_.radialSegments,_.heightSegments,_.openEnded,_.thetaStart,_.thetaLength)}}class ConeGeometry extends CylinderGeometry{constructor(_=1,_e=1,tt=32,nt=1,rt=!1,ot=0,at=Math.PI*2){super(0,_,_e,tt,nt,rt,ot,at),this.type="ConeGeometry",this.parameters={radius:_,height:_e,radialSegments:tt,heightSegments:nt,openEnded:rt,thetaStart:ot,thetaLength:at}}static fromJSON(_){return new ConeGeometry(_.radius,_.height,_.radialSegments,_.heightSegments,_.openEnded,_.thetaStart,_.thetaLength)}}class PolyhedronGeometry extends BufferGeometry{constructor(_=[],_e=[],tt=1,nt=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:_,indices:_e,radius:tt,detail:nt};const rt=[],ot=[];at(nt),ut(tt),dt(),this.setAttribute("position",new Float32BufferAttribute(rt,3)),this.setAttribute("normal",new Float32BufferAttribute(rt.slice(),3)),this.setAttribute("uv",new Float32BufferAttribute(ot,2)),nt===0?this.computeVertexNormals():this.normalizeNormals();function at(_t){const vt=new Vector3,bt=new Vector3,wt=new Vector3;for(let xt=0;xt<_e.length;xt+=3)ct(_e[xt+0],vt),ct(_e[xt+1],bt),ct(_e[xt+2],wt),lt(vt,bt,wt,_t)}function lt(_t,vt,bt,wt){const xt=wt+1,Mt=[];for(let At=0;At<=xt;At++){Mt[At]=[];const St=_t.clone().lerp(bt,At/xt),Tt=vt.clone().lerp(bt,At/xt),Ct=xt-At;for(let It=0;It<=Ct;It++)It===0&&At===xt?Mt[At][It]=St:Mt[At][It]=St.clone().lerp(Tt,It/Ct)}for(let At=0;At<xt;At++)for(let St=0;St<2*(xt-At)-1;St++){const Tt=Math.floor(St/2);St%2===0?(it(Mt[At][Tt+1]),it(Mt[At+1][Tt]),it(Mt[At][Tt])):(it(Mt[At][Tt+1]),it(Mt[At+1][Tt+1]),it(Mt[At+1][Tt]))}}function ut(_t){const vt=new Vector3;for(let bt=0;bt<rt.length;bt+=3)vt.x=rt[bt+0],vt.y=rt[bt+1],vt.z=rt[bt+2],vt.normalize().multiplyScalar(_t),rt[bt+0]=vt.x,rt[bt+1]=vt.y,rt[bt+2]=vt.z}function dt(){const _t=new Vector3;for(let vt=0;vt<rt.length;vt+=3){_t.x=rt[vt+0],_t.y=rt[vt+1],_t.z=rt[vt+2];const bt=mt(_t)/2/Math.PI+.5,wt=pt(_t)/Math.PI+.5;ot.push(bt,1-wt)}ft(),st()}function st(){for(let _t=0;_t<ot.length;_t+=6){const vt=ot[_t+0],bt=ot[_t+2],wt=ot[_t+4],xt=Math.max(vt,bt,wt),Mt=Math.min(vt,bt,wt);xt>.9&&Mt<.1&&(vt<.2&&(ot[_t+0]+=1),bt<.2&&(ot[_t+2]+=1),wt<.2&&(ot[_t+4]+=1))}}function it(_t){rt.push(_t.x,_t.y,_t.z)}function ct(_t,vt){const bt=_t*3;vt.x=_[bt+0],vt.y=_[bt+1],vt.z=_[bt+2]}function ft(){const _t=new Vector3,vt=new Vector3,bt=new Vector3,wt=new Vector3,xt=new Vector2,Mt=new Vector2,At=new Vector2;for(let St=0,Tt=0;St<rt.length;St+=9,Tt+=6){_t.set(rt[St+0],rt[St+1],rt[St+2]),vt.set(rt[St+3],rt[St+4],rt[St+5]),bt.set(rt[St+6],rt[St+7],rt[St+8]),xt.set(ot[Tt+0],ot[Tt+1]),Mt.set(ot[Tt+2],ot[Tt+3]),At.set(ot[Tt+4],ot[Tt+5]),wt.copy(_t).add(vt).add(bt).divideScalar(3);const Ct=mt(wt);ht(xt,Tt+0,_t,Ct),ht(Mt,Tt+2,vt,Ct),ht(At,Tt+4,bt,Ct)}}function ht(_t,vt,bt,wt){wt<0&&_t.x===1&&(ot[vt]=_t.x-1),bt.x===0&&bt.z===0&&(ot[vt]=wt/2/Math.PI+.5)}function mt(_t){return Math.atan2(_t.z,-_t.x)}function pt(_t){return Math.atan2(-_t.y,Math.sqrt(_t.x*_t.x+_t.z*_t.z))}}copy(_){return super.copy(_),this.parameters=Object.assign({},_.parameters),this}static fromJSON(_){return new PolyhedronGeometry(_.vertices,_.indices,_.radius,_.details)}}class DodecahedronGeometry extends PolyhedronGeometry{constructor(_=1,_e=0){const tt=(1+Math.sqrt(5))/2,nt=1/tt,rt=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-nt,-tt,0,-nt,tt,0,nt,-tt,0,nt,tt,-nt,-tt,0,-nt,tt,0,nt,-tt,0,nt,tt,0,-tt,0,-nt,tt,0,-nt,-tt,0,nt,tt,0,nt],ot=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(rt,ot,_,_e),this.type="DodecahedronGeometry",this.parameters={radius:_,detail:_e}}static fromJSON(_){return new DodecahedronGeometry(_.radius,_.detail)}}const _v0=new Vector3,_v1$1=new Vector3,_normal=new Vector3,_triangle=new Triangle;class EdgesGeometry extends BufferGeometry{constructor(_=null,_e=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:_,thresholdAngle:_e},_!==null){const nt=Math.pow(10,4),rt=Math.cos(DEG2RAD*_e),ot=_.getIndex(),at=_.getAttribute("position"),lt=ot?ot.count:at.count,ut=[0,0,0],dt=["a","b","c"],st=new Array(3),it={},ct=[];for(let ft=0;ft<lt;ft+=3){ot?(ut[0]=ot.getX(ft),ut[1]=ot.getX(ft+1),ut[2]=ot.getX(ft+2)):(ut[0]=ft,ut[1]=ft+1,ut[2]=ft+2);const{a:ht,b:mt,c:pt}=_triangle;if(ht.fromBufferAttribute(at,ut[0]),mt.fromBufferAttribute(at,ut[1]),pt.fromBufferAttribute(at,ut[2]),_triangle.getNormal(_normal),st[0]=`${Math.round(ht.x*nt)},${Math.round(ht.y*nt)},${Math.round(ht.z*nt)}`,st[1]=`${Math.round(mt.x*nt)},${Math.round(mt.y*nt)},${Math.round(mt.z*nt)}`,st[2]=`${Math.round(pt.x*nt)},${Math.round(pt.y*nt)},${Math.round(pt.z*nt)}`,!(st[0]===st[1]||st[1]===st[2]||st[2]===st[0]))for(let _t=0;_t<3;_t++){const vt=(_t+1)%3,bt=st[_t],wt=st[vt],xt=_triangle[dt[_t]],Mt=_triangle[dt[vt]],At=`${bt}_${wt}`,St=`${wt}_${bt}`;St in it&&it[St]?(_normal.dot(it[St].normal)<=rt&&(ct.push(xt.x,xt.y,xt.z),ct.push(Mt.x,Mt.y,Mt.z)),it[St]=null):At in it||(it[At]={index0:ut[_t],index1:ut[vt],normal:_normal.clone()})}}for(const ft in it)if(it[ft]){const{index0:ht,index1:mt}=it[ft];_v0.fromBufferAttribute(at,ht),_v1$1.fromBufferAttribute(at,mt),ct.push(_v0.x,_v0.y,_v0.z),ct.push(_v1$1.x,_v1$1.y,_v1$1.z)}this.setAttribute("position",new Float32BufferAttribute(ct,3))}}copy(_){return super.copy(_),this.parameters=Object.assign({},_.parameters),this}}class Shape extends Path{constructor(_){super(_),this.uuid=generateUUID(),this.type="Shape",this.holes=[]}getPointsHoles(_){const _e=[];for(let tt=0,nt=this.holes.length;tt<nt;tt++)_e[tt]=this.holes[tt].getPoints(_);return _e}extractPoints(_){return{shape:this.getPoints(_),holes:this.getPointsHoles(_)}}copy(_){super.copy(_),this.holes=[];for(let _e=0,tt=_.holes.length;_e<tt;_e++){const nt=_.holes[_e];this.holes.push(nt.clone())}return this}toJSON(){const _=super.toJSON();_.uuid=this.uuid,_.holes=[];for(let _e=0,tt=this.holes.length;_e<tt;_e++){const nt=this.holes[_e];_.holes.push(nt.toJSON())}return _}fromJSON(_){super.fromJSON(_),this.uuid=_.uuid,this.holes=[];for(let _e=0,tt=_.holes.length;_e<tt;_e++){const nt=_.holes[_e];this.holes.push(new Path().fromJSON(nt))}return this}}const Earcut={triangulate:function(et,_,_e=2){const tt=_&&_.length,nt=tt?_[0]*_e:et.length;let rt=linkedList(et,0,nt,_e,!0);const ot=[];if(!rt||rt.next===rt.prev)return ot;let at,lt,ut,dt,st,it,ct;if(tt&&(rt=eliminateHoles(et,_,rt,_e)),et.length>80*_e){at=ut=et[0],lt=dt=et[1];for(let ft=_e;ft<nt;ft+=_e)st=et[ft],it=et[ft+1],st<at&&(at=st),it<lt&&(lt=it),st>ut&&(ut=st),it>dt&&(dt=it);ct=Math.max(ut-at,dt-lt),ct=ct!==0?32767/ct:0}return earcutLinked(rt,ot,_e,at,lt,ct,0),ot}};function linkedList(et,_,_e,tt,nt){let rt,ot;if(nt===signedArea(et,_,_e,tt)>0)for(rt=_;rt<_e;rt+=tt)ot=insertNode(rt,et[rt],et[rt+1],ot);else for(rt=_e-tt;rt>=_;rt-=tt)ot=insertNode(rt,et[rt],et[rt+1],ot);return ot&&equals(ot,ot.next)&&(removeNode(ot),ot=ot.next),ot}function filterPoints(et,_){if(!et)return et;_||(_=et);let _e=et,tt;do if(tt=!1,!_e.steiner&&(equals(_e,_e.next)||area(_e.prev,_e,_e.next)===0)){if(removeNode(_e),_e=_=_e.prev,_e===_e.next)break;tt=!0}else _e=_e.next;while(tt||_e!==_);return _}function earcutLinked(et,_,_e,tt,nt,rt,ot){if(!et)return;!ot&&rt&&indexCurve(et,tt,nt,rt);let at=et,lt,ut;for(;et.prev!==et.next;){if(lt=et.prev,ut=et.next,rt?isEarHashed(et,tt,nt,rt):isEar(et)){_.push(lt.i/_e|0),_.push(et.i/_e|0),_.push(ut.i/_e|0),removeNode(et),et=ut.next,at=ut.next;continue}if(et=ut,et===at){ot?ot===1?(et=cureLocalIntersections(filterPoints(et),_,_e),earcutLinked(et,_,_e,tt,nt,rt,2)):ot===2&&splitEarcut(et,_,_e,tt,nt,rt):earcutLinked(filterPoints(et),_,_e,tt,nt,rt,1);break}}}function isEar(et){const _=et.prev,_e=et,tt=et.next;if(area(_,_e,tt)>=0)return!1;const nt=_.x,rt=_e.x,ot=tt.x,at=_.y,lt=_e.y,ut=tt.y,dt=nt<rt?nt<ot?nt:ot:rt<ot?rt:ot,st=at<lt?at<ut?at:ut:lt<ut?lt:ut,it=nt>rt?nt>ot?nt:ot:rt>ot?rt:ot,ct=at>lt?at>ut?at:ut:lt>ut?lt:ut;let ft=tt.next;for(;ft!==_;){if(ft.x>=dt&&ft.x<=it&&ft.y>=st&&ft.y<=ct&&pointInTriangle(nt,at,rt,lt,ot,ut,ft.x,ft.y)&&area(ft.prev,ft,ft.next)>=0)return!1;ft=ft.next}return!0}function isEarHashed(et,_,_e,tt){const nt=et.prev,rt=et,ot=et.next;if(area(nt,rt,ot)>=0)return!1;const at=nt.x,lt=rt.x,ut=ot.x,dt=nt.y,st=rt.y,it=ot.y,ct=at<lt?at<ut?at:ut:lt<ut?lt:ut,ft=dt<st?dt<it?dt:it:st<it?st:it,ht=at>lt?at>ut?at:ut:lt>ut?lt:ut,mt=dt>st?dt>it?dt:it:st>it?st:it,pt=zOrder(ct,ft,_,_e,tt),_t=zOrder(ht,mt,_,_e,tt);let vt=et.prevZ,bt=et.nextZ;for(;vt&&vt.z>=pt&&bt&&bt.z<=_t;){if(vt.x>=ct&&vt.x<=ht&&vt.y>=ft&&vt.y<=mt&&vt!==nt&&vt!==ot&&pointInTriangle(at,dt,lt,st,ut,it,vt.x,vt.y)&&area(vt.prev,vt,vt.next)>=0||(vt=vt.prevZ,bt.x>=ct&&bt.x<=ht&&bt.y>=ft&&bt.y<=mt&&bt!==nt&&bt!==ot&&pointInTriangle(at,dt,lt,st,ut,it,bt.x,bt.y)&&area(bt.prev,bt,bt.next)>=0))return!1;bt=bt.nextZ}for(;vt&&vt.z>=pt;){if(vt.x>=ct&&vt.x<=ht&&vt.y>=ft&&vt.y<=mt&&vt!==nt&&vt!==ot&&pointInTriangle(at,dt,lt,st,ut,it,vt.x,vt.y)&&area(vt.prev,vt,vt.next)>=0)return!1;vt=vt.prevZ}for(;bt&&bt.z<=_t;){if(bt.x>=ct&&bt.x<=ht&&bt.y>=ft&&bt.y<=mt&&bt!==nt&&bt!==ot&&pointInTriangle(at,dt,lt,st,ut,it,bt.x,bt.y)&&area(bt.prev,bt,bt.next)>=0)return!1;bt=bt.nextZ}return!0}function cureLocalIntersections(et,_,_e){let tt=et;do{const nt=tt.prev,rt=tt.next.next;!equals(nt,rt)&&intersects(nt,tt,tt.next,rt)&&locallyInside(nt,rt)&&locallyInside(rt,nt)&&(_.push(nt.i/_e|0),_.push(tt.i/_e|0),_.push(rt.i/_e|0),removeNode(tt),removeNode(tt.next),tt=et=rt),tt=tt.next}while(tt!==et);return filterPoints(tt)}function splitEarcut(et,_,_e,tt,nt,rt){let ot=et;do{let at=ot.next.next;for(;at!==ot.prev;){if(ot.i!==at.i&&isValidDiagonal(ot,at)){let lt=splitPolygon(ot,at);ot=filterPoints(ot,ot.next),lt=filterPoints(lt,lt.next),earcutLinked(ot,_,_e,tt,nt,rt,0),earcutLinked(lt,_,_e,tt,nt,rt,0);return}at=at.next}ot=ot.next}while(ot!==et)}function eliminateHoles(et,_,_e,tt){const nt=[];let rt,ot,at,lt,ut;for(rt=0,ot=_.length;rt<ot;rt++)at=_[rt]*tt,lt=rt<ot-1?_[rt+1]*tt:et.length,ut=linkedList(et,at,lt,tt,!1),ut===ut.next&&(ut.steiner=!0),nt.push(getLeftmost(ut));for(nt.sort(compareX),rt=0;rt<nt.length;rt++)_e=eliminateHole(nt[rt],_e);return _e}function compareX(et,_){return et.x-_.x}function eliminateHole(et,_){const _e=findHoleBridge(et,_);if(!_e)return _;const tt=splitPolygon(_e,et);return filterPoints(tt,tt.next),filterPoints(_e,_e.next)}function findHoleBridge(et,_){let _e=_,tt=-1/0,nt;const rt=et.x,ot=et.y;do{if(ot<=_e.y&&ot>=_e.next.y&&_e.next.y!==_e.y){const it=_e.x+(ot-_e.y)*(_e.next.x-_e.x)/(_e.next.y-_e.y);if(it<=rt&&it>tt&&(tt=it,nt=_e.x<_e.next.x?_e:_e.next,it===rt))return nt}_e=_e.next}while(_e!==_);if(!nt)return null;const at=nt,lt=nt.x,ut=nt.y;let dt=1/0,st;_e=nt;do rt>=_e.x&&_e.x>=lt&&rt!==_e.x&&pointInTriangle(ot<ut?rt:tt,ot,lt,ut,ot<ut?tt:rt,ot,_e.x,_e.y)&&(st=Math.abs(ot-_e.y)/(rt-_e.x),locallyInside(_e,et)&&(st<dt||st===dt&&(_e.x>nt.x||_e.x===nt.x&&sectorContainsSector(nt,_e)))&&(nt=_e,dt=st)),_e=_e.next;while(_e!==at);return nt}function sectorContainsSector(et,_){return area(et.prev,et,_.prev)<0&&area(_.next,et,et.next)<0}function indexCurve(et,_,_e,tt){let nt=et;do nt.z===0&&(nt.z=zOrder(nt.x,nt.y,_,_e,tt)),nt.prevZ=nt.prev,nt.nextZ=nt.next,nt=nt.next;while(nt!==et);nt.prevZ.nextZ=null,nt.prevZ=null,sortLinked(nt)}function sortLinked(et){let _,_e,tt,nt,rt,ot,at,lt,ut=1;do{for(_e=et,et=null,rt=null,ot=0;_e;){for(ot++,tt=_e,at=0,_=0;_<ut&&(at++,tt=tt.nextZ,!!tt);_++);for(lt=ut;at>0||lt>0&&tt;)at!==0&&(lt===0||!tt||_e.z<=tt.z)?(nt=_e,_e=_e.nextZ,at--):(nt=tt,tt=tt.nextZ,lt--),rt?rt.nextZ=nt:et=nt,nt.prevZ=rt,rt=nt;_e=tt}rt.nextZ=null,ut*=2}while(ot>1);return et}function zOrder(et,_,_e,tt,nt){return et=(et-_e)*nt|0,_=(_-tt)*nt|0,et=(et|et<<8)&16711935,et=(et|et<<4)&252645135,et=(et|et<<2)&858993459,et=(et|et<<1)&1431655765,_=(_|_<<8)&16711935,_=(_|_<<4)&252645135,_=(_|_<<2)&858993459,_=(_|_<<1)&1431655765,et|_<<1}function getLeftmost(et){let _=et,_e=et;do(_.x<_e.x||_.x===_e.x&&_.y<_e.y)&&(_e=_),_=_.next;while(_!==et);return _e}function pointInTriangle(et,_,_e,tt,nt,rt,ot,at){return(nt-ot)*(_-at)>=(et-ot)*(rt-at)&&(et-ot)*(tt-at)>=(_e-ot)*(_-at)&&(_e-ot)*(rt-at)>=(nt-ot)*(tt-at)}function isValidDiagonal(et,_){return et.next.i!==_.i&&et.prev.i!==_.i&&!intersectsPolygon(et,_)&&(locallyInside(et,_)&&locallyInside(_,et)&&middleInside(et,_)&&(area(et.prev,et,_.prev)||area(et,_.prev,_))||equals(et,_)&&area(et.prev,et,et.next)>0&&area(_.prev,_,_.next)>0)}function area(et,_,_e){return(_.y-et.y)*(_e.x-_.x)-(_.x-et.x)*(_e.y-_.y)}function equals(et,_){return et.x===_.x&&et.y===_.y}function intersects(et,_,_e,tt){const nt=sign(area(et,_,_e)),rt=sign(area(et,_,tt)),ot=sign(area(_e,tt,et)),at=sign(area(_e,tt,_));return!!(nt!==rt&&ot!==at||nt===0&&onSegment(et,_e,_)||rt===0&&onSegment(et,tt,_)||ot===0&&onSegment(_e,et,tt)||at===0&&onSegment(_e,_,tt))}function onSegment(et,_,_e){return _.x<=Math.max(et.x,_e.x)&&_.x>=Math.min(et.x,_e.x)&&_.y<=Math.max(et.y,_e.y)&&_.y>=Math.min(et.y,_e.y)}function sign(et){return et>0?1:et<0?-1:0}function intersectsPolygon(et,_){let _e=et;do{if(_e.i!==et.i&&_e.next.i!==et.i&&_e.i!==_.i&&_e.next.i!==_.i&&intersects(_e,_e.next,et,_))return!0;_e=_e.next}while(_e!==et);return!1}function locallyInside(et,_){return area(et.prev,et,et.next)<0?area(et,_,et.next)>=0&&area(et,et.prev,_)>=0:area(et,_,et.prev)<0||area(et,et.next,_)<0}function middleInside(et,_){let _e=et,tt=!1;const nt=(et.x+_.x)/2,rt=(et.y+_.y)/2;do _e.y>rt!=_e.next.y>rt&&_e.next.y!==_e.y&&nt<(_e.next.x-_e.x)*(rt-_e.y)/(_e.next.y-_e.y)+_e.x&&(tt=!tt),_e=_e.next;while(_e!==et);return tt}function splitPolygon(et,_){const _e=new Node$1(et.i,et.x,et.y),tt=new Node$1(_.i,_.x,_.y),nt=et.next,rt=_.prev;return et.next=_,_.prev=et,_e.next=nt,nt.prev=_e,tt.next=_e,_e.prev=tt,rt.next=tt,tt.prev=rt,tt}function insertNode(et,_,_e,tt){const nt=new Node$1(et,_,_e);return tt?(nt.next=tt.next,nt.prev=tt,tt.next.prev=nt,tt.next=nt):(nt.prev=nt,nt.next=nt),nt}function removeNode(et){et.next.prev=et.prev,et.prev.next=et.next,et.prevZ&&(et.prevZ.nextZ=et.nextZ),et.nextZ&&(et.nextZ.prevZ=et.prevZ)}function Node$1(et,_,_e){this.i=et,this.x=_,this.y=_e,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function signedArea(et,_,_e,tt){let nt=0;for(let rt=_,ot=_e-tt;rt<_e;rt+=tt)nt+=(et[ot]-et[rt])*(et[rt+1]+et[ot+1]),ot=rt;return nt}class ShapeUtils{static area(_){const _e=_.length;let tt=0;for(let nt=_e-1,rt=0;rt<_e;nt=rt++)tt+=_[nt].x*_[rt].y-_[rt].x*_[nt].y;return tt*.5}static isClockWise(_){return ShapeUtils.area(_)<0}static triangulateShape(_,_e){const tt=[],nt=[],rt=[];removeDupEndPts(_),addContour(tt,_);let ot=_.length;_e.forEach(removeDupEndPts);for(let lt=0;lt<_e.length;lt++)nt.push(ot),ot+=_e[lt].length,addContour(tt,_e[lt]);const at=Earcut.triangulate(tt,nt);for(let lt=0;lt<at.length;lt+=3)rt.push(at.slice(lt,lt+3));return rt}}function removeDupEndPts(et){const _=et.length;_>2&&et[_-1].equals(et[0])&&et.pop()}function addContour(et,_){for(let _e=0;_e<_.length;_e++)et.push(_[_e].x),et.push(_[_e].y)}class ExtrudeGeometry extends BufferGeometry{constructor(_=new Shape([new Vector2(.5,.5),new Vector2(-.5,.5),new Vector2(-.5,-.5),new Vector2(.5,-.5)]),_e={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:_,options:_e},_=Array.isArray(_)?_:[_];const tt=this,nt=[],rt=[];for(let at=0,lt=_.length;at<lt;at++){const ut=_[at];ot(ut)}this.setAttribute("position",new Float32BufferAttribute(nt,3)),this.setAttribute("uv",new Float32BufferAttribute(rt,2)),this.computeVertexNormals();function ot(at){const lt=[],ut=_e.curveSegments!==void 0?_e.curveSegments:12,dt=_e.steps!==void 0?_e.steps:1,st=_e.depth!==void 0?_e.depth:1;let it=_e.bevelEnabled!==void 0?_e.bevelEnabled:!0,ct=_e.bevelThickness!==void 0?_e.bevelThickness:.2,ft=_e.bevelSize!==void 0?_e.bevelSize:ct-.1,ht=_e.bevelOffset!==void 0?_e.bevelOffset:0,mt=_e.bevelSegments!==void 0?_e.bevelSegments:3;const pt=_e.extrudePath,_t=_e.UVGenerator!==void 0?_e.UVGenerator:WorldUVGenerator;let vt,bt=!1,wt,xt,Mt,At;pt&&(vt=pt.getSpacedPoints(dt),bt=!0,it=!1,wt=pt.computeFrenetFrames(dt,!1),xt=new Vector3,Mt=new Vector3,At=new Vector3),it||(mt=0,ct=0,ft=0,ht=0);const St=at.extractPoints(ut);let Tt=St.shape;const Ct=St.holes;if(!ShapeUtils.isClockWise(Tt)){Tt=Tt.reverse();for(let Vt=0,on=Ct.length;Vt<on;Vt++){const dn=Ct[Vt];ShapeUtils.isClockWise(dn)&&(Ct[Vt]=dn.reverse())}}const $t=ShapeUtils.triangulateShape(Tt,Ct),Nt=Tt;for(let Vt=0,on=Ct.length;Vt<on;Vt++){const dn=Ct[Vt];Tt=Tt.concat(dn)}function Bt(Vt,on,dn){return on||console.error("THREE.ExtrudeGeometry: vec does not exist"),Vt.clone().addScaledVector(on,dn)}const Ot=Tt.length,Ut=$t.length;function Lt(Vt,on,dn){let Ln,Sn,Xn;const Vn=Vt.x-on.x,Hn=Vt.y-on.y,Zt=dn.x-Vt.x,Gt=dn.y-Vt.y,fn=Vn*Vn+Hn*Hn,hn=Vn*Gt-Hn*Zt;if(Math.abs(hn)>Number.EPSILON){const xn=Math.sqrt(fn),Tn=Math.sqrt(Zt*Zt+Gt*Gt),sr=on.x-Hn/xn,Wn=on.y+Vn/xn,or=dn.x-Gt/Tn,fr=dn.y+Zt/Tn,Gn=((or-sr)*Gt-(fr-Wn)*Zt)/(Vn*Gt-Hn*Zt);Ln=sr+Vn*Gn-Vt.x,Sn=Wn+Hn*Gn-Vt.y;const nr=Ln*Ln+Sn*Sn;if(nr<=2)return new Vector2(Ln,Sn);Xn=Math.sqrt(nr/2)}else{let xn=!1;Vn>Number.EPSILON?Zt>Number.EPSILON&&(xn=!0):Vn<-Number.EPSILON?Zt<-Number.EPSILON&&(xn=!0):Math.sign(Hn)===Math.sign(Gt)&&(xn=!0),xn?(Ln=-Hn,Sn=Vn,Xn=Math.sqrt(fn)):(Ln=Vn,Sn=Hn,Xn=Math.sqrt(fn/2))}return new Vector2(Ln/Xn,Sn/Xn)}const zt=[];for(let Vt=0,on=Nt.length,dn=on-1,Ln=Vt+1;Vt<on;Vt++,dn++,Ln++)dn===on&&(dn=0),Ln===on&&(Ln=0),zt[Vt]=Lt(Nt[Vt],Nt[dn],Nt[Ln]);const Yt=[];let en,bn=zt.concat();for(let Vt=0,on=Ct.length;Vt<on;Vt++){const dn=Ct[Vt];en=[];for(let Ln=0,Sn=dn.length,Xn=Sn-1,Vn=Ln+1;Ln<Sn;Ln++,Xn++,Vn++)Xn===Sn&&(Xn=0),Vn===Sn&&(Vn=0),en[Ln]=Lt(dn[Ln],dn[Xn],dn[Vn]);Yt.push(en),bn=bn.concat(en)}for(let Vt=0;Vt<mt;Vt++){const on=Vt/mt,dn=ct*Math.cos(on*Math.PI/2),Ln=ft*Math.sin(on*Math.PI/2)+ht;for(let Sn=0,Xn=Nt.length;Sn<Xn;Sn++){const Vn=Bt(Nt[Sn],zt[Sn],Ln);Cn(Vn.x,Vn.y,-dn)}for(let Sn=0,Xn=Ct.length;Sn<Xn;Sn++){const Vn=Ct[Sn];en=Yt[Sn];for(let Hn=0,Zt=Vn.length;Hn<Zt;Hn++){const Gt=Bt(Vn[Hn],en[Hn],Ln);Cn(Gt.x,Gt.y,-dn)}}}const Un=ft+ht;for(let Vt=0;Vt<Ot;Vt++){const on=it?Bt(Tt[Vt],bn[Vt],Un):Tt[Vt];bt?(Mt.copy(wt.normals[0]).multiplyScalar(on.x),xt.copy(wt.binormals[0]).multiplyScalar(on.y),At.copy(vt[0]).add(Mt).add(xt),Cn(At.x,At.y,At.z)):Cn(on.x,on.y,0)}for(let Vt=1;Vt<=dt;Vt++)for(let on=0;on<Ot;on++){const dn=it?Bt(Tt[on],bn[on],Un):Tt[on];bt?(Mt.copy(wt.normals[Vt]).multiplyScalar(dn.x),xt.copy(wt.binormals[Vt]).multiplyScalar(dn.y),At.copy(vt[Vt]).add(Mt).add(xt),Cn(At.x,At.y,At.z)):Cn(dn.x,dn.y,st/dt*Vt)}for(let Vt=mt-1;Vt>=0;Vt--){const on=Vt/mt,dn=ct*Math.cos(on*Math.PI/2),Ln=ft*Math.sin(on*Math.PI/2)+ht;for(let Sn=0,Xn=Nt.length;Sn<Xn;Sn++){const Vn=Bt(Nt[Sn],zt[Sn],Ln);Cn(Vn.x,Vn.y,st+dn)}for(let Sn=0,Xn=Ct.length;Sn<Xn;Sn++){const Vn=Ct[Sn];en=Yt[Sn];for(let Hn=0,Zt=Vn.length;Hn<Zt;Hn++){const Gt=Bt(Vn[Hn],en[Hn],Ln);bt?Cn(Gt.x,Gt.y+vt[dt-1].y,vt[dt-1].x+dn):Cn(Gt.x,Gt.y,st+dn)}}}mn(),vn();function mn(){const Vt=nt.length/3;if(it){let on=0,dn=Ot*on;for(let Ln=0;Ln<Ut;Ln++){const Sn=$t[Ln];En(Sn[2]+dn,Sn[1]+dn,Sn[0]+dn)}on=dt+mt*2,dn=Ot*on;for(let Ln=0;Ln<Ut;Ln++){const Sn=$t[Ln];En(Sn[0]+dn,Sn[1]+dn,Sn[2]+dn)}}else{for(let on=0;on<Ut;on++){const dn=$t[on];En(dn[2],dn[1],dn[0])}for(let on=0;on<Ut;on++){const dn=$t[on];En(dn[0]+Ot*dt,dn[1]+Ot*dt,dn[2]+Ot*dt)}}tt.addGroup(Vt,nt.length/3-Vt,0)}function vn(){const Vt=nt.length/3;let on=0;In(Nt,on),on+=Nt.length;for(let dn=0,Ln=Ct.length;dn<Ln;dn++){const Sn=Ct[dn];In(Sn,on),on+=Sn.length}tt.addGroup(Vt,nt.length/3-Vt,1)}function In(Vt,on){let dn=Vt.length;for(;--dn>=0;){const Ln=dn;let Sn=dn-1;Sn<0&&(Sn=Vt.length-1);for(let Xn=0,Vn=dt+mt*2;Xn<Vn;Xn++){const Hn=Ot*Xn,Zt=Ot*(Xn+1),Gt=on+Ln+Hn,fn=on+Sn+Hn,hn=on+Sn+Zt,xn=on+Ln+Zt;jt(Gt,fn,hn,xn)}}}function Cn(Vt,on,dn){lt.push(Vt),lt.push(on),lt.push(dn)}function En(Vt,on,dn){Kt(Vt),Kt(on),Kt(dn);const Ln=nt.length/3,Sn=_t.generateTopUV(tt,nt,Ln-3,Ln-2,Ln-1);nn(Sn[0]),nn(Sn[1]),nn(Sn[2])}function jt(Vt,on,dn,Ln){Kt(Vt),Kt(on),Kt(Ln),Kt(on),Kt(dn),Kt(Ln);const Sn=nt.length/3,Xn=_t.generateSideWallUV(tt,nt,Sn-6,Sn-3,Sn-2,Sn-1);nn(Xn[0]),nn(Xn[1]),nn(Xn[3]),nn(Xn[1]),nn(Xn[2]),nn(Xn[3])}function Kt(Vt){nt.push(lt[Vt*3+0]),nt.push(lt[Vt*3+1]),nt.push(lt[Vt*3+2])}function nn(Vt){rt.push(Vt.x),rt.push(Vt.y)}}}copy(_){return super.copy(_),this.parameters=Object.assign({},_.parameters),this}toJSON(){const _=super.toJSON(),_e=this.parameters.shapes,tt=this.parameters.options;return toJSON$1(_e,tt,_)}static fromJSON(_,_e){const tt=[];for(let rt=0,ot=_.shapes.length;rt<ot;rt++){const at=_e[_.shapes[rt]];tt.push(at)}const nt=_.options.extrudePath;return nt!==void 0&&(_.options.extrudePath=new Curves[nt.type]().fromJSON(nt)),new ExtrudeGeometry(tt,_.options)}}const WorldUVGenerator={generateTopUV:function(et,_,_e,tt,nt){const rt=_[_e*3],ot=_[_e*3+1],at=_[tt*3],lt=_[tt*3+1],ut=_[nt*3],dt=_[nt*3+1];return[new Vector2(rt,ot),new Vector2(at,lt),new Vector2(ut,dt)]},generateSideWallUV:function(et,_,_e,tt,nt,rt){const ot=_[_e*3],at=_[_e*3+1],lt=_[_e*3+2],ut=_[tt*3],dt=_[tt*3+1],st=_[tt*3+2],it=_[nt*3],ct=_[nt*3+1],ft=_[nt*3+2],ht=_[rt*3],mt=_[rt*3+1],pt=_[rt*3+2];return Math.abs(at-dt)<Math.abs(ot-ut)?[new Vector2(ot,1-lt),new Vector2(ut,1-st),new Vector2(it,1-ft),new Vector2(ht,1-pt)]:[new Vector2(at,1-lt),new Vector2(dt,1-st),new Vector2(ct,1-ft),new Vector2(mt,1-pt)]}};function toJSON$1(et,_,_e){if(_e.shapes=[],Array.isArray(et))for(let tt=0,nt=et.length;tt<nt;tt++){const rt=et[tt];_e.shapes.push(rt.uuid)}else _e.shapes.push(et.uuid);return _e.options=Object.assign({},_),_.extrudePath!==void 0&&(_e.options.extrudePath=_.extrudePath.toJSON()),_e}class IcosahedronGeometry extends PolyhedronGeometry{constructor(_=1,_e=0){const tt=(1+Math.sqrt(5))/2,nt=[-1,tt,0,1,tt,0,-1,-tt,0,1,-tt,0,0,-1,tt,0,1,tt,0,-1,-tt,0,1,-tt,tt,0,-1,tt,0,1,-tt,0,-1,-tt,0,1],rt=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(nt,rt,_,_e),this.type="IcosahedronGeometry",this.parameters={radius:_,detail:_e}}static fromJSON(_){return new IcosahedronGeometry(_.radius,_.detail)}}class OctahedronGeometry extends PolyhedronGeometry{constructor(_=1,_e=0){const tt=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],nt=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(tt,nt,_,_e),this.type="OctahedronGeometry",this.parameters={radius:_,detail:_e}}static fromJSON(_){return new OctahedronGeometry(_.radius,_.detail)}}class RingGeometry extends BufferGeometry{constructor(_=.5,_e=1,tt=32,nt=1,rt=0,ot=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:_,outerRadius:_e,thetaSegments:tt,phiSegments:nt,thetaStart:rt,thetaLength:ot},tt=Math.max(3,tt),nt=Math.max(1,nt);const at=[],lt=[],ut=[],dt=[];let st=_;const it=(_e-_)/nt,ct=new Vector3,ft=new Vector2;for(let ht=0;ht<=nt;ht++){for(let mt=0;mt<=tt;mt++){const pt=rt+mt/tt*ot;ct.x=st*Math.cos(pt),ct.y=st*Math.sin(pt),lt.push(ct.x,ct.y,ct.z),ut.push(0,0,1),ft.x=(ct.x/_e+1)/2,ft.y=(ct.y/_e+1)/2,dt.push(ft.x,ft.y)}st+=it}for(let ht=0;ht<nt;ht++){const mt=ht*(tt+1);for(let pt=0;pt<tt;pt++){const _t=pt+mt,vt=_t,bt=_t+tt+1,wt=_t+tt+2,xt=_t+1;at.push(vt,bt,xt),at.push(bt,wt,xt)}}this.setIndex(at),this.setAttribute("position",new Float32BufferAttribute(lt,3)),this.setAttribute("normal",new Float32BufferAttribute(ut,3)),this.setAttribute("uv",new Float32BufferAttribute(dt,2))}copy(_){return super.copy(_),this.parameters=Object.assign({},_.parameters),this}static fromJSON(_){return new RingGeometry(_.innerRadius,_.outerRadius,_.thetaSegments,_.phiSegments,_.thetaStart,_.thetaLength)}}class ShapeGeometry extends BufferGeometry{constructor(_=new Shape([new Vector2(0,.5),new Vector2(-.5,-.5),new Vector2(.5,-.5)]),_e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:_,curveSegments:_e};const tt=[],nt=[],rt=[],ot=[];let at=0,lt=0;if(Array.isArray(_)===!1)ut(_);else for(let dt=0;dt<_.length;dt++)ut(_[dt]),this.addGroup(at,lt,dt),at+=lt,lt=0;this.setIndex(tt),this.setAttribute("position",new Float32BufferAttribute(nt,3)),this.setAttribute("normal",new Float32BufferAttribute(rt,3)),this.setAttribute("uv",new Float32BufferAttribute(ot,2));function ut(dt){const st=nt.length/3,it=dt.extractPoints(_e);let ct=it.shape;const ft=it.holes;ShapeUtils.isClockWise(ct)===!1&&(ct=ct.reverse());for(let mt=0,pt=ft.length;mt<pt;mt++){const _t=ft[mt];ShapeUtils.isClockWise(_t)===!0&&(ft[mt]=_t.reverse())}const ht=ShapeUtils.triangulateShape(ct,ft);for(let mt=0,pt=ft.length;mt<pt;mt++){const _t=ft[mt];ct=ct.concat(_t)}for(let mt=0,pt=ct.length;mt<pt;mt++){const _t=ct[mt];nt.push(_t.x,_t.y,0),rt.push(0,0,1),ot.push(_t.x,_t.y)}for(let mt=0,pt=ht.length;mt<pt;mt++){const _t=ht[mt],vt=_t[0]+st,bt=_t[1]+st,wt=_t[2]+st;tt.push(vt,bt,wt),lt+=3}}}copy(_){return super.copy(_),this.parameters=Object.assign({},_.parameters),this}toJSON(){const _=super.toJSON(),_e=this.parameters.shapes;return toJSON(_e,_)}static fromJSON(_,_e){const tt=[];for(let nt=0,rt=_.shapes.length;nt<rt;nt++){const ot=_e[_.shapes[nt]];tt.push(ot)}return new ShapeGeometry(tt,_.curveSegments)}}function toJSON(et,_){if(_.shapes=[],Array.isArray(et))for(let _e=0,tt=et.length;_e<tt;_e++){const nt=et[_e];_.shapes.push(nt.uuid)}else _.shapes.push(et.uuid);return _}class SphereGeometry extends BufferGeometry{constructor(_=1,_e=32,tt=16,nt=0,rt=Math.PI*2,ot=0,at=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:_,widthSegments:_e,heightSegments:tt,phiStart:nt,phiLength:rt,thetaStart:ot,thetaLength:at},_e=Math.max(3,Math.floor(_e)),tt=Math.max(2,Math.floor(tt));const lt=Math.min(ot+at,Math.PI);let ut=0;const dt=[],st=new Vector3,it=new Vector3,ct=[],ft=[],ht=[],mt=[];for(let pt=0;pt<=tt;pt++){const _t=[],vt=pt/tt;let bt=0;pt===0&&ot===0?bt=.5/_e:pt===tt&&lt===Math.PI&&(bt=-.5/_e);for(let wt=0;wt<=_e;wt++){const xt=wt/_e;st.x=-_*Math.cos(nt+xt*rt)*Math.sin(ot+vt*at),st.y=_*Math.cos(ot+vt*at),st.z=_*Math.sin(nt+xt*rt)*Math.sin(ot+vt*at),ft.push(st.x,st.y,st.z),it.copy(st).normalize(),ht.push(it.x,it.y,it.z),mt.push(xt+bt,1-vt),_t.push(ut++)}dt.push(_t)}for(let pt=0;pt<tt;pt++)for(let _t=0;_t<_e;_t++){const vt=dt[pt][_t+1],bt=dt[pt][_t],wt=dt[pt+1][_t],xt=dt[pt+1][_t+1];(pt!==0||ot>0)&&ct.push(vt,bt,xt),(pt!==tt-1||lt<Math.PI)&&ct.push(bt,wt,xt)}this.setIndex(ct),this.setAttribute("position",new Float32BufferAttribute(ft,3)),this.setAttribute("normal",new Float32BufferAttribute(ht,3)),this.setAttribute("uv",new Float32BufferAttribute(mt,2))}copy(_){return super.copy(_),this.parameters=Object.assign({},_.parameters),this}static fromJSON(_){return new SphereGeometry(_.radius,_.widthSegments,_.heightSegments,_.phiStart,_.phiLength,_.thetaStart,_.thetaLength)}}class TetrahedronGeometry extends PolyhedronGeometry{constructor(_=1,_e=0){const tt=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],nt=[2,1,0,0,3,2,1,3,0,2,3,1];super(tt,nt,_,_e),this.type="TetrahedronGeometry",this.parameters={radius:_,detail:_e}}static fromJSON(_){return new TetrahedronGeometry(_.radius,_.detail)}}class TorusGeometry extends BufferGeometry{constructor(_=1,_e=.4,tt=12,nt=48,rt=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:_,tube:_e,radialSegments:tt,tubularSegments:nt,arc:rt},tt=Math.floor(tt),nt=Math.floor(nt);const ot=[],at=[],lt=[],ut=[],dt=new Vector3,st=new Vector3,it=new Vector3;for(let ct=0;ct<=tt;ct++)for(let ft=0;ft<=nt;ft++){const ht=ft/nt*rt,mt=ct/tt*Math.PI*2;st.x=(_+_e*Math.cos(mt))*Math.cos(ht),st.y=(_+_e*Math.cos(mt))*Math.sin(ht),st.z=_e*Math.sin(mt),at.push(st.x,st.y,st.z),dt.x=_*Math.cos(ht),dt.y=_*Math.sin(ht),it.subVectors(st,dt).normalize(),lt.push(it.x,it.y,it.z),ut.push(ft/nt),ut.push(ct/tt)}for(let ct=1;ct<=tt;ct++)for(let ft=1;ft<=nt;ft++){const ht=(nt+1)*ct+ft-1,mt=(nt+1)*(ct-1)+ft-1,pt=(nt+1)*(ct-1)+ft,_t=(nt+1)*ct+ft;ot.push(ht,mt,_t),ot.push(mt,pt,_t)}this.setIndex(ot),this.setAttribute("position",new Float32BufferAttribute(at,3)),this.setAttribute("normal",new Float32BufferAttribute(lt,3)),this.setAttribute("uv",new Float32BufferAttribute(ut,2))}copy(_){return super.copy(_),this.parameters=Object.assign({},_.parameters),this}static fromJSON(_){return new TorusGeometry(_.radius,_.tube,_.radialSegments,_.tubularSegments,_.arc)}}class TorusKnotGeometry extends BufferGeometry{constructor(_=1,_e=.4,tt=64,nt=8,rt=2,ot=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:_,tube:_e,tubularSegments:tt,radialSegments:nt,p:rt,q:ot},tt=Math.floor(tt),nt=Math.floor(nt);const at=[],lt=[],ut=[],dt=[],st=new Vector3,it=new Vector3,ct=new Vector3,ft=new Vector3,ht=new Vector3,mt=new Vector3,pt=new Vector3;for(let vt=0;vt<=tt;++vt){const bt=vt/tt*rt*Math.PI*2;_t(bt,rt,ot,_,ct),_t(bt+.01,rt,ot,_,ft),mt.subVectors(ft,ct),pt.addVectors(ft,ct),ht.crossVectors(mt,pt),pt.crossVectors(ht,mt),ht.normalize(),pt.normalize();for(let wt=0;wt<=nt;++wt){const xt=wt/nt*Math.PI*2,Mt=-_e*Math.cos(xt),At=_e*Math.sin(xt);st.x=ct.x+(Mt*pt.x+At*ht.x),st.y=ct.y+(Mt*pt.y+At*ht.y),st.z=ct.z+(Mt*pt.z+At*ht.z),lt.push(st.x,st.y,st.z),it.subVectors(st,ct).normalize(),ut.push(it.x,it.y,it.z),dt.push(vt/tt),dt.push(wt/nt)}}for(let vt=1;vt<=tt;vt++)for(let bt=1;bt<=nt;bt++){const wt=(nt+1)*(vt-1)+(bt-1),xt=(nt+1)*vt+(bt-1),Mt=(nt+1)*vt+bt,At=(nt+1)*(vt-1)+bt;at.push(wt,xt,At),at.push(xt,Mt,At)}this.setIndex(at),this.setAttribute("position",new Float32BufferAttribute(lt,3)),this.setAttribute("normal",new Float32BufferAttribute(ut,3)),this.setAttribute("uv",new Float32BufferAttribute(dt,2));function _t(vt,bt,wt,xt,Mt){const At=Math.cos(vt),St=Math.sin(vt),Tt=wt/bt*vt,Ct=Math.cos(Tt);Mt.x=xt*(2+Ct)*.5*At,Mt.y=xt*(2+Ct)*St*.5,Mt.z=xt*Math.sin(Tt)*.5}}copy(_){return super.copy(_),this.parameters=Object.assign({},_.parameters),this}static fromJSON(_){return new TorusKnotGeometry(_.radius,_.tube,_.tubularSegments,_.radialSegments,_.p,_.q)}}class TubeGeometry extends BufferGeometry{constructor(_=new QuadraticBezierCurve3(new Vector3(-1,-1,0),new Vector3(-1,1,0),new Vector3(1,1,0)),_e=64,tt=1,nt=8,rt=!1){super(),this.type="TubeGeometry",this.parameters={path:_,tubularSegments:_e,radius:tt,radialSegments:nt,closed:rt};const ot=_.computeFrenetFrames(_e,rt);this.tangents=ot.tangents,this.normals=ot.normals,this.binormals=ot.binormals;const at=new Vector3,lt=new Vector3,ut=new Vector2;let dt=new Vector3;const st=[],it=[],ct=[],ft=[];ht(),this.setIndex(ft),this.setAttribute("position",new Float32BufferAttribute(st,3)),this.setAttribute("normal",new Float32BufferAttribute(it,3)),this.setAttribute("uv",new Float32BufferAttribute(ct,2));function ht(){for(let vt=0;vt<_e;vt++)mt(vt);mt(rt===!1?_e:0),_t(),pt()}function mt(vt){dt=_.getPointAt(vt/_e,dt);const bt=ot.normals[vt],wt=ot.binormals[vt];for(let xt=0;xt<=nt;xt++){const Mt=xt/nt*Math.PI*2,At=Math.sin(Mt),St=-Math.cos(Mt);lt.x=St*bt.x+At*wt.x,lt.y=St*bt.y+At*wt.y,lt.z=St*bt.z+At*wt.z,lt.normalize(),it.push(lt.x,lt.y,lt.z),at.x=dt.x+tt*lt.x,at.y=dt.y+tt*lt.y,at.z=dt.z+tt*lt.z,st.push(at.x,at.y,at.z)}}function pt(){for(let vt=1;vt<=_e;vt++)for(let bt=1;bt<=nt;bt++){const wt=(nt+1)*(vt-1)+(bt-1),xt=(nt+1)*vt+(bt-1),Mt=(nt+1)*vt+bt,At=(nt+1)*(vt-1)+bt;ft.push(wt,xt,At),ft.push(xt,Mt,At)}}function _t(){for(let vt=0;vt<=_e;vt++)for(let bt=0;bt<=nt;bt++)ut.x=vt/_e,ut.y=bt/nt,ct.push(ut.x,ut.y)}}copy(_){return super.copy(_),this.parameters=Object.assign({},_.parameters),this}toJSON(){const _=super.toJSON();return _.path=this.parameters.path.toJSON(),_}static fromJSON(_){return new TubeGeometry(new Curves[_.path.type]().fromJSON(_.path),_.tubularSegments,_.radius,_.radialSegments,_.closed)}}class WireframeGeometry extends BufferGeometry{constructor(_=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:_},_!==null){const _e=[],tt=new Set,nt=new Vector3,rt=new Vector3;if(_.index!==null){const ot=_.attributes.position,at=_.index;let lt=_.groups;lt.length===0&&(lt=[{start:0,count:at.count,materialIndex:0}]);for(let ut=0,dt=lt.length;ut<dt;++ut){const st=lt[ut],it=st.start,ct=st.count;for(let ft=it,ht=it+ct;ft<ht;ft+=3)for(let mt=0;mt<3;mt++){const pt=at.getX(ft+mt),_t=at.getX(ft+(mt+1)%3);nt.fromBufferAttribute(ot,pt),rt.fromBufferAttribute(ot,_t),isUniqueEdge(nt,rt,tt)===!0&&(_e.push(nt.x,nt.y,nt.z),_e.push(rt.x,rt.y,rt.z))}}}else{const ot=_.attributes.position;for(let at=0,lt=ot.count/3;at<lt;at++)for(let ut=0;ut<3;ut++){const dt=3*at+ut,st=3*at+(ut+1)%3;nt.fromBufferAttribute(ot,dt),rt.fromBufferAttribute(ot,st),isUniqueEdge(nt,rt,tt)===!0&&(_e.push(nt.x,nt.y,nt.z),_e.push(rt.x,rt.y,rt.z))}}this.setAttribute("position",new Float32BufferAttribute(_e,3))}}copy(_){return super.copy(_),this.parameters=Object.assign({},_.parameters),this}}function isUniqueEdge(et,_,_e){const tt=`${et.x},${et.y},${et.z}-${_.x},${_.y},${_.z}`,nt=`${_.x},${_.y},${_.z}-${et.x},${et.y},${et.z}`;return _e.has(tt)===!0||_e.has(nt)===!0?!1:(_e.add(tt),_e.add(nt),!0)}var Geometries=Object.freeze({__proto__:null,BoxGeometry,CapsuleGeometry,CircleGeometry,ConeGeometry,CylinderGeometry,DodecahedronGeometry,EdgesGeometry,ExtrudeGeometry,IcosahedronGeometry,LatheGeometry,OctahedronGeometry,PlaneGeometry,PolyhedronGeometry,RingGeometry,ShapeGeometry,SphereGeometry,TetrahedronGeometry,TorusGeometry,TorusKnotGeometry,TubeGeometry,WireframeGeometry});class ShadowMaterial extends Material{constructor(_){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new Color$1(0),this.transparent=!0,this.fog=!0,this.setValues(_)}copy(_){return super.copy(_),this.color.copy(_.color),this.fog=_.fog,this}}class RawShaderMaterial extends ShaderMaterial{constructor(_){super(_),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class MeshStandardMaterial extends Material{constructor(_){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Color$1(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color$1(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(_)}copy(_){return super.copy(_),this.defines={STANDARD:""},this.color.copy(_.color),this.roughness=_.roughness,this.metalness=_.metalness,this.map=_.map,this.lightMap=_.lightMap,this.lightMapIntensity=_.lightMapIntensity,this.aoMap=_.aoMap,this.aoMapIntensity=_.aoMapIntensity,this.emissive.copy(_.emissive),this.emissiveMap=_.emissiveMap,this.emissiveIntensity=_.emissiveIntensity,this.bumpMap=_.bumpMap,this.bumpScale=_.bumpScale,this.normalMap=_.normalMap,this.normalMapType=_.normalMapType,this.normalScale.copy(_.normalScale),this.displacementMap=_.displacementMap,this.displacementScale=_.displacementScale,this.displacementBias=_.displacementBias,this.roughnessMap=_.roughnessMap,this.metalnessMap=_.metalnessMap,this.alphaMap=_.alphaMap,this.envMap=_.envMap,this.envMapRotation.copy(_.envMapRotation),this.envMapIntensity=_.envMapIntensity,this.wireframe=_.wireframe,this.wireframeLinewidth=_.wireframeLinewidth,this.wireframeLinecap=_.wireframeLinecap,this.wireframeLinejoin=_.wireframeLinejoin,this.flatShading=_.flatShading,this.fog=_.fog,this}}class MeshPhysicalMaterial extends MeshStandardMaterial{constructor(_){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Vector2(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return clamp$4(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(_e){this.ior=(1+.4*_e)/(1-.4*_e)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Color$1(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Color$1(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Color$1(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(_)}get anisotropy(){return this._anisotropy}set anisotropy(_){this._anisotropy>0!=_>0&&this.version++,this._anisotropy=_}get clearcoat(){return this._clearcoat}set clearcoat(_){this._clearcoat>0!=_>0&&this.version++,this._clearcoat=_}get iridescence(){return this._iridescence}set iridescence(_){this._iridescence>0!=_>0&&this.version++,this._iridescence=_}get dispersion(){return this._dispersion}set dispersion(_){this._dispersion>0!=_>0&&this.version++,this._dispersion=_}get sheen(){return this._sheen}set sheen(_){this._sheen>0!=_>0&&this.version++,this._sheen=_}get transmission(){return this._transmission}set transmission(_){this._transmission>0!=_>0&&this.version++,this._transmission=_}copy(_){return super.copy(_),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=_.anisotropy,this.anisotropyRotation=_.anisotropyRotation,this.anisotropyMap=_.anisotropyMap,this.clearcoat=_.clearcoat,this.clearcoatMap=_.clearcoatMap,this.clearcoatRoughness=_.clearcoatRoughness,this.clearcoatRoughnessMap=_.clearcoatRoughnessMap,this.clearcoatNormalMap=_.clearcoatNormalMap,this.clearcoatNormalScale.copy(_.clearcoatNormalScale),this.dispersion=_.dispersion,this.ior=_.ior,this.iridescence=_.iridescence,this.iridescenceMap=_.iridescenceMap,this.iridescenceIOR=_.iridescenceIOR,this.iridescenceThicknessRange=[..._.iridescenceThicknessRange],this.iridescenceThicknessMap=_.iridescenceThicknessMap,this.sheen=_.sheen,this.sheenColor.copy(_.sheenColor),this.sheenColorMap=_.sheenColorMap,this.sheenRoughness=_.sheenRoughness,this.sheenRoughnessMap=_.sheenRoughnessMap,this.transmission=_.transmission,this.transmissionMap=_.transmissionMap,this.thickness=_.thickness,this.thicknessMap=_.thicknessMap,this.attenuationDistance=_.attenuationDistance,this.attenuationColor.copy(_.attenuationColor),this.specularIntensity=_.specularIntensity,this.specularIntensityMap=_.specularIntensityMap,this.specularColor.copy(_.specularColor),this.specularColorMap=_.specularColorMap,this}}class MeshPhongMaterial extends Material{constructor(_){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new Color$1(16777215),this.specular=new Color$1(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color$1(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.combine=MultiplyOperation,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(_)}copy(_){return super.copy(_),this.color.copy(_.color),this.specular.copy(_.specular),this.shininess=_.shininess,this.map=_.map,this.lightMap=_.lightMap,this.lightMapIntensity=_.lightMapIntensity,this.aoMap=_.aoMap,this.aoMapIntensity=_.aoMapIntensity,this.emissive.copy(_.emissive),this.emissiveMap=_.emissiveMap,this.emissiveIntensity=_.emissiveIntensity,this.bumpMap=_.bumpMap,this.bumpScale=_.bumpScale,this.normalMap=_.normalMap,this.normalMapType=_.normalMapType,this.normalScale.copy(_.normalScale),this.displacementMap=_.displacementMap,this.displacementScale=_.displacementScale,this.displacementBias=_.displacementBias,this.specularMap=_.specularMap,this.alphaMap=_.alphaMap,this.envMap=_.envMap,this.envMapRotation.copy(_.envMapRotation),this.combine=_.combine,this.reflectivity=_.reflectivity,this.refractionRatio=_.refractionRatio,this.wireframe=_.wireframe,this.wireframeLinewidth=_.wireframeLinewidth,this.wireframeLinecap=_.wireframeLinecap,this.wireframeLinejoin=_.wireframeLinejoin,this.flatShading=_.flatShading,this.fog=_.fog,this}}class MeshToonMaterial extends Material{constructor(_){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Color$1(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color$1(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(_)}copy(_){return super.copy(_),this.color.copy(_.color),this.map=_.map,this.gradientMap=_.gradientMap,this.lightMap=_.lightMap,this.lightMapIntensity=_.lightMapIntensity,this.aoMap=_.aoMap,this.aoMapIntensity=_.aoMapIntensity,this.emissive.copy(_.emissive),this.emissiveMap=_.emissiveMap,this.emissiveIntensity=_.emissiveIntensity,this.bumpMap=_.bumpMap,this.bumpScale=_.bumpScale,this.normalMap=_.normalMap,this.normalMapType=_.normalMapType,this.normalScale.copy(_.normalScale),this.displacementMap=_.displacementMap,this.displacementScale=_.displacementScale,this.displacementBias=_.displacementBias,this.alphaMap=_.alphaMap,this.wireframe=_.wireframe,this.wireframeLinewidth=_.wireframeLinewidth,this.wireframeLinecap=_.wireframeLinecap,this.wireframeLinejoin=_.wireframeLinejoin,this.fog=_.fog,this}}class MeshNormalMaterial extends Material{constructor(_){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(_)}copy(_){return super.copy(_),this.bumpMap=_.bumpMap,this.bumpScale=_.bumpScale,this.normalMap=_.normalMap,this.normalMapType=_.normalMapType,this.normalScale.copy(_.normalScale),this.displacementMap=_.displacementMap,this.displacementScale=_.displacementScale,this.displacementBias=_.displacementBias,this.wireframe=_.wireframe,this.wireframeLinewidth=_.wireframeLinewidth,this.flatShading=_.flatShading,this}}class MeshLambertMaterial extends Material{constructor(_){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new Color$1(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color$1(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.combine=MultiplyOperation,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(_)}copy(_){return super.copy(_),this.color.copy(_.color),this.map=_.map,this.lightMap=_.lightMap,this.lightMapIntensity=_.lightMapIntensity,this.aoMap=_.aoMap,this.aoMapIntensity=_.aoMapIntensity,this.emissive.copy(_.emissive),this.emissiveMap=_.emissiveMap,this.emissiveIntensity=_.emissiveIntensity,this.bumpMap=_.bumpMap,this.bumpScale=_.bumpScale,this.normalMap=_.normalMap,this.normalMapType=_.normalMapType,this.normalScale.copy(_.normalScale),this.displacementMap=_.displacementMap,this.displacementScale=_.displacementScale,this.displacementBias=_.displacementBias,this.specularMap=_.specularMap,this.alphaMap=_.alphaMap,this.envMap=_.envMap,this.envMapRotation.copy(_.envMapRotation),this.combine=_.combine,this.reflectivity=_.reflectivity,this.refractionRatio=_.refractionRatio,this.wireframe=_.wireframe,this.wireframeLinewidth=_.wireframeLinewidth,this.wireframeLinecap=_.wireframeLinecap,this.wireframeLinejoin=_.wireframeLinejoin,this.flatShading=_.flatShading,this.fog=_.fog,this}}class MeshMatcapMaterial extends Material{constructor(_){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Color$1(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(_)}copy(_){return super.copy(_),this.defines={MATCAP:""},this.color.copy(_.color),this.matcap=_.matcap,this.map=_.map,this.bumpMap=_.bumpMap,this.bumpScale=_.bumpScale,this.normalMap=_.normalMap,this.normalMapType=_.normalMapType,this.normalScale.copy(_.normalScale),this.displacementMap=_.displacementMap,this.displacementScale=_.displacementScale,this.displacementBias=_.displacementBias,this.alphaMap=_.alphaMap,this.flatShading=_.flatShading,this.fog=_.fog,this}}class LineDashedMaterial extends LineBasicMaterial{constructor(_){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(_)}copy(_){return super.copy(_),this.scale=_.scale,this.dashSize=_.dashSize,this.gapSize=_.gapSize,this}}function convertArray(et,_,_e){return!et||!_e&&et.constructor===_?et:typeof _.BYTES_PER_ELEMENT=="number"?new _(et):Array.prototype.slice.call(et)}function isTypedArray$1(et){return ArrayBuffer.isView(et)&&!(et instanceof DataView)}function getKeyframeOrder(et){function _(nt,rt){return et[nt]-et[rt]}const _e=et.length,tt=new Array(_e);for(let nt=0;nt!==_e;++nt)tt[nt]=nt;return tt.sort(_),tt}function sortedArray(et,_,_e){const tt=et.length,nt=new et.constructor(tt);for(let rt=0,ot=0;ot!==tt;++rt){const at=_e[rt]*_;for(let lt=0;lt!==_;++lt)nt[ot++]=et[at+lt]}return nt}function flattenJSON(et,_,_e,tt){let nt=1,rt=et[0];for(;rt!==void 0&&rt[tt]===void 0;)rt=et[nt++];if(rt===void 0)return;let ot=rt[tt];if(ot!==void 0)if(Array.isArray(ot))do ot=rt[tt],ot!==void 0&&(_.push(rt.time),_e.push.apply(_e,ot)),rt=et[nt++];while(rt!==void 0);else if(ot.toArray!==void 0)do ot=rt[tt],ot!==void 0&&(_.push(rt.time),ot.toArray(_e,_e.length)),rt=et[nt++];while(rt!==void 0);else do ot=rt[tt],ot!==void 0&&(_.push(rt.time),_e.push(ot)),rt=et[nt++];while(rt!==void 0)}function subclip(et,_,_e,tt,nt=30){const rt=et.clone();rt.name=_;const ot=[];for(let lt=0;lt<rt.tracks.length;++lt){const ut=rt.tracks[lt],dt=ut.getValueSize(),st=[],it=[];for(let ct=0;ct<ut.times.length;++ct){const ft=ut.times[ct]*nt;if(!(ft<_e||ft>=tt)){st.push(ut.times[ct]);for(let ht=0;ht<dt;++ht)it.push(ut.values[ct*dt+ht])}}st.length!==0&&(ut.times=convertArray(st,ut.times.constructor),ut.values=convertArray(it,ut.values.constructor),ot.push(ut))}rt.tracks=ot;let at=1/0;for(let lt=0;lt<rt.tracks.length;++lt)at>rt.tracks[lt].times[0]&&(at=rt.tracks[lt].times[0]);for(let lt=0;lt<rt.tracks.length;++lt)rt.tracks[lt].shift(-1*at);return rt.resetDuration(),rt}function makeClipAdditive(et,_=0,_e=et,tt=30){tt<=0&&(tt=30);const nt=_e.tracks.length,rt=_/tt;for(let ot=0;ot<nt;++ot){const at=_e.tracks[ot],lt=at.ValueTypeName;if(lt==="bool"||lt==="string")continue;const ut=et.tracks.find(function(pt){return pt.name===at.name&&pt.ValueTypeName===lt});if(ut===void 0)continue;let dt=0;const st=at.getValueSize();at.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(dt=st/3);let it=0;const ct=ut.getValueSize();ut.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(it=ct/3);const ft=at.times.length-1;let ht;if(rt<=at.times[0]){const pt=dt,_t=st-dt;ht=at.values.slice(pt,_t)}else if(rt>=at.times[ft]){const pt=ft*st+dt,_t=pt+st-dt;ht=at.values.slice(pt,_t)}else{const pt=at.createInterpolant(),_t=dt,vt=st-dt;pt.evaluate(rt),ht=pt.resultBuffer.slice(_t,vt)}lt==="quaternion"&&new Quaternion().fromArray(ht).normalize().conjugate().toArray(ht);const mt=ut.times.length;for(let pt=0;pt<mt;++pt){const _t=pt*ct+it;if(lt==="quaternion")Quaternion.multiplyQuaternionsFlat(ut.values,_t,ht,0,ut.values,_t);else{const vt=ct-it*2;for(let bt=0;bt<vt;++bt)ut.values[_t+bt]-=ht[bt]}}}return et.blendMode=AdditiveAnimationBlendMode,et}const AnimationUtils={convertArray,isTypedArray:isTypedArray$1,getKeyframeOrder,sortedArray,flattenJSON,subclip,makeClipAdditive};class Interpolant{constructor(_,_e,tt,nt){this.parameterPositions=_,this._cachedIndex=0,this.resultBuffer=nt!==void 0?nt:new _e.constructor(tt),this.sampleValues=_e,this.valueSize=tt,this.settings=null,this.DefaultSettings_={}}evaluate(_){const _e=this.parameterPositions;let tt=this._cachedIndex,nt=_e[tt],rt=_e[tt-1];e:{t:{let ot;n:{r:if(!(_<nt)){for(let at=tt+2;;){if(nt===void 0){if(_<rt)break r;return tt=_e.length,this._cachedIndex=tt,this.copySampleValue_(tt-1)}if(tt===at)break;if(rt=nt,nt=_e[++tt],_<nt)break t}ot=_e.length;break n}if(!(_>=rt)){const at=_e[1];_<at&&(tt=2,rt=at);for(let lt=tt-2;;){if(rt===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(tt===lt)break;if(nt=rt,rt=_e[--tt-1],_>=rt)break t}ot=tt,tt=0;break n}break e}for(;tt<ot;){const at=tt+ot>>>1;_<_e[at]?ot=at:tt=at+1}if(nt=_e[tt],rt=_e[tt-1],rt===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(nt===void 0)return tt=_e.length,this._cachedIndex=tt,this.copySampleValue_(tt-1)}this._cachedIndex=tt,this.intervalChanged_(tt,rt,nt)}return this.interpolate_(tt,rt,_,nt)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(_){const _e=this.resultBuffer,tt=this.sampleValues,nt=this.valueSize,rt=_*nt;for(let ot=0;ot!==nt;++ot)_e[ot]=tt[rt+ot];return _e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class CubicInterpolant extends Interpolant{constructor(_,_e,tt,nt){super(_,_e,tt,nt),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding}}intervalChanged_(_,_e,tt){const nt=this.parameterPositions;let rt=_-2,ot=_+1,at=nt[rt],lt=nt[ot];if(at===void 0)switch(this.getSettings_().endingStart){case ZeroSlopeEnding:rt=_,at=2*_e-tt;break;case WrapAroundEnding:rt=nt.length-2,at=_e+nt[rt]-nt[rt+1];break;default:rt=_,at=tt}if(lt===void 0)switch(this.getSettings_().endingEnd){case ZeroSlopeEnding:ot=_,lt=2*tt-_e;break;case WrapAroundEnding:ot=1,lt=tt+nt[1]-nt[0];break;default:ot=_-1,lt=_e}const ut=(tt-_e)*.5,dt=this.valueSize;this._weightPrev=ut/(_e-at),this._weightNext=ut/(lt-tt),this._offsetPrev=rt*dt,this._offsetNext=ot*dt}interpolate_(_,_e,tt,nt){const rt=this.resultBuffer,ot=this.sampleValues,at=this.valueSize,lt=_*at,ut=lt-at,dt=this._offsetPrev,st=this._offsetNext,it=this._weightPrev,ct=this._weightNext,ft=(tt-_e)/(nt-_e),ht=ft*ft,mt=ht*ft,pt=-it*mt+2*it*ht-it*ft,_t=(1+it)*mt+(-1.5-2*it)*ht+(-.5+it)*ft+1,vt=(-1-ct)*mt+(1.5+ct)*ht+.5*ft,bt=ct*mt-ct*ht;for(let wt=0;wt!==at;++wt)rt[wt]=pt*ot[dt+wt]+_t*ot[ut+wt]+vt*ot[lt+wt]+bt*ot[st+wt];return rt}}class LinearInterpolant extends Interpolant{constructor(_,_e,tt,nt){super(_,_e,tt,nt)}interpolate_(_,_e,tt,nt){const rt=this.resultBuffer,ot=this.sampleValues,at=this.valueSize,lt=_*at,ut=lt-at,dt=(tt-_e)/(nt-_e),st=1-dt;for(let it=0;it!==at;++it)rt[it]=ot[ut+it]*st+ot[lt+it]*dt;return rt}}class DiscreteInterpolant extends Interpolant{constructor(_,_e,tt,nt){super(_,_e,tt,nt)}interpolate_(_){return this.copySampleValue_(_-1)}}class KeyframeTrack{constructor(_,_e,tt,nt){if(_===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(_e===void 0||_e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+_);this.name=_,this.times=convertArray(_e,this.TimeBufferType),this.values=convertArray(tt,this.ValueBufferType),this.setInterpolation(nt||this.DefaultInterpolation)}static toJSON(_){const _e=_.constructor;let tt;if(_e.toJSON!==this.toJSON)tt=_e.toJSON(_);else{tt={name:_.name,times:convertArray(_.times,Array),values:convertArray(_.values,Array)};const nt=_.getInterpolation();nt!==_.DefaultInterpolation&&(tt.interpolation=nt)}return tt.type=_.ValueTypeName,tt}InterpolantFactoryMethodDiscrete(_){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),_)}InterpolantFactoryMethodLinear(_){return new LinearInterpolant(this.times,this.values,this.getValueSize(),_)}InterpolantFactoryMethodSmooth(_){return new CubicInterpolant(this.times,this.values,this.getValueSize(),_)}setInterpolation(_){let _e;switch(_){case InterpolateDiscrete:_e=this.InterpolantFactoryMethodDiscrete;break;case InterpolateLinear:_e=this.InterpolantFactoryMethodLinear;break;case InterpolateSmooth:_e=this.InterpolantFactoryMethodSmooth;break}if(_e===void 0){const tt="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(_!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(tt);return console.warn("THREE.KeyframeTrack:",tt),this}return this.createInterpolant=_e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return InterpolateDiscrete;case this.InterpolantFactoryMethodLinear:return InterpolateLinear;case this.InterpolantFactoryMethodSmooth:return InterpolateSmooth}}getValueSize(){return this.values.length/this.times.length}shift(_){if(_!==0){const _e=this.times;for(let tt=0,nt=_e.length;tt!==nt;++tt)_e[tt]+=_}return this}scale(_){if(_!==1){const _e=this.times;for(let tt=0,nt=_e.length;tt!==nt;++tt)_e[tt]*=_}return this}trim(_,_e){const tt=this.times,nt=tt.length;let rt=0,ot=nt-1;for(;rt!==nt&&tt[rt]<_;)++rt;for(;ot!==-1&&tt[ot]>_e;)--ot;if(++ot,rt!==0||ot!==nt){rt>=ot&&(ot=Math.max(ot,1),rt=ot-1);const at=this.getValueSize();this.times=tt.slice(rt,ot),this.values=this.values.slice(rt*at,ot*at)}return this}validate(){let _=!0;const _e=this.getValueSize();_e-Math.floor(_e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),_=!1);const tt=this.times,nt=this.values,rt=tt.length;rt===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),_=!1);let ot=null;for(let at=0;at!==rt;at++){const lt=tt[at];if(typeof lt=="number"&&isNaN(lt)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,at,lt),_=!1;break}if(ot!==null&&ot>lt){console.error("THREE.KeyframeTrack: Out of order keys.",this,at,lt,ot),_=!1;break}ot=lt}if(nt!==void 0&&isTypedArray$1(nt))for(let at=0,lt=nt.length;at!==lt;++at){const ut=nt[at];if(isNaN(ut)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,at,ut),_=!1;break}}return _}optimize(){const _=this.times.slice(),_e=this.values.slice(),tt=this.getValueSize(),nt=this.getInterpolation()===InterpolateSmooth,rt=_.length-1;let ot=1;for(let at=1;at<rt;++at){let lt=!1;const ut=_[at],dt=_[at+1];if(ut!==dt&&(at!==1||ut!==_[0]))if(nt)lt=!0;else{const st=at*tt,it=st-tt,ct=st+tt;for(let ft=0;ft!==tt;++ft){const ht=_e[st+ft];if(ht!==_e[it+ft]||ht!==_e[ct+ft]){lt=!0;break}}}if(lt){if(at!==ot){_[ot]=_[at];const st=at*tt,it=ot*tt;for(let ct=0;ct!==tt;++ct)_e[it+ct]=_e[st+ct]}++ot}}if(rt>0){_[ot]=_[rt];for(let at=rt*tt,lt=ot*tt,ut=0;ut!==tt;++ut)_e[lt+ut]=_e[at+ut];++ot}return ot!==_.length?(this.times=_.slice(0,ot),this.values=_e.slice(0,ot*tt)):(this.times=_,this.values=_e),this}clone(){const _=this.times.slice(),_e=this.values.slice(),tt=this.constructor,nt=new tt(this.name,_,_e);return nt.createInterpolant=this.createInterpolant,nt}}KeyframeTrack.prototype.TimeBufferType=Float32Array;KeyframeTrack.prototype.ValueBufferType=Float32Array;KeyframeTrack.prototype.DefaultInterpolation=InterpolateLinear;class BooleanKeyframeTrack extends KeyframeTrack{constructor(_,_e,tt){super(_,_e,tt)}}BooleanKeyframeTrack.prototype.ValueTypeName="bool";BooleanKeyframeTrack.prototype.ValueBufferType=Array;BooleanKeyframeTrack.prototype.DefaultInterpolation=InterpolateDiscrete;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear=void 0;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class ColorKeyframeTrack extends KeyframeTrack{}ColorKeyframeTrack.prototype.ValueTypeName="color";class NumberKeyframeTrack extends KeyframeTrack{}NumberKeyframeTrack.prototype.ValueTypeName="number";class QuaternionLinearInterpolant extends Interpolant{constructor(_,_e,tt,nt){super(_,_e,tt,nt)}interpolate_(_,_e,tt,nt){const rt=this.resultBuffer,ot=this.sampleValues,at=this.valueSize,lt=(tt-_e)/(nt-_e);let ut=_*at;for(let dt=ut+at;ut!==dt;ut+=4)Quaternion.slerpFlat(rt,0,ot,ut-at,ot,ut,lt);return rt}}class QuaternionKeyframeTrack extends KeyframeTrack{InterpolantFactoryMethodLinear(_){return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),_)}}QuaternionKeyframeTrack.prototype.ValueTypeName="quaternion";QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class StringKeyframeTrack extends KeyframeTrack{constructor(_,_e,tt){super(_,_e,tt)}}StringKeyframeTrack.prototype.ValueTypeName="string";StringKeyframeTrack.prototype.ValueBufferType=Array;StringKeyframeTrack.prototype.DefaultInterpolation=InterpolateDiscrete;StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear=void 0;StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class VectorKeyframeTrack extends KeyframeTrack{}VectorKeyframeTrack.prototype.ValueTypeName="vector";class AnimationClip{constructor(_="",_e=-1,tt=[],nt=NormalAnimationBlendMode){this.name=_,this.tracks=tt,this.duration=_e,this.blendMode=nt,this.uuid=generateUUID(),this.duration<0&&this.resetDuration()}static parse(_){const _e=[],tt=_.tracks,nt=1/(_.fps||1);for(let ot=0,at=tt.length;ot!==at;++ot)_e.push(parseKeyframeTrack(tt[ot]).scale(nt));const rt=new this(_.name,_.duration,_e,_.blendMode);return rt.uuid=_.uuid,rt}static toJSON(_){const _e=[],tt=_.tracks,nt={name:_.name,duration:_.duration,tracks:_e,uuid:_.uuid,blendMode:_.blendMode};for(let rt=0,ot=tt.length;rt!==ot;++rt)_e.push(KeyframeTrack.toJSON(tt[rt]));return nt}static CreateFromMorphTargetSequence(_,_e,tt,nt){const rt=_e.length,ot=[];for(let at=0;at<rt;at++){let lt=[],ut=[];lt.push((at+rt-1)%rt,at,(at+1)%rt),ut.push(0,1,0);const dt=getKeyframeOrder(lt);lt=sortedArray(lt,1,dt),ut=sortedArray(ut,1,dt),!nt&&lt[0]===0&&(lt.push(rt),ut.push(ut[0])),ot.push(new NumberKeyframeTrack(".morphTargetInfluences["+_e[at].name+"]",lt,ut).scale(1/tt))}return new this(_,-1,ot)}static findByName(_,_e){let tt=_;if(!Array.isArray(_)){const nt=_;tt=nt.geometry&&nt.geometry.animations||nt.animations}for(let nt=0;nt<tt.length;nt++)if(tt[nt].name===_e)return tt[nt];return null}static CreateClipsFromMorphTargetSequences(_,_e,tt){const nt={},rt=/^([\w-]*?)([\d]+)$/;for(let at=0,lt=_.length;at<lt;at++){const ut=_[at],dt=ut.name.match(rt);if(dt&&dt.length>1){const st=dt[1];let it=nt[st];it||(nt[st]=it=[]),it.push(ut)}}const ot=[];for(const at in nt)ot.push(this.CreateFromMorphTargetSequence(at,nt[at],_e,tt));return ot}static parseAnimation(_,_e){if(!_)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const tt=function(st,it,ct,ft,ht){if(ct.length!==0){const mt=[],pt=[];flattenJSON(ct,mt,pt,ft),mt.length!==0&&ht.push(new st(it,mt,pt))}},nt=[],rt=_.name||"default",ot=_.fps||30,at=_.blendMode;let lt=_.length||-1;const ut=_.hierarchy||[];for(let st=0;st<ut.length;st++){const it=ut[st].keys;if(!(!it||it.length===0))if(it[0].morphTargets){const ct={};let ft;for(ft=0;ft<it.length;ft++)if(it[ft].morphTargets)for(let ht=0;ht<it[ft].morphTargets.length;ht++)ct[it[ft].morphTargets[ht]]=-1;for(const ht in ct){const mt=[],pt=[];for(let _t=0;_t!==it[ft].morphTargets.length;++_t){const vt=it[ft];mt.push(vt.time),pt.push(vt.morphTarget===ht?1:0)}nt.push(new NumberKeyframeTrack(".morphTargetInfluence["+ht+"]",mt,pt))}lt=ct.length*ot}else{const ct=".bones["+_e[st].name+"]";tt(VectorKeyframeTrack,ct+".position",it,"pos",nt),tt(QuaternionKeyframeTrack,ct+".quaternion",it,"rot",nt),tt(VectorKeyframeTrack,ct+".scale",it,"scl",nt)}}return nt.length===0?null:new this(rt,lt,nt,at)}resetDuration(){const _=this.tracks;let _e=0;for(let tt=0,nt=_.length;tt!==nt;++tt){const rt=this.tracks[tt];_e=Math.max(_e,rt.times[rt.times.length-1])}return this.duration=_e,this}trim(){for(let _=0;_<this.tracks.length;_++)this.tracks[_].trim(0,this.duration);return this}validate(){let _=!0;for(let _e=0;_e<this.tracks.length;_e++)_=_&&this.tracks[_e].validate();return _}optimize(){for(let _=0;_<this.tracks.length;_++)this.tracks[_].optimize();return this}clone(){const _=[];for(let _e=0;_e<this.tracks.length;_e++)_.push(this.tracks[_e].clone());return new this.constructor(this.name,this.duration,_,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function getTrackTypeForValueTypeName(et){switch(et.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return NumberKeyframeTrack;case"vector":case"vector2":case"vector3":case"vector4":return VectorKeyframeTrack;case"color":return ColorKeyframeTrack;case"quaternion":return QuaternionKeyframeTrack;case"bool":case"boolean":return BooleanKeyframeTrack;case"string":return StringKeyframeTrack}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+et)}function parseKeyframeTrack(et){if(et.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const _=getTrackTypeForValueTypeName(et.type);if(et.times===void 0){const _e=[],tt=[];flattenJSON(et.keys,_e,tt,"value"),et.times=_e,et.values=tt}return _.parse!==void 0?_.parse(et):new _(et.name,et.times,et.values,et.interpolation)}const Cache={enabled:!1,files:{},add:function(et,_){this.enabled!==!1&&(this.files[et]=_)},get:function(et){if(this.enabled!==!1)return this.files[et]},remove:function(et){delete this.files[et]},clear:function(){this.files={}}};class LoadingManager{constructor(_,_e,tt){const nt=this;let rt=!1,ot=0,at=0,lt;const ut=[];this.onStart=void 0,this.onLoad=_,this.onProgress=_e,this.onError=tt,this.itemStart=function(dt){at++,rt===!1&&nt.onStart!==void 0&&nt.onStart(dt,ot,at),rt=!0},this.itemEnd=function(dt){ot++,nt.onProgress!==void 0&&nt.onProgress(dt,ot,at),ot===at&&(rt=!1,nt.onLoad!==void 0&&nt.onLoad())},this.itemError=function(dt){nt.onError!==void 0&&nt.onError(dt)},this.resolveURL=function(dt){return lt?lt(dt):dt},this.setURLModifier=function(dt){return lt=dt,this},this.addHandler=function(dt,st){return ut.push(dt,st),this},this.removeHandler=function(dt){const st=ut.indexOf(dt);return st!==-1&&ut.splice(st,2),this},this.getHandler=function(dt){for(let st=0,it=ut.length;st<it;st+=2){const ct=ut[st],ft=ut[st+1];if(ct.global&&(ct.lastIndex=0),ct.test(dt))return ft}return null}}}const DefaultLoadingManager=new LoadingManager;class Loader{constructor(_){this.manager=_!==void 0?_:DefaultLoadingManager,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(_,_e){const tt=this;return new Promise(function(nt,rt){tt.load(_,nt,_e,rt)})}parse(){}setCrossOrigin(_){return this.crossOrigin=_,this}setWithCredentials(_){return this.withCredentials=_,this}setPath(_){return this.path=_,this}setResourcePath(_){return this.resourcePath=_,this}setRequestHeader(_){return this.requestHeader=_,this}}Loader.DEFAULT_MATERIAL_NAME="__DEFAULT";const loading={};class HttpError extends Error{constructor(_,_e){super(_),this.response=_e}}class FileLoader extends Loader{constructor(_){super(_)}load(_,_e,tt,nt){_===void 0&&(_=""),this.path!==void 0&&(_=this.path+_),_=this.manager.resolveURL(_);const rt=Cache.get(_);if(rt!==void 0)return this.manager.itemStart(_),setTimeout(()=>{_e&&_e(rt),this.manager.itemEnd(_)},0),rt;if(loading[_]!==void 0){loading[_].push({onLoad:_e,onProgress:tt,onError:nt});return}loading[_]=[],loading[_].push({onLoad:_e,onProgress:tt,onError:nt});const ot=new Request(_,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),at=this.mimeType,lt=this.responseType;fetch(ot).then(ut=>{if(ut.status===200||ut.status===0){if(ut.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||ut.body===void 0||ut.body.getReader===void 0)return ut;const dt=loading[_],st=ut.body.getReader(),it=ut.headers.get("X-File-Size")||ut.headers.get("Content-Length"),ct=it?parseInt(it):0,ft=ct!==0;let ht=0;const mt=new ReadableStream({start(pt){_t();function _t(){st.read().then(({done:vt,value:bt})=>{if(vt)pt.close();else{ht+=bt.byteLength;const wt=new ProgressEvent("progress",{lengthComputable:ft,loaded:ht,total:ct});for(let xt=0,Mt=dt.length;xt<Mt;xt++){const At=dt[xt];At.onProgress&&At.onProgress(wt)}pt.enqueue(bt),_t()}},vt=>{pt.error(vt)})}}});return new Response(mt)}else throw new HttpError(`fetch for "${ut.url}" responded with ${ut.status}: ${ut.statusText}`,ut)}).then(ut=>{switch(lt){case"arraybuffer":return ut.arrayBuffer();case"blob":return ut.blob();case"document":return ut.text().then(dt=>new DOMParser().parseFromString(dt,at));case"json":return ut.json();default:if(at===void 0)return ut.text();{const st=/charset="?([^;"\s]*)"?/i.exec(at),it=st&&st[1]?st[1].toLowerCase():void 0,ct=new TextDecoder(it);return ut.arrayBuffer().then(ft=>ct.decode(ft))}}}).then(ut=>{Cache.add(_,ut);const dt=loading[_];delete loading[_];for(let st=0,it=dt.length;st<it;st++){const ct=dt[st];ct.onLoad&&ct.onLoad(ut)}}).catch(ut=>{const dt=loading[_];if(dt===void 0)throw this.manager.itemError(_),ut;delete loading[_];for(let st=0,it=dt.length;st<it;st++){const ct=dt[st];ct.onError&&ct.onError(ut)}this.manager.itemError(_)}).finally(()=>{this.manager.itemEnd(_)}),this.manager.itemStart(_)}setResponseType(_){return this.responseType=_,this}setMimeType(_){return this.mimeType=_,this}}class AnimationLoader extends Loader{constructor(_){super(_)}load(_,_e,tt,nt){const rt=this,ot=new FileLoader(this.manager);ot.setPath(this.path),ot.setRequestHeader(this.requestHeader),ot.setWithCredentials(this.withCredentials),ot.load(_,function(at){try{_e(rt.parse(JSON.parse(at)))}catch(lt){nt?nt(lt):console.error(lt),rt.manager.itemError(_)}},tt,nt)}parse(_){const _e=[];for(let tt=0;tt<_.length;tt++){const nt=AnimationClip.parse(_[tt]);_e.push(nt)}return _e}}class CompressedTextureLoader extends Loader{constructor(_){super(_)}load(_,_e,tt,nt){const rt=this,ot=[],at=new CompressedTexture,lt=new FileLoader(this.manager);lt.setPath(this.path),lt.setResponseType("arraybuffer"),lt.setRequestHeader(this.requestHeader),lt.setWithCredentials(rt.withCredentials);let ut=0;function dt(st){lt.load(_[st],function(it){const ct=rt.parse(it,!0);ot[st]={width:ct.width,height:ct.height,format:ct.format,mipmaps:ct.mipmaps},ut+=1,ut===6&&(ct.mipmapCount===1&&(at.minFilter=LinearFilter),at.image=ot,at.format=ct.format,at.needsUpdate=!0,_e&&_e(at))},tt,nt)}if(Array.isArray(_))for(let st=0,it=_.length;st<it;++st)dt(st);else lt.load(_,function(st){const it=rt.parse(st,!0);if(it.isCubemap){const ct=it.mipmaps.length/it.mipmapCount;for(let ft=0;ft<ct;ft++){ot[ft]={mipmaps:[]};for(let ht=0;ht<it.mipmapCount;ht++)ot[ft].mipmaps.push(it.mipmaps[ft*it.mipmapCount+ht]),ot[ft].format=it.format,ot[ft].width=it.width,ot[ft].height=it.height}at.image=ot}else at.image.width=it.width,at.image.height=it.height,at.mipmaps=it.mipmaps;it.mipmapCount===1&&(at.minFilter=LinearFilter),at.format=it.format,at.needsUpdate=!0,_e&&_e(at)},tt,nt);return at}}class ImageLoader extends Loader{constructor(_){super(_)}load(_,_e,tt,nt){this.path!==void 0&&(_=this.path+_),_=this.manager.resolveURL(_);const rt=this,ot=Cache.get(_);if(ot!==void 0)return rt.manager.itemStart(_),setTimeout(function(){_e&&_e(ot),rt.manager.itemEnd(_)},0),ot;const at=createElementNS("img");function lt(){dt(),Cache.add(_,this),_e&&_e(this),rt.manager.itemEnd(_)}function ut(st){dt(),nt&&nt(st),rt.manager.itemError(_),rt.manager.itemEnd(_)}function dt(){at.removeEventListener("load",lt,!1),at.removeEventListener("error",ut,!1)}return at.addEventListener("load",lt,!1),at.addEventListener("error",ut,!1),_.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(at.crossOrigin=this.crossOrigin),rt.manager.itemStart(_),at.src=_,at}}class CubeTextureLoader extends Loader{constructor(_){super(_)}load(_,_e,tt,nt){const rt=new CubeTexture;rt.colorSpace=SRGBColorSpace;const ot=new ImageLoader(this.manager);ot.setCrossOrigin(this.crossOrigin),ot.setPath(this.path);let at=0;function lt(ut){ot.load(_[ut],function(dt){rt.images[ut]=dt,at++,at===6&&(rt.needsUpdate=!0,_e&&_e(rt))},void 0,nt)}for(let ut=0;ut<_.length;++ut)lt(ut);return rt}}class DataTextureLoader extends Loader{constructor(_){super(_)}load(_,_e,tt,nt){const rt=this,ot=new DataTexture,at=new FileLoader(this.manager);return at.setResponseType("arraybuffer"),at.setRequestHeader(this.requestHeader),at.setPath(this.path),at.setWithCredentials(rt.withCredentials),at.load(_,function(lt){let ut;try{ut=rt.parse(lt)}catch(dt){if(nt!==void 0)nt(dt);else{console.error(dt);return}}ut.image!==void 0?ot.image=ut.image:ut.data!==void 0&&(ot.image.width=ut.width,ot.image.height=ut.height,ot.image.data=ut.data),ot.wrapS=ut.wrapS!==void 0?ut.wrapS:ClampToEdgeWrapping,ot.wrapT=ut.wrapT!==void 0?ut.wrapT:ClampToEdgeWrapping,ot.magFilter=ut.magFilter!==void 0?ut.magFilter:LinearFilter,ot.minFilter=ut.minFilter!==void 0?ut.minFilter:LinearFilter,ot.anisotropy=ut.anisotropy!==void 0?ut.anisotropy:1,ut.colorSpace!==void 0&&(ot.colorSpace=ut.colorSpace),ut.flipY!==void 0&&(ot.flipY=ut.flipY),ut.format!==void 0&&(ot.format=ut.format),ut.type!==void 0&&(ot.type=ut.type),ut.mipmaps!==void 0&&(ot.mipmaps=ut.mipmaps,ot.minFilter=LinearMipmapLinearFilter),ut.mipmapCount===1&&(ot.minFilter=LinearFilter),ut.generateMipmaps!==void 0&&(ot.generateMipmaps=ut.generateMipmaps),ot.needsUpdate=!0,_e&&_e(ot,ut)},tt,nt),ot}}class TextureLoader extends Loader{constructor(_){super(_)}load(_,_e,tt,nt){const rt=new Texture,ot=new ImageLoader(this.manager);return ot.setCrossOrigin(this.crossOrigin),ot.setPath(this.path),ot.load(_,function(at){rt.image=at,rt.needsUpdate=!0,_e!==void 0&&_e(rt)},tt,nt),rt}}class Light extends Object3D{constructor(_,_e=1){super(),this.isLight=!0,this.type="Light",this.color=new Color$1(_),this.intensity=_e}dispose(){}copy(_,_e){return super.copy(_,_e),this.color.copy(_.color),this.intensity=_.intensity,this}toJSON(_){const _e=super.toJSON(_);return _e.object.color=this.color.getHex(),_e.object.intensity=this.intensity,this.groundColor!==void 0&&(_e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(_e.object.distance=this.distance),this.angle!==void 0&&(_e.object.angle=this.angle),this.decay!==void 0&&(_e.object.decay=this.decay),this.penumbra!==void 0&&(_e.object.penumbra=this.penumbra),this.shadow!==void 0&&(_e.object.shadow=this.shadow.toJSON()),this.target!==void 0&&(_e.object.target=this.target.uuid),_e}}class HemisphereLight extends Light{constructor(_,_e,tt){super(_,tt),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(Object3D.DEFAULT_UP),this.updateMatrix(),this.groundColor=new Color$1(_e)}copy(_,_e){return super.copy(_,_e),this.groundColor.copy(_.groundColor),this}}const _projScreenMatrix$1=new Matrix4,_lightPositionWorld$1=new Vector3,_lookTarget$1=new Vector3;class LightShadow{constructor(_){this.camera=_,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Vector2(512,512),this.map=null,this.mapPass=null,this.matrix=new Matrix4,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Frustum,this._frameExtents=new Vector2(1,1),this._viewportCount=1,this._viewports=[new Vector4(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(_){const _e=this.camera,tt=this.matrix;_lightPositionWorld$1.setFromMatrixPosition(_.matrixWorld),_e.position.copy(_lightPositionWorld$1),_lookTarget$1.setFromMatrixPosition(_.target.matrixWorld),_e.lookAt(_lookTarget$1),_e.updateMatrixWorld(),_projScreenMatrix$1.multiplyMatrices(_e.projectionMatrix,_e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(_projScreenMatrix$1),tt.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),tt.multiply(_projScreenMatrix$1)}getViewport(_){return this._viewports[_]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(_){return this.camera=_.camera.clone(),this.intensity=_.intensity,this.bias=_.bias,this.radius=_.radius,this.mapSize.copy(_.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const _={};return this.intensity!==1&&(_.intensity=this.intensity),this.bias!==0&&(_.bias=this.bias),this.normalBias!==0&&(_.normalBias=this.normalBias),this.radius!==1&&(_.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(_.mapSize=this.mapSize.toArray()),_.camera=this.camera.toJSON(!1).object,delete _.camera.matrix,_}}class SpotLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(_){const _e=this.camera,tt=RAD2DEG*2*_.angle*this.focus,nt=this.mapSize.width/this.mapSize.height,rt=_.distance||_e.far;(tt!==_e.fov||nt!==_e.aspect||rt!==_e.far)&&(_e.fov=tt,_e.aspect=nt,_e.far=rt,_e.updateProjectionMatrix()),super.updateMatrices(_)}copy(_){return super.copy(_),this.focus=_.focus,this}}class SpotLight extends Light{constructor(_,_e,tt=0,nt=Math.PI/3,rt=0,ot=2){super(_,_e),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Object3D.DEFAULT_UP),this.updateMatrix(),this.target=new Object3D,this.distance=tt,this.angle=nt,this.penumbra=rt,this.decay=ot,this.map=null,this.shadow=new SpotLightShadow}get power(){return this.intensity*Math.PI}set power(_){this.intensity=_/Math.PI}dispose(){this.shadow.dispose()}copy(_,_e){return super.copy(_,_e),this.distance=_.distance,this.angle=_.angle,this.penumbra=_.penumbra,this.decay=_.decay,this.target=_.target.clone(),this.shadow=_.shadow.clone(),this}}const _projScreenMatrix=new Matrix4,_lightPositionWorld=new Vector3,_lookTarget=new Vector3;class PointLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Vector2(4,2),this._viewportCount=6,this._viewports=[new Vector4(2,1,1,1),new Vector4(0,1,1,1),new Vector4(3,1,1,1),new Vector4(1,1,1,1),new Vector4(3,0,1,1),new Vector4(1,0,1,1)],this._cubeDirections=[new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),new Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)],this._cubeUps=[new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,0,-1)]}updateMatrices(_,_e=0){const tt=this.camera,nt=this.matrix,rt=_.distance||tt.far;rt!==tt.far&&(tt.far=rt,tt.updateProjectionMatrix()),_lightPositionWorld.setFromMatrixPosition(_.matrixWorld),tt.position.copy(_lightPositionWorld),_lookTarget.copy(tt.position),_lookTarget.add(this._cubeDirections[_e]),tt.up.copy(this._cubeUps[_e]),tt.lookAt(_lookTarget),tt.updateMatrixWorld(),nt.makeTranslation(-_lightPositionWorld.x,-_lightPositionWorld.y,-_lightPositionWorld.z),_projScreenMatrix.multiplyMatrices(tt.projectionMatrix,tt.matrixWorldInverse),this._frustum.setFromProjectionMatrix(_projScreenMatrix)}}class PointLight extends Light{constructor(_,_e,tt=0,nt=2){super(_,_e),this.isPointLight=!0,this.type="PointLight",this.distance=tt,this.decay=nt,this.shadow=new PointLightShadow}get power(){return this.intensity*4*Math.PI}set power(_){this.intensity=_/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(_,_e){return super.copy(_,_e),this.distance=_.distance,this.decay=_.decay,this.shadow=_.shadow.clone(),this}}class DirectionalLightShadow extends LightShadow{constructor(){super(new OrthographicCamera$1(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class DirectionalLight extends Light{constructor(_,_e){super(_,_e),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Object3D.DEFAULT_UP),this.updateMatrix(),this.target=new Object3D,this.shadow=new DirectionalLightShadow}dispose(){this.shadow.dispose()}copy(_){return super.copy(_),this.target=_.target.clone(),this.shadow=_.shadow.clone(),this}}class AmbientLight extends Light{constructor(_,_e){super(_,_e),this.isAmbientLight=!0,this.type="AmbientLight"}}class RectAreaLight extends Light{constructor(_,_e,tt=10,nt=10){super(_,_e),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=tt,this.height=nt}get power(){return this.intensity*this.width*this.height*Math.PI}set power(_){this.intensity=_/(this.width*this.height*Math.PI)}copy(_){return super.copy(_),this.width=_.width,this.height=_.height,this}toJSON(_){const _e=super.toJSON(_);return _e.object.width=this.width,_e.object.height=this.height,_e}}class SphericalHarmonics3{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let _=0;_<9;_++)this.coefficients.push(new Vector3)}set(_){for(let _e=0;_e<9;_e++)this.coefficients[_e].copy(_[_e]);return this}zero(){for(let _=0;_<9;_++)this.coefficients[_].set(0,0,0);return this}getAt(_,_e){const tt=_.x,nt=_.y,rt=_.z,ot=this.coefficients;return _e.copy(ot[0]).multiplyScalar(.282095),_e.addScaledVector(ot[1],.488603*nt),_e.addScaledVector(ot[2],.488603*rt),_e.addScaledVector(ot[3],.488603*tt),_e.addScaledVector(ot[4],1.092548*(tt*nt)),_e.addScaledVector(ot[5],1.092548*(nt*rt)),_e.addScaledVector(ot[6],.315392*(3*rt*rt-1)),_e.addScaledVector(ot[7],1.092548*(tt*rt)),_e.addScaledVector(ot[8],.546274*(tt*tt-nt*nt)),_e}getIrradianceAt(_,_e){const tt=_.x,nt=_.y,rt=_.z,ot=this.coefficients;return _e.copy(ot[0]).multiplyScalar(.886227),_e.addScaledVector(ot[1],2*.511664*nt),_e.addScaledVector(ot[2],2*.511664*rt),_e.addScaledVector(ot[3],2*.511664*tt),_e.addScaledVector(ot[4],2*.429043*tt*nt),_e.addScaledVector(ot[5],2*.429043*nt*rt),_e.addScaledVector(ot[6],.743125*rt*rt-.247708),_e.addScaledVector(ot[7],2*.429043*tt*rt),_e.addScaledVector(ot[8],.429043*(tt*tt-nt*nt)),_e}add(_){for(let _e=0;_e<9;_e++)this.coefficients[_e].add(_.coefficients[_e]);return this}addScaledSH(_,_e){for(let tt=0;tt<9;tt++)this.coefficients[tt].addScaledVector(_.coefficients[tt],_e);return this}scale(_){for(let _e=0;_e<9;_e++)this.coefficients[_e].multiplyScalar(_);return this}lerp(_,_e){for(let tt=0;tt<9;tt++)this.coefficients[tt].lerp(_.coefficients[tt],_e);return this}equals(_){for(let _e=0;_e<9;_e++)if(!this.coefficients[_e].equals(_.coefficients[_e]))return!1;return!0}copy(_){return this.set(_.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(_,_e=0){const tt=this.coefficients;for(let nt=0;nt<9;nt++)tt[nt].fromArray(_,_e+nt*3);return this}toArray(_=[],_e=0){const tt=this.coefficients;for(let nt=0;nt<9;nt++)tt[nt].toArray(_,_e+nt*3);return _}static getBasisAt(_,_e){const tt=_.x,nt=_.y,rt=_.z;_e[0]=.282095,_e[1]=.488603*nt,_e[2]=.488603*rt,_e[3]=.488603*tt,_e[4]=1.092548*tt*nt,_e[5]=1.092548*nt*rt,_e[6]=.315392*(3*rt*rt-1),_e[7]=1.092548*tt*rt,_e[8]=.546274*(tt*tt-nt*nt)}}class LightProbe extends Light{constructor(_=new SphericalHarmonics3,_e=1){super(void 0,_e),this.isLightProbe=!0,this.sh=_}copy(_){return super.copy(_),this.sh.copy(_.sh),this}fromJSON(_){return this.intensity=_.intensity,this.sh.fromArray(_.sh),this}toJSON(_){const _e=super.toJSON(_);return _e.object.sh=this.sh.toArray(),_e}}class MaterialLoader extends Loader{constructor(_){super(_),this.textures={}}load(_,_e,tt,nt){const rt=this,ot=new FileLoader(rt.manager);ot.setPath(rt.path),ot.setRequestHeader(rt.requestHeader),ot.setWithCredentials(rt.withCredentials),ot.load(_,function(at){try{_e(rt.parse(JSON.parse(at)))}catch(lt){nt?nt(lt):console.error(lt),rt.manager.itemError(_)}},tt,nt)}parse(_){const _e=this.textures;function tt(rt){return _e[rt]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",rt),_e[rt]}const nt=MaterialLoader.createMaterialFromType(_.type);if(_.uuid!==void 0&&(nt.uuid=_.uuid),_.name!==void 0&&(nt.name=_.name),_.color!==void 0&&nt.color!==void 0&&nt.color.setHex(_.color),_.roughness!==void 0&&(nt.roughness=_.roughness),_.metalness!==void 0&&(nt.metalness=_.metalness),_.sheen!==void 0&&(nt.sheen=_.sheen),_.sheenColor!==void 0&&(nt.sheenColor=new Color$1().setHex(_.sheenColor)),_.sheenRoughness!==void 0&&(nt.sheenRoughness=_.sheenRoughness),_.emissive!==void 0&&nt.emissive!==void 0&&nt.emissive.setHex(_.emissive),_.specular!==void 0&&nt.specular!==void 0&&nt.specular.setHex(_.specular),_.specularIntensity!==void 0&&(nt.specularIntensity=_.specularIntensity),_.specularColor!==void 0&&nt.specularColor!==void 0&&nt.specularColor.setHex(_.specularColor),_.shininess!==void 0&&(nt.shininess=_.shininess),_.clearcoat!==void 0&&(nt.clearcoat=_.clearcoat),_.clearcoatRoughness!==void 0&&(nt.clearcoatRoughness=_.clearcoatRoughness),_.dispersion!==void 0&&(nt.dispersion=_.dispersion),_.iridescence!==void 0&&(nt.iridescence=_.iridescence),_.iridescenceIOR!==void 0&&(nt.iridescenceIOR=_.iridescenceIOR),_.iridescenceThicknessRange!==void 0&&(nt.iridescenceThicknessRange=_.iridescenceThicknessRange),_.transmission!==void 0&&(nt.transmission=_.transmission),_.thickness!==void 0&&(nt.thickness=_.thickness),_.attenuationDistance!==void 0&&(nt.attenuationDistance=_.attenuationDistance),_.attenuationColor!==void 0&&nt.attenuationColor!==void 0&&nt.attenuationColor.setHex(_.attenuationColor),_.anisotropy!==void 0&&(nt.anisotropy=_.anisotropy),_.anisotropyRotation!==void 0&&(nt.anisotropyRotation=_.anisotropyRotation),_.fog!==void 0&&(nt.fog=_.fog),_.flatShading!==void 0&&(nt.flatShading=_.flatShading),_.blending!==void 0&&(nt.blending=_.blending),_.combine!==void 0&&(nt.combine=_.combine),_.side!==void 0&&(nt.side=_.side),_.shadowSide!==void 0&&(nt.shadowSide=_.shadowSide),_.opacity!==void 0&&(nt.opacity=_.opacity),_.transparent!==void 0&&(nt.transparent=_.transparent),_.alphaTest!==void 0&&(nt.alphaTest=_.alphaTest),_.alphaHash!==void 0&&(nt.alphaHash=_.alphaHash),_.depthFunc!==void 0&&(nt.depthFunc=_.depthFunc),_.depthTest!==void 0&&(nt.depthTest=_.depthTest),_.depthWrite!==void 0&&(nt.depthWrite=_.depthWrite),_.colorWrite!==void 0&&(nt.colorWrite=_.colorWrite),_.blendSrc!==void 0&&(nt.blendSrc=_.blendSrc),_.blendDst!==void 0&&(nt.blendDst=_.blendDst),_.blendEquation!==void 0&&(nt.blendEquation=_.blendEquation),_.blendSrcAlpha!==void 0&&(nt.blendSrcAlpha=_.blendSrcAlpha),_.blendDstAlpha!==void 0&&(nt.blendDstAlpha=_.blendDstAlpha),_.blendEquationAlpha!==void 0&&(nt.blendEquationAlpha=_.blendEquationAlpha),_.blendColor!==void 0&&nt.blendColor!==void 0&&nt.blendColor.setHex(_.blendColor),_.blendAlpha!==void 0&&(nt.blendAlpha=_.blendAlpha),_.stencilWriteMask!==void 0&&(nt.stencilWriteMask=_.stencilWriteMask),_.stencilFunc!==void 0&&(nt.stencilFunc=_.stencilFunc),_.stencilRef!==void 0&&(nt.stencilRef=_.stencilRef),_.stencilFuncMask!==void 0&&(nt.stencilFuncMask=_.stencilFuncMask),_.stencilFail!==void 0&&(nt.stencilFail=_.stencilFail),_.stencilZFail!==void 0&&(nt.stencilZFail=_.stencilZFail),_.stencilZPass!==void 0&&(nt.stencilZPass=_.stencilZPass),_.stencilWrite!==void 0&&(nt.stencilWrite=_.stencilWrite),_.wireframe!==void 0&&(nt.wireframe=_.wireframe),_.wireframeLinewidth!==void 0&&(nt.wireframeLinewidth=_.wireframeLinewidth),_.wireframeLinecap!==void 0&&(nt.wireframeLinecap=_.wireframeLinecap),_.wireframeLinejoin!==void 0&&(nt.wireframeLinejoin=_.wireframeLinejoin),_.rotation!==void 0&&(nt.rotation=_.rotation),_.linewidth!==void 0&&(nt.linewidth=_.linewidth),_.dashSize!==void 0&&(nt.dashSize=_.dashSize),_.gapSize!==void 0&&(nt.gapSize=_.gapSize),_.scale!==void 0&&(nt.scale=_.scale),_.polygonOffset!==void 0&&(nt.polygonOffset=_.polygonOffset),_.polygonOffsetFactor!==void 0&&(nt.polygonOffsetFactor=_.polygonOffsetFactor),_.polygonOffsetUnits!==void 0&&(nt.polygonOffsetUnits=_.polygonOffsetUnits),_.dithering!==void 0&&(nt.dithering=_.dithering),_.alphaToCoverage!==void 0&&(nt.alphaToCoverage=_.alphaToCoverage),_.premultipliedAlpha!==void 0&&(nt.premultipliedAlpha=_.premultipliedAlpha),_.forceSinglePass!==void 0&&(nt.forceSinglePass=_.forceSinglePass),_.visible!==void 0&&(nt.visible=_.visible),_.toneMapped!==void 0&&(nt.toneMapped=_.toneMapped),_.userData!==void 0&&(nt.userData=_.userData),_.vertexColors!==void 0&&(typeof _.vertexColors=="number"?nt.vertexColors=_.vertexColors>0:nt.vertexColors=_.vertexColors),_.uniforms!==void 0)for(const rt in _.uniforms){const ot=_.uniforms[rt];switch(nt.uniforms[rt]={},ot.type){case"t":nt.uniforms[rt].value=tt(ot.value);break;case"c":nt.uniforms[rt].value=new Color$1().setHex(ot.value);break;case"v2":nt.uniforms[rt].value=new Vector2().fromArray(ot.value);break;case"v3":nt.uniforms[rt].value=new Vector3().fromArray(ot.value);break;case"v4":nt.uniforms[rt].value=new Vector4().fromArray(ot.value);break;case"m3":nt.uniforms[rt].value=new Matrix3().fromArray(ot.value);break;case"m4":nt.uniforms[rt].value=new Matrix4().fromArray(ot.value);break;default:nt.uniforms[rt].value=ot.value}}if(_.defines!==void 0&&(nt.defines=_.defines),_.vertexShader!==void 0&&(nt.vertexShader=_.vertexShader),_.fragmentShader!==void 0&&(nt.fragmentShader=_.fragmentShader),_.glslVersion!==void 0&&(nt.glslVersion=_.glslVersion),_.extensions!==void 0)for(const rt in _.extensions)nt.extensions[rt]=_.extensions[rt];if(_.lights!==void 0&&(nt.lights=_.lights),_.clipping!==void 0&&(nt.clipping=_.clipping),_.size!==void 0&&(nt.size=_.size),_.sizeAttenuation!==void 0&&(nt.sizeAttenuation=_.sizeAttenuation),_.map!==void 0&&(nt.map=tt(_.map)),_.matcap!==void 0&&(nt.matcap=tt(_.matcap)),_.alphaMap!==void 0&&(nt.alphaMap=tt(_.alphaMap)),_.bumpMap!==void 0&&(nt.bumpMap=tt(_.bumpMap)),_.bumpScale!==void 0&&(nt.bumpScale=_.bumpScale),_.normalMap!==void 0&&(nt.normalMap=tt(_.normalMap)),_.normalMapType!==void 0&&(nt.normalMapType=_.normalMapType),_.normalScale!==void 0){let rt=_.normalScale;Array.isArray(rt)===!1&&(rt=[rt,rt]),nt.normalScale=new Vector2().fromArray(rt)}return _.displacementMap!==void 0&&(nt.displacementMap=tt(_.displacementMap)),_.displacementScale!==void 0&&(nt.displacementScale=_.displacementScale),_.displacementBias!==void 0&&(nt.displacementBias=_.displacementBias),_.roughnessMap!==void 0&&(nt.roughnessMap=tt(_.roughnessMap)),_.metalnessMap!==void 0&&(nt.metalnessMap=tt(_.metalnessMap)),_.emissiveMap!==void 0&&(nt.emissiveMap=tt(_.emissiveMap)),_.emissiveIntensity!==void 0&&(nt.emissiveIntensity=_.emissiveIntensity),_.specularMap!==void 0&&(nt.specularMap=tt(_.specularMap)),_.specularIntensityMap!==void 0&&(nt.specularIntensityMap=tt(_.specularIntensityMap)),_.specularColorMap!==void 0&&(nt.specularColorMap=tt(_.specularColorMap)),_.envMap!==void 0&&(nt.envMap=tt(_.envMap)),_.envMapRotation!==void 0&&nt.envMapRotation.fromArray(_.envMapRotation),_.envMapIntensity!==void 0&&(nt.envMapIntensity=_.envMapIntensity),_.reflectivity!==void 0&&(nt.reflectivity=_.reflectivity),_.refractionRatio!==void 0&&(nt.refractionRatio=_.refractionRatio),_.lightMap!==void 0&&(nt.lightMap=tt(_.lightMap)),_.lightMapIntensity!==void 0&&(nt.lightMapIntensity=_.lightMapIntensity),_.aoMap!==void 0&&(nt.aoMap=tt(_.aoMap)),_.aoMapIntensity!==void 0&&(nt.aoMapIntensity=_.aoMapIntensity),_.gradientMap!==void 0&&(nt.gradientMap=tt(_.gradientMap)),_.clearcoatMap!==void 0&&(nt.clearcoatMap=tt(_.clearcoatMap)),_.clearcoatRoughnessMap!==void 0&&(nt.clearcoatRoughnessMap=tt(_.clearcoatRoughnessMap)),_.clearcoatNormalMap!==void 0&&(nt.clearcoatNormalMap=tt(_.clearcoatNormalMap)),_.clearcoatNormalScale!==void 0&&(nt.clearcoatNormalScale=new Vector2().fromArray(_.clearcoatNormalScale)),_.iridescenceMap!==void 0&&(nt.iridescenceMap=tt(_.iridescenceMap)),_.iridescenceThicknessMap!==void 0&&(nt.iridescenceThicknessMap=tt(_.iridescenceThicknessMap)),_.transmissionMap!==void 0&&(nt.transmissionMap=tt(_.transmissionMap)),_.thicknessMap!==void 0&&(nt.thicknessMap=tt(_.thicknessMap)),_.anisotropyMap!==void 0&&(nt.anisotropyMap=tt(_.anisotropyMap)),_.sheenColorMap!==void 0&&(nt.sheenColorMap=tt(_.sheenColorMap)),_.sheenRoughnessMap!==void 0&&(nt.sheenRoughnessMap=tt(_.sheenRoughnessMap)),nt}setTextures(_){return this.textures=_,this}static createMaterialFromType(_){const _e={ShadowMaterial,SpriteMaterial,RawShaderMaterial,ShaderMaterial,PointsMaterial,MeshPhysicalMaterial,MeshStandardMaterial,MeshPhongMaterial,MeshToonMaterial,MeshNormalMaterial,MeshLambertMaterial,MeshDepthMaterial,MeshDistanceMaterial,MeshBasicMaterial,MeshMatcapMaterial,LineDashedMaterial,LineBasicMaterial,Material};return new _e[_]}}class LoaderUtils{static decodeText(_){if(console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."),typeof TextDecoder<"u")return new TextDecoder().decode(_);let _e="";for(let tt=0,nt=_.length;tt<nt;tt++)_e+=String.fromCharCode(_[tt]);try{return decodeURIComponent(escape(_e))}catch{return _e}}static extractUrlBase(_){const _e=_.lastIndexOf("/");return _e===-1?"./":_.slice(0,_e+1)}static resolveURL(_,_e){return typeof _!="string"||_===""?"":(/^https?:\/\//i.test(_e)&&/^\//.test(_)&&(_e=_e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(_)||/^data:.*,.*$/i.test(_)||/^blob:.*$/i.test(_)?_:_e+_)}}class InstancedBufferGeometry extends BufferGeometry{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(_){return super.copy(_),this.instanceCount=_.instanceCount,this}toJSON(){const _=super.toJSON();return _.instanceCount=this.instanceCount,_.isInstancedBufferGeometry=!0,_}}class BufferGeometryLoader extends Loader{constructor(_){super(_)}load(_,_e,tt,nt){const rt=this,ot=new FileLoader(rt.manager);ot.setPath(rt.path),ot.setRequestHeader(rt.requestHeader),ot.setWithCredentials(rt.withCredentials),ot.load(_,function(at){try{_e(rt.parse(JSON.parse(at)))}catch(lt){nt?nt(lt):console.error(lt),rt.manager.itemError(_)}},tt,nt)}parse(_){const _e={},tt={};function nt(ct,ft){if(_e[ft]!==void 0)return _e[ft];const mt=ct.interleavedBuffers[ft],pt=rt(ct,mt.buffer),_t=getTypedArray(mt.type,pt),vt=new InterleavedBuffer(_t,mt.stride);return vt.uuid=mt.uuid,_e[ft]=vt,vt}function rt(ct,ft){if(tt[ft]!==void 0)return tt[ft];const mt=ct.arrayBuffers[ft],pt=new Uint32Array(mt).buffer;return tt[ft]=pt,pt}const ot=_.isInstancedBufferGeometry?new InstancedBufferGeometry:new BufferGeometry,at=_.data.index;if(at!==void 0){const ct=getTypedArray(at.type,at.array);ot.setIndex(new BufferAttribute(ct,1))}const lt=_.data.attributes;for(const ct in lt){const ft=lt[ct];let ht;if(ft.isInterleavedBufferAttribute){const mt=nt(_.data,ft.data);ht=new InterleavedBufferAttribute(mt,ft.itemSize,ft.offset,ft.normalized)}else{const mt=getTypedArray(ft.type,ft.array),pt=ft.isInstancedBufferAttribute?InstancedBufferAttribute:BufferAttribute;ht=new pt(mt,ft.itemSize,ft.normalized)}ft.name!==void 0&&(ht.name=ft.name),ft.usage!==void 0&&ht.setUsage(ft.usage),ot.setAttribute(ct,ht)}const ut=_.data.morphAttributes;if(ut)for(const ct in ut){const ft=ut[ct],ht=[];for(let mt=0,pt=ft.length;mt<pt;mt++){const _t=ft[mt];let vt;if(_t.isInterleavedBufferAttribute){const bt=nt(_.data,_t.data);vt=new InterleavedBufferAttribute(bt,_t.itemSize,_t.offset,_t.normalized)}else{const bt=getTypedArray(_t.type,_t.array);vt=new BufferAttribute(bt,_t.itemSize,_t.normalized)}_t.name!==void 0&&(vt.name=_t.name),ht.push(vt)}ot.morphAttributes[ct]=ht}_.data.morphTargetsRelative&&(ot.morphTargetsRelative=!0);const st=_.data.groups||_.data.drawcalls||_.data.offsets;if(st!==void 0)for(let ct=0,ft=st.length;ct!==ft;++ct){const ht=st[ct];ot.addGroup(ht.start,ht.count,ht.materialIndex)}const it=_.data.boundingSphere;if(it!==void 0){const ct=new Vector3;it.center!==void 0&&ct.fromArray(it.center),ot.boundingSphere=new Sphere(ct,it.radius)}return _.name&&(ot.name=_.name),_.userData&&(ot.userData=_.userData),ot}}class ObjectLoader extends Loader{constructor(_){super(_)}load(_,_e,tt,nt){const rt=this,ot=this.path===""?LoaderUtils.extractUrlBase(_):this.path;this.resourcePath=this.resourcePath||ot;const at=new FileLoader(this.manager);at.setPath(this.path),at.setRequestHeader(this.requestHeader),at.setWithCredentials(this.withCredentials),at.load(_,function(lt){let ut=null;try{ut=JSON.parse(lt)}catch(st){nt!==void 0&&nt(st),console.error("THREE:ObjectLoader: Can't parse "+_+".",st.message);return}const dt=ut.metadata;if(dt===void 0||dt.type===void 0||dt.type.toLowerCase()==="geometry"){nt!==void 0&&nt(new Error("THREE.ObjectLoader: Can't load "+_)),console.error("THREE.ObjectLoader: Can't load "+_);return}rt.parse(ut,_e)},tt,nt)}async loadAsync(_,_e){const tt=this,nt=this.path===""?LoaderUtils.extractUrlBase(_):this.path;this.resourcePath=this.resourcePath||nt;const rt=new FileLoader(this.manager);rt.setPath(this.path),rt.setRequestHeader(this.requestHeader),rt.setWithCredentials(this.withCredentials);const ot=await rt.loadAsync(_,_e),at=JSON.parse(ot),lt=at.metadata;if(lt===void 0||lt.type===void 0||lt.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+_);return await tt.parseAsync(at)}parse(_,_e){const tt=this.parseAnimations(_.animations),nt=this.parseShapes(_.shapes),rt=this.parseGeometries(_.geometries,nt),ot=this.parseImages(_.images,function(){_e!==void 0&&_e(ut)}),at=this.parseTextures(_.textures,ot),lt=this.parseMaterials(_.materials,at),ut=this.parseObject(_.object,rt,lt,at,tt),dt=this.parseSkeletons(_.skeletons,ut);if(this.bindSkeletons(ut,dt),this.bindLightTargets(ut),_e!==void 0){let st=!1;for(const it in ot)if(ot[it].data instanceof HTMLImageElement){st=!0;break}st===!1&&_e(ut)}return ut}async parseAsync(_){const _e=this.parseAnimations(_.animations),tt=this.parseShapes(_.shapes),nt=this.parseGeometries(_.geometries,tt),rt=await this.parseImagesAsync(_.images),ot=this.parseTextures(_.textures,rt),at=this.parseMaterials(_.materials,ot),lt=this.parseObject(_.object,nt,at,ot,_e),ut=this.parseSkeletons(_.skeletons,lt);return this.bindSkeletons(lt,ut),this.bindLightTargets(lt),lt}parseShapes(_){const _e={};if(_!==void 0)for(let tt=0,nt=_.length;tt<nt;tt++){const rt=new Shape().fromJSON(_[tt]);_e[rt.uuid]=rt}return _e}parseSkeletons(_,_e){const tt={},nt={};if(_e.traverse(function(rt){rt.isBone&&(nt[rt.uuid]=rt)}),_!==void 0)for(let rt=0,ot=_.length;rt<ot;rt++){const at=new Skeleton().fromJSON(_[rt],nt);tt[at.uuid]=at}return tt}parseGeometries(_,_e){const tt={};if(_!==void 0){const nt=new BufferGeometryLoader;for(let rt=0,ot=_.length;rt<ot;rt++){let at;const lt=_[rt];switch(lt.type){case"BufferGeometry":case"InstancedBufferGeometry":at=nt.parse(lt);break;default:lt.type in Geometries?at=Geometries[lt.type].fromJSON(lt,_e):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${lt.type}"`)}at.uuid=lt.uuid,lt.name!==void 0&&(at.name=lt.name),lt.userData!==void 0&&(at.userData=lt.userData),tt[lt.uuid]=at}}return tt}parseMaterials(_,_e){const tt={},nt={};if(_!==void 0){const rt=new MaterialLoader;rt.setTextures(_e);for(let ot=0,at=_.length;ot<at;ot++){const lt=_[ot];tt[lt.uuid]===void 0&&(tt[lt.uuid]=rt.parse(lt)),nt[lt.uuid]=tt[lt.uuid]}}return nt}parseAnimations(_){const _e={};if(_!==void 0)for(let tt=0;tt<_.length;tt++){const nt=_[tt],rt=AnimationClip.parse(nt);_e[rt.uuid]=rt}return _e}parseImages(_,_e){const tt=this,nt={};let rt;function ot(lt){return tt.manager.itemStart(lt),rt.load(lt,function(){tt.manager.itemEnd(lt)},void 0,function(){tt.manager.itemError(lt),tt.manager.itemEnd(lt)})}function at(lt){if(typeof lt=="string"){const ut=lt,dt=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(ut)?ut:tt.resourcePath+ut;return ot(dt)}else return lt.data?{data:getTypedArray(lt.type,lt.data),width:lt.width,height:lt.height}:null}if(_!==void 0&&_.length>0){const lt=new LoadingManager(_e);rt=new ImageLoader(lt),rt.setCrossOrigin(this.crossOrigin);for(let ut=0,dt=_.length;ut<dt;ut++){const st=_[ut],it=st.url;if(Array.isArray(it)){const ct=[];for(let ft=0,ht=it.length;ft<ht;ft++){const mt=it[ft],pt=at(mt);pt!==null&&(pt instanceof HTMLImageElement?ct.push(pt):ct.push(new DataTexture(pt.data,pt.width,pt.height)))}nt[st.uuid]=new Source(ct)}else{const ct=at(st.url);nt[st.uuid]=new Source(ct)}}}return nt}async parseImagesAsync(_){const _e=this,tt={};let nt;async function rt(ot){if(typeof ot=="string"){const at=ot,lt=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(at)?at:_e.resourcePath+at;return await nt.loadAsync(lt)}else return ot.data?{data:getTypedArray(ot.type,ot.data),width:ot.width,height:ot.height}:null}if(_!==void 0&&_.length>0){nt=new ImageLoader(this.manager),nt.setCrossOrigin(this.crossOrigin);for(let ot=0,at=_.length;ot<at;ot++){const lt=_[ot],ut=lt.url;if(Array.isArray(ut)){const dt=[];for(let st=0,it=ut.length;st<it;st++){const ct=ut[st],ft=await rt(ct);ft!==null&&(ft instanceof HTMLImageElement?dt.push(ft):dt.push(new DataTexture(ft.data,ft.width,ft.height)))}tt[lt.uuid]=new Source(dt)}else{const dt=await rt(lt.url);tt[lt.uuid]=new Source(dt)}}}return tt}parseTextures(_,_e){function tt(rt,ot){return typeof rt=="number"?rt:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",rt),ot[rt])}const nt={};if(_!==void 0)for(let rt=0,ot=_.length;rt<ot;rt++){const at=_[rt];at.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',at.uuid),_e[at.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",at.image);const lt=_e[at.image],ut=lt.data;let dt;Array.isArray(ut)?(dt=new CubeTexture,ut.length===6&&(dt.needsUpdate=!0)):(ut&&ut.data?dt=new DataTexture:dt=new Texture,ut&&(dt.needsUpdate=!0)),dt.source=lt,dt.uuid=at.uuid,at.name!==void 0&&(dt.name=at.name),at.mapping!==void 0&&(dt.mapping=tt(at.mapping,TEXTURE_MAPPING)),at.channel!==void 0&&(dt.channel=at.channel),at.offset!==void 0&&dt.offset.fromArray(at.offset),at.repeat!==void 0&&dt.repeat.fromArray(at.repeat),at.center!==void 0&&dt.center.fromArray(at.center),at.rotation!==void 0&&(dt.rotation=at.rotation),at.wrap!==void 0&&(dt.wrapS=tt(at.wrap[0],TEXTURE_WRAPPING),dt.wrapT=tt(at.wrap[1],TEXTURE_WRAPPING)),at.format!==void 0&&(dt.format=at.format),at.internalFormat!==void 0&&(dt.internalFormat=at.internalFormat),at.type!==void 0&&(dt.type=at.type),at.colorSpace!==void 0&&(dt.colorSpace=at.colorSpace),at.minFilter!==void 0&&(dt.minFilter=tt(at.minFilter,TEXTURE_FILTER)),at.magFilter!==void 0&&(dt.magFilter=tt(at.magFilter,TEXTURE_FILTER)),at.anisotropy!==void 0&&(dt.anisotropy=at.anisotropy),at.flipY!==void 0&&(dt.flipY=at.flipY),at.generateMipmaps!==void 0&&(dt.generateMipmaps=at.generateMipmaps),at.premultiplyAlpha!==void 0&&(dt.premultiplyAlpha=at.premultiplyAlpha),at.unpackAlignment!==void 0&&(dt.unpackAlignment=at.unpackAlignment),at.compareFunction!==void 0&&(dt.compareFunction=at.compareFunction),at.userData!==void 0&&(dt.userData=at.userData),nt[at.uuid]=dt}return nt}parseObject(_,_e,tt,nt,rt){let ot;function at(it){return _e[it]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",it),_e[it]}function lt(it){if(it!==void 0){if(Array.isArray(it)){const ct=[];for(let ft=0,ht=it.length;ft<ht;ft++){const mt=it[ft];tt[mt]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",mt),ct.push(tt[mt])}return ct}return tt[it]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",it),tt[it]}}function ut(it){return nt[it]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",it),nt[it]}let dt,st;switch(_.type){case"Scene":ot=new Scene$1,_.background!==void 0&&(Number.isInteger(_.background)?ot.background=new Color$1(_.background):ot.background=ut(_.background)),_.environment!==void 0&&(ot.environment=ut(_.environment)),_.fog!==void 0&&(_.fog.type==="Fog"?ot.fog=new Fog(_.fog.color,_.fog.near,_.fog.far):_.fog.type==="FogExp2"&&(ot.fog=new FogExp2(_.fog.color,_.fog.density)),_.fog.name!==""&&(ot.fog.name=_.fog.name)),_.backgroundBlurriness!==void 0&&(ot.backgroundBlurriness=_.backgroundBlurriness),_.backgroundIntensity!==void 0&&(ot.backgroundIntensity=_.backgroundIntensity),_.backgroundRotation!==void 0&&ot.backgroundRotation.fromArray(_.backgroundRotation),_.environmentIntensity!==void 0&&(ot.environmentIntensity=_.environmentIntensity),_.environmentRotation!==void 0&&ot.environmentRotation.fromArray(_.environmentRotation);break;case"PerspectiveCamera":ot=new PerspectiveCamera(_.fov,_.aspect,_.near,_.far),_.focus!==void 0&&(ot.focus=_.focus),_.zoom!==void 0&&(ot.zoom=_.zoom),_.filmGauge!==void 0&&(ot.filmGauge=_.filmGauge),_.filmOffset!==void 0&&(ot.filmOffset=_.filmOffset),_.view!==void 0&&(ot.view=Object.assign({},_.view));break;case"OrthographicCamera":ot=new OrthographicCamera$1(_.left,_.right,_.top,_.bottom,_.near,_.far),_.zoom!==void 0&&(ot.zoom=_.zoom),_.view!==void 0&&(ot.view=Object.assign({},_.view));break;case"AmbientLight":ot=new AmbientLight(_.color,_.intensity);break;case"DirectionalLight":ot=new DirectionalLight(_.color,_.intensity),ot.target=_.target||"";break;case"PointLight":ot=new PointLight(_.color,_.intensity,_.distance,_.decay);break;case"RectAreaLight":ot=new RectAreaLight(_.color,_.intensity,_.width,_.height);break;case"SpotLight":ot=new SpotLight(_.color,_.intensity,_.distance,_.angle,_.penumbra,_.decay),ot.target=_.target||"";break;case"HemisphereLight":ot=new HemisphereLight(_.color,_.groundColor,_.intensity);break;case"LightProbe":ot=new LightProbe().fromJSON(_);break;case"SkinnedMesh":dt=at(_.geometry),st=lt(_.material),ot=new SkinnedMesh(dt,st),_.bindMode!==void 0&&(ot.bindMode=_.bindMode),_.bindMatrix!==void 0&&ot.bindMatrix.fromArray(_.bindMatrix),_.skeleton!==void 0&&(ot.skeleton=_.skeleton);break;case"Mesh":dt=at(_.geometry),st=lt(_.material),ot=new Mesh(dt,st);break;case"InstancedMesh":dt=at(_.geometry),st=lt(_.material);const it=_.count,ct=_.instanceMatrix,ft=_.instanceColor;ot=new InstancedMesh(dt,st,it),ot.instanceMatrix=new InstancedBufferAttribute(new Float32Array(ct.array),16),ft!==void 0&&(ot.instanceColor=new InstancedBufferAttribute(new Float32Array(ft.array),ft.itemSize));break;case"BatchedMesh":dt=at(_.geometry),st=lt(_.material),ot=new BatchedMesh(_.maxInstanceCount,_.maxVertexCount,_.maxIndexCount,st),ot.geometry=dt,ot.perObjectFrustumCulled=_.perObjectFrustumCulled,ot.sortObjects=_.sortObjects,ot._drawRanges=_.drawRanges,ot._reservedRanges=_.reservedRanges,ot._visibility=_.visibility,ot._active=_.active,ot._bounds=_.bounds.map(ht=>{const mt=new Box3;mt.min.fromArray(ht.boxMin),mt.max.fromArray(ht.boxMax);const pt=new Sphere;return pt.radius=ht.sphereRadius,pt.center.fromArray(ht.sphereCenter),{boxInitialized:ht.boxInitialized,box:mt,sphereInitialized:ht.sphereInitialized,sphere:pt}}),ot._maxInstanceCount=_.maxInstanceCount,ot._maxVertexCount=_.maxVertexCount,ot._maxIndexCount=_.maxIndexCount,ot._geometryInitialized=_.geometryInitialized,ot._geometryCount=_.geometryCount,ot._matricesTexture=ut(_.matricesTexture.uuid),_.colorsTexture!==void 0&&(ot._colorsTexture=ut(_.colorsTexture.uuid));break;case"LOD":ot=new LOD;break;case"Line":ot=new Line(at(_.geometry),lt(_.material));break;case"LineLoop":ot=new LineLoop(at(_.geometry),lt(_.material));break;case"LineSegments":ot=new LineSegments(at(_.geometry),lt(_.material));break;case"PointCloud":case"Points":ot=new Points(at(_.geometry),lt(_.material));break;case"Sprite":ot=new Sprite(lt(_.material));break;case"Group":ot=new Group;break;case"Bone":ot=new Bone;break;default:ot=new Object3D}if(ot.uuid=_.uuid,_.name!==void 0&&(ot.name=_.name),_.matrix!==void 0?(ot.matrix.fromArray(_.matrix),_.matrixAutoUpdate!==void 0&&(ot.matrixAutoUpdate=_.matrixAutoUpdate),ot.matrixAutoUpdate&&ot.matrix.decompose(ot.position,ot.quaternion,ot.scale)):(_.position!==void 0&&ot.position.fromArray(_.position),_.rotation!==void 0&&ot.rotation.fromArray(_.rotation),_.quaternion!==void 0&&ot.quaternion.fromArray(_.quaternion),_.scale!==void 0&&ot.scale.fromArray(_.scale)),_.up!==void 0&&ot.up.fromArray(_.up),_.castShadow!==void 0&&(ot.castShadow=_.castShadow),_.receiveShadow!==void 0&&(ot.receiveShadow=_.receiveShadow),_.shadow&&(_.shadow.intensity!==void 0&&(ot.shadow.intensity=_.shadow.intensity),_.shadow.bias!==void 0&&(ot.shadow.bias=_.shadow.bias),_.shadow.normalBias!==void 0&&(ot.shadow.normalBias=_.shadow.normalBias),_.shadow.radius!==void 0&&(ot.shadow.radius=_.shadow.radius),_.shadow.mapSize!==void 0&&ot.shadow.mapSize.fromArray(_.shadow.mapSize),_.shadow.camera!==void 0&&(ot.shadow.camera=this.parseObject(_.shadow.camera))),_.visible!==void 0&&(ot.visible=_.visible),_.frustumCulled!==void 0&&(ot.frustumCulled=_.frustumCulled),_.renderOrder!==void 0&&(ot.renderOrder=_.renderOrder),_.userData!==void 0&&(ot.userData=_.userData),_.layers!==void 0&&(ot.layers.mask=_.layers),_.children!==void 0){const it=_.children;for(let ct=0;ct<it.length;ct++)ot.add(this.parseObject(it[ct],_e,tt,nt,rt))}if(_.animations!==void 0){const it=_.animations;for(let ct=0;ct<it.length;ct++){const ft=it[ct];ot.animations.push(rt[ft])}}if(_.type==="LOD"){_.autoUpdate!==void 0&&(ot.autoUpdate=_.autoUpdate);const it=_.levels;for(let ct=0;ct<it.length;ct++){const ft=it[ct],ht=ot.getObjectByProperty("uuid",ft.object);ht!==void 0&&ot.addLevel(ht,ft.distance,ft.hysteresis)}}return ot}bindSkeletons(_,_e){Object.keys(_e).length!==0&&_.traverse(function(tt){if(tt.isSkinnedMesh===!0&&tt.skeleton!==void 0){const nt=_e[tt.skeleton];nt===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",tt.skeleton):tt.bind(nt,tt.bindMatrix)}})}bindLightTargets(_){_.traverse(function(_e){if(_e.isDirectionalLight||_e.isSpotLight){const tt=_e.target,nt=_.getObjectByProperty("uuid",tt);nt!==void 0?_e.target=nt:_e.target=new Object3D}})}}const TEXTURE_MAPPING={UVMapping,CubeReflectionMapping,CubeRefractionMapping,EquirectangularReflectionMapping,EquirectangularRefractionMapping,CubeUVReflectionMapping},TEXTURE_WRAPPING={RepeatWrapping,ClampToEdgeWrapping,MirroredRepeatWrapping},TEXTURE_FILTER={NearestFilter,NearestMipmapNearestFilter,NearestMipmapLinearFilter,LinearFilter,LinearMipmapNearestFilter,LinearMipmapLinearFilter};class ImageBitmapLoader extends Loader{constructor(_){super(_),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(_){return this.options=_,this}load(_,_e,tt,nt){_===void 0&&(_=""),this.path!==void 0&&(_=this.path+_),_=this.manager.resolveURL(_);const rt=this,ot=Cache.get(_);if(ot!==void 0){if(rt.manager.itemStart(_),ot.then){ot.then(ut=>{_e&&_e(ut),rt.manager.itemEnd(_)}).catch(ut=>{nt&&nt(ut)});return}return setTimeout(function(){_e&&_e(ot),rt.manager.itemEnd(_)},0),ot}const at={};at.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",at.headers=this.requestHeader;const lt=fetch(_,at).then(function(ut){return ut.blob()}).then(function(ut){return createImageBitmap(ut,Object.assign(rt.options,{colorSpaceConversion:"none"}))}).then(function(ut){return Cache.add(_,ut),_e&&_e(ut),rt.manager.itemEnd(_),ut}).catch(function(ut){nt&&nt(ut),Cache.remove(_),rt.manager.itemError(_),rt.manager.itemEnd(_)});Cache.add(_,lt),rt.manager.itemStart(_)}}let _context,AudioContext$1=class{static getContext(){return _context===void 0&&(_context=new(window.AudioContext||window.webkitAudioContext)),_context}static setContext(_){_context=_}};class AudioLoader extends Loader{constructor(_){super(_)}load(_,_e,tt,nt){const rt=this,ot=new FileLoader(this.manager);ot.setResponseType("arraybuffer"),ot.setPath(this.path),ot.setRequestHeader(this.requestHeader),ot.setWithCredentials(this.withCredentials),ot.load(_,function(lt){try{const ut=lt.slice(0);AudioContext$1.getContext().decodeAudioData(ut,function(st){_e(st)}).catch(at)}catch(ut){at(ut)}},tt,nt);function at(lt){nt?nt(lt):console.error(lt),rt.manager.itemError(_)}}}const _eyeRight=new Matrix4,_eyeLeft=new Matrix4,_projectionMatrix=new Matrix4;class StereoCamera{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new PerspectiveCamera,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new PerspectiveCamera,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(_){const _e=this._cache;if(_e.focus!==_.focus||_e.fov!==_.fov||_e.aspect!==_.aspect*this.aspect||_e.near!==_.near||_e.far!==_.far||_e.zoom!==_.zoom||_e.eyeSep!==this.eyeSep){_e.focus=_.focus,_e.fov=_.fov,_e.aspect=_.aspect*this.aspect,_e.near=_.near,_e.far=_.far,_e.zoom=_.zoom,_e.eyeSep=this.eyeSep,_projectionMatrix.copy(_.projectionMatrix);const nt=_e.eyeSep/2,rt=nt*_e.near/_e.focus,ot=_e.near*Math.tan(DEG2RAD*_e.fov*.5)/_e.zoom;let at,lt;_eyeLeft.elements[12]=-nt,_eyeRight.elements[12]=nt,at=-ot*_e.aspect+rt,lt=ot*_e.aspect+rt,_projectionMatrix.elements[0]=2*_e.near/(lt-at),_projectionMatrix.elements[8]=(lt+at)/(lt-at),this.cameraL.projectionMatrix.copy(_projectionMatrix),at=-ot*_e.aspect-rt,lt=ot*_e.aspect-rt,_projectionMatrix.elements[0]=2*_e.near/(lt-at),_projectionMatrix.elements[8]=(lt+at)/(lt-at),this.cameraR.projectionMatrix.copy(_projectionMatrix)}this.cameraL.matrixWorld.copy(_.matrixWorld).multiply(_eyeLeft),this.cameraR.matrixWorld.copy(_.matrixWorld).multiply(_eyeRight)}}class Clock{constructor(_=!0){this.autoStart=_,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=now$1(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let _=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const _e=now$1();_=(_e-this.oldTime)/1e3,this.oldTime=_e,this.elapsedTime+=_}return _}}function now$1(){return(typeof performance>"u"?Date:performance).now()}const _position$1=new Vector3,_quaternion$1=new Quaternion,_scale$1=new Vector3,_orientation$1=new Vector3;class AudioListener extends Object3D{constructor(){super(),this.type="AudioListener",this.context=AudioContext$1.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Clock}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(_){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=_,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(_){return this.gain.gain.setTargetAtTime(_,this.context.currentTime,.01),this}updateMatrixWorld(_){super.updateMatrixWorld(_);const _e=this.context.listener,tt=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(_position$1,_quaternion$1,_scale$1),_orientation$1.set(0,0,-1).applyQuaternion(_quaternion$1),_e.positionX){const nt=this.context.currentTime+this.timeDelta;_e.positionX.linearRampToValueAtTime(_position$1.x,nt),_e.positionY.linearRampToValueAtTime(_position$1.y,nt),_e.positionZ.linearRampToValueAtTime(_position$1.z,nt),_e.forwardX.linearRampToValueAtTime(_orientation$1.x,nt),_e.forwardY.linearRampToValueAtTime(_orientation$1.y,nt),_e.forwardZ.linearRampToValueAtTime(_orientation$1.z,nt),_e.upX.linearRampToValueAtTime(tt.x,nt),_e.upY.linearRampToValueAtTime(tt.y,nt),_e.upZ.linearRampToValueAtTime(tt.z,nt)}else _e.setPosition(_position$1.x,_position$1.y,_position$1.z),_e.setOrientation(_orientation$1.x,_orientation$1.y,_orientation$1.z,tt.x,tt.y,tt.z)}}class Audio extends Object3D{constructor(_){super(),this.type="Audio",this.listener=_,this.context=_.context,this.gain=this.context.createGain(),this.gain.connect(_.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(_){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=_,this.connect(),this}setMediaElementSource(_){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(_),this.connect(),this}setMediaStreamSource(_){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(_),this.connect(),this}setBuffer(_){return this.buffer=_,this.sourceType="buffer",this.autoplay&&this.play(),this}play(_=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+_;const _e=this.context.createBufferSource();return _e.buffer=this.buffer,_e.loop=this.loop,_e.loopStart=this.loopStart,_e.loopEnd=this.loopEnd,_e.onended=this.onEnded.bind(this),_e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=_e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let _=1,_e=this.filters.length;_<_e;_++)this.filters[_-1].connect(this.filters[_]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this._connected!==!1){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let _=1,_e=this.filters.length;_<_e;_++)this.filters[_-1].disconnect(this.filters[_]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(_){return _||(_=[]),this._connected===!0?(this.disconnect(),this.filters=_.slice(),this.connect()):this.filters=_.slice(),this}setDetune(_){return this.detune=_,this.isPlaying===!0&&this.source.detune!==void 0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(_){return this.setFilters(_?[_]:[])}setPlaybackRate(_){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=_,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(_){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=_,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(_){return this.loopStart=_,this}setLoopEnd(_){return this.loopEnd=_,this}getVolume(){return this.gain.gain.value}setVolume(_){return this.gain.gain.setTargetAtTime(_,this.context.currentTime,.01),this}}const _position$4=new Vector3,_quaternion=new Quaternion,_scale=new Vector3,_orientation=new Vector3;class PositionalAudio extends Audio{constructor(_){super(_),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){super.connect(),this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(_){return this.panner.refDistance=_,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(_){return this.panner.rolloffFactor=_,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(_){return this.panner.distanceModel=_,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(_){return this.panner.maxDistance=_,this}setDirectionalCone(_,_e,tt){return this.panner.coneInnerAngle=_,this.panner.coneOuterAngle=_e,this.panner.coneOuterGain=tt,this}updateMatrixWorld(_){if(super.updateMatrixWorld(_),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(_position$4,_quaternion,_scale),_orientation.set(0,0,1).applyQuaternion(_quaternion);const _e=this.panner;if(_e.positionX){const tt=this.context.currentTime+this.listener.timeDelta;_e.positionX.linearRampToValueAtTime(_position$4.x,tt),_e.positionY.linearRampToValueAtTime(_position$4.y,tt),_e.positionZ.linearRampToValueAtTime(_position$4.z,tt),_e.orientationX.linearRampToValueAtTime(_orientation.x,tt),_e.orientationY.linearRampToValueAtTime(_orientation.y,tt),_e.orientationZ.linearRampToValueAtTime(_orientation.z,tt)}else _e.setPosition(_position$4.x,_position$4.y,_position$4.z),_e.setOrientation(_orientation.x,_orientation.y,_orientation.z)}}class AudioAnalyser{constructor(_,_e=2048){this.analyser=_.context.createAnalyser(),this.analyser.fftSize=_e,this.data=new Uint8Array(this.analyser.frequencyBinCount),_.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let _=0;const _e=this.getFrequencyData();for(let tt=0;tt<_e.length;tt++)_+=_e[tt];return _/_e.length}}class PropertyMixer{constructor(_,_e,tt){this.binding=_,this.valueSize=tt;let nt,rt,ot;switch(_e){case"quaternion":nt=this._slerp,rt=this._slerpAdditive,ot=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(tt*6),this._workIndex=5;break;case"string":case"bool":nt=this._select,rt=this._select,ot=this._setAdditiveIdentityOther,this.buffer=new Array(tt*5);break;default:nt=this._lerp,rt=this._lerpAdditive,ot=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(tt*5)}this._mixBufferRegion=nt,this._mixBufferRegionAdditive=rt,this._setIdentity=ot,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(_,_e){const tt=this.buffer,nt=this.valueSize,rt=_*nt+nt;let ot=this.cumulativeWeight;if(ot===0){for(let at=0;at!==nt;++at)tt[rt+at]=tt[at];ot=_e}else{ot+=_e;const at=_e/ot;this._mixBufferRegion(tt,rt,0,at,nt)}this.cumulativeWeight=ot}accumulateAdditive(_){const _e=this.buffer,tt=this.valueSize,nt=tt*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(_e,nt,0,_,tt),this.cumulativeWeightAdditive+=_}apply(_){const _e=this.valueSize,tt=this.buffer,nt=_*_e+_e,rt=this.cumulativeWeight,ot=this.cumulativeWeightAdditive,at=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,rt<1){const lt=_e*this._origIndex;this._mixBufferRegion(tt,nt,lt,1-rt,_e)}ot>0&&this._mixBufferRegionAdditive(tt,nt,this._addIndex*_e,1,_e);for(let lt=_e,ut=_e+_e;lt!==ut;++lt)if(tt[lt]!==tt[lt+_e]){at.setValue(tt,nt);break}}saveOriginalState(){const _=this.binding,_e=this.buffer,tt=this.valueSize,nt=tt*this._origIndex;_.getValue(_e,nt);for(let rt=tt,ot=nt;rt!==ot;++rt)_e[rt]=_e[nt+rt%tt];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const _=this.valueSize*3;this.binding.setValue(this.buffer,_)}_setAdditiveIdentityNumeric(){const _=this._addIndex*this.valueSize,_e=_+this.valueSize;for(let tt=_;tt<_e;tt++)this.buffer[tt]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const _=this._origIndex*this.valueSize,_e=this._addIndex*this.valueSize;for(let tt=0;tt<this.valueSize;tt++)this.buffer[_e+tt]=this.buffer[_+tt]}_select(_,_e,tt,nt,rt){if(nt>=.5)for(let ot=0;ot!==rt;++ot)_[_e+ot]=_[tt+ot]}_slerp(_,_e,tt,nt){Quaternion.slerpFlat(_,_e,_,_e,_,tt,nt)}_slerpAdditive(_,_e,tt,nt,rt){const ot=this._workIndex*rt;Quaternion.multiplyQuaternionsFlat(_,ot,_,_e,_,tt),Quaternion.slerpFlat(_,_e,_,_e,_,ot,nt)}_lerp(_,_e,tt,nt,rt){const ot=1-nt;for(let at=0;at!==rt;++at){const lt=_e+at;_[lt]=_[lt]*ot+_[tt+at]*nt}}_lerpAdditive(_,_e,tt,nt,rt){for(let ot=0;ot!==rt;++ot){const at=_e+ot;_[at]=_[at]+_[tt+ot]*nt}}}const _RESERVED_CHARS_RE="\\[\\]\\.:\\/",_reservedRe=new RegExp("["+_RESERVED_CHARS_RE+"]","g"),_wordChar="[^"+_RESERVED_CHARS_RE+"]",_wordCharOrDot="[^"+_RESERVED_CHARS_RE.replace("\\.","")+"]",_directoryRe=/((?:WC+[\/:])*)/.source.replace("WC",_wordChar),_nodeRe=/(WCOD+)?/.source.replace("WCOD",_wordCharOrDot),_objectRe=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",_wordChar),_propertyRe=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",_wordChar),_trackRe=new RegExp("^"+_directoryRe+_nodeRe+_objectRe+_propertyRe+"$"),_supportedObjectNames=["material","materials","bones","map"];class Composite{constructor(_,_e,tt){const nt=tt||PropertyBinding.parseTrackName(_e);this._targetGroup=_,this._bindings=_.subscribe_(_e,nt)}getValue(_,_e){this.bind();const tt=this._targetGroup.nCachedObjects_,nt=this._bindings[tt];nt!==void 0&&nt.getValue(_,_e)}setValue(_,_e){const tt=this._bindings;for(let nt=this._targetGroup.nCachedObjects_,rt=tt.length;nt!==rt;++nt)tt[nt].setValue(_,_e)}bind(){const _=this._bindings;for(let _e=this._targetGroup.nCachedObjects_,tt=_.length;_e!==tt;++_e)_[_e].bind()}unbind(){const _=this._bindings;for(let _e=this._targetGroup.nCachedObjects_,tt=_.length;_e!==tt;++_e)_[_e].unbind()}}class PropertyBinding{constructor(_,_e,tt){this.path=_e,this.parsedPath=tt||PropertyBinding.parseTrackName(_e),this.node=PropertyBinding.findNode(_,this.parsedPath.nodeName),this.rootNode=_,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(_,_e,tt){return _&&_.isAnimationObjectGroup?new PropertyBinding.Composite(_,_e,tt):new PropertyBinding(_,_e,tt)}static sanitizeNodeName(_){return _.replace(/\s/g,"_").replace(_reservedRe,"")}static parseTrackName(_){const _e=_trackRe.exec(_);if(_e===null)throw new Error("PropertyBinding: Cannot parse trackName: "+_);const tt={nodeName:_e[2],objectName:_e[3],objectIndex:_e[4],propertyName:_e[5],propertyIndex:_e[6]},nt=tt.nodeName&&tt.nodeName.lastIndexOf(".");if(nt!==void 0&&nt!==-1){const rt=tt.nodeName.substring(nt+1);_supportedObjectNames.indexOf(rt)!==-1&&(tt.nodeName=tt.nodeName.substring(0,nt),tt.objectName=rt)}if(tt.propertyName===null||tt.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+_);return tt}static findNode(_,_e){if(_e===void 0||_e===""||_e==="."||_e===-1||_e===_.name||_e===_.uuid)return _;if(_.skeleton){const tt=_.skeleton.getBoneByName(_e);if(tt!==void 0)return tt}if(_.children){const tt=function(rt){for(let ot=0;ot<rt.length;ot++){const at=rt[ot];if(at.name===_e||at.uuid===_e)return at;const lt=tt(at.children);if(lt)return lt}return null},nt=tt(_.children);if(nt)return nt}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(_,_e){_[_e]=this.targetObject[this.propertyName]}_getValue_array(_,_e){const tt=this.resolvedProperty;for(let nt=0,rt=tt.length;nt!==rt;++nt)_[_e++]=tt[nt]}_getValue_arrayElement(_,_e){_[_e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(_,_e){this.resolvedProperty.toArray(_,_e)}_setValue_direct(_,_e){this.targetObject[this.propertyName]=_[_e]}_setValue_direct_setNeedsUpdate(_,_e){this.targetObject[this.propertyName]=_[_e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(_,_e){this.targetObject[this.propertyName]=_[_e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(_,_e){const tt=this.resolvedProperty;for(let nt=0,rt=tt.length;nt!==rt;++nt)tt[nt]=_[_e++]}_setValue_array_setNeedsUpdate(_,_e){const tt=this.resolvedProperty;for(let nt=0,rt=tt.length;nt!==rt;++nt)tt[nt]=_[_e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(_,_e){const tt=this.resolvedProperty;for(let nt=0,rt=tt.length;nt!==rt;++nt)tt[nt]=_[_e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(_,_e){this.resolvedProperty[this.propertyIndex]=_[_e]}_setValue_arrayElement_setNeedsUpdate(_,_e){this.resolvedProperty[this.propertyIndex]=_[_e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(_,_e){this.resolvedProperty[this.propertyIndex]=_[_e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(_,_e){this.resolvedProperty.fromArray(_,_e)}_setValue_fromArray_setNeedsUpdate(_,_e){this.resolvedProperty.fromArray(_,_e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(_,_e){this.resolvedProperty.fromArray(_,_e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(_,_e){this.bind(),this.getValue(_,_e)}_setValue_unbound(_,_e){this.bind(),this.setValue(_,_e)}bind(){let _=this.node;const _e=this.parsedPath,tt=_e.objectName,nt=_e.propertyName;let rt=_e.propertyIndex;if(_||(_=PropertyBinding.findNode(this.rootNode,_e.nodeName),this.node=_),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!_){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(tt){let ut=_e.objectIndex;switch(tt){case"materials":if(!_.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!_.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}_=_.material.materials;break;case"bones":if(!_.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}_=_.skeleton.bones;for(let dt=0;dt<_.length;dt++)if(_[dt].name===ut){ut=dt;break}break;case"map":if("map"in _){_=_.map;break}if(!_.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!_.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}_=_.material.map;break;default:if(_[tt]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}_=_[tt]}if(ut!==void 0){if(_[ut]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,_);return}_=_[ut]}}const ot=_[nt];if(ot===void 0){const ut=_e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+ut+"."+nt+" but it wasn't found.",_);return}let at=this.Versioning.None;this.targetObject=_,_.needsUpdate!==void 0?at=this.Versioning.NeedsUpdate:_.matrixWorldNeedsUpdate!==void 0&&(at=this.Versioning.MatrixWorldNeedsUpdate);let lt=this.BindingType.Direct;if(rt!==void 0){if(nt==="morphTargetInfluences"){if(!_.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!_.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}_.morphTargetDictionary[rt]!==void 0&&(rt=_.morphTargetDictionary[rt])}lt=this.BindingType.ArrayElement,this.resolvedProperty=ot,this.propertyIndex=rt}else ot.fromArray!==void 0&&ot.toArray!==void 0?(lt=this.BindingType.HasFromToArray,this.resolvedProperty=ot):Array.isArray(ot)?(lt=this.BindingType.EntireArray,this.resolvedProperty=ot):this.propertyName=nt;this.getValue=this.GetterByBindingType[lt],this.setValue=this.SetterByBindingTypeAndVersioning[lt][at]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}PropertyBinding.Composite=Composite;PropertyBinding.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};PropertyBinding.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};PropertyBinding.prototype.GetterByBindingType=[PropertyBinding.prototype._getValue_direct,PropertyBinding.prototype._getValue_array,PropertyBinding.prototype._getValue_arrayElement,PropertyBinding.prototype._getValue_toArray];PropertyBinding.prototype.SetterByBindingTypeAndVersioning=[[PropertyBinding.prototype._setValue_direct,PropertyBinding.prototype._setValue_direct_setNeedsUpdate,PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_array,PropertyBinding.prototype._setValue_array_setNeedsUpdate,PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_arrayElement,PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_fromArray,PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class AnimationObjectGroup{constructor(){this.isAnimationObjectGroup=!0,this.uuid=generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const _={};this._indicesByUUID=_;for(let tt=0,nt=arguments.length;tt!==nt;++tt)_[arguments[tt].uuid]=tt;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const _e=this;this.stats={objects:{get total(){return _e._objects.length},get inUse(){return this.total-_e.nCachedObjects_}},get bindingsPerObject(){return _e._bindings.length}}}add(){const _=this._objects,_e=this._indicesByUUID,tt=this._paths,nt=this._parsedPaths,rt=this._bindings,ot=rt.length;let at,lt=_.length,ut=this.nCachedObjects_;for(let dt=0,st=arguments.length;dt!==st;++dt){const it=arguments[dt],ct=it.uuid;let ft=_e[ct];if(ft===void 0){ft=lt++,_e[ct]=ft,_.push(it);for(let ht=0,mt=ot;ht!==mt;++ht)rt[ht].push(new PropertyBinding(it,tt[ht],nt[ht]))}else if(ft<ut){at=_[ft];const ht=--ut,mt=_[ht];_e[mt.uuid]=ft,_[ft]=mt,_e[ct]=ht,_[ht]=it;for(let pt=0,_t=ot;pt!==_t;++pt){const vt=rt[pt],bt=vt[ht];let wt=vt[ft];vt[ft]=bt,wt===void 0&&(wt=new PropertyBinding(it,tt[pt],nt[pt])),vt[ht]=wt}}else _[ft]!==at&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=ut}remove(){const _=this._objects,_e=this._indicesByUUID,tt=this._bindings,nt=tt.length;let rt=this.nCachedObjects_;for(let ot=0,at=arguments.length;ot!==at;++ot){const lt=arguments[ot],ut=lt.uuid,dt=_e[ut];if(dt!==void 0&&dt>=rt){const st=rt++,it=_[st];_e[it.uuid]=dt,_[dt]=it,_e[ut]=st,_[st]=lt;for(let ct=0,ft=nt;ct!==ft;++ct){const ht=tt[ct],mt=ht[st],pt=ht[dt];ht[dt]=mt,ht[st]=pt}}}this.nCachedObjects_=rt}uncache(){const _=this._objects,_e=this._indicesByUUID,tt=this._bindings,nt=tt.length;let rt=this.nCachedObjects_,ot=_.length;for(let at=0,lt=arguments.length;at!==lt;++at){const ut=arguments[at],dt=ut.uuid,st=_e[dt];if(st!==void 0)if(delete _e[dt],st<rt){const it=--rt,ct=_[it],ft=--ot,ht=_[ft];_e[ct.uuid]=st,_[st]=ct,_e[ht.uuid]=it,_[it]=ht,_.pop();for(let mt=0,pt=nt;mt!==pt;++mt){const _t=tt[mt],vt=_t[it],bt=_t[ft];_t[st]=vt,_t[it]=bt,_t.pop()}}else{const it=--ot,ct=_[it];it>0&&(_e[ct.uuid]=st),_[st]=ct,_.pop();for(let ft=0,ht=nt;ft!==ht;++ft){const mt=tt[ft];mt[st]=mt[it],mt.pop()}}}this.nCachedObjects_=rt}subscribe_(_,_e){const tt=this._bindingsIndicesByPath;let nt=tt[_];const rt=this._bindings;if(nt!==void 0)return rt[nt];const ot=this._paths,at=this._parsedPaths,lt=this._objects,ut=lt.length,dt=this.nCachedObjects_,st=new Array(ut);nt=rt.length,tt[_]=nt,ot.push(_),at.push(_e),rt.push(st);for(let it=dt,ct=lt.length;it!==ct;++it){const ft=lt[it];st[it]=new PropertyBinding(ft,_,_e)}return st}unsubscribe_(_){const _e=this._bindingsIndicesByPath,tt=_e[_];if(tt!==void 0){const nt=this._paths,rt=this._parsedPaths,ot=this._bindings,at=ot.length-1,lt=ot[at],ut=_[at];_e[ut]=tt,ot[tt]=lt,ot.pop(),rt[tt]=rt[at],rt.pop(),nt[tt]=nt[at],nt.pop()}}}class AnimationAction{constructor(_,_e,tt=null,nt=_e.blendMode){this._mixer=_,this._clip=_e,this._localRoot=tt,this.blendMode=nt;const rt=_e.tracks,ot=rt.length,at=new Array(ot),lt={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding};for(let ut=0;ut!==ot;++ut){const dt=rt[ut].createInterpolant(null);at[ut]=dt,dt.settings=lt}this._interpolantSettings=lt,this._interpolants=at,this._propertyBindings=new Array(ot),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=LoopRepeat,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(_){return this._startTime=_,this}setLoop(_,_e){return this.loop=_,this.repetitions=_e,this}setEffectiveWeight(_){return this.weight=_,this._effectiveWeight=this.enabled?_:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(_){return this._scheduleFading(_,0,1)}fadeOut(_){return this._scheduleFading(_,1,0)}crossFadeFrom(_,_e,tt){if(_.fadeOut(_e),this.fadeIn(_e),tt){const nt=this._clip.duration,rt=_._clip.duration,ot=rt/nt,at=nt/rt;_.warp(1,ot,_e),this.warp(at,1,_e)}return this}crossFadeTo(_,_e,tt){return _.crossFadeFrom(this,_e,tt)}stopFading(){const _=this._weightInterpolant;return _!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(_)),this}setEffectiveTimeScale(_){return this.timeScale=_,this._effectiveTimeScale=this.paused?0:_,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(_){return this.timeScale=this._clip.duration/_,this.stopWarping()}syncWith(_){return this.time=_.time,this.timeScale=_.timeScale,this.stopWarping()}halt(_){return this.warp(this._effectiveTimeScale,0,_)}warp(_,_e,tt){const nt=this._mixer,rt=nt.time,ot=this.timeScale;let at=this._timeScaleInterpolant;at===null&&(at=nt._lendControlInterpolant(),this._timeScaleInterpolant=at);const lt=at.parameterPositions,ut=at.sampleValues;return lt[0]=rt,lt[1]=rt+tt,ut[0]=_/ot,ut[1]=_e/ot,this}stopWarping(){const _=this._timeScaleInterpolant;return _!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(_)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(_,_e,tt,nt){if(!this.enabled){this._updateWeight(_);return}const rt=this._startTime;if(rt!==null){const lt=(_-rt)*tt;lt<0||tt===0?_e=0:(this._startTime=null,_e=tt*lt)}_e*=this._updateTimeScale(_);const ot=this._updateTime(_e),at=this._updateWeight(_);if(at>0){const lt=this._interpolants,ut=this._propertyBindings;switch(this.blendMode){case AdditiveAnimationBlendMode:for(let dt=0,st=lt.length;dt!==st;++dt)lt[dt].evaluate(ot),ut[dt].accumulateAdditive(at);break;case NormalAnimationBlendMode:default:for(let dt=0,st=lt.length;dt!==st;++dt)lt[dt].evaluate(ot),ut[dt].accumulate(nt,at)}}}_updateWeight(_){let _e=0;if(this.enabled){_e=this.weight;const tt=this._weightInterpolant;if(tt!==null){const nt=tt.evaluate(_)[0];_e*=nt,_>tt.parameterPositions[1]&&(this.stopFading(),nt===0&&(this.enabled=!1))}}return this._effectiveWeight=_e,_e}_updateTimeScale(_){let _e=0;if(!this.paused){_e=this.timeScale;const tt=this._timeScaleInterpolant;if(tt!==null){const nt=tt.evaluate(_)[0];_e*=nt,_>tt.parameterPositions[1]&&(this.stopWarping(),_e===0?this.paused=!0:this.timeScale=_e)}}return this._effectiveTimeScale=_e,_e}_updateTime(_){const _e=this._clip.duration,tt=this.loop;let nt=this.time+_,rt=this._loopCount;const ot=tt===LoopPingPong;if(_===0)return rt===-1?nt:ot&&(rt&1)===1?_e-nt:nt;if(tt===LoopOnce){rt===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(nt>=_e)nt=_e;else if(nt<0)nt=0;else{this.time=nt;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=nt,this._mixer.dispatchEvent({type:"finished",action:this,direction:_<0?-1:1})}}else{if(rt===-1&&(_>=0?(rt=0,this._setEndings(!0,this.repetitions===0,ot)):this._setEndings(this.repetitions===0,!0,ot)),nt>=_e||nt<0){const at=Math.floor(nt/_e);nt-=_e*at,rt+=Math.abs(at);const lt=this.repetitions-rt;if(lt<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,nt=_>0?_e:0,this.time=nt,this._mixer.dispatchEvent({type:"finished",action:this,direction:_>0?1:-1});else{if(lt===1){const ut=_<0;this._setEndings(ut,!ut,ot)}else this._setEndings(!1,!1,ot);this._loopCount=rt,this.time=nt,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:at})}}else this.time=nt;if(ot&&(rt&1)===1)return _e-nt}return nt}_setEndings(_,_e,tt){const nt=this._interpolantSettings;tt?(nt.endingStart=ZeroSlopeEnding,nt.endingEnd=ZeroSlopeEnding):(_?nt.endingStart=this.zeroSlopeAtStart?ZeroSlopeEnding:ZeroCurvatureEnding:nt.endingStart=WrapAroundEnding,_e?nt.endingEnd=this.zeroSlopeAtEnd?ZeroSlopeEnding:ZeroCurvatureEnding:nt.endingEnd=WrapAroundEnding)}_scheduleFading(_,_e,tt){const nt=this._mixer,rt=nt.time;let ot=this._weightInterpolant;ot===null&&(ot=nt._lendControlInterpolant(),this._weightInterpolant=ot);const at=ot.parameterPositions,lt=ot.sampleValues;return at[0]=rt,lt[0]=_e,at[1]=rt+_,lt[1]=tt,this}}const _controlInterpolantsResultBuffer=new Float32Array(1);class AnimationMixer extends EventDispatcher{constructor(_){super(),this._root=_,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(_,_e){const tt=_._localRoot||this._root,nt=_._clip.tracks,rt=nt.length,ot=_._propertyBindings,at=_._interpolants,lt=tt.uuid,ut=this._bindingsByRootAndName;let dt=ut[lt];dt===void 0&&(dt={},ut[lt]=dt);for(let st=0;st!==rt;++st){const it=nt[st],ct=it.name;let ft=dt[ct];if(ft!==void 0)++ft.referenceCount,ot[st]=ft;else{if(ft=ot[st],ft!==void 0){ft._cacheIndex===null&&(++ft.referenceCount,this._addInactiveBinding(ft,lt,ct));continue}const ht=_e&&_e._propertyBindings[st].binding.parsedPath;ft=new PropertyMixer(PropertyBinding.create(tt,ct,ht),it.ValueTypeName,it.getValueSize()),++ft.referenceCount,this._addInactiveBinding(ft,lt,ct),ot[st]=ft}at[st].resultBuffer=ft.buffer}}_activateAction(_){if(!this._isActiveAction(_)){if(_._cacheIndex===null){const tt=(_._localRoot||this._root).uuid,nt=_._clip.uuid,rt=this._actionsByClip[nt];this._bindAction(_,rt&&rt.knownActions[0]),this._addInactiveAction(_,nt,tt)}const _e=_._propertyBindings;for(let tt=0,nt=_e.length;tt!==nt;++tt){const rt=_e[tt];rt.useCount++===0&&(this._lendBinding(rt),rt.saveOriginalState())}this._lendAction(_)}}_deactivateAction(_){if(this._isActiveAction(_)){const _e=_._propertyBindings;for(let tt=0,nt=_e.length;tt!==nt;++tt){const rt=_e[tt];--rt.useCount===0&&(rt.restoreOriginalState(),this._takeBackBinding(rt))}this._takeBackAction(_)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const _=this;this.stats={actions:{get total(){return _._actions.length},get inUse(){return _._nActiveActions}},bindings:{get total(){return _._bindings.length},get inUse(){return _._nActiveBindings}},controlInterpolants:{get total(){return _._controlInterpolants.length},get inUse(){return _._nActiveControlInterpolants}}}}_isActiveAction(_){const _e=_._cacheIndex;return _e!==null&&_e<this._nActiveActions}_addInactiveAction(_,_e,tt){const nt=this._actions,rt=this._actionsByClip;let ot=rt[_e];if(ot===void 0)ot={knownActions:[_],actionByRoot:{}},_._byClipCacheIndex=0,rt[_e]=ot;else{const at=ot.knownActions;_._byClipCacheIndex=at.length,at.push(_)}_._cacheIndex=nt.length,nt.push(_),ot.actionByRoot[tt]=_}_removeInactiveAction(_){const _e=this._actions,tt=_e[_e.length-1],nt=_._cacheIndex;tt._cacheIndex=nt,_e[nt]=tt,_e.pop(),_._cacheIndex=null;const rt=_._clip.uuid,ot=this._actionsByClip,at=ot[rt],lt=at.knownActions,ut=lt[lt.length-1],dt=_._byClipCacheIndex;ut._byClipCacheIndex=dt,lt[dt]=ut,lt.pop(),_._byClipCacheIndex=null;const st=at.actionByRoot,it=(_._localRoot||this._root).uuid;delete st[it],lt.length===0&&delete ot[rt],this._removeInactiveBindingsForAction(_)}_removeInactiveBindingsForAction(_){const _e=_._propertyBindings;for(let tt=0,nt=_e.length;tt!==nt;++tt){const rt=_e[tt];--rt.referenceCount===0&&this._removeInactiveBinding(rt)}}_lendAction(_){const _e=this._actions,tt=_._cacheIndex,nt=this._nActiveActions++,rt=_e[nt];_._cacheIndex=nt,_e[nt]=_,rt._cacheIndex=tt,_e[tt]=rt}_takeBackAction(_){const _e=this._actions,tt=_._cacheIndex,nt=--this._nActiveActions,rt=_e[nt];_._cacheIndex=nt,_e[nt]=_,rt._cacheIndex=tt,_e[tt]=rt}_addInactiveBinding(_,_e,tt){const nt=this._bindingsByRootAndName,rt=this._bindings;let ot=nt[_e];ot===void 0&&(ot={},nt[_e]=ot),ot[tt]=_,_._cacheIndex=rt.length,rt.push(_)}_removeInactiveBinding(_){const _e=this._bindings,tt=_.binding,nt=tt.rootNode.uuid,rt=tt.path,ot=this._bindingsByRootAndName,at=ot[nt],lt=_e[_e.length-1],ut=_._cacheIndex;lt._cacheIndex=ut,_e[ut]=lt,_e.pop(),delete at[rt],Object.keys(at).length===0&&delete ot[nt]}_lendBinding(_){const _e=this._bindings,tt=_._cacheIndex,nt=this._nActiveBindings++,rt=_e[nt];_._cacheIndex=nt,_e[nt]=_,rt._cacheIndex=tt,_e[tt]=rt}_takeBackBinding(_){const _e=this._bindings,tt=_._cacheIndex,nt=--this._nActiveBindings,rt=_e[nt];_._cacheIndex=nt,_e[nt]=_,rt._cacheIndex=tt,_e[tt]=rt}_lendControlInterpolant(){const _=this._controlInterpolants,_e=this._nActiveControlInterpolants++;let tt=_[_e];return tt===void 0&&(tt=new LinearInterpolant(new Float32Array(2),new Float32Array(2),1,_controlInterpolantsResultBuffer),tt.__cacheIndex=_e,_[_e]=tt),tt}_takeBackControlInterpolant(_){const _e=this._controlInterpolants,tt=_.__cacheIndex,nt=--this._nActiveControlInterpolants,rt=_e[nt];_.__cacheIndex=nt,_e[nt]=_,rt.__cacheIndex=tt,_e[tt]=rt}clipAction(_,_e,tt){const nt=_e||this._root,rt=nt.uuid;let ot=typeof _=="string"?AnimationClip.findByName(nt,_):_;const at=ot!==null?ot.uuid:_,lt=this._actionsByClip[at];let ut=null;if(tt===void 0&&(ot!==null?tt=ot.blendMode:tt=NormalAnimationBlendMode),lt!==void 0){const st=lt.actionByRoot[rt];if(st!==void 0&&st.blendMode===tt)return st;ut=lt.knownActions[0],ot===null&&(ot=ut._clip)}if(ot===null)return null;const dt=new AnimationAction(this,ot,_e,tt);return this._bindAction(dt,ut),this._addInactiveAction(dt,at,rt),dt}existingAction(_,_e){const tt=_e||this._root,nt=tt.uuid,rt=typeof _=="string"?AnimationClip.findByName(tt,_):_,ot=rt?rt.uuid:_,at=this._actionsByClip[ot];return at!==void 0&&at.actionByRoot[nt]||null}stopAllAction(){const _=this._actions,_e=this._nActiveActions;for(let tt=_e-1;tt>=0;--tt)_[tt].stop();return this}update(_){_*=this.timeScale;const _e=this._actions,tt=this._nActiveActions,nt=this.time+=_,rt=Math.sign(_),ot=this._accuIndex^=1;for(let ut=0;ut!==tt;++ut)_e[ut]._update(nt,_,rt,ot);const at=this._bindings,lt=this._nActiveBindings;for(let ut=0;ut!==lt;++ut)at[ut].apply(ot);return this}setTime(_){this.time=0;for(let _e=0;_e<this._actions.length;_e++)this._actions[_e].time=0;return this.update(_)}getRoot(){return this._root}uncacheClip(_){const _e=this._actions,tt=_.uuid,nt=this._actionsByClip,rt=nt[tt];if(rt!==void 0){const ot=rt.knownActions;for(let at=0,lt=ot.length;at!==lt;++at){const ut=ot[at];this._deactivateAction(ut);const dt=ut._cacheIndex,st=_e[_e.length-1];ut._cacheIndex=null,ut._byClipCacheIndex=null,st._cacheIndex=dt,_e[dt]=st,_e.pop(),this._removeInactiveBindingsForAction(ut)}delete nt[tt]}}uncacheRoot(_){const _e=_.uuid,tt=this._actionsByClip;for(const ot in tt){const at=tt[ot].actionByRoot,lt=at[_e];lt!==void 0&&(this._deactivateAction(lt),this._removeInactiveAction(lt))}const nt=this._bindingsByRootAndName,rt=nt[_e];if(rt!==void 0)for(const ot in rt){const at=rt[ot];at.restoreOriginalState(),this._removeInactiveBinding(at)}}uncacheAction(_,_e){const tt=this.existingAction(_,_e);tt!==null&&(this._deactivateAction(tt),this._removeInactiveAction(tt))}}class Uniform{constructor(_){this.value=_}clone(){return new Uniform(this.value.clone===void 0?this.value:this.value.clone())}}let _id=0;class UniformsGroup extends EventDispatcher{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:_id++}),this.name="",this.usage=StaticDrawUsage,this.uniforms=[]}add(_){return this.uniforms.push(_),this}remove(_){const _e=this.uniforms.indexOf(_);return _e!==-1&&this.uniforms.splice(_e,1),this}setName(_){return this.name=_,this}setUsage(_){return this.usage=_,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(_){this.name=_.name,this.usage=_.usage;const _e=_.uniforms;this.uniforms.length=0;for(let tt=0,nt=_e.length;tt<nt;tt++){const rt=Array.isArray(_e[tt])?_e[tt]:[_e[tt]];for(let ot=0;ot<rt.length;ot++)this.uniforms.push(rt[ot].clone())}return this}clone(){return new this.constructor().copy(this)}}class InstancedInterleavedBuffer extends InterleavedBuffer{constructor(_,_e,tt=1){super(_,_e),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=tt}copy(_){return super.copy(_),this.meshPerAttribute=_.meshPerAttribute,this}clone(_){const _e=super.clone(_);return _e.meshPerAttribute=this.meshPerAttribute,_e}toJSON(_){const _e=super.toJSON(_);return _e.isInstancedInterleavedBuffer=!0,_e.meshPerAttribute=this.meshPerAttribute,_e}}class GLBufferAttribute{constructor(_,_e,tt,nt,rt){this.isGLBufferAttribute=!0,this.name="",this.buffer=_,this.type=_e,this.itemSize=tt,this.elementSize=nt,this.count=rt,this.version=0}set needsUpdate(_){_===!0&&this.version++}setBuffer(_){return this.buffer=_,this}setType(_,_e){return this.type=_,this.elementSize=_e,this}setItemSize(_){return this.itemSize=_,this}setCount(_){return this.count=_,this}}const _matrix=new Matrix4;class Raycaster{constructor(_,_e,tt=0,nt=1/0){this.ray=new Ray(_,_e),this.near=tt,this.far=nt,this.camera=null,this.layers=new Layers,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(_,_e){this.ray.set(_,_e)}setFromCamera(_,_e){_e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(_e.matrixWorld),this.ray.direction.set(_.x,_.y,.5).unproject(_e).sub(this.ray.origin).normalize(),this.camera=_e):_e.isOrthographicCamera?(this.ray.origin.set(_.x,_.y,(_e.near+_e.far)/(_e.near-_e.far)).unproject(_e),this.ray.direction.set(0,0,-1).transformDirection(_e.matrixWorld),this.camera=_e):console.error("THREE.Raycaster: Unsupported camera type: "+_e.type)}setFromXRController(_){return _matrix.identity().extractRotation(_.matrixWorld),this.ray.origin.setFromMatrixPosition(_.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(_matrix),this}intersectObject(_,_e=!0,tt=[]){return intersect(_,this,tt,_e),tt.sort(ascSort),tt}intersectObjects(_,_e=!0,tt=[]){for(let nt=0,rt=_.length;nt<rt;nt++)intersect(_[nt],this,tt,_e);return tt.sort(ascSort),tt}}function ascSort(et,_){return et.distance-_.distance}function intersect(et,_,_e,tt){let nt=!0;if(et.layers.test(_.layers)&&et.raycast(_,_e)===!1&&(nt=!1),nt===!0&&tt===!0){const rt=et.children;for(let ot=0,at=rt.length;ot<at;ot++)intersect(rt[ot],_,_e,!0)}}class Spherical{constructor(_=1,_e=0,tt=0){return this.radius=_,this.phi=_e,this.theta=tt,this}set(_,_e,tt){return this.radius=_,this.phi=_e,this.theta=tt,this}copy(_){return this.radius=_.radius,this.phi=_.phi,this.theta=_.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(_){return this.setFromCartesianCoords(_.x,_.y,_.z)}setFromCartesianCoords(_,_e,tt){return this.radius=Math.sqrt(_*_+_e*_e+tt*tt),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(_,tt),this.phi=Math.acos(clamp$4(_e/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class Cylindrical{constructor(_=1,_e=0,tt=0){return this.radius=_,this.theta=_e,this.y=tt,this}set(_,_e,tt){return this.radius=_,this.theta=_e,this.y=tt,this}copy(_){return this.radius=_.radius,this.theta=_.theta,this.y=_.y,this}setFromVector3(_){return this.setFromCartesianCoords(_.x,_.y,_.z)}setFromCartesianCoords(_,_e,tt){return this.radius=Math.sqrt(_*_+tt*tt),this.theta=Math.atan2(_,tt),this.y=_e,this}clone(){return new this.constructor().copy(this)}}const _vector$4=new Vector2;class Box2{constructor(_=new Vector2(1/0,1/0),_e=new Vector2(-1/0,-1/0)){this.isBox2=!0,this.min=_,this.max=_e}set(_,_e){return this.min.copy(_),this.max.copy(_e),this}setFromPoints(_){this.makeEmpty();for(let _e=0,tt=_.length;_e<tt;_e++)this.expandByPoint(_[_e]);return this}setFromCenterAndSize(_,_e){const tt=_vector$4.copy(_e).multiplyScalar(.5);return this.min.copy(_).sub(tt),this.max.copy(_).add(tt),this}clone(){return new this.constructor().copy(this)}copy(_){return this.min.copy(_.min),this.max.copy(_.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(_){return this.isEmpty()?_.set(0,0):_.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(_){return this.isEmpty()?_.set(0,0):_.subVectors(this.max,this.min)}expandByPoint(_){return this.min.min(_),this.max.max(_),this}expandByVector(_){return this.min.sub(_),this.max.add(_),this}expandByScalar(_){return this.min.addScalar(-_),this.max.addScalar(_),this}containsPoint(_){return!(_.x<this.min.x||_.x>this.max.x||_.y<this.min.y||_.y>this.max.y)}containsBox(_){return this.min.x<=_.min.x&&_.max.x<=this.max.x&&this.min.y<=_.min.y&&_.max.y<=this.max.y}getParameter(_,_e){return _e.set((_.x-this.min.x)/(this.max.x-this.min.x),(_.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(_){return!(_.max.x<this.min.x||_.min.x>this.max.x||_.max.y<this.min.y||_.min.y>this.max.y)}clampPoint(_,_e){return _e.copy(_).clamp(this.min,this.max)}distanceToPoint(_){return this.clampPoint(_,_vector$4).distanceTo(_)}intersect(_){return this.min.max(_.min),this.max.min(_.max),this.isEmpty()&&this.makeEmpty(),this}union(_){return this.min.min(_.min),this.max.max(_.max),this}translate(_){return this.min.add(_),this.max.add(_),this}equals(_){return _.min.equals(this.min)&&_.max.equals(this.max)}}const _startP=new Vector3,_startEnd=new Vector3;class Line3{constructor(_=new Vector3,_e=new Vector3){this.start=_,this.end=_e}set(_,_e){return this.start.copy(_),this.end.copy(_e),this}copy(_){return this.start.copy(_.start),this.end.copy(_.end),this}getCenter(_){return _.addVectors(this.start,this.end).multiplyScalar(.5)}delta(_){return _.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(_,_e){return this.delta(_e).multiplyScalar(_).add(this.start)}closestPointToPointParameter(_,_e){_startP.subVectors(_,this.start),_startEnd.subVectors(this.end,this.start);const tt=_startEnd.dot(_startEnd);let rt=_startEnd.dot(_startP)/tt;return _e&&(rt=clamp$4(rt,0,1)),rt}closestPointToPoint(_,_e,tt){const nt=this.closestPointToPointParameter(_,_e);return this.delta(tt).multiplyScalar(nt).add(this.start)}applyMatrix4(_){return this.start.applyMatrix4(_),this.end.applyMatrix4(_),this}equals(_){return _.start.equals(this.start)&&_.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const _vector$3=new Vector3;class SpotLightHelper extends Object3D{constructor(_,_e){super(),this.light=_,this.matrixAutoUpdate=!1,this.color=_e,this.type="SpotLightHelper";const tt=new BufferGeometry,nt=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let ot=0,at=1,lt=32;ot<lt;ot++,at++){const ut=ot/lt*Math.PI*2,dt=at/lt*Math.PI*2;nt.push(Math.cos(ut),Math.sin(ut),1,Math.cos(dt),Math.sin(dt),1)}tt.setAttribute("position",new Float32BufferAttribute(nt,3));const rt=new LineBasicMaterial({fog:!1,toneMapped:!1});this.cone=new LineSegments(tt,rt),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);const _=this.light.distance?this.light.distance:1e3,_e=_*Math.tan(this.light.angle);this.cone.scale.set(_e,_e,_),_vector$3.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(_vector$3),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const _vector$2=new Vector3,_boneMatrix=new Matrix4,_matrixWorldInv=new Matrix4;class SkeletonHelper extends LineSegments{constructor(_){const _e=getBoneList(_),tt=new BufferGeometry,nt=[],rt=[],ot=new Color$1(0,0,1),at=new Color$1(0,1,0);for(let ut=0;ut<_e.length;ut++){const dt=_e[ut];dt.parent&&dt.parent.isBone&&(nt.push(0,0,0),nt.push(0,0,0),rt.push(ot.r,ot.g,ot.b),rt.push(at.r,at.g,at.b))}tt.setAttribute("position",new Float32BufferAttribute(nt,3)),tt.setAttribute("color",new Float32BufferAttribute(rt,3));const lt=new LineBasicMaterial({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(tt,lt),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=_,this.bones=_e,this.matrix=_.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(_){const _e=this.bones,tt=this.geometry,nt=tt.getAttribute("position");_matrixWorldInv.copy(this.root.matrixWorld).invert();for(let rt=0,ot=0;rt<_e.length;rt++){const at=_e[rt];at.parent&&at.parent.isBone&&(_boneMatrix.multiplyMatrices(_matrixWorldInv,at.matrixWorld),_vector$2.setFromMatrixPosition(_boneMatrix),nt.setXYZ(ot,_vector$2.x,_vector$2.y,_vector$2.z),_boneMatrix.multiplyMatrices(_matrixWorldInv,at.parent.matrixWorld),_vector$2.setFromMatrixPosition(_boneMatrix),nt.setXYZ(ot+1,_vector$2.x,_vector$2.y,_vector$2.z),ot+=2)}tt.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(_)}dispose(){this.geometry.dispose(),this.material.dispose()}}function getBoneList(et){const _=[];et.isBone===!0&&_.push(et);for(let _e=0;_e<et.children.length;_e++)_.push.apply(_,getBoneList(et.children[_e]));return _}class PointLightHelper extends Mesh{constructor(_,_e,tt){const nt=new SphereGeometry(_e,4,2),rt=new MeshBasicMaterial({wireframe:!0,fog:!1,toneMapped:!1});super(nt,rt),this.light=_,this.color=tt,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const _vector$1=new Vector3,_color1=new Color$1,_color2=new Color$1;class HemisphereLightHelper extends Object3D{constructor(_,_e,tt){super(),this.light=_,this.matrix=_.matrixWorld,this.matrixAutoUpdate=!1,this.color=tt,this.type="HemisphereLightHelper";const nt=new OctahedronGeometry(_e);nt.rotateY(Math.PI*.5),this.material=new MeshBasicMaterial({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const rt=nt.getAttribute("position"),ot=new Float32Array(rt.count*3);nt.setAttribute("color",new BufferAttribute(ot,3)),this.add(new Mesh(nt,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const _=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const _e=_.geometry.getAttribute("color");_color1.copy(this.light.color),_color2.copy(this.light.groundColor);for(let tt=0,nt=_e.count;tt<nt;tt++){const rt=tt<nt/2?_color1:_color2;_e.setXYZ(tt,rt.r,rt.g,rt.b)}_e.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),_.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate())}}class GridHelper extends LineSegments{constructor(_=10,_e=10,tt=4473924,nt=8947848){tt=new Color$1(tt),nt=new Color$1(nt);const rt=_e/2,ot=_/_e,at=_/2,lt=[],ut=[];for(let it=0,ct=0,ft=-at;it<=_e;it++,ft+=ot){lt.push(-at,0,ft,at,0,ft),lt.push(ft,0,-at,ft,0,at);const ht=it===rt?tt:nt;ht.toArray(ut,ct),ct+=3,ht.toArray(ut,ct),ct+=3,ht.toArray(ut,ct),ct+=3,ht.toArray(ut,ct),ct+=3}const dt=new BufferGeometry;dt.setAttribute("position",new Float32BufferAttribute(lt,3)),dt.setAttribute("color",new Float32BufferAttribute(ut,3));const st=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});super(dt,st),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class PolarGridHelper extends LineSegments{constructor(_=10,_e=16,tt=8,nt=64,rt=4473924,ot=8947848){rt=new Color$1(rt),ot=new Color$1(ot);const at=[],lt=[];if(_e>1)for(let st=0;st<_e;st++){const it=st/_e*(Math.PI*2),ct=Math.sin(it)*_,ft=Math.cos(it)*_;at.push(0,0,0),at.push(ct,0,ft);const ht=st&1?rt:ot;lt.push(ht.r,ht.g,ht.b),lt.push(ht.r,ht.g,ht.b)}for(let st=0;st<tt;st++){const it=st&1?rt:ot,ct=_-_/tt*st;for(let ft=0;ft<nt;ft++){let ht=ft/nt*(Math.PI*2),mt=Math.sin(ht)*ct,pt=Math.cos(ht)*ct;at.push(mt,0,pt),lt.push(it.r,it.g,it.b),ht=(ft+1)/nt*(Math.PI*2),mt=Math.sin(ht)*ct,pt=Math.cos(ht)*ct,at.push(mt,0,pt),lt.push(it.r,it.g,it.b)}}const ut=new BufferGeometry;ut.setAttribute("position",new Float32BufferAttribute(at,3)),ut.setAttribute("color",new Float32BufferAttribute(lt,3));const dt=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});super(ut,dt),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const _v1=new Vector3,_v2=new Vector3,_v3=new Vector3;class DirectionalLightHelper extends Object3D{constructor(_,_e,tt){super(),this.light=_,this.matrix=_.matrixWorld,this.matrixAutoUpdate=!1,this.color=tt,this.type="DirectionalLightHelper",_e===void 0&&(_e=1);let nt=new BufferGeometry;nt.setAttribute("position",new Float32BufferAttribute([-_e,_e,0,_e,_e,0,_e,-_e,0,-_e,-_e,0,-_e,_e,0],3));const rt=new LineBasicMaterial({fog:!1,toneMapped:!1});this.lightPlane=new Line(nt,rt),this.add(this.lightPlane),nt=new BufferGeometry,nt.setAttribute("position",new Float32BufferAttribute([0,0,0,0,0,1],3)),this.targetLine=new Line(nt,rt),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),_v1.setFromMatrixPosition(this.light.matrixWorld),_v2.setFromMatrixPosition(this.light.target.matrixWorld),_v3.subVectors(_v2,_v1),this.lightPlane.lookAt(_v2),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(_v2),this.targetLine.scale.z=_v3.length()}}const _vector=new Vector3,_camera=new Camera;class CameraHelper extends LineSegments{constructor(_){const _e=new BufferGeometry,tt=new LineBasicMaterial({color:16777215,vertexColors:!0,toneMapped:!1}),nt=[],rt=[],ot={};at("n1","n2"),at("n2","n4"),at("n4","n3"),at("n3","n1"),at("f1","f2"),at("f2","f4"),at("f4","f3"),at("f3","f1"),at("n1","f1"),at("n2","f2"),at("n3","f3"),at("n4","f4"),at("p","n1"),at("p","n2"),at("p","n3"),at("p","n4"),at("u1","u2"),at("u2","u3"),at("u3","u1"),at("c","t"),at("p","c"),at("cn1","cn2"),at("cn3","cn4"),at("cf1","cf2"),at("cf3","cf4");function at(ft,ht){lt(ft),lt(ht)}function lt(ft){nt.push(0,0,0),rt.push(0,0,0),ot[ft]===void 0&&(ot[ft]=[]),ot[ft].push(nt.length/3-1)}_e.setAttribute("position",new Float32BufferAttribute(nt,3)),_e.setAttribute("color",new Float32BufferAttribute(rt,3)),super(_e,tt),this.type="CameraHelper",this.camera=_,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=_.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=ot,this.update();const ut=new Color$1(16755200),dt=new Color$1(16711680),st=new Color$1(43775),it=new Color$1(16777215),ct=new Color$1(3355443);this.setColors(ut,dt,st,it,ct)}setColors(_,_e,tt,nt,rt){const at=this.geometry.getAttribute("color");at.setXYZ(0,_.r,_.g,_.b),at.setXYZ(1,_.r,_.g,_.b),at.setXYZ(2,_.r,_.g,_.b),at.setXYZ(3,_.r,_.g,_.b),at.setXYZ(4,_.r,_.g,_.b),at.setXYZ(5,_.r,_.g,_.b),at.setXYZ(6,_.r,_.g,_.b),at.setXYZ(7,_.r,_.g,_.b),at.setXYZ(8,_.r,_.g,_.b),at.setXYZ(9,_.r,_.g,_.b),at.setXYZ(10,_.r,_.g,_.b),at.setXYZ(11,_.r,_.g,_.b),at.setXYZ(12,_.r,_.g,_.b),at.setXYZ(13,_.r,_.g,_.b),at.setXYZ(14,_.r,_.g,_.b),at.setXYZ(15,_.r,_.g,_.b),at.setXYZ(16,_.r,_.g,_.b),at.setXYZ(17,_.r,_.g,_.b),at.setXYZ(18,_.r,_.g,_.b),at.setXYZ(19,_.r,_.g,_.b),at.setXYZ(20,_.r,_.g,_.b),at.setXYZ(21,_.r,_.g,_.b),at.setXYZ(22,_.r,_.g,_.b),at.setXYZ(23,_.r,_.g,_.b),at.setXYZ(24,_e.r,_e.g,_e.b),at.setXYZ(25,_e.r,_e.g,_e.b),at.setXYZ(26,_e.r,_e.g,_e.b),at.setXYZ(27,_e.r,_e.g,_e.b),at.setXYZ(28,_e.r,_e.g,_e.b),at.setXYZ(29,_e.r,_e.g,_e.b),at.setXYZ(30,_e.r,_e.g,_e.b),at.setXYZ(31,_e.r,_e.g,_e.b),at.setXYZ(32,tt.r,tt.g,tt.b),at.setXYZ(33,tt.r,tt.g,tt.b),at.setXYZ(34,tt.r,tt.g,tt.b),at.setXYZ(35,tt.r,tt.g,tt.b),at.setXYZ(36,tt.r,tt.g,tt.b),at.setXYZ(37,tt.r,tt.g,tt.b),at.setXYZ(38,nt.r,nt.g,nt.b),at.setXYZ(39,nt.r,nt.g,nt.b),at.setXYZ(40,rt.r,rt.g,rt.b),at.setXYZ(41,rt.r,rt.g,rt.b),at.setXYZ(42,rt.r,rt.g,rt.b),at.setXYZ(43,rt.r,rt.g,rt.b),at.setXYZ(44,rt.r,rt.g,rt.b),at.setXYZ(45,rt.r,rt.g,rt.b),at.setXYZ(46,rt.r,rt.g,rt.b),at.setXYZ(47,rt.r,rt.g,rt.b),at.setXYZ(48,rt.r,rt.g,rt.b),at.setXYZ(49,rt.r,rt.g,rt.b),at.needsUpdate=!0}update(){const _=this.geometry,_e=this.pointMap,tt=1,nt=1;_camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),setPoint("c",_e,_,_camera,0,0,-1),setPoint("t",_e,_,_camera,0,0,1),setPoint("n1",_e,_,_camera,-tt,-nt,-1),setPoint("n2",_e,_,_camera,tt,-nt,-1),setPoint("n3",_e,_,_camera,-tt,nt,-1),setPoint("n4",_e,_,_camera,tt,nt,-1),setPoint("f1",_e,_,_camera,-tt,-nt,1),setPoint("f2",_e,_,_camera,tt,-nt,1),setPoint("f3",_e,_,_camera,-tt,nt,1),setPoint("f4",_e,_,_camera,tt,nt,1),setPoint("u1",_e,_,_camera,tt*.7,nt*1.1,-1),setPoint("u2",_e,_,_camera,-tt*.7,nt*1.1,-1),setPoint("u3",_e,_,_camera,0,nt*2,-1),setPoint("cf1",_e,_,_camera,-tt,0,1),setPoint("cf2",_e,_,_camera,tt,0,1),setPoint("cf3",_e,_,_camera,0,-nt,1),setPoint("cf4",_e,_,_camera,0,nt,1),setPoint("cn1",_e,_,_camera,-tt,0,-1),setPoint("cn2",_e,_,_camera,tt,0,-1),setPoint("cn3",_e,_,_camera,0,-nt,-1),setPoint("cn4",_e,_,_camera,0,nt,-1),_.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function setPoint(et,_,_e,tt,nt,rt,ot){_vector.set(nt,rt,ot).unproject(tt);const at=_[et];if(at!==void 0){const lt=_e.getAttribute("position");for(let ut=0,dt=at.length;ut<dt;ut++)lt.setXYZ(at[ut],_vector.x,_vector.y,_vector.z)}}const _box=new Box3;class BoxHelper extends LineSegments{constructor(_,_e=16776960){const tt=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),nt=new Float32Array(8*3),rt=new BufferGeometry;rt.setIndex(new BufferAttribute(tt,1)),rt.setAttribute("position",new BufferAttribute(nt,3)),super(rt,new LineBasicMaterial({color:_e,toneMapped:!1})),this.object=_,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(_){if(_!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&_box.setFromObject(this.object),_box.isEmpty())return;const _e=_box.min,tt=_box.max,nt=this.geometry.attributes.position,rt=nt.array;rt[0]=tt.x,rt[1]=tt.y,rt[2]=tt.z,rt[3]=_e.x,rt[4]=tt.y,rt[5]=tt.z,rt[6]=_e.x,rt[7]=_e.y,rt[8]=tt.z,rt[9]=tt.x,rt[10]=_e.y,rt[11]=tt.z,rt[12]=tt.x,rt[13]=tt.y,rt[14]=_e.z,rt[15]=_e.x,rt[16]=tt.y,rt[17]=_e.z,rt[18]=_e.x,rt[19]=_e.y,rt[20]=_e.z,rt[21]=tt.x,rt[22]=_e.y,rt[23]=_e.z,nt.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(_){return this.object=_,this.update(),this}copy(_,_e){return super.copy(_,_e),this.object=_.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class Box3Helper extends LineSegments{constructor(_,_e=16776960){const tt=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),nt=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],rt=new BufferGeometry;rt.setIndex(new BufferAttribute(tt,1)),rt.setAttribute("position",new Float32BufferAttribute(nt,3)),super(rt,new LineBasicMaterial({color:_e,toneMapped:!1})),this.box=_,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(_){const _e=this.box;_e.isEmpty()||(_e.getCenter(this.position),_e.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(_))}dispose(){this.geometry.dispose(),this.material.dispose()}}class PlaneHelper extends Line{constructor(_,_e=1,tt=16776960){const nt=tt,rt=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],ot=new BufferGeometry;ot.setAttribute("position",new Float32BufferAttribute(rt,3)),ot.computeBoundingSphere(),super(ot,new LineBasicMaterial({color:nt,toneMapped:!1})),this.type="PlaneHelper",this.plane=_,this.size=_e;const at=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],lt=new BufferGeometry;lt.setAttribute("position",new Float32BufferAttribute(at,3)),lt.computeBoundingSphere(),this.add(new Mesh(lt,new MeshBasicMaterial({color:nt,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(_){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(_)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const _axis=new Vector3;let _lineGeometry,_coneGeometry;class ArrowHelper extends Object3D{constructor(_=new Vector3(0,0,1),_e=new Vector3(0,0,0),tt=1,nt=16776960,rt=tt*.2,ot=rt*.2){super(),this.type="ArrowHelper",_lineGeometry===void 0&&(_lineGeometry=new BufferGeometry,_lineGeometry.setAttribute("position",new Float32BufferAttribute([0,0,0,0,1,0],3)),_coneGeometry=new CylinderGeometry(0,.5,1,5,1),_coneGeometry.translate(0,-.5,0)),this.position.copy(_e),this.line=new Line(_lineGeometry,new LineBasicMaterial({color:nt,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Mesh(_coneGeometry,new MeshBasicMaterial({color:nt,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(_),this.setLength(tt,rt,ot)}setDirection(_){if(_.y>.99999)this.quaternion.set(0,0,0,1);else if(_.y<-.99999)this.quaternion.set(1,0,0,0);else{_axis.set(_.z,0,-_.x).normalize();const _e=Math.acos(_.y);this.quaternion.setFromAxisAngle(_axis,_e)}}setLength(_,_e=_*.2,tt=_e*.2){this.line.scale.set(1,Math.max(1e-4,_-_e),1),this.line.updateMatrix(),this.cone.scale.set(tt,_e,tt),this.cone.position.y=_,this.cone.updateMatrix()}setColor(_){this.line.material.color.set(_),this.cone.material.color.set(_)}copy(_){return super.copy(_,!1),this.line.copy(_.line),this.cone.copy(_.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class AxesHelper extends LineSegments{constructor(_=1){const _e=[0,0,0,_,0,0,0,0,0,0,_,0,0,0,0,0,0,_],tt=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],nt=new BufferGeometry;nt.setAttribute("position",new Float32BufferAttribute(_e,3)),nt.setAttribute("color",new Float32BufferAttribute(tt,3));const rt=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});super(nt,rt),this.type="AxesHelper"}setColors(_,_e,tt){const nt=new Color$1,rt=this.geometry.attributes.color.array;return nt.set(_),nt.toArray(rt,0),nt.toArray(rt,3),nt.set(_e),nt.toArray(rt,6),nt.toArray(rt,9),nt.set(tt),nt.toArray(rt,12),nt.toArray(rt,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class ShapePath{constructor(){this.type="ShapePath",this.color=new Color$1,this.subPaths=[],this.currentPath=null}moveTo(_,_e){return this.currentPath=new Path,this.subPaths.push(this.currentPath),this.currentPath.moveTo(_,_e),this}lineTo(_,_e){return this.currentPath.lineTo(_,_e),this}quadraticCurveTo(_,_e,tt,nt){return this.currentPath.quadraticCurveTo(_,_e,tt,nt),this}bezierCurveTo(_,_e,tt,nt,rt,ot){return this.currentPath.bezierCurveTo(_,_e,tt,nt,rt,ot),this}splineThru(_){return this.currentPath.splineThru(_),this}toShapes(_){function _e(pt){const _t=[];for(let vt=0,bt=pt.length;vt<bt;vt++){const wt=pt[vt],xt=new Shape;xt.curves=wt.curves,_t.push(xt)}return _t}function tt(pt,_t){const vt=_t.length;let bt=!1;for(let wt=vt-1,xt=0;xt<vt;wt=xt++){let Mt=_t[wt],At=_t[xt],St=At.x-Mt.x,Tt=At.y-Mt.y;if(Math.abs(Tt)>Number.EPSILON){if(Tt<0&&(Mt=_t[xt],St=-St,At=_t[wt],Tt=-Tt),pt.y<Mt.y||pt.y>At.y)continue;if(pt.y===Mt.y){if(pt.x===Mt.x)return!0}else{const Ct=Tt*(pt.x-Mt.x)-St*(pt.y-Mt.y);if(Ct===0)return!0;if(Ct<0)continue;bt=!bt}}else{if(pt.y!==Mt.y)continue;if(At.x<=pt.x&&pt.x<=Mt.x||Mt.x<=pt.x&&pt.x<=At.x)return!0}}return bt}const nt=ShapeUtils.isClockWise,rt=this.subPaths;if(rt.length===0)return[];let ot,at,lt;const ut=[];if(rt.length===1)return at=rt[0],lt=new Shape,lt.curves=at.curves,ut.push(lt),ut;let dt=!nt(rt[0].getPoints());dt=_?!dt:dt;const st=[],it=[];let ct=[],ft=0,ht;it[ft]=void 0,ct[ft]=[];for(let pt=0,_t=rt.length;pt<_t;pt++)at=rt[pt],ht=at.getPoints(),ot=nt(ht),ot=_?!ot:ot,ot?(!dt&&it[ft]&&ft++,it[ft]={s:new Shape,p:ht},it[ft].s.curves=at.curves,dt&&ft++,ct[ft]=[]):ct[ft].push({h:at,p:ht[0]});if(!it[0])return _e(rt);if(it.length>1){let pt=!1,_t=0;for(let vt=0,bt=it.length;vt<bt;vt++)st[vt]=[];for(let vt=0,bt=it.length;vt<bt;vt++){const wt=ct[vt];for(let xt=0;xt<wt.length;xt++){const Mt=wt[xt];let At=!0;for(let St=0;St<it.length;St++)tt(Mt.p,it[St].p)&&(vt!==St&&_t++,At?(At=!1,st[St].push(Mt)):pt=!0);At&&st[vt].push(Mt)}}_t>0&&pt===!1&&(ct=st)}let mt;for(let pt=0,_t=it.length;pt<_t;pt++){lt=it[pt].s,ut.push(lt),mt=ct[pt];for(let vt=0,bt=mt.length;vt<bt;vt++)lt.holes.push(mt[vt].h)}return ut}}class WebGLMultipleRenderTargets extends WebGLRenderTarget{constructor(_=1,_e=1,tt=1,nt={}){console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'),super(_,_e,{...nt,count:tt}),this.isWebGLMultipleRenderTargets=!0}get texture(){return this.textures}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:REVISION}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=REVISION);const THREE=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping,AddEquation,AddOperation,AdditiveAnimationBlendMode,AdditiveBlending,AgXToneMapping,AlphaFormat,AlwaysCompare,AlwaysDepth,AlwaysStencilFunc,AmbientLight,AnimationAction,AnimationClip,AnimationLoader,AnimationMixer,AnimationObjectGroup,AnimationUtils,ArcCurve,ArrayCamera,ArrowHelper,AttachedBindMode,Audio,AudioAnalyser,AudioContext:AudioContext$1,AudioListener,AudioLoader,AxesHelper,BackSide,BasicDepthPacking,BasicShadowMap,BatchedMesh,Bone,BooleanKeyframeTrack,Box2,Box3,Box3Helper,BoxGeometry,BoxHelper,BufferAttribute,BufferGeometry,BufferGeometryLoader,ByteType,Cache,Camera,CameraHelper,CanvasTexture,CapsuleGeometry,CatmullRomCurve3,CineonToneMapping,CircleGeometry,ClampToEdgeWrapping,Clock,Color:Color$1,ColorKeyframeTrack,ColorManagement,CompressedArrayTexture,CompressedCubeTexture,CompressedTexture,CompressedTextureLoader,ConeGeometry,ConstantAlphaFactor,ConstantColorFactor,CubeCamera,CubeReflectionMapping,CubeRefractionMapping,CubeTexture,CubeTextureLoader,CubeUVReflectionMapping,CubicBezierCurve,CubicBezierCurve3,CubicInterpolant,CullFaceBack,CullFaceFront,CullFaceFrontBack,CullFaceNone,Curve,CurvePath,CustomBlending,CustomToneMapping,CylinderGeometry,Cylindrical,Data3DTexture,DataArrayTexture,DataTexture,DataTextureLoader,DataUtils,DecrementStencilOp,DecrementWrapStencilOp,DefaultLoadingManager,DepthFormat,DepthStencilFormat,DepthTexture,DetachedBindMode,DirectionalLight,DirectionalLightHelper,DiscreteInterpolant,DisplayP3ColorSpace,DodecahedronGeometry,DoubleSide,DstAlphaFactor,DstColorFactor,DynamicCopyUsage,DynamicDrawUsage,DynamicReadUsage,EdgesGeometry,EllipseCurve,EqualCompare,EqualDepth,EqualStencilFunc,EquirectangularReflectionMapping,EquirectangularRefractionMapping,Euler,EventDispatcher,ExtrudeGeometry,FileLoader,Float16BufferAttribute,Float32BufferAttribute,FloatType,Fog,FogExp2,FramebufferTexture,FrontSide,Frustum,GLBufferAttribute,GLSL1,GLSL3,GreaterCompare,GreaterDepth,GreaterEqualCompare,GreaterEqualDepth,GreaterEqualStencilFunc,GreaterStencilFunc,GridHelper,Group,HalfFloatType,HemisphereLight,HemisphereLightHelper,IcosahedronGeometry,ImageBitmapLoader,ImageLoader,ImageUtils,IncrementStencilOp,IncrementWrapStencilOp,InstancedBufferAttribute,InstancedBufferGeometry,InstancedInterleavedBuffer,InstancedMesh,Int16BufferAttribute,Int32BufferAttribute,Int8BufferAttribute,IntType,InterleavedBuffer,InterleavedBufferAttribute,Interpolant,InterpolateDiscrete,InterpolateLinear,InterpolateSmooth,InvertStencilOp,KeepStencilOp,KeyframeTrack,LOD,LatheGeometry,Layers,LessCompare,LessDepth,LessEqualCompare,LessEqualDepth,LessEqualStencilFunc,LessStencilFunc,Light,LightProbe,Line,Line3,LineBasicMaterial,LineCurve,LineCurve3,LineDashedMaterial,LineLoop,LineSegments,LinearDisplayP3ColorSpace,LinearFilter,LinearInterpolant,LinearMipMapLinearFilter,LinearMipMapNearestFilter,LinearMipmapLinearFilter,LinearMipmapNearestFilter,LinearSRGBColorSpace,LinearToneMapping,LinearTransfer,Loader,LoaderUtils,LoadingManager,LoopOnce,LoopPingPong,LoopRepeat,LuminanceAlphaFormat,LuminanceFormat,MOUSE,Material,MaterialLoader,MathUtils,Matrix3,Matrix4,MaxEquation,Mesh,MeshBasicMaterial,MeshDepthMaterial,MeshDistanceMaterial,MeshLambertMaterial,MeshMatcapMaterial,MeshNormalMaterial,MeshPhongMaterial,MeshPhysicalMaterial,MeshStandardMaterial,MeshToonMaterial,MinEquation,MirroredRepeatWrapping,MixOperation,MultiplyBlending,MultiplyOperation,NearestFilter,NearestMipMapLinearFilter,NearestMipMapNearestFilter,NearestMipmapLinearFilter,NearestMipmapNearestFilter,NeutralToneMapping,NeverCompare,NeverDepth,NeverStencilFunc,NoBlending,NoColorSpace,NoToneMapping,NormalAnimationBlendMode,NormalBlending,NotEqualCompare,NotEqualDepth,NotEqualStencilFunc,NumberKeyframeTrack,Object3D,ObjectLoader,ObjectSpaceNormalMap,OctahedronGeometry,OneFactor,OneMinusConstantAlphaFactor,OneMinusConstantColorFactor,OneMinusDstAlphaFactor,OneMinusDstColorFactor,OneMinusSrcAlphaFactor,OneMinusSrcColorFactor,OrthographicCamera:OrthographicCamera$1,P3Primaries,PCFShadowMap,PCFSoftShadowMap,PMREMGenerator,Path,PerspectiveCamera,Plane,PlaneGeometry,PlaneHelper,PointLight,PointLightHelper,Points,PointsMaterial,PolarGridHelper,PolyhedronGeometry,PositionalAudio,PropertyBinding,PropertyMixer,QuadraticBezierCurve,QuadraticBezierCurve3,Quaternion,QuaternionKeyframeTrack,QuaternionLinearInterpolant,RED_GREEN_RGTC2_Format,RED_RGTC1_Format,REVISION,RGBADepthPacking,RGBAFormat,RGBAIntegerFormat,RGBA_ASTC_10x10_Format,RGBA_ASTC_10x5_Format,RGBA_ASTC_10x6_Format,RGBA_ASTC_10x8_Format,RGBA_ASTC_12x10_Format,RGBA_ASTC_12x12_Format,RGBA_ASTC_4x4_Format,RGBA_ASTC_5x4_Format,RGBA_ASTC_5x5_Format,RGBA_ASTC_6x5_Format,RGBA_ASTC_6x6_Format,RGBA_ASTC_8x5_Format,RGBA_ASTC_8x6_Format,RGBA_ASTC_8x8_Format,RGBA_BPTC_Format,RGBA_ETC2_EAC_Format,RGBA_PVRTC_2BPPV1_Format,RGBA_PVRTC_4BPPV1_Format,RGBA_S3TC_DXT1_Format,RGBA_S3TC_DXT3_Format,RGBA_S3TC_DXT5_Format,RGBFormat,RGBIntegerFormat,RGB_BPTC_SIGNED_Format,RGB_BPTC_UNSIGNED_Format,RGB_ETC1_Format,RGB_ETC2_Format,RGB_PVRTC_2BPPV1_Format,RGB_PVRTC_4BPPV1_Format,RGB_S3TC_DXT1_Format,RGFormat,RGIntegerFormat,RawShaderMaterial,Ray,Raycaster,Rec709Primaries,RectAreaLight,RedFormat,RedIntegerFormat,ReinhardToneMapping,RenderTarget,RepeatWrapping,ReplaceStencilOp,ReverseSubtractEquation,RingGeometry,SIGNED_RED_GREEN_RGTC2_Format,SIGNED_RED_RGTC1_Format,SRGBColorSpace,SRGBTransfer,Scene:Scene$1,ShaderChunk,ShaderLib,ShaderMaterial,ShadowMaterial,Shape,ShapeGeometry,ShapePath,ShapeUtils,ShortType,Skeleton,SkeletonHelper,SkinnedMesh,Source,Sphere,SphereGeometry,Spherical,SphericalHarmonics3,SplineCurve,SpotLight,SpotLightHelper,Sprite,SpriteMaterial,SrcAlphaFactor,SrcAlphaSaturateFactor,SrcColorFactor,StaticCopyUsage,StaticDrawUsage,StaticReadUsage,StereoCamera,StreamCopyUsage,StreamDrawUsage,StreamReadUsage,StringKeyframeTrack,SubtractEquation,SubtractiveBlending,TOUCH,TangentSpaceNormalMap,TetrahedronGeometry,Texture,TextureLoader,TextureUtils,TorusGeometry,TorusKnotGeometry,Triangle,TriangleFanDrawMode,TriangleStripDrawMode,TrianglesDrawMode,TubeGeometry,UVMapping,Uint16BufferAttribute,Uint32BufferAttribute,Uint8BufferAttribute,Uint8ClampedBufferAttribute,Uniform,UniformsGroup,UniformsLib,UniformsUtils,UnsignedByteType,UnsignedInt248Type,UnsignedInt5999Type,UnsignedIntType,UnsignedShort4444Type,UnsignedShort5551Type,UnsignedShortType,VSMShadowMap,Vector2,Vector3,Vector4,VectorKeyframeTrack,VideoTexture,WebGL3DRenderTarget,WebGLArrayRenderTarget,WebGLCoordinateSystem,WebGLCubeRenderTarget,WebGLMultipleRenderTargets,WebGLRenderTarget,WebGLRenderer,WebGLUtils,WebGPUCoordinateSystem,WireframeGeometry,WrapAroundEnding,ZeroCurvatureEnding,ZeroFactor,ZeroSlopeEnding,ZeroStencilOp,createCanvasElement},Symbol.toStringTag,{value:"Module"}));var constants={exports:{}},reactReconcilerConstants_production_min={};/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */reactReconcilerConstants_production_min.ConcurrentRoot=1;reactReconcilerConstants_production_min.ContinuousEventPriority=4;reactReconcilerConstants_production_min.DefaultEventPriority=16;reactReconcilerConstants_production_min.DiscreteEventPriority=1;reactReconcilerConstants_production_min.IdleEventPriority=536870912;reactReconcilerConstants_production_min.LegacyRoot=0;constants.exports=reactReconcilerConstants_production_min;var constantsExports=constants.exports;function createStore$1(et){let _;const _e=new Set,tt=(ut,dt)=>{const st=typeof ut=="function"?ut(_):ut;if(st!==_){const it=_;_=dt?st:Object.assign({},_,st),_e.forEach(ct=>ct(_,it))}},nt=()=>_,rt=(ut,dt=nt,st=Object.is)=>{console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");let it=dt(_);function ct(){const ft=dt(_);if(!st(it,ft)){const ht=it;ut(it=ft,ht)}}return _e.add(ct),()=>_e.delete(ct)},lt={setState:tt,getState:nt,subscribe:(ut,dt,st)=>dt||st?rt(ut,dt,st):(_e.add(ut),()=>_e.delete(ut)),destroy:()=>_e.clear()};return _=et(tt,nt,lt),lt}const isSSR=typeof window>"u"||!window.navigator||/ServerSideRendering|^Deno\//.test(window.navigator.userAgent),useIsomorphicLayoutEffect$1=isSSR?reactExports.useEffect:reactExports.useLayoutEffect;function create(et){const _=typeof et=="function"?createStore$1(et):et,_e=(tt=_.getState,nt=Object.is)=>{const[,rt]=reactExports.useReducer(mt=>mt+1,0),ot=_.getState(),at=reactExports.useRef(ot),lt=reactExports.useRef(tt),ut=reactExports.useRef(nt),dt=reactExports.useRef(!1),st=reactExports.useRef();st.current===void 0&&(st.current=tt(ot));let it,ct=!1;(at.current!==ot||lt.current!==tt||ut.current!==nt||dt.current)&&(it=tt(ot),ct=!nt(st.current,it)),useIsomorphicLayoutEffect$1(()=>{ct&&(st.current=it),at.current=ot,lt.current=tt,ut.current=nt,dt.current=!1});const ft=reactExports.useRef(ot);useIsomorphicLayoutEffect$1(()=>{const mt=()=>{try{const _t=_.getState(),vt=lt.current(_t);ut.current(st.current,vt)||(at.current=_t,st.current=vt,rt())}catch{dt.current=!0,rt()}},pt=_.subscribe(mt);return _.getState()!==ft.current&&mt(),pt},[]);const ht=ct?it:st.current;return reactExports.useDebugValue(ht),ht};return Object.assign(_e,_),_e[Symbol.iterator]=function(){console.warn("[useStore, api] = create() is deprecated and will be removed in v4");const tt=[_e,_];return{next(){const nt=tt.length<=0;return{value:tt.shift(),done:nt}}}},_e}var reactReconciler={exports:{}},scheduler$1={exports:{}},scheduler_production_min$1={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredScheduler_production_min;function requireScheduler_production_min(){return hasRequiredScheduler_production_min||(hasRequiredScheduler_production_min=1,function(et){function _(Lt,zt){var Yt=Lt.length;Lt.push(zt);e:for(;0<Yt;){var en=Yt-1>>>1,bn=Lt[en];if(0<nt(bn,zt))Lt[en]=zt,Lt[Yt]=bn,Yt=en;else break e}}function _e(Lt){return Lt.length===0?null:Lt[0]}function tt(Lt){if(Lt.length===0)return null;var zt=Lt[0],Yt=Lt.pop();if(Yt!==zt){Lt[0]=Yt;e:for(var en=0,bn=Lt.length,Un=bn>>>1;en<Un;){var mn=2*(en+1)-1,vn=Lt[mn],In=mn+1,Cn=Lt[In];if(0>nt(vn,Yt))In<bn&&0>nt(Cn,vn)?(Lt[en]=Cn,Lt[In]=Yt,en=In):(Lt[en]=vn,Lt[mn]=Yt,en=mn);else if(In<bn&&0>nt(Cn,Yt))Lt[en]=Cn,Lt[In]=Yt,en=In;else break e}}return zt}function nt(Lt,zt){var Yt=Lt.sortIndex-zt.sortIndex;return Yt!==0?Yt:Lt.id-zt.id}if(typeof performance=="object"&&typeof performance.now=="function"){var rt=performance;et.unstable_now=function(){return rt.now()}}else{var ot=Date,at=ot.now();et.unstable_now=function(){return ot.now()-at}}var lt=[],ut=[],dt=1,st=null,it=3,ct=!1,ft=!1,ht=!1,mt=typeof setTimeout=="function"?setTimeout:null,pt=typeof clearTimeout=="function"?clearTimeout:null,_t=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function vt(Lt){for(var zt=_e(ut);zt!==null;){if(zt.callback===null)tt(ut);else if(zt.startTime<=Lt)tt(ut),zt.sortIndex=zt.expirationTime,_(lt,zt);else break;zt=_e(ut)}}function bt(Lt){if(ht=!1,vt(Lt),!ft)if(_e(lt)!==null)ft=!0,Ot(wt);else{var zt=_e(ut);zt!==null&&Ut(bt,zt.startTime-Lt)}}function wt(Lt,zt){ft=!1,ht&&(ht=!1,pt(At),At=-1),ct=!0;var Yt=it;try{for(vt(zt),st=_e(lt);st!==null&&(!(st.expirationTime>zt)||Lt&&!Ct());){var en=st.callback;if(typeof en=="function"){st.callback=null,it=st.priorityLevel;var bn=en(st.expirationTime<=zt);zt=et.unstable_now(),typeof bn=="function"?st.callback=bn:st===_e(lt)&&tt(lt),vt(zt)}else tt(lt);st=_e(lt)}if(st!==null)var Un=!0;else{var mn=_e(ut);mn!==null&&Ut(bt,mn.startTime-zt),Un=!1}return Un}finally{st=null,it=Yt,ct=!1}}var xt=!1,Mt=null,At=-1,St=5,Tt=-1;function Ct(){return!(et.unstable_now()-Tt<St)}function It(){if(Mt!==null){var Lt=et.unstable_now();Tt=Lt;var zt=!0;try{zt=Mt(!0,Lt)}finally{zt?$t():(xt=!1,Mt=null)}}else xt=!1}var $t;if(typeof _t=="function")$t=function(){_t(It)};else if(typeof MessageChannel<"u"){var Nt=new MessageChannel,Bt=Nt.port2;Nt.port1.onmessage=It,$t=function(){Bt.postMessage(null)}}else $t=function(){mt(It,0)};function Ot(Lt){Mt=Lt,xt||(xt=!0,$t())}function Ut(Lt,zt){At=mt(function(){Lt(et.unstable_now())},zt)}et.unstable_IdlePriority=5,et.unstable_ImmediatePriority=1,et.unstable_LowPriority=4,et.unstable_NormalPriority=3,et.unstable_Profiling=null,et.unstable_UserBlockingPriority=2,et.unstable_cancelCallback=function(Lt){Lt.callback=null},et.unstable_continueExecution=function(){ft||ct||(ft=!0,Ot(wt))},et.unstable_forceFrameRate=function(Lt){0>Lt||125<Lt?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):St=0<Lt?Math.floor(1e3/Lt):5},et.unstable_getCurrentPriorityLevel=function(){return it},et.unstable_getFirstCallbackNode=function(){return _e(lt)},et.unstable_next=function(Lt){switch(it){case 1:case 2:case 3:var zt=3;break;default:zt=it}var Yt=it;it=zt;try{return Lt()}finally{it=Yt}},et.unstable_pauseExecution=function(){},et.unstable_requestPaint=function(){},et.unstable_runWithPriority=function(Lt,zt){switch(Lt){case 1:case 2:case 3:case 4:case 5:break;default:Lt=3}var Yt=it;it=Lt;try{return zt()}finally{it=Yt}},et.unstable_scheduleCallback=function(Lt,zt,Yt){var en=et.unstable_now();switch(typeof Yt=="object"&&Yt!==null?(Yt=Yt.delay,Yt=typeof Yt=="number"&&0<Yt?en+Yt:en):Yt=en,Lt){case 1:var bn=-1;break;case 2:bn=250;break;case 5:bn=1073741823;break;case 4:bn=1e4;break;default:bn=5e3}return bn=Yt+bn,Lt={id:dt++,callback:zt,priorityLevel:Lt,startTime:Yt,expirationTime:bn,sortIndex:-1},Yt>en?(Lt.sortIndex=Yt,_(ut,Lt),_e(lt)===null&&Lt===_e(ut)&&(ht?(pt(At),At=-1):ht=!0,Ut(bt,Yt-en))):(Lt.sortIndex=bn,_(lt,Lt),ft||ct||(ft=!0,Ot(wt))),Lt},et.unstable_shouldYield=Ct,et.unstable_wrapCallback=function(Lt){var zt=it;return function(){var Yt=it;it=zt;try{return Lt.apply(this,arguments)}finally{it=Yt}}}}(scheduler_production_min$1)),scheduler_production_min$1}var hasRequiredScheduler;function requireScheduler(){return hasRequiredScheduler||(hasRequiredScheduler=1,scheduler$1.exports=requireScheduler_production_min()),scheduler$1.exports}/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var reactReconciler_production_min=function(_){var _e={},tt=reactExports,nt=requireScheduler(),rt=Object.assign;function ot(gt){for(var yt="https://reactjs.org/docs/error-decoder.html?invariant="+gt,Et=1;Et<arguments.length;Et++)yt+="&args[]="+encodeURIComponent(arguments[Et]);return"Minified React error #"+gt+"; visit "+yt+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var at=tt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,lt=Symbol.for("react.element"),ut=Symbol.for("react.portal"),dt=Symbol.for("react.fragment"),st=Symbol.for("react.strict_mode"),it=Symbol.for("react.profiler"),ct=Symbol.for("react.provider"),ft=Symbol.for("react.context"),ht=Symbol.for("react.forward_ref"),mt=Symbol.for("react.suspense"),pt=Symbol.for("react.suspense_list"),_t=Symbol.for("react.memo"),vt=Symbol.for("react.lazy"),bt=Symbol.for("react.offscreen"),wt=Symbol.iterator;function xt(gt){return gt===null||typeof gt!="object"?null:(gt=wt&&gt[wt]||gt["@@iterator"],typeof gt=="function"?gt:null)}function Mt(gt){if(gt==null)return null;if(typeof gt=="function")return gt.displayName||gt.name||null;if(typeof gt=="string")return gt;switch(gt){case dt:return"Fragment";case ut:return"Portal";case it:return"Profiler";case st:return"StrictMode";case mt:return"Suspense";case pt:return"SuspenseList"}if(typeof gt=="object")switch(gt.$$typeof){case ft:return(gt.displayName||"Context")+".Consumer";case ct:return(gt._context.displayName||"Context")+".Provider";case ht:var yt=gt.render;return gt=gt.displayName,gt||(gt=yt.displayName||yt.name||"",gt=gt!==""?"ForwardRef("+gt+")":"ForwardRef"),gt;case _t:return yt=gt.displayName||null,yt!==null?yt:Mt(gt.type)||"Memo";case vt:yt=gt._payload,gt=gt._init;try{return Mt(gt(yt))}catch{}}return null}function At(gt){var yt=gt.type;switch(gt.tag){case 24:return"Cache";case 9:return(yt.displayName||"Context")+".Consumer";case 10:return(yt._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return gt=yt.render,gt=gt.displayName||gt.name||"",yt.displayName||(gt!==""?"ForwardRef("+gt+")":"ForwardRef");case 7:return"Fragment";case 5:return yt;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Mt(yt);case 8:return yt===st?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof yt=="function")return yt.displayName||yt.name||null;if(typeof yt=="string")return yt}return null}function St(gt){var yt=gt,Et=gt;if(gt.alternate)for(;yt.return;)yt=yt.return;else{gt=yt;do yt=gt,yt.flags&4098&&(Et=yt.return),gt=yt.return;while(gt)}return yt.tag===3?Et:null}function Tt(gt){if(St(gt)!==gt)throw Error(ot(188))}function Ct(gt){var yt=gt.alternate;if(!yt){if(yt=St(gt),yt===null)throw Error(ot(188));return yt!==gt?null:gt}for(var Et=gt,Pt=yt;;){var Rt=Et.return;if(Rt===null)break;var kt=Rt.alternate;if(kt===null){if(Pt=Rt.return,Pt!==null){Et=Pt;continue}break}if(Rt.child===kt.child){for(kt=Rt.child;kt;){if(kt===Et)return Tt(Rt),gt;if(kt===Pt)return Tt(Rt),yt;kt=kt.sibling}throw Error(ot(188))}if(Et.return!==Pt.return)Et=Rt,Pt=kt;else{for(var tn=!1,gn=Rt.child;gn;){if(gn===Et){tn=!0,Et=Rt,Pt=kt;break}if(gn===Pt){tn=!0,Pt=Rt,Et=kt;break}gn=gn.sibling}if(!tn){for(gn=kt.child;gn;){if(gn===Et){tn=!0,Et=kt,Pt=Rt;break}if(gn===Pt){tn=!0,Pt=kt,Et=Rt;break}gn=gn.sibling}if(!tn)throw Error(ot(189))}}if(Et.alternate!==Pt)throw Error(ot(190))}if(Et.tag!==3)throw Error(ot(188));return Et.stateNode.current===Et?gt:yt}function It(gt){return gt=Ct(gt),gt!==null?$t(gt):null}function $t(gt){if(gt.tag===5||gt.tag===6)return gt;for(gt=gt.child;gt!==null;){var yt=$t(gt);if(yt!==null)return yt;gt=gt.sibling}return null}function Nt(gt){if(gt.tag===5||gt.tag===6)return gt;for(gt=gt.child;gt!==null;){if(gt.tag!==4){var yt=Nt(gt);if(yt!==null)return yt}gt=gt.sibling}return null}var Bt=Array.isArray,Ot=_.getPublicInstance,Ut=_.getRootHostContext,Lt=_.getChildHostContext,zt=_.prepareForCommit,Yt=_.resetAfterCommit,en=_.createInstance,bn=_.appendInitialChild,Un=_.finalizeInitialChildren,mn=_.prepareUpdate,vn=_.shouldSetTextContent,In=_.createTextInstance,Cn=_.scheduleTimeout,En=_.cancelTimeout,jt=_.noTimeout,Kt=_.isPrimaryRenderer,nn=_.supportsMutation,Vt=_.supportsPersistence,on=_.supportsHydration,dn=_.getInstanceFromNode,Ln=_.preparePortalMount,Sn=_.getCurrentEventPriority,Xn=_.detachDeletedInstance,Vn=_.supportsMicrotasks,Hn=_.scheduleMicrotask,Zt=_.supportsTestSelectors,Gt=_.findFiberRoot,fn=_.getBoundingRect,hn=_.getTextContent,xn=_.isHiddenSubtree,Tn=_.matchAccessibilityRole,sr=_.setFocusIfFocusable,Wn=_.setupIntersectionObserver,or=_.appendChild,fr=_.appendChildToContainer,Gn=_.commitTextUpdate,nr=_.commitMount,mr=_.commitUpdate,hr=_.insertBefore,Bn=_.insertInContainerBefore,cn=_.removeChild,Fn=_.removeChildFromContainer,ir=_.resetTextContent,ln=_.hideInstance,On=_.hideTextInstance,Dn=_.unhideInstance,$n=_.unhideTextInstance,Jn=_.clearContainer,qn=_.cloneInstance,Kn=_.createContainerChildSet,ar=_.appendChildToContainerChildSet,Ur=_.finalizeContainerChildren,wr=_.replaceContainerChildren,Hr=_.cloneHiddenInstance,Wr=_.cloneHiddenTextInstance,jo=_.canHydrateInstance,go=_.canHydrateTextInstance,Uo=_.canHydrateSuspenseInstance,zo=_.isSuspenseInstancePending,Co=_.isSuspenseInstanceFallback,Ro=_.registerSuspenseInstanceRetry,vo=_.getNextHydratableSibling,Oo=_.getFirstHydratableChild,Ho=_.getFirstHydratableChildWithinContainer,Wo=_.getFirstHydratableChildWithinSuspenseInstance,Wt=_.hydrateInstance,rn=_.hydrateTextInstance,pn=_.hydrateSuspenseInstance,Dt=_.getNextHydratableInstanceAfterSuspenseInstance,Xt=_.commitHydratedContainer,Jt=_.commitHydratedSuspenseInstance,sn=_.clearSuspenseBoundary,an=_.clearSuspenseBoundaryFromContainer,Mn=_.shouldDeleteUnhydratedTailInstances,zn=_.didNotMatchHydratedContainerTextInstance,Qn=_.didNotMatchHydratedTextInstance,rr;function cr(gt){if(rr===void 0)try{throw Error()}catch(Et){var yt=Et.stack.trim().match(/\n( *(at )?)/);rr=yt&&yt[1]||""}return`
`+rr+gt}var _n=!1;function Zn(gt,yt){if(!gt||_n)return"";_n=!0;var Et=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(yt)if(yt=function(){throw Error()},Object.defineProperty(yt.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(yt,[])}catch(er){var Pt=er}Reflect.construct(gt,[],yt)}else{try{yt.call()}catch(er){Pt=er}gt.call(yt.prototype)}else{try{throw Error()}catch(er){Pt=er}gt()}}catch(er){if(er&&Pt&&typeof er.stack=="string"){for(var Rt=er.stack.split(`
`),kt=Pt.stack.split(`
`),tn=Rt.length-1,gn=kt.length-1;1<=tn&&0<=gn&&Rt[tn]!==kt[gn];)gn--;for(;1<=tn&&0<=gn;tn--,gn--)if(Rt[tn]!==kt[gn]){if(tn!==1||gn!==1)do if(tn--,gn--,0>gn||Rt[tn]!==kt[gn]){var Nn=`
`+Rt[tn].replace(" at new "," at ");return gt.displayName&&Nn.includes("<anonymous>")&&(Nn=Nn.replace("<anonymous>",gt.displayName)),Nn}while(1<=tn&&0<=gn);break}}}finally{_n=!1,Error.prepareStackTrace=Et}return(gt=gt?gt.displayName||gt.name:"")?cr(gt):""}var _r=Object.prototype.hasOwnProperty,Ir=[],Lr=-1;function jr(gt){return{current:gt}}function gr(gt){0>Lr||(gt.current=Ir[Lr],Ir[Lr]=null,Lr--)}function tr(gt,yt){Lr++,Ir[Lr]=gt.current,gt.current=yt}var Pr={},br=jr(Pr),zr=jr(!1),ao=Pr;function Yr(gt,yt){var Et=gt.type.contextTypes;if(!Et)return Pr;var Pt=gt.stateNode;if(Pt&&Pt.__reactInternalMemoizedUnmaskedChildContext===yt)return Pt.__reactInternalMemoizedMaskedChildContext;var Rt={},kt;for(kt in Et)Rt[kt]=yt[kt];return Pt&&(gt=gt.stateNode,gt.__reactInternalMemoizedUnmaskedChildContext=yt,gt.__reactInternalMemoizedMaskedChildContext=Rt),Rt}function eo(gt){return gt=gt.childContextTypes,gt!=null}function Vr(){gr(zr),gr(br)}function co(gt,yt,Et){if(br.current!==Pr)throw Error(ot(168));tr(br,yt),tr(zr,Et)}function qo(gt,yt,Et){var Pt=gt.stateNode;if(yt=yt.childContextTypes,typeof Pt.getChildContext!="function")return Et;Pt=Pt.getChildContext();for(var Rt in Pt)if(!(Rt in yt))throw Error(ot(108,At(gt)||"Unknown",Rt));return rt({},Et,Pt)}function to(gt){return gt=(gt=gt.stateNode)&&gt.__reactInternalMemoizedMergedChildContext||Pr,ao=br.current,tr(br,gt),tr(zr,zr.current),!0}function Jo(gt,yt,Et){var Pt=gt.stateNode;if(!Pt)throw Error(ot(169));Et?(gt=qo(gt,yt,ao),Pt.__reactInternalMemoizedMergedChildContext=gt,gr(zr),gr(br),tr(br,gt)):gr(zr),tr(zr,Et)}var uo=Math.clz32?Math.clz32:El,gs=Math.log,Cs=Math.LN2;function El(gt){return gt>>>=0,gt===0?32:31-(gs(gt)/Cs|0)|0}var _s=64,ss=4194304;function as(gt){switch(gt&-gt){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return gt&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return gt&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return gt}}function Tr(gt,yt){var Et=gt.pendingLanes;if(Et===0)return 0;var Pt=0,Rt=gt.suspendedLanes,kt=gt.pingedLanes,tn=Et&268435455;if(tn!==0){var gn=tn&~Rt;gn!==0?Pt=as(gn):(kt&=tn,kt!==0&&(Pt=as(kt)))}else tn=Et&~Rt,tn!==0?Pt=as(tn):kt!==0&&(Pt=as(kt));if(Pt===0)return 0;if(yt!==0&&yt!==Pt&&!(yt&Rt)&&(Rt=Pt&-Pt,kt=yt&-yt,Rt>=kt||Rt===16&&(kt&4194240)!==0))return yt;if(Pt&4&&(Pt|=Et&16),yt=gt.entangledLanes,yt!==0)for(gt=gt.entanglements,yt&=Pt;0<yt;)Et=31-uo(yt),Rt=1<<Et,Pt|=gt[Et],yt&=~Rt;return Pt}function Ml(gt,yt){switch(gt){case 1:case 2:case 4:return yt+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return yt+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Cr(gt,yt){for(var Et=gt.suspendedLanes,Pt=gt.pingedLanes,Rt=gt.expirationTimes,kt=gt.pendingLanes;0<kt;){var tn=31-uo(kt),gn=1<<tn,Nn=Rt[tn];Nn===-1?(!(gn&Et)||gn&Pt)&&(Rt[tn]=Ml(gn,yt)):Nn<=yt&&(gt.expiredLanes|=gn),kt&=~gn}}function Sr(gt){return gt=gt.pendingLanes&-1073741825,gt!==0?gt:gt&1073741824?1073741824:0}function ys(gt){for(var yt=[],Et=0;31>Et;Et++)yt.push(gt);return yt}function Xo(gt,yt,Et){gt.pendingLanes|=yt,yt!==536870912&&(gt.suspendedLanes=0,gt.pingedLanes=0),gt=gt.eventTimes,yt=31-uo(yt),gt[yt]=Et}function Al(gt,yt){var Et=gt.pendingLanes&~yt;gt.pendingLanes=yt,gt.suspendedLanes=0,gt.pingedLanes=0,gt.expiredLanes&=yt,gt.mutableReadLanes&=yt,gt.entangledLanes&=yt,yt=gt.entanglements;var Pt=gt.eventTimes;for(gt=gt.expirationTimes;0<Et;){var Rt=31-uo(Et),kt=1<<Rt;yt[Rt]=0,Pt[Rt]=-1,gt[Rt]=-1,Et&=~kt}}function Rs(gt,yt){var Et=gt.entangledLanes|=yt;for(gt=gt.entanglements;Et;){var Pt=31-uo(Et),Rt=1<<Pt;Rt&yt|gt[Pt]&yt&&(gt[Pt]|=yt),Et&=~Rt}}var Nr=0;function Ws(gt){return gt&=-gt,1<gt?4<gt?gt&268435455?16:536870912:4:1}var Os=nt.unstable_scheduleCallback,qs=nt.unstable_cancelCallback,Pl=nt.unstable_shouldYield,Cl=nt.unstable_requestPaint,Zr=nt.unstable_now,Is=nt.unstable_ImmediatePriority,Rl=nt.unstable_UserBlockingPriority,Ls=nt.unstable_NormalPriority,Ft=nt.unstable_IdlePriority,Ht=null,Qt=null;function un(gt){if(Qt&&typeof Qt.onCommitFiberRoot=="function")try{Qt.onCommitFiberRoot(Ht,gt,void 0,(gt.current.flags&128)===128)}catch{}}function wn(gt,yt){return gt===yt&&(gt!==0||1/gt===1/yt)||gt!==gt&&yt!==yt}var Pn=typeof Object.is=="function"?Object.is:wn,Yn=null,pr=!1,Ar=!1;function Rr(gt){Yn===null?Yn=[gt]:Yn.push(gt)}function qr(gt){pr=!0,Rr(gt)}function Jr(){if(!Ar&&Yn!==null){Ar=!0;var gt=0,yt=Nr;try{var Et=Yn;for(Nr=1;gt<Et.length;gt++){var Pt=Et[gt];do Pt=Pt(!0);while(Pt!==null)}Yn=null,pr=!1}catch(Rt){throw Yn!==null&&(Yn=Yn.slice(gt+1)),Os(Is,Jr),Rt}finally{Nr=yt,Ar=!1}}return null}var bo=at.ReactCurrentBatchConfig;function Rn(gt,yt){if(Pn(gt,yt))return!0;if(typeof gt!="object"||gt===null||typeof yt!="object"||yt===null)return!1;var Et=Object.keys(gt),Pt=Object.keys(yt);if(Et.length!==Pt.length)return!1;for(Pt=0;Pt<Et.length;Pt++){var Rt=Et[Pt];if(!_r.call(yt,Rt)||!Pn(gt[Rt],yt[Rt]))return!1}return!0}function Dr(gt){switch(gt.tag){case 5:return cr(gt.type);case 16:return cr("Lazy");case 13:return cr("Suspense");case 19:return cr("SuspenseList");case 0:case 2:case 15:return gt=Zn(gt.type,!1),gt;case 11:return gt=Zn(gt.type.render,!1),gt;case 1:return gt=Zn(gt.type,!0),gt;default:return""}}function Fr(gt,yt){if(gt&&gt.defaultProps){yt=rt({},yt),gt=gt.defaultProps;for(var Et in gt)yt[Et]===void 0&&(yt[Et]=gt[Et]);return yt}return yt}var xo=jr(null),Vo=null,ks=null,_u=null;function yu(){_u=ks=Vo=null}function dp(gt,yt,Et){Kt?(tr(xo,yt._currentValue),yt._currentValue=Et):(tr(xo,yt._currentValue2),yt._currentValue2=Et)}function vu(gt){var yt=xo.current;gr(xo),Kt?gt._currentValue=yt:gt._currentValue2=yt}function bu(gt,yt,Et){for(;gt!==null;){var Pt=gt.alternate;if((gt.childLanes&yt)!==yt?(gt.childLanes|=yt,Pt!==null&&(Pt.childLanes|=yt)):Pt!==null&&(Pt.childLanes&yt)!==yt&&(Pt.childLanes|=yt),gt===Et)break;gt=gt.return}}function Ds(gt,yt){Vo=gt,_u=ks=null,gt=gt.dependencies,gt!==null&&gt.firstContext!==null&&(gt.lanes&yt&&(Ao=!0),gt.firstContext=null)}function Io(gt){var yt=Kt?gt._currentValue:gt._currentValue2;if(_u!==gt)if(gt={context:gt,memoizedValue:yt,next:null},ks===null){if(Vo===null)throw Error(ot(308));ks=gt,Vo.dependencies={lanes:0,firstContext:gt}}else ks=ks.next=gt;return yt}var Yo=null,ls=!1;function xu(gt){gt.updateQueue={baseState:gt.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function fp(gt,yt){gt=gt.updateQueue,yt.updateQueue===gt&&(yt.updateQueue={baseState:gt.baseState,firstBaseUpdate:gt.firstBaseUpdate,lastBaseUpdate:gt.lastBaseUpdate,shared:gt.shared,effects:gt.effects})}function es(gt,yt){return{eventTime:gt,lane:yt,tag:0,payload:null,callback:null,next:null}}function cs(gt,yt){var Et=gt.updateQueue;Et!==null&&(Et=Et.shared,no!==null&&gt.mode&1&&!(kr&2)?(gt=Et.interleaved,gt===null?(yt.next=yt,Yo===null?Yo=[Et]:Yo.push(Et)):(yt.next=gt.next,gt.next=yt),Et.interleaved=yt):(gt=Et.pending,gt===null?yt.next=yt:(yt.next=gt.next,gt.next=yt),Et.pending=yt))}function Ol(gt,yt,Et){if(yt=yt.updateQueue,yt!==null&&(yt=yt.shared,(Et&4194240)!==0)){var Pt=yt.lanes;Pt&=gt.pendingLanes,Et|=Pt,yt.lanes=Et,Rs(gt,Et)}}function hp(gt,yt){var Et=gt.updateQueue,Pt=gt.alternate;if(Pt!==null&&(Pt=Pt.updateQueue,Et===Pt)){var Rt=null,kt=null;if(Et=Et.firstBaseUpdate,Et!==null){do{var tn={eventTime:Et.eventTime,lane:Et.lane,tag:Et.tag,payload:Et.payload,callback:Et.callback,next:null};kt===null?Rt=kt=tn:kt=kt.next=tn,Et=Et.next}while(Et!==null);kt===null?Rt=kt=yt:kt=kt.next=yt}else Rt=kt=yt;Et={baseState:Pt.baseState,firstBaseUpdate:Rt,lastBaseUpdate:kt,shared:Pt.shared,effects:Pt.effects},gt.updateQueue=Et;return}gt=Et.lastBaseUpdate,gt===null?Et.firstBaseUpdate=yt:gt.next=yt,Et.lastBaseUpdate=yt}function Il(gt,yt,Et,Pt){var Rt=gt.updateQueue;ls=!1;var kt=Rt.firstBaseUpdate,tn=Rt.lastBaseUpdate,gn=Rt.shared.pending;if(gn!==null){Rt.shared.pending=null;var Nn=gn,er=Nn.next;Nn.next=null,tn===null?kt=er:tn.next=er,tn=Nn;var dr=gt.alternate;dr!==null&&(dr=dr.updateQueue,gn=dr.lastBaseUpdate,gn!==tn&&(gn===null?dr.firstBaseUpdate=er:gn.next=er,dr.lastBaseUpdate=Nn))}if(kt!==null){var Er=Rt.baseState;tn=0,dr=er=Nn=null,gn=kt;do{var xr=gn.lane,Gr=gn.eventTime;if((Pt&xr)===xr){dr!==null&&(dr=dr.next={eventTime:Gr,lane:0,tag:gn.tag,payload:gn.payload,callback:gn.callback,next:null});e:{var vr=gt,mo=gn;switch(xr=yt,Gr=Et,mo.tag){case 1:if(vr=mo.payload,typeof vr=="function"){Er=vr.call(Gr,Er,xr);break e}Er=vr;break e;case 3:vr.flags=vr.flags&-65537|128;case 0:if(vr=mo.payload,xr=typeof vr=="function"?vr.call(Gr,Er,xr):vr,xr==null)break e;Er=rt({},Er,xr);break e;case 2:ls=!0}}gn.callback!==null&&gn.lane!==0&&(gt.flags|=64,xr=Rt.effects,xr===null?Rt.effects=[gn]:xr.push(gn))}else Gr={eventTime:Gr,lane:xr,tag:gn.tag,payload:gn.payload,callback:gn.callback,next:null},dr===null?(er=dr=Gr,Nn=Er):dr=dr.next=Gr,tn|=xr;if(gn=gn.next,gn===null){if(gn=Rt.shared.pending,gn===null)break;xr=gn,gn=xr.next,xr.next=null,Rt.lastBaseUpdate=xr,Rt.shared.pending=null}}while(!0);if(dr===null&&(Nn=Er),Rt.baseState=Nn,Rt.firstBaseUpdate=er,Rt.lastBaseUpdate=dr,yt=Rt.shared.interleaved,yt!==null){Rt=yt;do tn|=Rt.lane,Rt=Rt.next;while(Rt!==yt)}else kt===null&&(Rt.shared.lanes=0);js|=tn,gt.lanes=tn,gt.memoizedState=Er}}function pp(gt,yt,Et){if(gt=yt.effects,yt.effects=null,gt!==null)for(yt=0;yt<gt.length;yt++){var Pt=gt[yt],Rt=Pt.callback;if(Rt!==null){if(Pt.callback=null,Pt=Et,typeof Rt!="function")throw Error(ot(191,Rt));Rt.call(Pt)}}}var mp=new tt.Component().refs;function wu(gt,yt,Et,Pt){yt=gt.memoizedState,Et=Et(Pt,yt),Et=Et==null?yt:rt({},yt,Et),gt.memoizedState=Et,gt.lanes===0&&(gt.updateQueue.baseState=Et)}var Ll={isMounted:function(gt){return(gt=gt._reactInternals)?St(gt)===gt:!1},enqueueSetState:function(gt,yt,Et){gt=gt._reactInternals;var Pt=yo(),Rt=fs(gt),kt=es(Pt,Rt);kt.payload=yt,Et!=null&&(kt.callback=Et),cs(gt,kt),yt=Fo(gt,Rt,Pt),yt!==null&&Ol(yt,gt,Rt)},enqueueReplaceState:function(gt,yt,Et){gt=gt._reactInternals;var Pt=yo(),Rt=fs(gt),kt=es(Pt,Rt);kt.tag=1,kt.payload=yt,Et!=null&&(kt.callback=Et),cs(gt,kt),yt=Fo(gt,Rt,Pt),yt!==null&&Ol(yt,gt,Rt)},enqueueForceUpdate:function(gt,yt){gt=gt._reactInternals;var Et=yo(),Pt=fs(gt),Rt=es(Et,Pt);Rt.tag=2,yt!=null&&(Rt.callback=yt),cs(gt,Rt),yt=Fo(gt,Pt,Et),yt!==null&&Ol(yt,gt,Pt)}};function gp(gt,yt,Et,Pt,Rt,kt,tn){return gt=gt.stateNode,typeof gt.shouldComponentUpdate=="function"?gt.shouldComponentUpdate(Pt,kt,tn):yt.prototype&&yt.prototype.isPureReactComponent?!Rn(Et,Pt)||!Rn(Rt,kt):!0}function _p(gt,yt,Et){var Pt=!1,Rt=Pr,kt=yt.contextType;return typeof kt=="object"&&kt!==null?kt=Io(kt):(Rt=eo(yt)?ao:br.current,Pt=yt.contextTypes,kt=(Pt=Pt!=null)?Yr(gt,Rt):Pr),yt=new yt(Et,kt),gt.memoizedState=yt.state!==null&&yt.state!==void 0?yt.state:null,yt.updater=Ll,gt.stateNode=yt,yt._reactInternals=gt,Pt&&(gt=gt.stateNode,gt.__reactInternalMemoizedUnmaskedChildContext=Rt,gt.__reactInternalMemoizedMaskedChildContext=kt),yt}function yp(gt,yt,Et,Pt){gt=yt.state,typeof yt.componentWillReceiveProps=="function"&&yt.componentWillReceiveProps(Et,Pt),typeof yt.UNSAFE_componentWillReceiveProps=="function"&&yt.UNSAFE_componentWillReceiveProps(Et,Pt),yt.state!==gt&&Ll.enqueueReplaceState(yt,yt.state,null)}function Su(gt,yt,Et,Pt){var Rt=gt.stateNode;Rt.props=Et,Rt.state=gt.memoizedState,Rt.refs=mp,xu(gt);var kt=yt.contextType;typeof kt=="object"&&kt!==null?Rt.context=Io(kt):(kt=eo(yt)?ao:br.current,Rt.context=Yr(gt,kt)),Rt.state=gt.memoizedState,kt=yt.getDerivedStateFromProps,typeof kt=="function"&&(wu(gt,yt,kt,Et),Rt.state=gt.memoizedState),typeof yt.getDerivedStateFromProps=="function"||typeof Rt.getSnapshotBeforeUpdate=="function"||typeof Rt.UNSAFE_componentWillMount!="function"&&typeof Rt.componentWillMount!="function"||(yt=Rt.state,typeof Rt.componentWillMount=="function"&&Rt.componentWillMount(),typeof Rt.UNSAFE_componentWillMount=="function"&&Rt.UNSAFE_componentWillMount(),yt!==Rt.state&&Ll.enqueueReplaceState(Rt,Rt.state,null),Il(gt,Et,Rt,Pt),Rt.state=gt.memoizedState),typeof Rt.componentDidMount=="function"&&(gt.flags|=4194308)}var Ns=[],Fs=0,Dl=null,Nl=0,Lo=[],ko=0,vs=null,ts=1,ns="";function bs(gt,yt){Ns[Fs++]=Nl,Ns[Fs++]=Dl,Dl=gt,Nl=yt}function vp(gt,yt,Et){Lo[ko++]=ts,Lo[ko++]=ns,Lo[ko++]=vs,vs=gt;var Pt=ts;gt=ns;var Rt=32-uo(Pt)-1;Pt&=~(1<<Rt),Et+=1;var kt=32-uo(yt)+Rt;if(30<kt){var tn=Rt-Rt%5;kt=(Pt&(1<<tn)-1).toString(32),Pt>>=tn,Rt-=tn,ts=1<<32-uo(yt)+Rt|Et<<Rt|Pt,ns=kt+gt}else ts=1<<kt|Et<<Rt|Pt,ns=gt}function Tu(gt){gt.return!==null&&(bs(gt,1),vp(gt,1,0))}function Eu(gt){for(;gt===Dl;)Dl=Ns[--Fs],Ns[Fs]=null,Nl=Ns[--Fs],Ns[Fs]=null;for(;gt===vs;)vs=Lo[--ko],Lo[ko]=null,ns=Lo[--ko],Lo[ko]=null,ts=Lo[--ko],Lo[ko]=null}var Eo=null,Mo=null,Xr=!1,Xs=!1,Go=null;function bp(gt,yt){var Et=$o(5,null,null,0);Et.elementType="DELETED",Et.stateNode=yt,Et.return=gt,yt=gt.deletions,yt===null?(gt.deletions=[Et],gt.flags|=16):yt.push(Et)}function xp(gt,yt){switch(gt.tag){case 5:return yt=jo(yt,gt.type,gt.pendingProps),yt!==null?(gt.stateNode=yt,Eo=gt,Mo=Oo(yt),!0):!1;case 6:return yt=go(yt,gt.pendingProps),yt!==null?(gt.stateNode=yt,Eo=gt,Mo=null,!0):!1;case 13:if(yt=Uo(yt),yt!==null){var Et=vs!==null?{id:ts,overflow:ns}:null;return gt.memoizedState={dehydrated:yt,treeContext:Et,retryLane:1073741824},Et=$o(18,null,null,0),Et.stateNode=yt,Et.return=gt,gt.child=Et,Eo=gt,Mo=null,!0}return!1;default:return!1}}function Mu(gt){return(gt.mode&1)!==0&&(gt.flags&128)===0}function Au(gt){if(Xr){var yt=Mo;if(yt){var Et=yt;if(!xp(gt,yt)){if(Mu(gt))throw Error(ot(418));yt=vo(Et);var Pt=Eo;yt&&xp(gt,yt)?bp(Pt,Et):(gt.flags=gt.flags&-4097|2,Xr=!1,Eo=gt)}}else{if(Mu(gt))throw Error(ot(418));gt.flags=gt.flags&-4097|2,Xr=!1,Eo=gt}}}function wp(gt){for(gt=gt.return;gt!==null&&gt.tag!==5&&gt.tag!==3&&gt.tag!==13;)gt=gt.return;Eo=gt}function Ys(gt){if(!on||gt!==Eo)return!1;if(!Xr)return wp(gt),Xr=!0,!1;if(gt.tag!==3&&(gt.tag!==5||Mn(gt.type)&&!vn(gt.type,gt.memoizedProps))){var yt=Mo;if(yt){if(Mu(gt)){for(gt=Mo;gt;)gt=vo(gt);throw Error(ot(418))}for(;yt;)bp(gt,yt),yt=vo(yt)}}if(wp(gt),gt.tag===13){if(!on)throw Error(ot(316));if(gt=gt.memoizedState,gt=gt!==null?gt.dehydrated:null,!gt)throw Error(ot(317));Mo=Dt(gt)}else Mo=Eo?vo(gt.stateNode):null;return!0}function $s(){on&&(Mo=Eo=null,Xs=Xr=!1)}function Pu(gt){Go===null?Go=[gt]:Go.push(gt)}function Ks(gt,yt,Et){if(gt=Et.ref,gt!==null&&typeof gt!="function"&&typeof gt!="object"){if(Et._owner){if(Et=Et._owner,Et){if(Et.tag!==1)throw Error(ot(309));var Pt=Et.stateNode}if(!Pt)throw Error(ot(147,gt));var Rt=Pt,kt=""+gt;return yt!==null&&yt.ref!==null&&typeof yt.ref=="function"&&yt.ref._stringRef===kt?yt.ref:(yt=function(tn){var gn=Rt.refs;gn===mp&&(gn=Rt.refs={}),tn===null?delete gn[kt]:gn[kt]=tn},yt._stringRef=kt,yt)}if(typeof gt!="string")throw Error(ot(284));if(!Et._owner)throw Error(ot(290,gt))}return gt}function Fl(gt,yt){throw gt=Object.prototype.toString.call(yt),Error(ot(31,gt==="[object Object]"?"object with keys {"+Object.keys(yt).join(", ")+"}":gt))}function Sp(gt){var yt=gt._init;return yt(gt._payload)}function Tp(gt){function yt(An,yn){if(gt){var kn=An.deletions;kn===null?(An.deletions=[yn],An.flags|=16):kn.push(yn)}}function Et(An,yn){if(!gt)return null;for(;yn!==null;)yt(An,yn),yn=yn.sibling;return null}function Pt(An,yn){for(An=new Map;yn!==null;)yn.key!==null?An.set(yn.key,yn):An.set(yn.index,yn),yn=yn.sibling;return An}function Rt(An,yn){return An=ps(An,yn),An.index=0,An.sibling=null,An}function kt(An,yn,kn){return An.index=kn,gt?(kn=An.alternate,kn!==null?(kn=kn.index,kn<yn?(An.flags|=2,yn):kn):(An.flags|=2,yn)):(An.flags|=1048576,yn)}function tn(An){return gt&&An.alternate===null&&(An.flags|=2),An}function gn(An,yn,kn,ur){return yn===null||yn.tag!==6?(yn=lp(kn,An.mode,ur),yn.return=An,yn):(yn=Rt(yn,kn),yn.return=An,yn)}function Nn(An,yn,kn,ur){var yr=kn.type;return yr===dt?dr(An,yn,kn.props.children,ur,kn.key):yn!==null&&(yn.elementType===yr||typeof yr=="object"&&yr!==null&&yr.$$typeof===vt&&Sp(yr)===yn.type)?(ur=Rt(yn,kn.props),ur.ref=Ks(An,yn,kn),ur.return=An,ur):(ur=mu(kn.type,kn.key,kn.props,null,An.mode,ur),ur.ref=Ks(An,yn,kn),ur.return=An,ur)}function er(An,yn,kn,ur){return yn===null||yn.tag!==4||yn.stateNode.containerInfo!==kn.containerInfo||yn.stateNode.implementation!==kn.implementation?(yn=cp(kn,An.mode,ur),yn.return=An,yn):(yn=Rt(yn,kn.children||[]),yn.return=An,yn)}function dr(An,yn,kn,ur,yr){return yn===null||yn.tag!==7?(yn=As(kn,An.mode,ur,yr),yn.return=An,yn):(yn=Rt(yn,kn),yn.return=An,yn)}function Er(An,yn,kn){if(typeof yn=="string"&&yn!==""||typeof yn=="number")return yn=lp(""+yn,An.mode,kn),yn.return=An,yn;if(typeof yn=="object"&&yn!==null){switch(yn.$$typeof){case lt:return kn=mu(yn.type,yn.key,yn.props,null,An.mode,kn),kn.ref=Ks(An,null,yn),kn.return=An,kn;case ut:return yn=cp(yn,An.mode,kn),yn.return=An,yn;case vt:var ur=yn._init;return Er(An,ur(yn._payload),kn)}if(Bt(yn)||xt(yn))return yn=As(yn,An.mode,kn,null),yn.return=An,yn;Fl(An,yn)}return null}function xr(An,yn,kn,ur){var yr=yn!==null?yn.key:null;if(typeof kn=="string"&&kn!==""||typeof kn=="number")return yr!==null?null:gn(An,yn,""+kn,ur);if(typeof kn=="object"&&kn!==null){switch(kn.$$typeof){case lt:return kn.key===yr?Nn(An,yn,kn,ur):null;case ut:return kn.key===yr?er(An,yn,kn,ur):null;case vt:return yr=kn._init,xr(An,yn,yr(kn._payload),ur)}if(Bt(kn)||xt(kn))return yr!==null?null:dr(An,yn,kn,ur,null);Fl(An,kn)}return null}function Gr(An,yn,kn,ur,yr){if(typeof ur=="string"&&ur!==""||typeof ur=="number")return An=An.get(kn)||null,gn(yn,An,""+ur,yr);if(typeof ur=="object"&&ur!==null){switch(ur.$$typeof){case lt:return An=An.get(ur.key===null?kn:ur.key)||null,Nn(yn,An,ur,yr);case ut:return An=An.get(ur.key===null?kn:ur.key)||null,er(yn,An,ur,yr);case vt:var Or=ur._init;return Gr(An,yn,kn,Or(ur._payload),yr)}if(Bt(ur)||xt(ur))return An=An.get(kn)||null,dr(yn,An,ur,yr,null);Fl(yn,ur)}return null}function vr(An,yn,kn,ur){for(var yr=null,Or=null,Mr=yn,$r=yn=0,so=null;Mr!==null&&$r<kn.length;$r++){Mr.index>$r?(so=Mr,Mr=null):so=Mr.sibling;var Br=xr(An,Mr,kn[$r],ur);if(Br===null){Mr===null&&(Mr=so);break}gt&&Mr&&Br.alternate===null&&yt(An,Mr),yn=kt(Br,yn,$r),Or===null?yr=Br:Or.sibling=Br,Or=Br,Mr=so}if($r===kn.length)return Et(An,Mr),Xr&&bs(An,$r),yr;if(Mr===null){for(;$r<kn.length;$r++)Mr=Er(An,kn[$r],ur),Mr!==null&&(yn=kt(Mr,yn,$r),Or===null?yr=Mr:Or.sibling=Mr,Or=Mr);return Xr&&bs(An,$r),yr}for(Mr=Pt(An,Mr);$r<kn.length;$r++)so=Gr(Mr,An,$r,kn[$r],ur),so!==null&&(gt&&so.alternate!==null&&Mr.delete(so.key===null?$r:so.key),yn=kt(so,yn,$r),Or===null?yr=so:Or.sibling=so,Or=so);return gt&&Mr.forEach(function(ms){return yt(An,ms)}),Xr&&bs(An,$r),yr}function mo(An,yn,kn,ur){var yr=xt(kn);if(typeof yr!="function")throw Error(ot(150));if(kn=yr.call(kn),kn==null)throw Error(ot(151));for(var Or=yr=null,Mr=yn,$r=yn=0,so=null,Br=kn.next();Mr!==null&&!Br.done;$r++,Br=kn.next()){Mr.index>$r?(so=Mr,Mr=null):so=Mr.sibling;var ms=xr(An,Mr,Br.value,ur);if(ms===null){Mr===null&&(Mr=so);break}gt&&Mr&&ms.alternate===null&&yt(An,Mr),yn=kt(ms,yn,$r),Or===null?yr=ms:Or.sibling=ms,Or=ms,Mr=so}if(Br.done)return Et(An,Mr),Xr&&bs(An,$r),yr;if(Mr===null){for(;!Br.done;$r++,Br=kn.next())Br=Er(An,Br.value,ur),Br!==null&&(yn=kt(Br,yn,$r),Or===null?yr=Br:Or.sibling=Br,Or=Br);return Xr&&bs(An,$r),yr}for(Mr=Pt(An,Mr);!Br.done;$r++,Br=kn.next())Br=Gr(Mr,An,$r,Br.value,ur),Br!==null&&(gt&&Br.alternate!==null&&Mr.delete(Br.key===null?$r:Br.key),yn=kt(Br,yn,$r),Or===null?yr=Br:Or.sibling=Br,Or=Br);return gt&&Mr.forEach(function(m_){return yt(An,m_)}),Xr&&bs(An,$r),yr}function Bo(An,yn,kn,ur){if(typeof kn=="object"&&kn!==null&&kn.type===dt&&kn.key===null&&(kn=kn.props.children),typeof kn=="object"&&kn!==null){switch(kn.$$typeof){case lt:e:{for(var yr=kn.key,Or=yn;Or!==null;){if(Or.key===yr){if(yr=kn.type,yr===dt){if(Or.tag===7){Et(An,Or.sibling),yn=Rt(Or,kn.props.children),yn.return=An,An=yn;break e}}else if(Or.elementType===yr||typeof yr=="object"&&yr!==null&&yr.$$typeof===vt&&Sp(yr)===Or.type){Et(An,Or.sibling),yn=Rt(Or,kn.props),yn.ref=Ks(An,Or,kn),yn.return=An,An=yn;break e}Et(An,Or);break}else yt(An,Or);Or=Or.sibling}kn.type===dt?(yn=As(kn.props.children,An.mode,ur,kn.key),yn.return=An,An=yn):(ur=mu(kn.type,kn.key,kn.props,null,An.mode,ur),ur.ref=Ks(An,yn,kn),ur.return=An,An=ur)}return tn(An);case ut:e:{for(Or=kn.key;yn!==null;){if(yn.key===Or)if(yn.tag===4&&yn.stateNode.containerInfo===kn.containerInfo&&yn.stateNode.implementation===kn.implementation){Et(An,yn.sibling),yn=Rt(yn,kn.children||[]),yn.return=An,An=yn;break e}else{Et(An,yn);break}else yt(An,yn);yn=yn.sibling}yn=cp(kn,An.mode,ur),yn.return=An,An=yn}return tn(An);case vt:return Or=kn._init,Bo(An,yn,Or(kn._payload),ur)}if(Bt(kn))return vr(An,yn,kn,ur);if(xt(kn))return mo(An,yn,kn,ur);Fl(An,kn)}return typeof kn=="string"&&kn!==""||typeof kn=="number"?(kn=""+kn,yn!==null&&yn.tag===6?(Et(An,yn.sibling),yn=Rt(yn,kn),yn.return=An,An=yn):(Et(An,yn),yn=lp(kn,An.mode,ur),yn.return=An,An=yn),tn(An)):Et(An,yn)}return Bo}var Bs=Tp(!0),Ep=Tp(!1),Qs={},Do=jr(Qs),Zs=jr(Qs),Us=jr(Qs);function Ko(gt){if(gt===Qs)throw Error(ot(174));return gt}function Cu(gt,yt){tr(Us,yt),tr(Zs,gt),tr(Do,Qs),gt=Ut(yt),gr(Do),tr(Do,gt)}function zs(){gr(Do),gr(Zs),gr(Us)}function Mp(gt){var yt=Ko(Us.current),Et=Ko(Do.current);yt=Lt(Et,gt.type,yt),Et!==yt&&(tr(Zs,gt),tr(Do,yt))}function Ru(gt){Zs.current===gt&&(gr(Do),gr(Zs))}var Kr=jr(0);function $l(gt){for(var yt=gt;yt!==null;){if(yt.tag===13){var Et=yt.memoizedState;if(Et!==null&&(Et=Et.dehydrated,Et===null||zo(Et)||Co(Et)))return yt}else if(yt.tag===19&&yt.memoizedProps.revealOrder!==void 0){if(yt.flags&128)return yt}else if(yt.child!==null){yt.child.return=yt,yt=yt.child;continue}if(yt===gt)break;for(;yt.sibling===null;){if(yt.return===null||yt.return===gt)return null;yt=yt.return}yt.sibling.return=yt.return,yt=yt.sibling}return null}var Ou=[];function Iu(){for(var gt=0;gt<Ou.length;gt++){var yt=Ou[gt];Kt?yt._workInProgressVersionPrimary=null:yt._workInProgressVersionSecondary=null}Ou.length=0}var Bl=at.ReactCurrentDispatcher,No=at.ReactCurrentBatchConfig,Vs=0,Qr=null,fo=null,oo=null,Ul=!1,Js=!1,na=0,zm=0;function ho(){throw Error(ot(321))}function Lu(gt,yt){if(yt===null)return!1;for(var Et=0;Et<yt.length&&Et<gt.length;Et++)if(!Pn(gt[Et],yt[Et]))return!1;return!0}function ku(gt,yt,Et,Pt,Rt,kt){if(Vs=kt,Qr=yt,yt.memoizedState=null,yt.updateQueue=null,yt.lanes=0,Bl.current=gt===null||gt.memoizedState===null?Hm:Wm,gt=Et(Pt,Rt),Js){kt=0;do{if(Js=!1,na=0,25<=kt)throw Error(ot(301));kt+=1,oo=fo=null,yt.updateQueue=null,Bl.current=qm,gt=Et(Pt,Rt)}while(Js)}if(Bl.current=Wl,yt=fo!==null&&fo.next!==null,Vs=0,oo=fo=Qr=null,Ul=!1,yt)throw Error(ot(300));return gt}function Du(){var gt=na!==0;return na=0,gt}function rs(){var gt={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return oo===null?Qr.memoizedState=oo=gt:oo=oo.next=gt,oo}function Qo(){if(fo===null){var gt=Qr.alternate;gt=gt!==null?gt.memoizedState:null}else gt=fo.next;var yt=oo===null?Qr.memoizedState:oo.next;if(yt!==null)oo=yt,fo=gt;else{if(gt===null)throw Error(ot(310));fo=gt,gt={memoizedState:fo.memoizedState,baseState:fo.baseState,baseQueue:fo.baseQueue,queue:fo.queue,next:null},oo===null?Qr.memoizedState=oo=gt:oo=oo.next=gt}return oo}function xs(gt,yt){return typeof yt=="function"?yt(gt):yt}function zl(gt){var yt=Qo(),Et=yt.queue;if(Et===null)throw Error(ot(311));Et.lastRenderedReducer=gt;var Pt=fo,Rt=Pt.baseQueue,kt=Et.pending;if(kt!==null){if(Rt!==null){var tn=Rt.next;Rt.next=kt.next,kt.next=tn}Pt.baseQueue=Rt=kt,Et.pending=null}if(Rt!==null){kt=Rt.next,Pt=Pt.baseState;var gn=tn=null,Nn=null,er=kt;do{var dr=er.lane;if((Vs&dr)===dr)Nn!==null&&(Nn=Nn.next={lane:0,action:er.action,hasEagerState:er.hasEagerState,eagerState:er.eagerState,next:null}),Pt=er.hasEagerState?er.eagerState:gt(Pt,er.action);else{var Er={lane:dr,action:er.action,hasEagerState:er.hasEagerState,eagerState:er.eagerState,next:null};Nn===null?(gn=Nn=Er,tn=Pt):Nn=Nn.next=Er,Qr.lanes|=dr,js|=dr}er=er.next}while(er!==null&&er!==kt);Nn===null?tn=Pt:Nn.next=gn,Pn(Pt,yt.memoizedState)||(Ao=!0),yt.memoizedState=Pt,yt.baseState=tn,yt.baseQueue=Nn,Et.lastRenderedState=Pt}if(gt=Et.interleaved,gt!==null){Rt=gt;do kt=Rt.lane,Qr.lanes|=kt,js|=kt,Rt=Rt.next;while(Rt!==gt)}else Rt===null&&(Et.lanes=0);return[yt.memoizedState,Et.dispatch]}function Vl(gt){var yt=Qo(),Et=yt.queue;if(Et===null)throw Error(ot(311));Et.lastRenderedReducer=gt;var Pt=Et.dispatch,Rt=Et.pending,kt=yt.memoizedState;if(Rt!==null){Et.pending=null;var tn=Rt=Rt.next;do kt=gt(kt,tn.action),tn=tn.next;while(tn!==Rt);Pn(kt,yt.memoizedState)||(Ao=!0),yt.memoizedState=kt,yt.baseQueue===null&&(yt.baseState=kt),Et.lastRenderedState=kt}return[kt,Pt]}function Ap(){}function Pp(gt,yt){var Et=Qr,Pt=Qo(),Rt=yt(),kt=!Pn(Pt.memoizedState,Rt);if(kt&&(Pt.memoizedState=Rt,Ao=!0),Pt=Pt.queue,ba(Op.bind(null,Et,Pt,gt),[gt]),Pt.getSnapshot!==yt||kt||oo!==null&&oo.memoizedState.tag&1){if(Et.flags|=2048,ga(9,Rp.bind(null,Et,Pt,Rt,yt),void 0,null),no===null)throw Error(ot(349));Vs&30||Cp(Et,yt,Rt)}return Rt}function Cp(gt,yt,Et){gt.flags|=16384,gt={getSnapshot:yt,value:Et},yt=Qr.updateQueue,yt===null?(yt={lastEffect:null,stores:null},Qr.updateQueue=yt,yt.stores=[gt]):(Et=yt.stores,Et===null?yt.stores=[gt]:Et.push(gt))}function Rp(gt,yt,Et,Pt){yt.value=Et,yt.getSnapshot=Pt,Ip(yt)&&Fo(gt,1,-1)}function Op(gt,yt,Et){return Et(function(){Ip(yt)&&Fo(gt,1,-1)})}function Ip(gt){var yt=gt.getSnapshot;gt=gt.value;try{var Et=yt();return!Pn(gt,Et)}catch{return!0}}function Nu(gt){var yt=rs();return typeof gt=="function"&&(gt=gt()),yt.memoizedState=yt.baseState=gt,gt={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:xs,lastRenderedState:gt},yt.queue=gt,gt=gt.dispatch=jm.bind(null,Qr,gt),[yt.memoizedState,gt]}function ga(gt,yt,Et,Pt){return gt={tag:gt,create:yt,destroy:Et,deps:Pt,next:null},yt=Qr.updateQueue,yt===null?(yt={lastEffect:null,stores:null},Qr.updateQueue=yt,yt.lastEffect=gt.next=gt):(Et=yt.lastEffect,Et===null?yt.lastEffect=gt.next=gt:(Pt=Et.next,Et.next=gt,gt.next=Pt,yt.lastEffect=gt)),gt}function Lp(){return Qo().memoizedState}function Gl(gt,yt,Et,Pt){var Rt=rs();Qr.flags|=gt,Rt.memoizedState=ga(1|yt,Et,void 0,Pt===void 0?null:Pt)}function Hl(gt,yt,Et,Pt){var Rt=Qo();Pt=Pt===void 0?null:Pt;var kt=void 0;if(fo!==null){var tn=fo.memoizedState;if(kt=tn.destroy,Pt!==null&&Lu(Pt,tn.deps)){Rt.memoizedState=ga(yt,Et,kt,Pt);return}}Qr.flags|=gt,Rt.memoizedState=ga(1|yt,Et,kt,Pt)}function Fu(gt,yt){return Gl(8390656,8,gt,yt)}function ba(gt,yt){return Hl(2048,8,gt,yt)}function kp(gt,yt){return Hl(4,2,gt,yt)}function Dp(gt,yt){return Hl(4,4,gt,yt)}function Np(gt,yt){if(typeof yt=="function")return gt=gt(),yt(gt),function(){yt(null)};if(yt!=null)return gt=gt(),yt.current=gt,function(){yt.current=null}}function Fp(gt,yt,Et){return Et=Et!=null?Et.concat([gt]):null,Hl(4,4,Np.bind(null,yt,gt),Et)}function $u(){}function $p(gt,yt){var Et=Qo();yt=yt===void 0?null:yt;var Pt=Et.memoizedState;return Pt!==null&&yt!==null&&Lu(yt,Pt[1])?Pt[0]:(Et.memoizedState=[gt,yt],gt)}function Bp(gt,yt){var Et=Qo();yt=yt===void 0?null:yt;var Pt=Et.memoizedState;return Pt!==null&&yt!==null&&Lu(yt,Pt[1])?Pt[0]:(gt=gt(),Et.memoizedState=[gt,yt],gt)}function Vm(gt,yt){var Et=Nr;Nr=Et!==0&&4>Et?Et:4,gt(!0);var Pt=No.transition;No.transition={};try{gt(!1),yt()}finally{Nr=Et,No.transition=Pt}}function Up(){return Qo().memoizedState}function Gm(gt,yt,Et){var Pt=fs(gt);Et={lane:Pt,action:Et,hasEagerState:!1,eagerState:null,next:null},zp(gt)?Vp(yt,Et):(Gp(gt,yt,Et),Et=yo(),gt=Fo(gt,Pt,Et),gt!==null&&jp(gt,yt,Pt))}function jm(gt,yt,Et){var Pt=fs(gt),Rt={lane:Pt,action:Et,hasEagerState:!1,eagerState:null,next:null};if(zp(gt))Vp(yt,Rt);else{Gp(gt,yt,Rt);var kt=gt.alternate;if(gt.lanes===0&&(kt===null||kt.lanes===0)&&(kt=yt.lastRenderedReducer,kt!==null))try{var tn=yt.lastRenderedState,gn=kt(tn,Et);if(Rt.hasEagerState=!0,Rt.eagerState=gn,Pn(gn,tn))return}catch{}finally{}Et=yo(),gt=Fo(gt,Pt,Et),gt!==null&&jp(gt,yt,Pt)}}function zp(gt){var yt=gt.alternate;return gt===Qr||yt!==null&&yt===Qr}function Vp(gt,yt){Js=Ul=!0;var Et=gt.pending;Et===null?yt.next=yt:(yt.next=Et.next,Et.next=yt),gt.pending=yt}function Gp(gt,yt,Et){no!==null&&gt.mode&1&&!(kr&2)?(gt=yt.interleaved,gt===null?(Et.next=Et,Yo===null?Yo=[yt]:Yo.push(yt)):(Et.next=gt.next,gt.next=Et),yt.interleaved=Et):(gt=yt.pending,gt===null?Et.next=Et:(Et.next=gt.next,gt.next=Et),yt.pending=Et)}function jp(gt,yt,Et){if(Et&4194240){var Pt=yt.lanes;Pt&=gt.pendingLanes,Et|=Pt,yt.lanes=Et,Rs(gt,Et)}}var Wl={readContext:Io,useCallback:ho,useContext:ho,useEffect:ho,useImperativeHandle:ho,useInsertionEffect:ho,useLayoutEffect:ho,useMemo:ho,useReducer:ho,useRef:ho,useState:ho,useDebugValue:ho,useDeferredValue:ho,useTransition:ho,useMutableSource:ho,useSyncExternalStore:ho,useId:ho,unstable_isNewReconciler:!1},Hm={readContext:Io,useCallback:function(gt,yt){return rs().memoizedState=[gt,yt===void 0?null:yt],gt},useContext:Io,useEffect:Fu,useImperativeHandle:function(gt,yt,Et){return Et=Et!=null?Et.concat([gt]):null,Gl(4194308,4,Np.bind(null,yt,gt),Et)},useLayoutEffect:function(gt,yt){return Gl(4194308,4,gt,yt)},useInsertionEffect:function(gt,yt){return Gl(4,2,gt,yt)},useMemo:function(gt,yt){var Et=rs();return yt=yt===void 0?null:yt,gt=gt(),Et.memoizedState=[gt,yt],gt},useReducer:function(gt,yt,Et){var Pt=rs();return yt=Et!==void 0?Et(yt):yt,Pt.memoizedState=Pt.baseState=yt,gt={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:gt,lastRenderedState:yt},Pt.queue=gt,gt=gt.dispatch=Gm.bind(null,Qr,gt),[Pt.memoizedState,gt]},useRef:function(gt){var yt=rs();return gt={current:gt},yt.memoizedState=gt},useState:Nu,useDebugValue:$u,useDeferredValue:function(gt){var yt=Nu(gt),Et=yt[0],Pt=yt[1];return Fu(function(){var Rt=No.transition;No.transition={};try{Pt(gt)}finally{No.transition=Rt}},[gt]),Et},useTransition:function(){var gt=Nu(!1),yt=gt[0];return gt=Vm.bind(null,gt[1]),rs().memoizedState=gt,[yt,gt]},useMutableSource:function(){},useSyncExternalStore:function(gt,yt,Et){var Pt=Qr,Rt=rs();if(Xr){if(Et===void 0)throw Error(ot(407));Et=Et()}else{if(Et=yt(),no===null)throw Error(ot(349));Vs&30||Cp(Pt,yt,Et)}Rt.memoizedState=Et;var kt={value:Et,getSnapshot:yt};return Rt.queue=kt,Fu(Op.bind(null,Pt,kt,gt),[gt]),Pt.flags|=2048,ga(9,Rp.bind(null,Pt,kt,Et,yt),void 0,null),Et},useId:function(){var gt=rs(),yt=no.identifierPrefix;if(Xr){var Et=ns,Pt=ts;Et=(Pt&~(1<<32-uo(Pt)-1)).toString(32)+Et,yt=":"+yt+"R"+Et,Et=na++,0<Et&&(yt+="H"+Et.toString(32)),yt+=":"}else Et=zm++,yt=":"+yt+"r"+Et.toString(32)+":";return gt.memoizedState=yt},unstable_isNewReconciler:!1},Wm={readContext:Io,useCallback:$p,useContext:Io,useEffect:ba,useImperativeHandle:Fp,useInsertionEffect:kp,useLayoutEffect:Dp,useMemo:Bp,useReducer:zl,useRef:Lp,useState:function(){return zl(xs)},useDebugValue:$u,useDeferredValue:function(gt){var yt=zl(xs),Et=yt[0],Pt=yt[1];return ba(function(){var Rt=No.transition;No.transition={};try{Pt(gt)}finally{No.transition=Rt}},[gt]),Et},useTransition:function(){var gt=zl(xs)[0],yt=Qo().memoizedState;return[gt,yt]},useMutableSource:Ap,useSyncExternalStore:Pp,useId:Up,unstable_isNewReconciler:!1},qm={readContext:Io,useCallback:$p,useContext:Io,useEffect:ba,useImperativeHandle:Fp,useInsertionEffect:kp,useLayoutEffect:Dp,useMemo:Bp,useReducer:Vl,useRef:Lp,useState:function(){return Vl(xs)},useDebugValue:$u,useDeferredValue:function(gt){var yt=Vl(xs),Et=yt[0],Pt=yt[1];return ba(function(){var Rt=No.transition;No.transition={};try{Pt(gt)}finally{No.transition=Rt}},[gt]),Et},useTransition:function(){var gt=Vl(xs)[0],yt=Qo().memoizedState;return[gt,yt]},useMutableSource:Ap,useSyncExternalStore:Pp,useId:Up,unstable_isNewReconciler:!1};function Bu(gt,yt){try{var Et="",Pt=yt;do Et+=Dr(Pt),Pt=Pt.return;while(Pt);var Rt=Et}catch(kt){Rt=`
Error generating stack: `+kt.message+`
`+kt.stack}return{value:gt,source:yt,stack:Rt}}function Uu(gt,yt){try{console.error(yt.value)}catch(Et){setTimeout(function(){throw Et})}}var Xm=typeof WeakMap=="function"?WeakMap:Map;function Hp(gt,yt,Et){Et=es(-1,Et),Et.tag=3,Et.payload={element:null};var Pt=yt.value;return Et.callback=function(){lu||(lu=!0,tp=Pt),Uu(gt,yt)},Et}function Wp(gt,yt,Et){Et=es(-1,Et),Et.tag=3;var Pt=gt.type.getDerivedStateFromError;if(typeof Pt=="function"){var Rt=yt.value;Et.payload=function(){return Pt(Rt)},Et.callback=function(){Uu(gt,yt)}}var kt=gt.stateNode;return kt!==null&&typeof kt.componentDidCatch=="function"&&(Et.callback=function(){Uu(gt,yt),typeof Pt!="function"&&(us===null?us=new Set([this]):us.add(this));var tn=yt.stack;this.componentDidCatch(yt.value,{componentStack:tn!==null?tn:""})}),Et}function qp(gt,yt,Et){var Pt=gt.pingCache;if(Pt===null){Pt=gt.pingCache=new Xm;var Rt=new Set;Pt.set(yt,Rt)}else Rt=Pt.get(yt),Rt===void 0&&(Rt=new Set,Pt.set(yt,Rt));Rt.has(Et)||(Rt.add(Et),gt=a_.bind(null,gt,yt,Et),yt.then(gt,gt))}function Xp(gt){do{var yt;if((yt=gt.tag===13)&&(yt=gt.memoizedState,yt=yt!==null?yt.dehydrated!==null:!0),yt)return gt;gt=gt.return}while(gt!==null);return null}function Yp(gt,yt,Et,Pt,Rt){return gt.mode&1?(gt.flags|=65536,gt.lanes=Rt,gt):(gt===yt?gt.flags|=65536:(gt.flags|=128,Et.flags|=131072,Et.flags&=-52805,Et.tag===1&&(Et.alternate===null?Et.tag=17:(yt=es(-1,1),yt.tag=2,cs(Et,yt))),Et.lanes|=1),gt)}function Zo(gt){gt.flags|=4}function Kp(gt,yt){if(gt!==null&&gt.child===yt.child)return!0;if(yt.flags&16)return!1;for(gt=yt.child;gt!==null;){if(gt.flags&12854||gt.subtreeFlags&12854)return!1;gt=gt.sibling}return!0}var xa,$a,Xl,Yl;if(nn)xa=function(gt,yt){for(var Et=yt.child;Et!==null;){if(Et.tag===5||Et.tag===6)bn(gt,Et.stateNode);else if(Et.tag!==4&&Et.child!==null){Et.child.return=Et,Et=Et.child;continue}if(Et===yt)break;for(;Et.sibling===null;){if(Et.return===null||Et.return===yt)return;Et=Et.return}Et.sibling.return=Et.return,Et=Et.sibling}},$a=function(){},Xl=function(gt,yt,Et,Pt,Rt){if(gt=gt.memoizedProps,gt!==Pt){var kt=yt.stateNode,tn=Ko(Do.current);Et=mn(kt,Et,gt,Pt,Rt,tn),(yt.updateQueue=Et)&&Zo(yt)}},Yl=function(gt,yt,Et,Pt){Et!==Pt&&Zo(yt)};else if(Vt){xa=function(gt,yt,Et,Pt){for(var Rt=yt.child;Rt!==null;){if(Rt.tag===5){var kt=Rt.stateNode;Et&&Pt&&(kt=Hr(kt,Rt.type,Rt.memoizedProps,Rt)),bn(gt,kt)}else if(Rt.tag===6)kt=Rt.stateNode,Et&&Pt&&(kt=Wr(kt,Rt.memoizedProps,Rt)),bn(gt,kt);else if(Rt.tag!==4){if(Rt.tag===22&&Rt.memoizedState!==null)kt=Rt.child,kt!==null&&(kt.return=Rt),xa(gt,Rt,!0,!0);else if(Rt.child!==null){Rt.child.return=Rt,Rt=Rt.child;continue}}if(Rt===yt)break;for(;Rt.sibling===null;){if(Rt.return===null||Rt.return===yt)return;Rt=Rt.return}Rt.sibling.return=Rt.return,Rt=Rt.sibling}};var Qp=function(gt,yt,Et,Pt){for(var Rt=yt.child;Rt!==null;){if(Rt.tag===5){var kt=Rt.stateNode;Et&&Pt&&(kt=Hr(kt,Rt.type,Rt.memoizedProps,Rt)),ar(gt,kt)}else if(Rt.tag===6)kt=Rt.stateNode,Et&&Pt&&(kt=Wr(kt,Rt.memoizedProps,Rt)),ar(gt,kt);else if(Rt.tag!==4){if(Rt.tag===22&&Rt.memoizedState!==null)kt=Rt.child,kt!==null&&(kt.return=Rt),Qp(gt,Rt,!0,!0);else if(Rt.child!==null){Rt.child.return=Rt,Rt=Rt.child;continue}}if(Rt===yt)break;for(;Rt.sibling===null;){if(Rt.return===null||Rt.return===yt)return;Rt=Rt.return}Rt.sibling.return=Rt.return,Rt=Rt.sibling}};$a=function(gt,yt){var Et=yt.stateNode;if(!Kp(gt,yt)){gt=Et.containerInfo;var Pt=Kn(gt);Qp(Pt,yt,!1,!1),Et.pendingChildren=Pt,Zo(yt),Ur(gt,Pt)}},Xl=function(gt,yt,Et,Pt,Rt){var kt=gt.stateNode,tn=gt.memoizedProps;if((gt=Kp(gt,yt))&&tn===Pt)yt.stateNode=kt;else{var gn=yt.stateNode,Nn=Ko(Do.current),er=null;tn!==Pt&&(er=mn(gn,Et,tn,Pt,Rt,Nn)),gt&&er===null?yt.stateNode=kt:(kt=qn(kt,er,Et,tn,Pt,yt,gt,gn),Un(kt,Et,Pt,Rt,Nn)&&Zo(yt),yt.stateNode=kt,gt?Zo(yt):xa(kt,yt,!1,!1))}},Yl=function(gt,yt,Et,Pt){Et!==Pt?(gt=Ko(Us.current),Et=Ko(Do.current),yt.stateNode=In(Pt,gt,Et,yt),Zo(yt)):yt.stateNode=gt.stateNode}}else $a=function(){},Xl=function(){},Yl=function(){};function _l(gt,yt){if(!Xr)switch(gt.tailMode){case"hidden":yt=gt.tail;for(var Et=null;yt!==null;)yt.alternate!==null&&(Et=yt),yt=yt.sibling;Et===null?gt.tail=null:Et.sibling=null;break;case"collapsed":Et=gt.tail;for(var Pt=null;Et!==null;)Et.alternate!==null&&(Pt=Et),Et=Et.sibling;Pt===null?yt||gt.tail===null?gt.tail=null:gt.tail.sibling=null:Pt.sibling=null}}function po(gt){var yt=gt.alternate!==null&&gt.alternate.child===gt.child,Et=0,Pt=0;if(yt)for(var Rt=gt.child;Rt!==null;)Et|=Rt.lanes|Rt.childLanes,Pt|=Rt.subtreeFlags&14680064,Pt|=Rt.flags&14680064,Rt.return=gt,Rt=Rt.sibling;else for(Rt=gt.child;Rt!==null;)Et|=Rt.lanes|Rt.childLanes,Pt|=Rt.subtreeFlags,Pt|=Rt.flags,Rt.return=gt,Rt=Rt.sibling;return gt.subtreeFlags|=Pt,gt.childLanes=Et,yt}function Ym(gt,yt,Et){var Pt=yt.pendingProps;switch(Eu(yt),yt.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return po(yt),null;case 1:return eo(yt.type)&&Vr(),po(yt),null;case 3:return Pt=yt.stateNode,zs(),gr(zr),gr(br),Iu(),Pt.pendingContext&&(Pt.context=Pt.pendingContext,Pt.pendingContext=null),(gt===null||gt.child===null)&&(Ys(yt)?Zo(yt):gt===null||gt.memoizedState.isDehydrated&&!(yt.flags&256)||(yt.flags|=1024,Go!==null&&(ip(Go),Go=null))),$a(gt,yt),po(yt),null;case 5:Ru(yt),Et=Ko(Us.current);var Rt=yt.type;if(gt!==null&&yt.stateNode!=null)Xl(gt,yt,Rt,Pt,Et),gt.ref!==yt.ref&&(yt.flags|=512,yt.flags|=2097152);else{if(!Pt){if(yt.stateNode===null)throw Error(ot(166));return po(yt),null}if(gt=Ko(Do.current),Ys(yt)){if(!on)throw Error(ot(175));gt=Wt(yt.stateNode,yt.type,yt.memoizedProps,Et,gt,yt,!Xs),yt.updateQueue=gt,gt!==null&&Zo(yt)}else{var kt=en(Rt,Pt,Et,gt,yt);xa(kt,yt,!1,!1),yt.stateNode=kt,Un(kt,Rt,Pt,Et,gt)&&Zo(yt)}yt.ref!==null&&(yt.flags|=512,yt.flags|=2097152)}return po(yt),null;case 6:if(gt&&yt.stateNode!=null)Yl(gt,yt,gt.memoizedProps,Pt);else{if(typeof Pt!="string"&&yt.stateNode===null)throw Error(ot(166));if(gt=Ko(Us.current),Et=Ko(Do.current),Ys(yt)){if(!on)throw Error(ot(176));if(gt=yt.stateNode,Pt=yt.memoizedProps,(Et=rn(gt,Pt,yt,!Xs))&&(Rt=Eo,Rt!==null))switch(kt=(Rt.mode&1)!==0,Rt.tag){case 3:zn(Rt.stateNode.containerInfo,gt,Pt,kt);break;case 5:Qn(Rt.type,Rt.memoizedProps,Rt.stateNode,gt,Pt,kt)}Et&&Zo(yt)}else yt.stateNode=In(Pt,gt,Et,yt)}return po(yt),null;case 13:if(gr(Kr),Pt=yt.memoizedState,Xr&&Mo!==null&&yt.mode&1&&!(yt.flags&128)){for(gt=Mo;gt;)gt=vo(gt);return $s(),yt.flags|=98560,yt}if(Pt!==null&&Pt.dehydrated!==null){if(Pt=Ys(yt),gt===null){if(!Pt)throw Error(ot(318));if(!on)throw Error(ot(344));if(gt=yt.memoizedState,gt=gt!==null?gt.dehydrated:null,!gt)throw Error(ot(317));pn(gt,yt)}else $s(),!(yt.flags&128)&&(yt.memoizedState=null),yt.flags|=4;return po(yt),null}return Go!==null&&(ip(Go),Go=null),yt.flags&128?(yt.lanes=Et,yt):(Pt=Pt!==null,Et=!1,gt===null?Ys(yt):Et=gt.memoizedState!==null,Pt&&!Et&&(yt.child.flags|=8192,yt.mode&1&&(gt===null||Kr.current&1?io===0&&(io=3):sp())),yt.updateQueue!==null&&(yt.flags|=4),po(yt),null);case 4:return zs(),$a(gt,yt),gt===null&&Ln(yt.stateNode.containerInfo),po(yt),null;case 10:return vu(yt.type._context),po(yt),null;case 17:return eo(yt.type)&&Vr(),po(yt),null;case 19:if(gr(Kr),Rt=yt.memoizedState,Rt===null)return po(yt),null;if(Pt=(yt.flags&128)!==0,kt=Rt.rendering,kt===null)if(Pt)_l(Rt,!1);else{if(io!==0||gt!==null&&gt.flags&128)for(gt=yt.child;gt!==null;){if(kt=$l(gt),kt!==null){for(yt.flags|=128,_l(Rt,!1),gt=kt.updateQueue,gt!==null&&(yt.updateQueue=gt,yt.flags|=4),yt.subtreeFlags=0,gt=Et,Pt=yt.child;Pt!==null;)Et=Pt,Rt=gt,Et.flags&=14680066,kt=Et.alternate,kt===null?(Et.childLanes=0,Et.lanes=Rt,Et.child=null,Et.subtreeFlags=0,Et.memoizedProps=null,Et.memoizedState=null,Et.updateQueue=null,Et.dependencies=null,Et.stateNode=null):(Et.childLanes=kt.childLanes,Et.lanes=kt.lanes,Et.child=kt.child,Et.subtreeFlags=0,Et.deletions=null,Et.memoizedProps=kt.memoizedProps,Et.memoizedState=kt.memoizedState,Et.updateQueue=kt.updateQueue,Et.type=kt.type,Rt=kt.dependencies,Et.dependencies=Rt===null?null:{lanes:Rt.lanes,firstContext:Rt.firstContext}),Pt=Pt.sibling;return tr(Kr,Kr.current&1|2),yt.child}gt=gt.sibling}Rt.tail!==null&&Zr()>ep&&(yt.flags|=128,Pt=!0,_l(Rt,!1),yt.lanes=4194304)}else{if(!Pt)if(gt=$l(kt),gt!==null){if(yt.flags|=128,Pt=!0,gt=gt.updateQueue,gt!==null&&(yt.updateQueue=gt,yt.flags|=4),_l(Rt,!0),Rt.tail===null&&Rt.tailMode==="hidden"&&!kt.alternate&&!Xr)return po(yt),null}else 2*Zr()-Rt.renderingStartTime>ep&&Et!==1073741824&&(yt.flags|=128,Pt=!0,_l(Rt,!1),yt.lanes=4194304);Rt.isBackwards?(kt.sibling=yt.child,yt.child=kt):(gt=Rt.last,gt!==null?gt.sibling=kt:yt.child=kt,Rt.last=kt)}return Rt.tail!==null?(yt=Rt.tail,Rt.rendering=yt,Rt.tail=yt.sibling,Rt.renderingStartTime=Zr(),yt.sibling=null,gt=Kr.current,tr(Kr,Pt?gt&1|2:gt&1),yt):(po(yt),null);case 22:case 23:return op(),Pt=yt.memoizedState!==null,gt!==null&&gt.memoizedState!==null!==Pt&&(yt.flags|=8192),Pt&&yt.mode&1?Po&1073741824&&(po(yt),nn&&yt.subtreeFlags&6&&(yt.flags|=8192)):po(yt),null;case 24:return null;case 25:return null}throw Error(ot(156,yt.tag))}var Km=at.ReactCurrentOwner,Ao=!1;function _o(gt,yt,Et,Pt){yt.child=gt===null?Ep(yt,null,Et,Pt):Bs(yt,gt.child,Et,Pt)}function Zp(gt,yt,Et,Pt,Rt){Et=Et.render;var kt=yt.ref;return Ds(yt,Rt),Pt=ku(gt,yt,Et,Pt,kt,Rt),Et=Du(),gt!==null&&!Ao?(yt.updateQueue=gt.updateQueue,yt.flags&=-2053,gt.lanes&=~Rt,os(gt,yt,Rt)):(Xr&&Et&&Tu(yt),yt.flags|=1,_o(gt,yt,Pt,Rt),yt.child)}function Jp(gt,yt,Et,Pt,Rt){if(gt===null){var kt=Et.type;return typeof kt=="function"&&!ap(kt)&&kt.defaultProps===void 0&&Et.compare===null&&Et.defaultProps===void 0?(yt.tag=15,yt.type=kt,em(gt,yt,kt,Pt,Rt)):(gt=mu(Et.type,null,Pt,yt,yt.mode,Rt),gt.ref=yt.ref,gt.return=yt,yt.child=gt)}if(kt=gt.child,!(gt.lanes&Rt)){var tn=kt.memoizedProps;if(Et=Et.compare,Et=Et!==null?Et:Rn,Et(tn,Pt)&&gt.ref===yt.ref)return os(gt,yt,Rt)}return yt.flags|=1,gt=ps(kt,Pt),gt.ref=yt.ref,gt.return=yt,yt.child=gt}function em(gt,yt,Et,Pt,Rt){if(gt!==null&&Rn(gt.memoizedProps,Pt)&&gt.ref===yt.ref)if(Ao=!1,(gt.lanes&Rt)!==0)gt.flags&131072&&(Ao=!0);else return yt.lanes=gt.lanes,os(gt,yt,Rt);return zu(gt,yt,Et,Pt,Rt)}function tm(gt,yt,Et){var Pt=yt.pendingProps,Rt=Pt.children,kt=gt!==null?gt.memoizedState:null;if(Pt.mode==="hidden")if(!(yt.mode&1))yt.memoizedState={baseLanes:0,cachePool:null},tr(Gs,Po),Po|=Et;else if(Et&1073741824)yt.memoizedState={baseLanes:0,cachePool:null},Pt=kt!==null?kt.baseLanes:Et,tr(Gs,Po),Po|=Pt;else return gt=kt!==null?kt.baseLanes|Et:Et,yt.lanes=yt.childLanes=1073741824,yt.memoizedState={baseLanes:gt,cachePool:null},yt.updateQueue=null,tr(Gs,Po),Po|=gt,null;else kt!==null?(Pt=kt.baseLanes|Et,yt.memoizedState=null):Pt=Et,tr(Gs,Po),Po|=Pt;return _o(gt,yt,Rt,Et),yt.child}function nm(gt,yt){var Et=yt.ref;(gt===null&&Et!==null||gt!==null&&gt.ref!==Et)&&(yt.flags|=512,yt.flags|=2097152)}function zu(gt,yt,Et,Pt,Rt){var kt=eo(Et)?ao:br.current;return kt=Yr(yt,kt),Ds(yt,Rt),Et=ku(gt,yt,Et,Pt,kt,Rt),Pt=Du(),gt!==null&&!Ao?(yt.updateQueue=gt.updateQueue,yt.flags&=-2053,gt.lanes&=~Rt,os(gt,yt,Rt)):(Xr&&Pt&&Tu(yt),yt.flags|=1,_o(gt,yt,Et,Rt),yt.child)}function rm(gt,yt,Et,Pt,Rt){if(eo(Et)){var kt=!0;to(yt)}else kt=!1;if(Ds(yt,Rt),yt.stateNode===null)gt!==null&&(gt.alternate=null,yt.alternate=null,yt.flags|=2),_p(yt,Et,Pt),Su(yt,Et,Pt,Rt),Pt=!0;else if(gt===null){var tn=yt.stateNode,gn=yt.memoizedProps;tn.props=gn;var Nn=tn.context,er=Et.contextType;typeof er=="object"&&er!==null?er=Io(er):(er=eo(Et)?ao:br.current,er=Yr(yt,er));var dr=Et.getDerivedStateFromProps,Er=typeof dr=="function"||typeof tn.getSnapshotBeforeUpdate=="function";Er||typeof tn.UNSAFE_componentWillReceiveProps!="function"&&typeof tn.componentWillReceiveProps!="function"||(gn!==Pt||Nn!==er)&&yp(yt,tn,Pt,er),ls=!1;var xr=yt.memoizedState;tn.state=xr,Il(yt,Pt,tn,Rt),Nn=yt.memoizedState,gn!==Pt||xr!==Nn||zr.current||ls?(typeof dr=="function"&&(wu(yt,Et,dr,Pt),Nn=yt.memoizedState),(gn=ls||gp(yt,Et,gn,Pt,xr,Nn,er))?(Er||typeof tn.UNSAFE_componentWillMount!="function"&&typeof tn.componentWillMount!="function"||(typeof tn.componentWillMount=="function"&&tn.componentWillMount(),typeof tn.UNSAFE_componentWillMount=="function"&&tn.UNSAFE_componentWillMount()),typeof tn.componentDidMount=="function"&&(yt.flags|=4194308)):(typeof tn.componentDidMount=="function"&&(yt.flags|=4194308),yt.memoizedProps=Pt,yt.memoizedState=Nn),tn.props=Pt,tn.state=Nn,tn.context=er,Pt=gn):(typeof tn.componentDidMount=="function"&&(yt.flags|=4194308),Pt=!1)}else{tn=yt.stateNode,fp(gt,yt),gn=yt.memoizedProps,er=yt.type===yt.elementType?gn:Fr(yt.type,gn),tn.props=er,Er=yt.pendingProps,xr=tn.context,Nn=Et.contextType,typeof Nn=="object"&&Nn!==null?Nn=Io(Nn):(Nn=eo(Et)?ao:br.current,Nn=Yr(yt,Nn));var Gr=Et.getDerivedStateFromProps;(dr=typeof Gr=="function"||typeof tn.getSnapshotBeforeUpdate=="function")||typeof tn.UNSAFE_componentWillReceiveProps!="function"&&typeof tn.componentWillReceiveProps!="function"||(gn!==Er||xr!==Nn)&&yp(yt,tn,Pt,Nn),ls=!1,xr=yt.memoizedState,tn.state=xr,Il(yt,Pt,tn,Rt);var vr=yt.memoizedState;gn!==Er||xr!==vr||zr.current||ls?(typeof Gr=="function"&&(wu(yt,Et,Gr,Pt),vr=yt.memoizedState),(er=ls||gp(yt,Et,er,Pt,xr,vr,Nn)||!1)?(dr||typeof tn.UNSAFE_componentWillUpdate!="function"&&typeof tn.componentWillUpdate!="function"||(typeof tn.componentWillUpdate=="function"&&tn.componentWillUpdate(Pt,vr,Nn),typeof tn.UNSAFE_componentWillUpdate=="function"&&tn.UNSAFE_componentWillUpdate(Pt,vr,Nn)),typeof tn.componentDidUpdate=="function"&&(yt.flags|=4),typeof tn.getSnapshotBeforeUpdate=="function"&&(yt.flags|=1024)):(typeof tn.componentDidUpdate!="function"||gn===gt.memoizedProps&&xr===gt.memoizedState||(yt.flags|=4),typeof tn.getSnapshotBeforeUpdate!="function"||gn===gt.memoizedProps&&xr===gt.memoizedState||(yt.flags|=1024),yt.memoizedProps=Pt,yt.memoizedState=vr),tn.props=Pt,tn.state=vr,tn.context=Nn,Pt=er):(typeof tn.componentDidUpdate!="function"||gn===gt.memoizedProps&&xr===gt.memoizedState||(yt.flags|=4),typeof tn.getSnapshotBeforeUpdate!="function"||gn===gt.memoizedProps&&xr===gt.memoizedState||(yt.flags|=1024),Pt=!1)}return Vu(gt,yt,Et,Pt,kt,Rt)}function Vu(gt,yt,Et,Pt,Rt,kt){nm(gt,yt);var tn=(yt.flags&128)!==0;if(!Pt&&!tn)return Rt&&Jo(yt,Et,!1),os(gt,yt,kt);Pt=yt.stateNode,Km.current=yt;var gn=tn&&typeof Et.getDerivedStateFromError!="function"?null:Pt.render();return yt.flags|=1,gt!==null&&tn?(yt.child=Bs(yt,gt.child,null,kt),yt.child=Bs(yt,null,gn,kt)):_o(gt,yt,gn,kt),yt.memoizedState=Pt.state,Rt&&Jo(yt,Et,!0),yt.child}function im(gt){var yt=gt.stateNode;yt.pendingContext?co(gt,yt.pendingContext,yt.pendingContext!==yt.context):yt.context&&co(gt,yt.context,!1),Cu(gt,yt.containerInfo)}function om(gt,yt,Et,Pt,Rt){return $s(),Pu(Rt),yt.flags|=256,_o(gt,yt,Et,Pt),yt.child}var Kl={dehydrated:null,treeContext:null,retryLane:0};function Ql(gt){return{baseLanes:gt,cachePool:null}}function sm(gt,yt,Et){var Pt=yt.pendingProps,Rt=Kr.current,kt=!1,tn=(yt.flags&128)!==0,gn;if((gn=tn)||(gn=gt!==null&&gt.memoizedState===null?!1:(Rt&2)!==0),gn?(kt=!0,yt.flags&=-129):(gt===null||gt.memoizedState!==null)&&(Rt|=1),tr(Kr,Rt&1),gt===null)return Au(yt),gt=yt.memoizedState,gt!==null&&(gt=gt.dehydrated,gt!==null)?(yt.mode&1?Co(gt)?yt.lanes=8:yt.lanes=1073741824:yt.lanes=1,null):(Rt=Pt.children,gt=Pt.fallback,kt?(Pt=yt.mode,kt=yt.child,Rt={mode:"hidden",children:Rt},!(Pt&1)&&kt!==null?(kt.childLanes=0,kt.pendingProps=Rt):kt=gu(Rt,Pt,0,null),gt=As(gt,Pt,Et,null),kt.return=yt,gt.return=yt,kt.sibling=gt,yt.child=kt,yt.child.memoizedState=Ql(Et),yt.memoizedState=Kl,gt):Gu(yt,Rt));if(Rt=gt.memoizedState,Rt!==null){if(gn=Rt.dehydrated,gn!==null){if(tn)return yt.flags&256?(yt.flags&=-257,Zl(gt,yt,Et,Error(ot(422)))):yt.memoizedState!==null?(yt.child=gt.child,yt.flags|=128,null):(kt=Pt.fallback,Rt=yt.mode,Pt=gu({mode:"visible",children:Pt.children},Rt,0,null),kt=As(kt,Rt,Et,null),kt.flags|=2,Pt.return=yt,kt.return=yt,Pt.sibling=kt,yt.child=Pt,yt.mode&1&&Bs(yt,gt.child,null,Et),yt.child.memoizedState=Ql(Et),yt.memoizedState=Kl,kt);if(!(yt.mode&1))yt=Zl(gt,yt,Et,null);else if(Co(gn))yt=Zl(gt,yt,Et,Error(ot(419)));else if(Pt=(Et&gt.childLanes)!==0,Ao||Pt){if(Pt=no,Pt!==null){switch(Et&-Et){case 4:kt=2;break;case 16:kt=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:kt=32;break;case 536870912:kt=268435456;break;default:kt=0}Pt=kt&(Pt.suspendedLanes|Et)?0:kt,Pt!==0&&Pt!==Rt.retryLane&&(Rt.retryLane=Pt,Fo(gt,Pt,-1))}sp(),yt=Zl(gt,yt,Et,Error(ot(421)))}else zo(gn)?(yt.flags|=128,yt.child=gt.child,yt=l_.bind(null,gt),Ro(gn,yt),yt=null):(Et=Rt.treeContext,on&&(Mo=Wo(gn),Eo=yt,Xr=!0,Go=null,Xs=!1,Et!==null&&(Lo[ko++]=ts,Lo[ko++]=ns,Lo[ko++]=vs,ts=Et.id,ns=Et.overflow,vs=yt)),yt=Gu(yt,yt.pendingProps.children),yt.flags|=4096);return yt}return kt?(Pt=lm(gt,yt,Pt.children,Pt.fallback,Et),kt=yt.child,Rt=gt.child.memoizedState,kt.memoizedState=Rt===null?Ql(Et):{baseLanes:Rt.baseLanes|Et,cachePool:null},kt.childLanes=gt.childLanes&~Et,yt.memoizedState=Kl,Pt):(Et=am(gt,yt,Pt.children,Et),yt.memoizedState=null,Et)}return kt?(Pt=lm(gt,yt,Pt.children,Pt.fallback,Et),kt=yt.child,Rt=gt.child.memoizedState,kt.memoizedState=Rt===null?Ql(Et):{baseLanes:Rt.baseLanes|Et,cachePool:null},kt.childLanes=gt.childLanes&~Et,yt.memoizedState=Kl,Pt):(Et=am(gt,yt,Pt.children,Et),yt.memoizedState=null,Et)}function Gu(gt,yt){return yt=gu({mode:"visible",children:yt},gt.mode,0,null),yt.return=gt,gt.child=yt}function am(gt,yt,Et,Pt){var Rt=gt.child;return gt=Rt.sibling,Et=ps(Rt,{mode:"visible",children:Et}),!(yt.mode&1)&&(Et.lanes=Pt),Et.return=yt,Et.sibling=null,gt!==null&&(Pt=yt.deletions,Pt===null?(yt.deletions=[gt],yt.flags|=16):Pt.push(gt)),yt.child=Et}function lm(gt,yt,Et,Pt,Rt){var kt=yt.mode;gt=gt.child;var tn=gt.sibling,gn={mode:"hidden",children:Et};return!(kt&1)&&yt.child!==gt?(Et=yt.child,Et.childLanes=0,Et.pendingProps=gn,yt.deletions=null):(Et=ps(gt,gn),Et.subtreeFlags=gt.subtreeFlags&14680064),tn!==null?Pt=ps(tn,Pt):(Pt=As(Pt,kt,Rt,null),Pt.flags|=2),Pt.return=yt,Et.return=yt,Et.sibling=Pt,yt.child=Et,Pt}function Zl(gt,yt,Et,Pt){return Pt!==null&&Pu(Pt),Bs(yt,gt.child,null,Et),gt=Gu(yt,yt.pendingProps.children),gt.flags|=2,yt.memoizedState=null,gt}function cm(gt,yt,Et){gt.lanes|=yt;var Pt=gt.alternate;Pt!==null&&(Pt.lanes|=yt),bu(gt.return,yt,Et)}function ju(gt,yt,Et,Pt,Rt){var kt=gt.memoizedState;kt===null?gt.memoizedState={isBackwards:yt,rendering:null,renderingStartTime:0,last:Pt,tail:Et,tailMode:Rt}:(kt.isBackwards=yt,kt.rendering=null,kt.renderingStartTime=0,kt.last=Pt,kt.tail=Et,kt.tailMode=Rt)}function um(gt,yt,Et){var Pt=yt.pendingProps,Rt=Pt.revealOrder,kt=Pt.tail;if(_o(gt,yt,Pt.children,Et),Pt=Kr.current,Pt&2)Pt=Pt&1|2,yt.flags|=128;else{if(gt!==null&&gt.flags&128)e:for(gt=yt.child;gt!==null;){if(gt.tag===13)gt.memoizedState!==null&&cm(gt,Et,yt);else if(gt.tag===19)cm(gt,Et,yt);else if(gt.child!==null){gt.child.return=gt,gt=gt.child;continue}if(gt===yt)break e;for(;gt.sibling===null;){if(gt.return===null||gt.return===yt)break e;gt=gt.return}gt.sibling.return=gt.return,gt=gt.sibling}Pt&=1}if(tr(Kr,Pt),!(yt.mode&1))yt.memoizedState=null;else switch(Rt){case"forwards":for(Et=yt.child,Rt=null;Et!==null;)gt=Et.alternate,gt!==null&&$l(gt)===null&&(Rt=Et),Et=Et.sibling;Et=Rt,Et===null?(Rt=yt.child,yt.child=null):(Rt=Et.sibling,Et.sibling=null),ju(yt,!1,Rt,Et,kt);break;case"backwards":for(Et=null,Rt=yt.child,yt.child=null;Rt!==null;){if(gt=Rt.alternate,gt!==null&&$l(gt)===null){yt.child=Rt;break}gt=Rt.sibling,Rt.sibling=Et,Et=Rt,Rt=gt}ju(yt,!0,Et,null,kt);break;case"together":ju(yt,!1,null,null,void 0);break;default:yt.memoizedState=null}return yt.child}function os(gt,yt,Et){if(gt!==null&&(yt.dependencies=gt.dependencies),js|=yt.lanes,!(Et&yt.childLanes))return null;if(gt!==null&&yt.child!==gt.child)throw Error(ot(153));if(yt.child!==null){for(gt=yt.child,Et=ps(gt,gt.pendingProps),yt.child=Et,Et.return=yt;gt.sibling!==null;)gt=gt.sibling,Et=Et.sibling=ps(gt,gt.pendingProps),Et.return=yt;Et.sibling=null}return yt.child}function Qm(gt,yt,Et){switch(yt.tag){case 3:im(yt),$s();break;case 5:Mp(yt);break;case 1:eo(yt.type)&&to(yt);break;case 4:Cu(yt,yt.stateNode.containerInfo);break;case 10:dp(yt,yt.type._context,yt.memoizedProps.value);break;case 13:var Pt=yt.memoizedState;if(Pt!==null)return Pt.dehydrated!==null?(tr(Kr,Kr.current&1),yt.flags|=128,null):Et&yt.child.childLanes?sm(gt,yt,Et):(tr(Kr,Kr.current&1),gt=os(gt,yt,Et),gt!==null?gt.sibling:null);tr(Kr,Kr.current&1);break;case 19:if(Pt=(Et&yt.childLanes)!==0,gt.flags&128){if(Pt)return um(gt,yt,Et);yt.flags|=128}var Rt=yt.memoizedState;if(Rt!==null&&(Rt.rendering=null,Rt.tail=null,Rt.lastEffect=null),tr(Kr,Kr.current),Pt)break;return null;case 22:case 23:return yt.lanes=0,tm(gt,yt,Et)}return os(gt,yt,Et)}function Zm(gt,yt){switch(Eu(yt),yt.tag){case 1:return eo(yt.type)&&Vr(),gt=yt.flags,gt&65536?(yt.flags=gt&-65537|128,yt):null;case 3:return zs(),gr(zr),gr(br),Iu(),gt=yt.flags,gt&65536&&!(gt&128)?(yt.flags=gt&-65537|128,yt):null;case 5:return Ru(yt),null;case 13:if(gr(Kr),gt=yt.memoizedState,gt!==null&&gt.dehydrated!==null){if(yt.alternate===null)throw Error(ot(340));$s()}return gt=yt.flags,gt&65536?(yt.flags=gt&-65537|128,yt):null;case 19:return gr(Kr),null;case 4:return zs(),null;case 10:return vu(yt.type._context),null;case 22:case 23:return op(),null;case 24:return null;default:return null}}var Jl=!1,ws=!1,Jm=typeof WeakSet=="function"?WeakSet:Set,lr=null;function _c(gt,yt){var Et=gt.ref;if(Et!==null)if(typeof Et=="function")try{Et(null)}catch(Pt){To(gt,yt,Pt)}else Et.current=null}function Hu(gt,yt,Et){try{Et()}catch(Pt){To(gt,yt,Pt)}}var dm=!1;function _g(gt,yt){for(zt(gt.containerInfo),lr=yt;lr!==null;)if(gt=lr,yt=gt.child,(gt.subtreeFlags&1028)!==0&&yt!==null)yt.return=gt,lr=yt;else for(;lr!==null;){gt=lr;try{var Et=gt.alternate;if(gt.flags&1024)switch(gt.tag){case 0:case 11:case 15:break;case 1:if(Et!==null){var Pt=Et.memoizedProps,Rt=Et.memoizedState,kt=gt.stateNode,tn=kt.getSnapshotBeforeUpdate(gt.elementType===gt.type?Pt:Fr(gt.type,Pt),Rt);kt.__reactInternalSnapshotBeforeUpdate=tn}break;case 3:nn&&Jn(gt.stateNode.containerInfo);break;case 5:case 6:case 4:case 17:break;default:throw Error(ot(163))}}catch(gn){To(gt,gt.return,gn)}if(yt=gt.sibling,yt!==null){yt.return=gt.return,lr=yt;break}lr=gt.return}return Et=dm,dm=!1,Et}function Ss(gt,yt,Et){var Pt=yt.updateQueue;if(Pt=Pt!==null?Pt.lastEffect:null,Pt!==null){var Rt=Pt=Pt.next;do{if((Rt.tag&gt)===gt){var kt=Rt.destroy;Rt.destroy=void 0,kt!==void 0&&Hu(yt,Et,kt)}Rt=Rt.next}while(Rt!==Pt)}}function yl(gt,yt){if(yt=yt.updateQueue,yt=yt!==null?yt.lastEffect:null,yt!==null){var Et=yt=yt.next;do{if((Et.tag&gt)===gt){var Pt=Et.create;Et.destroy=Pt()}Et=Et.next}while(Et!==yt)}}function Wu(gt){var yt=gt.ref;if(yt!==null){var Et=gt.stateNode;switch(gt.tag){case 5:gt=Ot(Et);break;default:gt=Et}typeof yt=="function"?yt(gt):yt.current=gt}}function fm(gt,yt,Et){if(Qt&&typeof Qt.onCommitFiberUnmount=="function")try{Qt.onCommitFiberUnmount(Ht,yt)}catch{}switch(yt.tag){case 0:case 11:case 14:case 15:if(gt=yt.updateQueue,gt!==null&&(gt=gt.lastEffect,gt!==null)){var Pt=gt=gt.next;do{var Rt=Pt,kt=Rt.destroy;Rt=Rt.tag,kt!==void 0&&(Rt&2||Rt&4)&&Hu(yt,Et,kt),Pt=Pt.next}while(Pt!==gt)}break;case 1:if(_c(yt,Et),gt=yt.stateNode,typeof gt.componentWillUnmount=="function")try{gt.props=yt.memoizedProps,gt.state=yt.memoizedState,gt.componentWillUnmount()}catch(tn){To(yt,Et,tn)}break;case 5:_c(yt,Et);break;case 4:nn?ym(gt,yt,Et):Vt&&Vt&&(yt=yt.stateNode.containerInfo,Et=Kn(yt),wr(yt,Et))}}function hm(gt,yt,Et){for(var Pt=yt;;)if(fm(gt,Pt,Et),Pt.child===null||nn&&Pt.tag===4){if(Pt===yt)break;for(;Pt.sibling===null;){if(Pt.return===null||Pt.return===yt)return;Pt=Pt.return}Pt.sibling.return=Pt.return,Pt=Pt.sibling}else Pt.child.return=Pt,Pt=Pt.child}function pm(gt){var yt=gt.alternate;yt!==null&&(gt.alternate=null,pm(yt)),gt.child=null,gt.deletions=null,gt.sibling=null,gt.tag===5&&(yt=gt.stateNode,yt!==null&&Xn(yt)),gt.stateNode=null,gt.return=null,gt.dependencies=null,gt.memoizedProps=null,gt.memoizedState=null,gt.pendingProps=null,gt.stateNode=null,gt.updateQueue=null}function mm(gt){return gt.tag===5||gt.tag===3||gt.tag===4}function gm(gt){e:for(;;){for(;gt.sibling===null;){if(gt.return===null||mm(gt.return))return null;gt=gt.return}for(gt.sibling.return=gt.return,gt=gt.sibling;gt.tag!==5&&gt.tag!==6&&gt.tag!==18;){if(gt.flags&2||gt.child===null||gt.tag===4)continue e;gt.child.return=gt,gt=gt.child}if(!(gt.flags&2))return gt.stateNode}}function _m(gt){if(nn){e:{for(var yt=gt.return;yt!==null;){if(mm(yt))break e;yt=yt.return}throw Error(ot(160))}var Et=yt;switch(Et.tag){case 5:yt=Et.stateNode,Et.flags&32&&(ir(yt),Et.flags&=-33),Et=gm(gt),Xu(gt,Et,yt);break;case 3:case 4:yt=Et.stateNode.containerInfo,Et=gm(gt),qu(gt,Et,yt);break;default:throw Error(ot(161))}}}function qu(gt,yt,Et){var Pt=gt.tag;if(Pt===5||Pt===6)gt=gt.stateNode,yt?Bn(Et,gt,yt):fr(Et,gt);else if(Pt!==4&&(gt=gt.child,gt!==null))for(qu(gt,yt,Et),gt=gt.sibling;gt!==null;)qu(gt,yt,Et),gt=gt.sibling}function Xu(gt,yt,Et){var Pt=gt.tag;if(Pt===5||Pt===6)gt=gt.stateNode,yt?hr(Et,gt,yt):or(Et,gt);else if(Pt!==4&&(gt=gt.child,gt!==null))for(Xu(gt,yt,Et),gt=gt.sibling;gt!==null;)Xu(gt,yt,Et),gt=gt.sibling}function ym(gt,yt,Et){for(var Pt=yt,Rt=!1,kt,tn;;){if(!Rt){Rt=Pt.return;e:for(;;){if(Rt===null)throw Error(ot(160));switch(kt=Rt.stateNode,Rt.tag){case 5:tn=!1;break e;case 3:kt=kt.containerInfo,tn=!0;break e;case 4:kt=kt.containerInfo,tn=!0;break e}Rt=Rt.return}Rt=!0}if(Pt.tag===5||Pt.tag===6)hm(gt,Pt,Et),tn?Fn(kt,Pt.stateNode):cn(kt,Pt.stateNode);else if(Pt.tag===18)tn?an(kt,Pt.stateNode):sn(kt,Pt.stateNode);else if(Pt.tag===4){if(Pt.child!==null){kt=Pt.stateNode.containerInfo,tn=!0,Pt.child.return=Pt,Pt=Pt.child;continue}}else if(fm(gt,Pt,Et),Pt.child!==null){Pt.child.return=Pt,Pt=Pt.child;continue}if(Pt===yt)break;for(;Pt.sibling===null;){if(Pt.return===null||Pt.return===yt)return;Pt=Pt.return,Pt.tag===4&&(Rt=!1)}Pt.sibling.return=Pt.return,Pt=Pt.sibling}}function Yu(gt,yt){if(nn){switch(yt.tag){case 0:case 11:case 14:case 15:Ss(3,yt,yt.return),yl(3,yt),Ss(5,yt,yt.return);return;case 1:return;case 5:var Et=yt.stateNode;if(Et!=null){var Pt=yt.memoizedProps;gt=gt!==null?gt.memoizedProps:Pt;var Rt=yt.type,kt=yt.updateQueue;yt.updateQueue=null,kt!==null&&mr(Et,kt,Rt,gt,Pt,yt)}return;case 6:if(yt.stateNode===null)throw Error(ot(162));Et=yt.memoizedProps,Gn(yt.stateNode,gt!==null?gt.memoizedProps:Et,Et);return;case 3:on&&gt!==null&&gt.memoizedState.isDehydrated&&Xt(yt.stateNode.containerInfo);return;case 12:return;case 13:eu(yt);return;case 19:eu(yt);return;case 17:return}throw Error(ot(163))}switch(yt.tag){case 0:case 11:case 14:case 15:Ss(3,yt,yt.return),yl(3,yt),Ss(5,yt,yt.return);return;case 12:return;case 13:eu(yt);return;case 19:eu(yt);return;case 3:on&&gt!==null&&gt.memoizedState.isDehydrated&&Xt(yt.stateNode.containerInfo);break;case 22:case 23:return}e:if(Vt){switch(yt.tag){case 1:case 5:case 6:break e;case 3:case 4:yt=yt.stateNode,wr(yt.containerInfo,yt.pendingChildren);break e}throw Error(ot(163))}}function eu(gt){var yt=gt.updateQueue;if(yt!==null){gt.updateQueue=null;var Et=gt.stateNode;Et===null&&(Et=gt.stateNode=new Jm),yt.forEach(function(Pt){var Rt=c_.bind(null,gt,Pt);Et.has(Pt)||(Et.add(Pt),Pt.then(Rt,Rt))})}}function e_(gt,yt){for(lr=yt;lr!==null;){yt=lr;var Et=yt.deletions;if(Et!==null)for(var Pt=0;Pt<Et.length;Pt++){var Rt=Et[Pt];try{var kt=gt;nn?ym(kt,Rt,yt):hm(kt,Rt,yt);var tn=Rt.alternate;tn!==null&&(tn.return=null),Rt.return=null}catch(yr){To(Rt,yt,yr)}}if(Et=yt.child,yt.subtreeFlags&12854&&Et!==null)Et.return=yt,lr=Et;else for(;lr!==null;){yt=lr;try{var gn=yt.flags;if(gn&32&&nn&&ir(yt.stateNode),gn&512){var Nn=yt.alternate;if(Nn!==null){var er=Nn.ref;er!==null&&(typeof er=="function"?er(null):er.current=null)}}if(gn&8192)switch(yt.tag){case 13:if(yt.memoizedState!==null){var dr=yt.alternate;(dr===null||dr.memoizedState===null)&&(_h=Zr())}break;case 22:var Er=yt.memoizedState!==null,xr=yt.alternate,Gr=xr!==null&&xr.memoizedState!==null;if(Et=yt,nn){e:if(Pt=Et,Rt=Er,kt=null,nn)for(var vr=Pt;;){if(vr.tag===5){if(kt===null){kt=vr;var mo=vr.stateNode;Rt?ln(mo):Dn(vr.stateNode,vr.memoizedProps)}}else if(vr.tag===6){if(kt===null){var Bo=vr.stateNode;Rt?On(Bo):$n(Bo,vr.memoizedProps)}}else if((vr.tag!==22&&vr.tag!==23||vr.memoizedState===null||vr===Pt)&&vr.child!==null){vr.child.return=vr,vr=vr.child;continue}if(vr===Pt)break;for(;vr.sibling===null;){if(vr.return===null||vr.return===Pt)break e;kt===vr&&(kt=null),vr=vr.return}kt===vr&&(kt=null),vr.sibling.return=vr.return,vr=vr.sibling}}if(Er&&!Gr&&Et.mode&1){lr=Et;for(var An=Et.child;An!==null;){for(Et=lr=An;lr!==null;){Pt=lr;var yn=Pt.child;switch(Pt.tag){case 0:case 11:case 14:case 15:Ss(4,Pt,Pt.return);break;case 1:_c(Pt,Pt.return);var kn=Pt.stateNode;if(typeof kn.componentWillUnmount=="function"){var ur=Pt.return;try{kn.props=Pt.memoizedProps,kn.state=Pt.memoizedState,kn.componentWillUnmount()}catch(yr){To(Pt,ur,yr)}}break;case 5:_c(Pt,Pt.return);break;case 22:if(Pt.memoizedState!==null){xm(Et);continue}}yn!==null?(yn.return=Pt,lr=yn):xm(Et)}An=An.sibling}}}switch(gn&4102){case 2:_m(yt),yt.flags&=-3;break;case 6:_m(yt),yt.flags&=-3,Yu(yt.alternate,yt);break;case 4096:yt.flags&=-4097;break;case 4100:yt.flags&=-4097,Yu(yt.alternate,yt);break;case 4:Yu(yt.alternate,yt)}}catch(yr){To(yt,yt.return,yr)}if(Et=yt.sibling,Et!==null){Et.return=yt.return,lr=Et;break}lr=yt.return}}}function t_(gt,yt,Et){lr=gt,vm(gt)}function vm(gt,yt,Et){for(var Pt=(gt.mode&1)!==0;lr!==null;){var Rt=lr,kt=Rt.child;if(Rt.tag===22&&Pt){var tn=Rt.memoizedState!==null||Jl;if(!tn){var gn=Rt.alternate,Nn=gn!==null&&gn.memoizedState!==null||ws;gn=Jl;var er=ws;if(Jl=tn,(ws=Nn)&&!er)for(lr=Rt;lr!==null;)tn=lr,Nn=tn.child,tn.tag===22&&tn.memoizedState!==null?wm(Rt):Nn!==null?(Nn.return=tn,lr=Nn):wm(Rt);for(;kt!==null;)lr=kt,vm(kt),kt=kt.sibling;lr=Rt,Jl=gn,ws=er}bm(gt)}else Rt.subtreeFlags&8772&&kt!==null?(kt.return=Rt,lr=kt):bm(gt)}}function bm(gt){for(;lr!==null;){var yt=lr;if(yt.flags&8772){var Et=yt.alternate;try{if(yt.flags&8772)switch(yt.tag){case 0:case 11:case 15:ws||yl(5,yt);break;case 1:var Pt=yt.stateNode;if(yt.flags&4&&!ws)if(Et===null)Pt.componentDidMount();else{var Rt=yt.elementType===yt.type?Et.memoizedProps:Fr(yt.type,Et.memoizedProps);Pt.componentDidUpdate(Rt,Et.memoizedState,Pt.__reactInternalSnapshotBeforeUpdate)}var kt=yt.updateQueue;kt!==null&&pp(yt,kt,Pt);break;case 3:var tn=yt.updateQueue;if(tn!==null){if(Et=null,yt.child!==null)switch(yt.child.tag){case 5:Et=Ot(yt.child.stateNode);break;case 1:Et=yt.child.stateNode}pp(yt,tn,Et)}break;case 5:var gn=yt.stateNode;Et===null&&yt.flags&4&&nr(gn,yt.type,yt.memoizedProps,yt);break;case 6:break;case 4:break;case 12:break;case 13:if(on&&yt.memoizedState===null){var Nn=yt.alternate;if(Nn!==null){var er=Nn.memoizedState;if(er!==null){var dr=er.dehydrated;dr!==null&&Jt(dr)}}}break;case 19:case 17:case 21:case 22:case 23:break;default:throw Error(ot(163))}ws||yt.flags&512&&Wu(yt)}catch(Er){To(yt,yt.return,Er)}}if(yt===gt){lr=null;break}if(Et=yt.sibling,Et!==null){Et.return=yt.return,lr=Et;break}lr=yt.return}}function xm(gt){for(;lr!==null;){var yt=lr;if(yt===gt){lr=null;break}var Et=yt.sibling;if(Et!==null){Et.return=yt.return,lr=Et;break}lr=yt.return}}function wm(gt){for(;lr!==null;){var yt=lr;try{switch(yt.tag){case 0:case 11:case 15:var Et=yt.return;try{yl(4,yt)}catch(Nn){To(yt,Et,Nn)}break;case 1:var Pt=yt.stateNode;if(typeof Pt.componentDidMount=="function"){var Rt=yt.return;try{Pt.componentDidMount()}catch(Nn){To(yt,Rt,Nn)}}var kt=yt.return;try{Wu(yt)}catch(Nn){To(yt,kt,Nn)}break;case 5:var tn=yt.return;try{Wu(yt)}catch(Nn){To(yt,tn,Nn)}}}catch(Nn){To(yt,yt.return,Nn)}if(yt===gt){lr=null;break}var gn=yt.sibling;if(gn!==null){gn.return=yt.return,lr=gn;break}lr=yt.return}}var tu=0,nu=1,ru=2,iu=3,ou=4;if(typeof Symbol=="function"&&Symbol.for){var xl=Symbol.for;tu=xl("selector.component"),nu=xl("selector.has_pseudo_class"),ru=xl("selector.role"),iu=xl("selector.test_id"),ou=xl("selector.text")}function Ku(gt){var yt=dn(gt);if(yt!=null){if(typeof yt.memoizedProps["data-testname"]!="string")throw Error(ot(364));return yt}if(gt=Gt(gt),gt===null)throw Error(ot(362));return gt.stateNode.current}function Qu(gt,yt){switch(yt.$$typeof){case tu:if(gt.type===yt.value)return!0;break;case nu:e:{yt=yt.value,gt=[gt,0];for(var Et=0;Et<gt.length;){var Pt=gt[Et++],Rt=gt[Et++],kt=yt[Rt];if(Pt.tag!==5||!xn(Pt)){for(;kt!=null&&Qu(Pt,kt);)Rt++,kt=yt[Rt];if(Rt===yt.length){yt=!0;break e}else for(Pt=Pt.child;Pt!==null;)gt.push(Pt,Rt),Pt=Pt.sibling}}yt=!1}return yt;case ru:if(gt.tag===5&&Tn(gt.stateNode,yt.value))return!0;break;case ou:if((gt.tag===5||gt.tag===6)&&(gt=hn(gt),gt!==null&&0<=gt.indexOf(yt.value)))return!0;break;case iu:if(gt.tag===5&&(gt=gt.memoizedProps["data-testname"],typeof gt=="string"&&gt.toLowerCase()===yt.value.toLowerCase()))return!0;break;default:throw Error(ot(365))}return!1}function Zu(gt){switch(gt.$$typeof){case tu:return"<"+(Mt(gt.value)||"Unknown")+">";case nu:return":has("+(Zu(gt)||"")+")";case ru:return'[role="'+gt.value+'"]';case ou:return'"'+gt.value+'"';case iu:return'[data-testname="'+gt.value+'"]';default:throw Error(ot(365))}}function Sm(gt,yt){var Et=[];gt=[gt,0];for(var Pt=0;Pt<gt.length;){var Rt=gt[Pt++],kt=gt[Pt++],tn=yt[kt];if(Rt.tag!==5||!xn(Rt)){for(;tn!=null&&Qu(Rt,tn);)kt++,tn=yt[kt];if(kt===yt.length)Et.push(Rt);else for(Rt=Rt.child;Rt!==null;)gt.push(Rt,kt),Rt=Rt.sibling}}return Et}function Ju(gt,yt){if(!Zt)throw Error(ot(363));gt=Ku(gt),gt=Sm(gt,yt),yt=[],gt=Array.from(gt);for(var Et=0;Et<gt.length;){var Pt=gt[Et++];if(Pt.tag===5)xn(Pt)||yt.push(Pt.stateNode);else for(Pt=Pt.child;Pt!==null;)gt.push(Pt),Pt=Pt.sibling}return yt}var n_=Math.ceil,su=at.ReactCurrentDispatcher,_d=at.ReactCurrentOwner,_i=at.ReactCurrentBatchConfig,kr=0,no=null,ro=null,lo=0,Po=0,Gs=jr(0),io=0,wl=null,js=0,au=0,_f=0,Sl=null,wo=null,_h=0,ep=1/0;function Hs(){ep=Zr()+500}var lu=!1,tp=null,us=null,cu=!1,ds=null,uu=0,Tl=0,np=null,du=-1,fu=0;function yo(){return kr&6?Zr():du!==-1?du:du=Zr()}function fs(gt){return gt.mode&1?kr&2&&lo!==0?lo&-lo:bo.transition!==null?(fu===0&&(gt=_s,_s<<=1,!(_s&4194240)&&(_s=64),fu=gt),fu):(gt=Nr,gt!==0?gt:Sn()):1}function Fo(gt,yt,Et){if(50<Tl)throw Tl=0,np=null,Error(ot(185));var Pt=hu(gt,yt);return Pt===null?null:(Xo(Pt,yt,Et),(!(kr&2)||Pt!==no)&&(Pt===no&&(!(kr&2)&&(au|=yt),io===4&&hs(Pt,lo)),So(Pt,Et),yt===1&&kr===0&&!(gt.mode&1)&&(Hs(),pr&&Jr())),Pt)}function hu(gt,yt){gt.lanes|=yt;var Et=gt.alternate;for(Et!==null&&(Et.lanes|=yt),Et=gt,gt=gt.return;gt!==null;)gt.childLanes|=yt,Et=gt.alternate,Et!==null&&(Et.childLanes|=yt),Et=gt,gt=gt.return;return Et.tag===3?Et.stateNode:null}function So(gt,yt){var Et=gt.callbackNode;Cr(gt,yt);var Pt=Tr(gt,gt===no?lo:0);if(Pt===0)Et!==null&&qs(Et),gt.callbackNode=null,gt.callbackPriority=0;else if(yt=Pt&-Pt,gt.callbackPriority!==yt){if(Et!=null&&qs(Et),yt===1)gt.tag===0?qr(Em.bind(null,gt)):Rr(Em.bind(null,gt)),Vn?Hn(function(){kr===0&&Jr()}):Os(Is,Jr),Et=null;else{switch(Ws(Pt)){case 1:Et=Is;break;case 4:Et=Rl;break;case 16:Et=Ls;break;case 536870912:Et=Ft;break;default:Et=Ls}Et=km(Et,Tm.bind(null,gt))}gt.callbackPriority=yt,gt.callbackNode=Et}}function Tm(gt,yt){if(du=-1,fu=0,kr&6)throw Error(ot(327));var Et=gt.callbackNode;if(Ms()&&gt.callbackNode!==Et)return null;var Pt=Tr(gt,gt===no?lo:0);if(Pt===0)return null;if(Pt&30||Pt&gt.expiredLanes||yt)yt=pu(gt,Pt);else{yt=Pt;var Rt=kr;kr|=2;var kt=Pm();(no!==gt||lo!==yt)&&(Hs(),Ts(gt,yt));do try{o_();break}catch(gn){Am(gt,gn)}while(!0);yu(),su.current=kt,kr=Rt,ro!==null?yt=0:(no=null,lo=0,yt=io)}if(yt!==0){if(yt===2&&(Rt=Sr(gt),Rt!==0&&(Pt=Rt,yt=rp(gt,Rt))),yt===1)throw Et=wl,Ts(gt,0),hs(gt,Pt),So(gt,Zr()),Et;if(yt===6)hs(gt,Pt);else{if(Rt=gt.current.alternate,!(Pt&30)&&!r_(Rt)&&(yt=pu(gt,Pt),yt===2&&(kt=Sr(gt),kt!==0&&(Pt=kt,yt=rp(gt,kt))),yt===1))throw Et=wl,Ts(gt,0),hs(gt,Pt),So(gt,Zr()),Et;switch(gt.finishedWork=Rt,gt.finishedLanes=Pt,yt){case 0:case 1:throw Error(ot(345));case 2:Es(gt,wo);break;case 3:if(hs(gt,Pt),(Pt&130023424)===Pt&&(yt=_h+500-Zr(),10<yt)){if(Tr(gt,0)!==0)break;if(Rt=gt.suspendedLanes,(Rt&Pt)!==Pt){yo(),gt.pingedLanes|=gt.suspendedLanes&Rt;break}gt.timeoutHandle=Cn(Es.bind(null,gt,wo),yt);break}Es(gt,wo);break;case 4:if(hs(gt,Pt),(Pt&4194240)===Pt)break;for(yt=gt.eventTimes,Rt=-1;0<Pt;){var tn=31-uo(Pt);kt=1<<tn,tn=yt[tn],tn>Rt&&(Rt=tn),Pt&=~kt}if(Pt=Rt,Pt=Zr()-Pt,Pt=(120>Pt?120:480>Pt?480:1080>Pt?1080:1920>Pt?1920:3e3>Pt?3e3:4320>Pt?4320:1960*n_(Pt/1960))-Pt,10<Pt){gt.timeoutHandle=Cn(Es.bind(null,gt,wo),Pt);break}Es(gt,wo);break;case 5:Es(gt,wo);break;default:throw Error(ot(329))}}}return So(gt,Zr()),gt.callbackNode===Et?Tm.bind(null,gt):null}function rp(gt,yt){var Et=Sl;return gt.current.memoizedState.isDehydrated&&(Ts(gt,yt).flags|=256),gt=pu(gt,yt),gt!==2&&(yt=wo,wo=Et,yt!==null&&ip(yt)),gt}function ip(gt){wo===null?wo=gt:wo.push.apply(wo,gt)}function r_(gt){for(var yt=gt;;){if(yt.flags&16384){var Et=yt.updateQueue;if(Et!==null&&(Et=Et.stores,Et!==null))for(var Pt=0;Pt<Et.length;Pt++){var Rt=Et[Pt],kt=Rt.getSnapshot;Rt=Rt.value;try{if(!Pn(kt(),Rt))return!1}catch{return!1}}}if(Et=yt.child,yt.subtreeFlags&16384&&Et!==null)Et.return=yt,yt=Et;else{if(yt===gt)break;for(;yt.sibling===null;){if(yt.return===null||yt.return===gt)return!0;yt=yt.return}yt.sibling.return=yt.return,yt=yt.sibling}}return!0}function hs(gt,yt){for(yt&=~_f,yt&=~au,gt.suspendedLanes|=yt,gt.pingedLanes&=~yt,gt=gt.expirationTimes;0<yt;){var Et=31-uo(yt),Pt=1<<Et;gt[Et]=-1,yt&=~Pt}}function Em(gt){if(kr&6)throw Error(ot(327));Ms();var yt=Tr(gt,0);if(!(yt&1))return So(gt,Zr()),null;var Et=pu(gt,yt);if(gt.tag!==0&&Et===2){var Pt=Sr(gt);Pt!==0&&(yt=Pt,Et=rp(gt,Pt))}if(Et===1)throw Et=wl,Ts(gt,0),hs(gt,yt),So(gt,Zr()),Et;if(Et===6)throw Error(ot(345));return gt.finishedWork=gt.current.alternate,gt.finishedLanes=yt,Es(gt,wo),So(gt,Zr()),null}function Mm(gt){ds!==null&&ds.tag===0&&!(kr&6)&&Ms();var yt=kr;kr|=1;var Et=_i.transition,Pt=Nr;try{if(_i.transition=null,Nr=1,gt)return gt()}finally{Nr=Pt,_i.transition=Et,kr=yt,!(kr&6)&&Jr()}}function op(){Po=Gs.current,gr(Gs)}function Ts(gt,yt){gt.finishedWork=null,gt.finishedLanes=0;var Et=gt.timeoutHandle;if(Et!==jt&&(gt.timeoutHandle=jt,En(Et)),ro!==null)for(Et=ro.return;Et!==null;){var Pt=Et;switch(Eu(Pt),Pt.tag){case 1:Pt=Pt.type.childContextTypes,Pt!=null&&Vr();break;case 3:zs(),gr(zr),gr(br),Iu();break;case 5:Ru(Pt);break;case 4:zs();break;case 13:gr(Kr);break;case 19:gr(Kr);break;case 10:vu(Pt.type._context);break;case 22:case 23:op()}Et=Et.return}if(no=gt,ro=gt=ps(gt.current,null),lo=Po=yt,io=0,wl=null,_f=au=js=0,wo=Sl=null,Yo!==null){for(yt=0;yt<Yo.length;yt++)if(Et=Yo[yt],Pt=Et.interleaved,Pt!==null){Et.interleaved=null;var Rt=Pt.next,kt=Et.pending;if(kt!==null){var tn=kt.next;kt.next=Rt,Pt.next=tn}Et.pending=Pt}Yo=null}return gt}function Am(gt,yt){do{var Et=ro;try{if(yu(),Bl.current=Wl,Ul){for(var Pt=Qr.memoizedState;Pt!==null;){var Rt=Pt.queue;Rt!==null&&(Rt.pending=null),Pt=Pt.next}Ul=!1}if(Vs=0,oo=fo=Qr=null,Js=!1,na=0,_d.current=null,Et===null||Et.return===null){io=1,wl=yt,ro=null;break}e:{var kt=gt,tn=Et.return,gn=Et,Nn=yt;if(yt=lo,gn.flags|=32768,Nn!==null&&typeof Nn=="object"&&typeof Nn.then=="function"){var er=Nn,dr=gn,Er=dr.tag;if(!(dr.mode&1)&&(Er===0||Er===11||Er===15)){var xr=dr.alternate;xr?(dr.updateQueue=xr.updateQueue,dr.memoizedState=xr.memoizedState,dr.lanes=xr.lanes):(dr.updateQueue=null,dr.memoizedState=null)}var Gr=Xp(tn);if(Gr!==null){Gr.flags&=-257,Yp(Gr,tn,gn,kt,yt),Gr.mode&1&&qp(kt,er,yt),yt=Gr,Nn=er;var vr=yt.updateQueue;if(vr===null){var mo=new Set;mo.add(Nn),yt.updateQueue=mo}else vr.add(Nn);break e}else{if(!(yt&1)){qp(kt,er,yt),sp();break e}Nn=Error(ot(426))}}else if(Xr&&gn.mode&1){var Bo=Xp(tn);if(Bo!==null){!(Bo.flags&65536)&&(Bo.flags|=256),Yp(Bo,tn,gn,kt,yt),Pu(Nn);break e}}kt=Nn,io!==4&&(io=2),Sl===null?Sl=[kt]:Sl.push(kt),Nn=Bu(Nn,gn),gn=tn;do{switch(gn.tag){case 3:gn.flags|=65536,yt&=-yt,gn.lanes|=yt;var An=Hp(gn,Nn,yt);hp(gn,An);break e;case 1:kt=Nn;var yn=gn.type,kn=gn.stateNode;if(!(gn.flags&128)&&(typeof yn.getDerivedStateFromError=="function"||kn!==null&&typeof kn.componentDidCatch=="function"&&(us===null||!us.has(kn)))){gn.flags|=65536,yt&=-yt,gn.lanes|=yt;var ur=Wp(gn,kt,yt);hp(gn,ur);break e}}gn=gn.return}while(gn!==null)}Rm(Et)}catch(yr){yt=yr,ro===Et&&Et!==null&&(ro=Et=Et.return);continue}break}while(!0)}function Pm(){var gt=su.current;return su.current=Wl,gt===null?Wl:gt}function sp(){(io===0||io===3||io===2)&&(io=4),no===null||!(js&268435455)&&!(au&268435455)||hs(no,lo)}function pu(gt,yt){var Et=kr;kr|=2;var Pt=Pm();no===gt&&lo===yt||Ts(gt,yt);do try{i_();break}catch(Rt){Am(gt,Rt)}while(!0);if(yu(),kr=Et,su.current=Pt,ro!==null)throw Error(ot(261));return no=null,lo=0,io}function i_(){for(;ro!==null;)Cm(ro)}function o_(){for(;ro!==null&&!Pl();)Cm(ro)}function Cm(gt){var yt=Lm(gt.alternate,gt,Po);gt.memoizedProps=gt.pendingProps,yt===null?Rm(gt):ro=yt,_d.current=null}function Rm(gt){var yt=gt;do{var Et=yt.alternate;if(gt=yt.return,yt.flags&32768){if(Et=Zm(Et,yt),Et!==null){Et.flags&=32767,ro=Et;return}if(gt!==null)gt.flags|=32768,gt.subtreeFlags=0,gt.deletions=null;else{io=6,ro=null;return}}else if(Et=Ym(Et,yt,Po),Et!==null){ro=Et;return}if(yt=yt.sibling,yt!==null){ro=yt;return}ro=yt=gt}while(yt!==null);io===0&&(io=5)}function Es(gt,yt){var Et=Nr,Pt=_i.transition;try{_i.transition=null,Nr=1,s_(gt,yt,Et)}finally{_i.transition=Pt,Nr=Et}return null}function s_(gt,yt,Et){do Ms();while(ds!==null);if(kr&6)throw Error(ot(327));var Pt=gt.finishedWork,Rt=gt.finishedLanes;if(Pt===null)return null;if(gt.finishedWork=null,gt.finishedLanes=0,Pt===gt.current)throw Error(ot(177));gt.callbackNode=null,gt.callbackPriority=0;var kt=Pt.lanes|Pt.childLanes;if(Al(gt,kt),gt===no&&(ro=no=null,lo=0),!(Pt.subtreeFlags&2064)&&!(Pt.flags&2064)||cu||(cu=!0,km(Ls,function(){return Ms(),null})),kt=(Pt.flags&15990)!==0,Pt.subtreeFlags&15990||kt){kt=_i.transition,_i.transition=null;var tn=Nr;Nr=1;var gn=kr;kr|=4,_d.current=null,_g(gt,Pt),e_(gt,Pt),Yt(gt.containerInfo),gt.current=Pt,t_(Pt),Cl(),kr=gn,Nr=tn,_i.transition=kt}else gt.current=Pt;if(cu&&(cu=!1,ds=gt,uu=Rt),kt=gt.pendingLanes,kt===0&&(us=null),un(Pt.stateNode),So(gt,Zr()),yt!==null)for(Et=gt.onRecoverableError,Pt=0;Pt<yt.length;Pt++)Et(yt[Pt]);if(lu)throw lu=!1,gt=tp,tp=null,gt;return uu&1&&gt.tag!==0&&Ms(),kt=gt.pendingLanes,kt&1?gt===np?Tl++:(Tl=0,np=gt):Tl=0,Jr(),null}function Ms(){if(ds!==null){var gt=Ws(uu),yt=_i.transition,Et=Nr;try{if(_i.transition=null,Nr=16>gt?16:gt,ds===null)var Pt=!1;else{if(gt=ds,ds=null,uu=0,kr&6)throw Error(ot(331));var Rt=kr;for(kr|=4,lr=gt.current;lr!==null;){var kt=lr,tn=kt.child;if(lr.flags&16){var gn=kt.deletions;if(gn!==null){for(var Nn=0;Nn<gn.length;Nn++){var er=gn[Nn];for(lr=er;lr!==null;){var dr=lr;switch(dr.tag){case 0:case 11:case 15:Ss(8,dr,kt)}var Er=dr.child;if(Er!==null)Er.return=dr,lr=Er;else for(;lr!==null;){dr=lr;var xr=dr.sibling,Gr=dr.return;if(pm(dr),dr===er){lr=null;break}if(xr!==null){xr.return=Gr,lr=xr;break}lr=Gr}}}var vr=kt.alternate;if(vr!==null){var mo=vr.child;if(mo!==null){vr.child=null;do{var Bo=mo.sibling;mo.sibling=null,mo=Bo}while(mo!==null)}}lr=kt}}if(kt.subtreeFlags&2064&&tn!==null)tn.return=kt,lr=tn;else e:for(;lr!==null;){if(kt=lr,kt.flags&2048)switch(kt.tag){case 0:case 11:case 15:Ss(9,kt,kt.return)}var An=kt.sibling;if(An!==null){An.return=kt.return,lr=An;break e}lr=kt.return}}var yn=gt.current;for(lr=yn;lr!==null;){tn=lr;var kn=tn.child;if(tn.subtreeFlags&2064&&kn!==null)kn.return=tn,lr=kn;else e:for(tn=yn;lr!==null;){if(gn=lr,gn.flags&2048)try{switch(gn.tag){case 0:case 11:case 15:yl(9,gn)}}catch(yr){To(gn,gn.return,yr)}if(gn===tn){lr=null;break e}var ur=gn.sibling;if(ur!==null){ur.return=gn.return,lr=ur;break e}lr=gn.return}}if(kr=Rt,Jr(),Qt&&typeof Qt.onPostCommitFiberRoot=="function")try{Qt.onPostCommitFiberRoot(Ht,gt)}catch{}Pt=!0}return Pt}finally{Nr=Et,_i.transition=yt}}return!1}function Om(gt,yt,Et){yt=Bu(Et,yt),yt=Hp(gt,yt,1),cs(gt,yt),yt=yo(),gt=hu(gt,1),gt!==null&&(Xo(gt,1,yt),So(gt,yt))}function To(gt,yt,Et){if(gt.tag===3)Om(gt,gt,Et);else for(;yt!==null;){if(yt.tag===3){Om(yt,gt,Et);break}else if(yt.tag===1){var Pt=yt.stateNode;if(typeof yt.type.getDerivedStateFromError=="function"||typeof Pt.componentDidCatch=="function"&&(us===null||!us.has(Pt))){gt=Bu(Et,gt),gt=Wp(yt,gt,1),cs(yt,gt),gt=yo(),yt=hu(yt,1),yt!==null&&(Xo(yt,1,gt),So(yt,gt));break}}yt=yt.return}}function a_(gt,yt,Et){var Pt=gt.pingCache;Pt!==null&&Pt.delete(yt),yt=yo(),gt.pingedLanes|=gt.suspendedLanes&Et,no===gt&&(lo&Et)===Et&&(io===4||io===3&&(lo&130023424)===lo&&500>Zr()-_h?Ts(gt,0):_f|=Et),So(gt,yt)}function Im(gt,yt){yt===0&&(gt.mode&1?(yt=ss,ss<<=1,!(ss&130023424)&&(ss=4194304)):yt=1);var Et=yo();gt=hu(gt,yt),gt!==null&&(Xo(gt,yt,Et),So(gt,Et))}function l_(gt){var yt=gt.memoizedState,Et=0;yt!==null&&(Et=yt.retryLane),Im(gt,Et)}function c_(gt,yt){var Et=0;switch(gt.tag){case 13:var Pt=gt.stateNode,Rt=gt.memoizedState;Rt!==null&&(Et=Rt.retryLane);break;case 19:Pt=gt.stateNode;break;default:throw Error(ot(314))}Pt!==null&&Pt.delete(yt),Im(gt,Et)}var Lm;Lm=function(gt,yt,Et){if(gt!==null)if(gt.memoizedProps!==yt.pendingProps||zr.current)Ao=!0;else{if(!(gt.lanes&Et)&&!(yt.flags&128))return Ao=!1,Qm(gt,yt,Et);Ao=!!(gt.flags&131072)}else Ao=!1,Xr&&yt.flags&1048576&&vp(yt,Nl,yt.index);switch(yt.lanes=0,yt.tag){case 2:var Pt=yt.type;gt!==null&&(gt.alternate=null,yt.alternate=null,yt.flags|=2),gt=yt.pendingProps;var Rt=Yr(yt,br.current);Ds(yt,Et),Rt=ku(null,yt,Pt,gt,Rt,Et);var kt=Du();return yt.flags|=1,typeof Rt=="object"&&Rt!==null&&typeof Rt.render=="function"&&Rt.$$typeof===void 0?(yt.tag=1,yt.memoizedState=null,yt.updateQueue=null,eo(Pt)?(kt=!0,to(yt)):kt=!1,yt.memoizedState=Rt.state!==null&&Rt.state!==void 0?Rt.state:null,xu(yt),Rt.updater=Ll,yt.stateNode=Rt,Rt._reactInternals=yt,Su(yt,Pt,gt,Et),yt=Vu(null,yt,Pt,!0,kt,Et)):(yt.tag=0,Xr&&kt&&Tu(yt),_o(null,yt,Rt,Et),yt=yt.child),yt;case 16:Pt=yt.elementType;e:{switch(gt!==null&&(gt.alternate=null,yt.alternate=null,yt.flags|=2),gt=yt.pendingProps,Rt=Pt._init,Pt=Rt(Pt._payload),yt.type=Pt,Rt=yt.tag=d_(Pt),gt=Fr(Pt,gt),Rt){case 0:yt=zu(null,yt,Pt,gt,Et);break e;case 1:yt=rm(null,yt,Pt,gt,Et);break e;case 11:yt=Zp(null,yt,Pt,gt,Et);break e;case 14:yt=Jp(null,yt,Pt,Fr(Pt.type,gt),Et);break e}throw Error(ot(306,Pt,""))}return yt;case 0:return Pt=yt.type,Rt=yt.pendingProps,Rt=yt.elementType===Pt?Rt:Fr(Pt,Rt),zu(gt,yt,Pt,Rt,Et);case 1:return Pt=yt.type,Rt=yt.pendingProps,Rt=yt.elementType===Pt?Rt:Fr(Pt,Rt),rm(gt,yt,Pt,Rt,Et);case 3:e:{if(im(yt),gt===null)throw Error(ot(387));Pt=yt.pendingProps,kt=yt.memoizedState,Rt=kt.element,fp(gt,yt),Il(yt,Pt,null,Et);var tn=yt.memoizedState;if(Pt=tn.element,on&&kt.isDehydrated)if(kt={element:Pt,isDehydrated:!1,cache:tn.cache,transitions:tn.transitions},yt.updateQueue.baseState=kt,yt.memoizedState=kt,yt.flags&256){Rt=Error(ot(423)),yt=om(gt,yt,Pt,Et,Rt);break e}else if(Pt!==Rt){Rt=Error(ot(424)),yt=om(gt,yt,Pt,Et,Rt);break e}else for(on&&(Mo=Ho(yt.stateNode.containerInfo),Eo=yt,Xr=!0,Go=null,Xs=!1),Et=Ep(yt,null,Pt,Et),yt.child=Et;Et;)Et.flags=Et.flags&-3|4096,Et=Et.sibling;else{if($s(),Pt===Rt){yt=os(gt,yt,Et);break e}_o(gt,yt,Pt,Et)}yt=yt.child}return yt;case 5:return Mp(yt),gt===null&&Au(yt),Pt=yt.type,Rt=yt.pendingProps,kt=gt!==null?gt.memoizedProps:null,tn=Rt.children,vn(Pt,Rt)?tn=null:kt!==null&&vn(Pt,kt)&&(yt.flags|=32),nm(gt,yt),_o(gt,yt,tn,Et),yt.child;case 6:return gt===null&&Au(yt),null;case 13:return sm(gt,yt,Et);case 4:return Cu(yt,yt.stateNode.containerInfo),Pt=yt.pendingProps,gt===null?yt.child=Bs(yt,null,Pt,Et):_o(gt,yt,Pt,Et),yt.child;case 11:return Pt=yt.type,Rt=yt.pendingProps,Rt=yt.elementType===Pt?Rt:Fr(Pt,Rt),Zp(gt,yt,Pt,Rt,Et);case 7:return _o(gt,yt,yt.pendingProps,Et),yt.child;case 8:return _o(gt,yt,yt.pendingProps.children,Et),yt.child;case 12:return _o(gt,yt,yt.pendingProps.children,Et),yt.child;case 10:e:{if(Pt=yt.type._context,Rt=yt.pendingProps,kt=yt.memoizedProps,tn=Rt.value,dp(yt,Pt,tn),kt!==null)if(Pn(kt.value,tn)){if(kt.children===Rt.children&&!zr.current){yt=os(gt,yt,Et);break e}}else for(kt=yt.child,kt!==null&&(kt.return=yt);kt!==null;){var gn=kt.dependencies;if(gn!==null){tn=kt.child;for(var Nn=gn.firstContext;Nn!==null;){if(Nn.context===Pt){if(kt.tag===1){Nn=es(-1,Et&-Et),Nn.tag=2;var er=kt.updateQueue;if(er!==null){er=er.shared;var dr=er.pending;dr===null?Nn.next=Nn:(Nn.next=dr.next,dr.next=Nn),er.pending=Nn}}kt.lanes|=Et,Nn=kt.alternate,Nn!==null&&(Nn.lanes|=Et),bu(kt.return,Et,yt),gn.lanes|=Et;break}Nn=Nn.next}}else if(kt.tag===10)tn=kt.type===yt.type?null:kt.child;else if(kt.tag===18){if(tn=kt.return,tn===null)throw Error(ot(341));tn.lanes|=Et,gn=tn.alternate,gn!==null&&(gn.lanes|=Et),bu(tn,Et,yt),tn=kt.sibling}else tn=kt.child;if(tn!==null)tn.return=kt;else for(tn=kt;tn!==null;){if(tn===yt){tn=null;break}if(kt=tn.sibling,kt!==null){kt.return=tn.return,tn=kt;break}tn=tn.return}kt=tn}_o(gt,yt,Rt.children,Et),yt=yt.child}return yt;case 9:return Rt=yt.type,Pt=yt.pendingProps.children,Ds(yt,Et),Rt=Io(Rt),Pt=Pt(Rt),yt.flags|=1,_o(gt,yt,Pt,Et),yt.child;case 14:return Pt=yt.type,Rt=Fr(Pt,yt.pendingProps),Rt=Fr(Pt.type,Rt),Jp(gt,yt,Pt,Rt,Et);case 15:return em(gt,yt,yt.type,yt.pendingProps,Et);case 17:return Pt=yt.type,Rt=yt.pendingProps,Rt=yt.elementType===Pt?Rt:Fr(Pt,Rt),gt!==null&&(gt.alternate=null,yt.alternate=null,yt.flags|=2),yt.tag=1,eo(Pt)?(gt=!0,to(yt)):gt=!1,Ds(yt,Et),_p(yt,Pt,Rt),Su(yt,Pt,Rt,Et),Vu(null,yt,Pt,!0,gt,Et);case 19:return um(gt,yt,Et);case 22:return tm(gt,yt,Et)}throw Error(ot(156,yt.tag))};function km(gt,yt){return Os(gt,yt)}function u_(gt,yt,Et,Pt){this.tag=gt,this.key=Et,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=yt,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=Pt,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function $o(gt,yt,Et,Pt){return new u_(gt,yt,Et,Pt)}function ap(gt){return gt=gt.prototype,!(!gt||!gt.isReactComponent)}function d_(gt){if(typeof gt=="function")return ap(gt)?1:0;if(gt!=null){if(gt=gt.$$typeof,gt===ht)return 11;if(gt===_t)return 14}return 2}function ps(gt,yt){var Et=gt.alternate;return Et===null?(Et=$o(gt.tag,yt,gt.key,gt.mode),Et.elementType=gt.elementType,Et.type=gt.type,Et.stateNode=gt.stateNode,Et.alternate=gt,gt.alternate=Et):(Et.pendingProps=yt,Et.type=gt.type,Et.flags=0,Et.subtreeFlags=0,Et.deletions=null),Et.flags=gt.flags&14680064,Et.childLanes=gt.childLanes,Et.lanes=gt.lanes,Et.child=gt.child,Et.memoizedProps=gt.memoizedProps,Et.memoizedState=gt.memoizedState,Et.updateQueue=gt.updateQueue,yt=gt.dependencies,Et.dependencies=yt===null?null:{lanes:yt.lanes,firstContext:yt.firstContext},Et.sibling=gt.sibling,Et.index=gt.index,Et.ref=gt.ref,Et}function mu(gt,yt,Et,Pt,Rt,kt){var tn=2;if(Pt=gt,typeof gt=="function")ap(gt)&&(tn=1);else if(typeof gt=="string")tn=5;else e:switch(gt){case dt:return As(Et.children,Rt,kt,yt);case st:tn=8,Rt|=8;break;case it:return gt=$o(12,Et,yt,Rt|2),gt.elementType=it,gt.lanes=kt,gt;case mt:return gt=$o(13,Et,yt,Rt),gt.elementType=mt,gt.lanes=kt,gt;case pt:return gt=$o(19,Et,yt,Rt),gt.elementType=pt,gt.lanes=kt,gt;case bt:return gu(Et,Rt,kt,yt);default:if(typeof gt=="object"&&gt!==null)switch(gt.$$typeof){case ct:tn=10;break e;case ft:tn=9;break e;case ht:tn=11;break e;case _t:tn=14;break e;case vt:tn=16,Pt=null;break e}throw Error(ot(130,gt==null?gt:typeof gt,""))}return yt=$o(tn,Et,yt,Rt),yt.elementType=gt,yt.type=Pt,yt.lanes=kt,yt}function As(gt,yt,Et,Pt){return gt=$o(7,gt,Pt,yt),gt.lanes=Et,gt}function gu(gt,yt,Et,Pt){return gt=$o(22,gt,Pt,yt),gt.elementType=bt,gt.lanes=Et,gt.stateNode={},gt}function lp(gt,yt,Et){return gt=$o(6,gt,null,yt),gt.lanes=Et,gt}function cp(gt,yt,Et){return yt=$o(4,gt.children!==null?gt.children:[],gt.key,yt),yt.lanes=Et,yt.stateNode={containerInfo:gt.containerInfo,pendingChildren:null,implementation:gt.implementation},yt}function f_(gt,yt,Et,Pt,Rt){this.tag=yt,this.containerInfo=gt,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=jt,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=ys(0),this.expirationTimes=ys(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=ys(0),this.identifierPrefix=Pt,this.onRecoverableError=Rt,on&&(this.mutableSourceEagerHydrationData=null)}function Dm(gt,yt,Et,Pt,Rt,kt,tn,gn,Nn){return gt=new f_(gt,yt,Et,gn,Nn),yt===1?(yt=1,kt===!0&&(yt|=8)):yt=0,kt=$o(3,null,null,yt),gt.current=kt,kt.stateNode=gt,kt.memoizedState={element:Pt,isDehydrated:Et,cache:null,transitions:null},xu(kt),gt}function Nm(gt){if(!gt)return Pr;gt=gt._reactInternals;e:{if(St(gt)!==gt||gt.tag!==1)throw Error(ot(170));var yt=gt;do{switch(yt.tag){case 3:yt=yt.stateNode.context;break e;case 1:if(eo(yt.type)){yt=yt.stateNode.__reactInternalMemoizedMergedChildContext;break e}}yt=yt.return}while(yt!==null);throw Error(ot(171))}if(gt.tag===1){var Et=gt.type;if(eo(Et))return qo(gt,Et,yt)}return yt}function Fm(gt){var yt=gt._reactInternals;if(yt===void 0)throw typeof gt.render=="function"?Error(ot(188)):(gt=Object.keys(gt).join(","),Error(ot(268,gt)));return gt=It(yt),gt===null?null:gt.stateNode}function $m(gt,yt){if(gt=gt.memoizedState,gt!==null&&gt.dehydrated!==null){var Et=gt.retryLane;gt.retryLane=Et!==0&&Et<yt?Et:yt}}function up(gt,yt){$m(gt,yt),(gt=gt.alternate)&&$m(gt,yt)}function h_(gt){return gt=It(gt),gt===null?null:gt.stateNode}function p_(){return null}return _e.attemptContinuousHydration=function(gt){if(gt.tag===13){var yt=yo();Fo(gt,134217728,yt),up(gt,134217728)}},_e.attemptHydrationAtCurrentPriority=function(gt){if(gt.tag===13){var yt=yo(),Et=fs(gt);Fo(gt,Et,yt),up(gt,Et)}},_e.attemptSynchronousHydration=function(gt){switch(gt.tag){case 3:var yt=gt.stateNode;if(yt.current.memoizedState.isDehydrated){var Et=as(yt.pendingLanes);Et!==0&&(Rs(yt,Et|1),So(yt,Zr()),!(kr&6)&&(Hs(),Jr()))}break;case 13:var Pt=yo();Mm(function(){return Fo(gt,1,Pt)}),up(gt,1)}},_e.batchedUpdates=function(gt,yt){var Et=kr;kr|=1;try{return gt(yt)}finally{kr=Et,kr===0&&(Hs(),pr&&Jr())}},_e.createComponentSelector=function(gt){return{$$typeof:tu,value:gt}},_e.createContainer=function(gt,yt,Et,Pt,Rt,kt,tn){return Dm(gt,yt,!1,null,Et,Pt,Rt,kt,tn)},_e.createHasPseudoClassSelector=function(gt){return{$$typeof:nu,value:gt}},_e.createHydrationContainer=function(gt,yt,Et,Pt,Rt,kt,tn,gn,Nn){return gt=Dm(Et,Pt,!0,gt,Rt,kt,tn,gn,Nn),gt.context=Nm(null),Et=gt.current,Pt=yo(),Rt=fs(Et),kt=es(Pt,Rt),kt.callback=yt??null,cs(Et,kt),gt.current.lanes=Rt,Xo(gt,Rt,Pt),So(gt,Pt),gt},_e.createPortal=function(gt,yt,Et){var Pt=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:ut,key:Pt==null?null:""+Pt,children:gt,containerInfo:yt,implementation:Et}},_e.createRoleSelector=function(gt){return{$$typeof:ru,value:gt}},_e.createTestNameSelector=function(gt){return{$$typeof:iu,value:gt}},_e.createTextSelector=function(gt){return{$$typeof:ou,value:gt}},_e.deferredUpdates=function(gt){var yt=Nr,Et=_i.transition;try{return _i.transition=null,Nr=16,gt()}finally{Nr=yt,_i.transition=Et}},_e.discreteUpdates=function(gt,yt,Et,Pt,Rt){var kt=Nr,tn=_i.transition;try{return _i.transition=null,Nr=1,gt(yt,Et,Pt,Rt)}finally{Nr=kt,_i.transition=tn,kr===0&&Hs()}},_e.findAllNodes=Ju,_e.findBoundingRects=function(gt,yt){if(!Zt)throw Error(ot(363));yt=Ju(gt,yt),gt=[];for(var Et=0;Et<yt.length;Et++)gt.push(fn(yt[Et]));for(yt=gt.length-1;0<yt;yt--){Et=gt[yt];for(var Pt=Et.x,Rt=Pt+Et.width,kt=Et.y,tn=kt+Et.height,gn=yt-1;0<=gn;gn--)if(yt!==gn){var Nn=gt[gn],er=Nn.x,dr=er+Nn.width,Er=Nn.y,xr=Er+Nn.height;if(Pt>=er&&kt>=Er&&Rt<=dr&&tn<=xr){gt.splice(yt,1);break}else if(Pt!==er||Et.width!==Nn.width||xr<kt||Er>tn){if(!(kt!==Er||Et.height!==Nn.height||dr<Pt||er>Rt)){er>Pt&&(Nn.width+=er-Pt,Nn.x=Pt),dr<Rt&&(Nn.width=Rt-er),gt.splice(yt,1);break}}else{Er>kt&&(Nn.height+=Er-kt,Nn.y=kt),xr<tn&&(Nn.height=tn-Er),gt.splice(yt,1);break}}}return gt},_e.findHostInstance=Fm,_e.findHostInstanceWithNoPortals=function(gt){return gt=Ct(gt),gt=gt!==null?Nt(gt):null,gt===null?null:gt.stateNode},_e.findHostInstanceWithWarning=function(gt){return Fm(gt)},_e.flushControlled=function(gt){var yt=kr;kr|=1;var Et=_i.transition,Pt=Nr;try{_i.transition=null,Nr=1,gt()}finally{Nr=Pt,_i.transition=Et,kr=yt,kr===0&&(Hs(),Jr())}},_e.flushPassiveEffects=Ms,_e.flushSync=Mm,_e.focusWithin=function(gt,yt){if(!Zt)throw Error(ot(363));for(gt=Ku(gt),yt=Sm(gt,yt),yt=Array.from(yt),gt=0;gt<yt.length;){var Et=yt[gt++];if(!xn(Et)){if(Et.tag===5&&sr(Et.stateNode))return!0;for(Et=Et.child;Et!==null;)yt.push(Et),Et=Et.sibling}}return!1},_e.getCurrentUpdatePriority=function(){return Nr},_e.getFindAllNodesFailureDescription=function(gt,yt){if(!Zt)throw Error(ot(363));var Et=0,Pt=[];gt=[Ku(gt),0];for(var Rt=0;Rt<gt.length;){var kt=gt[Rt++],tn=gt[Rt++],gn=yt[tn];if((kt.tag!==5||!xn(kt))&&(Qu(kt,gn)&&(Pt.push(Zu(gn)),tn++,tn>Et&&(Et=tn)),tn<yt.length))for(kt=kt.child;kt!==null;)gt.push(kt,tn),kt=kt.sibling}if(Et<yt.length){for(gt=[];Et<yt.length;Et++)gt.push(Zu(yt[Et]));return`findAllNodes was able to match part of the selector:
  `+(Pt.join(" > ")+`

No matching component was found for:
  `)+gt.join(" > ")}return null},_e.getPublicRootInstance=function(gt){if(gt=gt.current,!gt.child)return null;switch(gt.child.tag){case 5:return Ot(gt.child.stateNode);default:return gt.child.stateNode}},_e.injectIntoDevTools=function(gt){if(gt={bundleType:gt.bundleType,version:gt.version,rendererPackageName:gt.rendererPackageName,rendererConfig:gt.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:at.ReactCurrentDispatcher,findHostInstanceByFiber:h_,findFiberByHostInstance:gt.findFiberByHostInstance||p_,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.0.0-fc46dba67-20220329"},typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u")gt=!1;else{var yt=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(yt.isDisabled||!yt.supportsFiber)gt=!0;else{try{Ht=yt.inject(gt),Qt=yt}catch{}gt=!!yt.checkDCE}}return gt},_e.isAlreadyRendering=function(){return!1},_e.observeVisibleRects=function(gt,yt,Et,Pt){if(!Zt)throw Error(ot(363));gt=Ju(gt,yt);var Rt=Wn(gt,Et,Pt).disconnect;return{disconnect:function(){Rt()}}},_e.registerMutableSourceForHydration=function(gt,yt){var Et=yt._getVersion;Et=Et(yt._source),gt.mutableSourceEagerHydrationData==null?gt.mutableSourceEagerHydrationData=[yt,Et]:gt.mutableSourceEagerHydrationData.push(yt,Et)},_e.runWithPriority=function(gt,yt){var Et=Nr;try{return Nr=gt,yt()}finally{Nr=Et}},_e.shouldError=function(){return null},_e.shouldSuspend=function(){return!1},_e.updateContainer=function(gt,yt,Et,Pt){var Rt=yt.current,kt=yo(),tn=fs(Rt);return Et=Nm(Et),yt.context===null?yt.context=Et:yt.pendingContext=Et,yt=es(kt,tn),yt.payload={element:gt},Pt=Pt===void 0?null:Pt,Pt!==null&&(yt.callback=Pt),cs(Rt,yt),gt=Fo(Rt,tn,kt),gt!==null&&Ol(gt,Rt,tn),tn},_e};reactReconciler.exports=reactReconciler_production_min;var reactReconcilerExports=reactReconciler.exports;const Reconciler=getDefaultExportFromCjs(reactReconcilerExports);var scheduler={exports:{}},scheduler_production_min={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(et){function _(Lt,zt){var Yt=Lt.length;Lt.push(zt);e:for(;0<Yt;){var en=Yt-1>>>1,bn=Lt[en];if(0<nt(bn,zt))Lt[en]=zt,Lt[Yt]=bn,Yt=en;else break e}}function _e(Lt){return Lt.length===0?null:Lt[0]}function tt(Lt){if(Lt.length===0)return null;var zt=Lt[0],Yt=Lt.pop();if(Yt!==zt){Lt[0]=Yt;e:for(var en=0,bn=Lt.length,Un=bn>>>1;en<Un;){var mn=2*(en+1)-1,vn=Lt[mn],In=mn+1,Cn=Lt[In];if(0>nt(vn,Yt))In<bn&&0>nt(Cn,vn)?(Lt[en]=Cn,Lt[In]=Yt,en=In):(Lt[en]=vn,Lt[mn]=Yt,en=mn);else if(In<bn&&0>nt(Cn,Yt))Lt[en]=Cn,Lt[In]=Yt,en=In;else break e}}return zt}function nt(Lt,zt){var Yt=Lt.sortIndex-zt.sortIndex;return Yt!==0?Yt:Lt.id-zt.id}if(typeof performance=="object"&&typeof performance.now=="function"){var rt=performance;et.unstable_now=function(){return rt.now()}}else{var ot=Date,at=ot.now();et.unstable_now=function(){return ot.now()-at}}var lt=[],ut=[],dt=1,st=null,it=3,ct=!1,ft=!1,ht=!1,mt=typeof setTimeout=="function"?setTimeout:null,pt=typeof clearTimeout=="function"?clearTimeout:null,_t=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function vt(Lt){for(var zt=_e(ut);zt!==null;){if(zt.callback===null)tt(ut);else if(zt.startTime<=Lt)tt(ut),zt.sortIndex=zt.expirationTime,_(lt,zt);else break;zt=_e(ut)}}function bt(Lt){if(ht=!1,vt(Lt),!ft)if(_e(lt)!==null)ft=!0,Ot(wt);else{var zt=_e(ut);zt!==null&&Ut(bt,zt.startTime-Lt)}}function wt(Lt,zt){ft=!1,ht&&(ht=!1,pt(At),At=-1),ct=!0;var Yt=it;try{for(vt(zt),st=_e(lt);st!==null&&(!(st.expirationTime>zt)||Lt&&!Ct());){var en=st.callback;if(typeof en=="function"){st.callback=null,it=st.priorityLevel;var bn=en(st.expirationTime<=zt);zt=et.unstable_now(),typeof bn=="function"?st.callback=bn:st===_e(lt)&&tt(lt),vt(zt)}else tt(lt);st=_e(lt)}if(st!==null)var Un=!0;else{var mn=_e(ut);mn!==null&&Ut(bt,mn.startTime-zt),Un=!1}return Un}finally{st=null,it=Yt,ct=!1}}var xt=!1,Mt=null,At=-1,St=5,Tt=-1;function Ct(){return!(et.unstable_now()-Tt<St)}function It(){if(Mt!==null){var Lt=et.unstable_now();Tt=Lt;var zt=!0;try{zt=Mt(!0,Lt)}finally{zt?$t():(xt=!1,Mt=null)}}else xt=!1}var $t;if(typeof _t=="function")$t=function(){_t(It)};else if(typeof MessageChannel<"u"){var Nt=new MessageChannel,Bt=Nt.port2;Nt.port1.onmessage=It,$t=function(){Bt.postMessage(null)}}else $t=function(){mt(It,0)};function Ot(Lt){Mt=Lt,xt||(xt=!0,$t())}function Ut(Lt,zt){At=mt(function(){Lt(et.unstable_now())},zt)}et.unstable_IdlePriority=5,et.unstable_ImmediatePriority=1,et.unstable_LowPriority=4,et.unstable_NormalPriority=3,et.unstable_Profiling=null,et.unstable_UserBlockingPriority=2,et.unstable_cancelCallback=function(Lt){Lt.callback=null},et.unstable_continueExecution=function(){ft||ct||(ft=!0,Ot(wt))},et.unstable_forceFrameRate=function(Lt){0>Lt||125<Lt?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):St=0<Lt?Math.floor(1e3/Lt):5},et.unstable_getCurrentPriorityLevel=function(){return it},et.unstable_getFirstCallbackNode=function(){return _e(lt)},et.unstable_next=function(Lt){switch(it){case 1:case 2:case 3:var zt=3;break;default:zt=it}var Yt=it;it=zt;try{return Lt()}finally{it=Yt}},et.unstable_pauseExecution=function(){},et.unstable_requestPaint=function(){},et.unstable_runWithPriority=function(Lt,zt){switch(Lt){case 1:case 2:case 3:case 4:case 5:break;default:Lt=3}var Yt=it;it=Lt;try{return zt()}finally{it=Yt}},et.unstable_scheduleCallback=function(Lt,zt,Yt){var en=et.unstable_now();switch(typeof Yt=="object"&&Yt!==null?(Yt=Yt.delay,Yt=typeof Yt=="number"&&0<Yt?en+Yt:en):Yt=en,Lt){case 1:var bn=-1;break;case 2:bn=250;break;case 5:bn=1073741823;break;case 4:bn=1e4;break;default:bn=5e3}return bn=Yt+bn,Lt={id:dt++,callback:zt,priorityLevel:Lt,startTime:Yt,expirationTime:bn,sortIndex:-1},Yt>en?(Lt.sortIndex=Yt,_(ut,Lt),_e(lt)===null&&Lt===_e(ut)&&(ht?(pt(At),At=-1):ht=!0,Ut(bt,Yt-en))):(Lt.sortIndex=bn,_(lt,Lt),ft||ct||(ft=!0,Ot(wt))),Lt},et.unstable_shouldYield=Ct,et.unstable_wrapCallback=function(Lt){var zt=it;return function(){var Yt=it;it=zt;try{return Lt.apply(this,arguments)}finally{it=Yt}}}})(scheduler_production_min);scheduler.exports=scheduler_production_min;var schedulerExports=scheduler.exports;const isPromise=et=>typeof et=="object"&&typeof et.then=="function",globalCache=[];function shallowEqualArrays(et,_,_e=(tt,nt)=>tt===nt){if(et===_)return!0;if(!et||!_)return!1;const tt=et.length;if(_.length!==tt)return!1;for(let nt=0;nt<tt;nt++)if(!_e(et[nt],_[nt]))return!1;return!0}function query(et,_=null,_e=!1,tt={}){_===null&&(_=[et]);for(const rt of globalCache)if(shallowEqualArrays(_,rt.keys,rt.equal)){if(_e)return;if(Object.prototype.hasOwnProperty.call(rt,"error"))throw rt.error;if(Object.prototype.hasOwnProperty.call(rt,"response"))return tt.lifespan&&tt.lifespan>0&&(rt.timeout&&clearTimeout(rt.timeout),rt.timeout=setTimeout(rt.remove,tt.lifespan)),rt.response;if(!_e)throw rt.promise}const nt={keys:_,equal:tt.equal,remove:()=>{const rt=globalCache.indexOf(nt);rt!==-1&&globalCache.splice(rt,1)},promise:(isPromise(et)?et:et(..._)).then(rt=>{nt.response=rt,tt.lifespan&&tt.lifespan>0&&(nt.timeout=setTimeout(nt.remove,tt.lifespan))}).catch(rt=>nt.error=rt)};if(globalCache.push(nt),!_e)throw nt.promise}const suspend=(et,_,_e)=>query(et,_,!1,_e),preload=(et,_,_e)=>void query(et,_,!0,_e),clear=et=>{if(et===void 0||et.length===0)globalCache.splice(0,globalCache.length);else{const _=globalCache.find(_e=>shallowEqualArrays(et,_e.keys,_e.equal));_&&_.remove()}},catalogue={},extend$2=et=>void Object.assign(catalogue,et);function createRenderer(et,_){function _e(dt,{args:st=[],attach:it,...ct},ft){let ht=`${dt[0].toUpperCase()}${dt.slice(1)}`,mt;if(dt==="primitive"){if(ct.object===void 0)throw new Error("R3F: Primitives without 'object' are invalid!");const pt=ct.object;mt=prepare(pt,{type:dt,root:ft,attach:it,primitive:!0})}else{const pt=catalogue[ht];if(!pt)throw new Error(`R3F: ${ht} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);if(!Array.isArray(st))throw new Error("R3F: The args prop must be an array!");mt=prepare(new pt(...st),{type:dt,root:ft,attach:it,memoizedProps:{args:st}})}return mt.__r3f.attach===void 0&&(mt instanceof BufferGeometry?mt.__r3f.attach="geometry":mt instanceof Material&&(mt.__r3f.attach="material")),ht!=="inject"&&applyProps$1(mt,ct),mt}function tt(dt,st){let it=!1;if(st){var ct,ft;(ct=st.__r3f)!=null&&ct.attach?attach(dt,st,st.__r3f.attach):st.isObject3D&&dt.isObject3D&&(dt.add(st),it=!0),it||(ft=dt.__r3f)==null||ft.objects.push(st),st.__r3f||prepare(st,{}),st.__r3f.parent=dt,updateInstance(st),invalidateInstance(st)}}function nt(dt,st,it){let ct=!1;if(st){var ft,ht;if((ft=st.__r3f)!=null&&ft.attach)attach(dt,st,st.__r3f.attach);else if(st.isObject3D&&dt.isObject3D){st.parent=dt,st.dispatchEvent({type:"added"}),dt.dispatchEvent({type:"childadded",child:st});const mt=dt.children.filter(_t=>_t!==st),pt=mt.indexOf(it);dt.children=[...mt.slice(0,pt),st,...mt.slice(pt)],ct=!0}ct||(ht=dt.__r3f)==null||ht.objects.push(st),st.__r3f||prepare(st,{}),st.__r3f.parent=dt,updateInstance(st),invalidateInstance(st)}}function rt(dt,st,it=!1){dt&&[...dt].forEach(ct=>ot(st,ct,it))}function ot(dt,st,it){if(st){var ct,ft,ht;if(st.__r3f&&(st.__r3f.parent=null),(ct=dt.__r3f)!=null&&ct.objects&&(dt.__r3f.objects=dt.__r3f.objects.filter(bt=>bt!==st)),(ft=st.__r3f)!=null&&ft.attach)detach(dt,st,st.__r3f.attach);else if(st.isObject3D&&dt.isObject3D){var mt;dt.remove(st),(mt=st.__r3f)!=null&&mt.root&&removeInteractivity(findInitialRoot(st),st)}const _t=(ht=st.__r3f)==null?void 0:ht.primitive,vt=!_t&&(it===void 0?st.dispose!==null:it);if(!_t){var pt;rt((pt=st.__r3f)==null?void 0:pt.objects,st,vt),rt(st.children,st,vt)}if(delete st.__r3f,vt&&st.dispose&&st.type!=="Scene"){const bt=()=>{try{st.dispose()}catch{}};typeof IS_REACT_ACT_ENVIRONMENT>"u"?schedulerExports.unstable_scheduleCallback(schedulerExports.unstable_IdlePriority,bt):bt()}invalidateInstance(dt)}}function at(dt,st,it,ct){var ft;const ht=(ft=dt.__r3f)==null?void 0:ft.parent;if(!ht)return;const mt=_e(st,it,dt.__r3f.root);if(dt.children){for(const pt of dt.children)pt.__r3f&&tt(mt,pt);dt.children=dt.children.filter(pt=>!pt.__r3f)}dt.__r3f.objects.forEach(pt=>tt(mt,pt)),dt.__r3f.objects=[],dt.__r3f.autoRemovedBeforeAppend||ot(ht,dt),mt.parent&&(mt.__r3f.autoRemovedBeforeAppend=!0),tt(ht,mt),mt.raycast&&mt.__r3f.eventCount&&findInitialRoot(mt).getState().internal.interaction.push(mt),[ct,ct.alternate].forEach(pt=>{pt!==null&&(pt.stateNode=mt,pt.ref&&(typeof pt.ref=="function"?pt.ref(mt):pt.ref.current=mt))})}const lt=()=>console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");return{reconciler:Reconciler({createInstance:_e,removeChild:ot,appendChild:tt,appendInitialChild:tt,insertBefore:nt,supportsMutation:!0,isPrimaryRenderer:!1,supportsPersistence:!1,supportsHydration:!1,noTimeout:-1,appendChildToContainer:(dt,st)=>{if(!st)return;const it=dt.getState().scene;it.__r3f&&(it.__r3f.root=dt,tt(it,st))},removeChildFromContainer:(dt,st)=>{st&&ot(dt.getState().scene,st)},insertInContainerBefore:(dt,st,it)=>{if(!st||!it)return;const ct=dt.getState().scene;ct.__r3f&&nt(ct,st,it)},getRootHostContext:()=>null,getChildHostContext:dt=>dt,finalizeInitialChildren(dt){var st;return!!((st=dt==null?void 0:dt.__r3f)!=null?st:{}).handlers},prepareUpdate(dt,st,it,ct){var ft;if(((ft=dt==null?void 0:dt.__r3f)!=null?ft:{}).primitive&&ct.object&&ct.object!==dt)return[!0];{const{args:mt=[],children:pt,..._t}=ct,{args:vt=[],children:bt,...wt}=it;if(!Array.isArray(mt))throw new Error("R3F: the args prop must be an array!");if(mt.some((Mt,At)=>Mt!==vt[At]))return[!0];const xt=diffProps(dt,_t,wt,!0);return xt.changes.length?[!1,xt]:null}},commitUpdate(dt,[st,it],ct,ft,ht,mt){st?at(dt,ct,ht,mt):applyProps$1(dt,it)},commitMount(dt,st,it,ct){var ft;const ht=(ft=dt.__r3f)!=null?ft:{};dt.raycast&&ht.handlers&&ht.eventCount&&findInitialRoot(dt).getState().internal.interaction.push(dt)},getPublicInstance:dt=>dt,prepareForCommit:()=>null,preparePortalMount:dt=>prepare(dt.getState().scene),resetAfterCommit:()=>{},shouldSetTextContent:()=>!1,clearContainer:()=>!1,hideInstance(dt){var st;const{attach:it,parent:ct}=(st=dt.__r3f)!=null?st:{};it&&ct&&detach(ct,dt,it),dt.isObject3D&&(dt.visible=!1),invalidateInstance(dt)},unhideInstance(dt,st){var it;const{attach:ct,parent:ft}=(it=dt.__r3f)!=null?it:{};ct&&ft&&attach(ft,dt,ct),(dt.isObject3D&&st.visible==null||st.visible)&&(dt.visible=!0),invalidateInstance(dt)},createTextInstance:lt,hideTextInstance:lt,unhideTextInstance:lt,getCurrentEventPriority:()=>_?_():constantsExports.DefaultEventPriority,beforeActiveInstanceBlur:()=>{},afterActiveInstanceBlur:()=>{},detachDeletedInstance:()=>{},now:typeof performance<"u"&&is.fun(performance.now)?performance.now:is.fun(Date.now)?Date.now:()=>0,scheduleTimeout:is.fun(setTimeout)?setTimeout:void 0,cancelTimeout:is.fun(clearTimeout)?clearTimeout:void 0}),applyProps:applyProps$1}}var _window$document,_window$navigator;const hasColorSpace=et=>"colorSpace"in et||"outputColorSpace"in et,getColorManagement=()=>{var et;return(et=catalogue.ColorManagement)!=null?et:null},isOrthographicCamera=et=>et&&et.isOrthographicCamera,isRef=et=>et&&et.hasOwnProperty("current"),useIsomorphicLayoutEffect=typeof window<"u"&&((_window$document=window.document)!=null&&_window$document.createElement||((_window$navigator=window.navigator)==null?void 0:_window$navigator.product)==="ReactNative")?reactExports.useLayoutEffect:reactExports.useEffect;function useMutableCallback(et){const _=reactExports.useRef(et);return useIsomorphicLayoutEffect(()=>void(_.current=et),[et]),_}function Block({set:et}){return useIsomorphicLayoutEffect(()=>(et(new Promise(()=>null)),()=>et(!1)),[et]),null}class ErrorBoundary extends reactExports.Component{constructor(..._){super(..._),this.state={error:!1}}componentDidCatch(_){this.props.set(_)}render(){return this.state.error?null:this.props.children}}ErrorBoundary.getDerivedStateFromError=()=>({error:!0});const DEFAULT="__default",DEFAULTS=new Map,isDiffSet=et=>et&&!!et.memoized&&!!et.changes;function calculateDpr(et){var _;const _e=typeof window<"u"?(_=window.devicePixelRatio)!=null?_:2:1;return Array.isArray(et)?Math.min(Math.max(et[0],_e),et[1]):et}const getRootState=et=>{var _;return(_=et.__r3f)==null?void 0:_.root.getState()};function findInitialRoot(et){let _=et.__r3f.root;for(;_.getState().previousRoot;)_=_.getState().previousRoot;return _}const is={obj:et=>et===Object(et)&&!is.arr(et)&&typeof et!="function",fun:et=>typeof et=="function",str:et=>typeof et=="string",num:et=>typeof et=="number",boo:et=>typeof et=="boolean",und:et=>et===void 0,arr:et=>Array.isArray(et),equ(et,_,{arrays:_e="shallow",objects:tt="reference",strict:nt=!0}={}){if(typeof et!=typeof _||!!et!=!!_)return!1;if(is.str(et)||is.num(et)||is.boo(et))return et===_;const rt=is.obj(et);if(rt&&tt==="reference")return et===_;const ot=is.arr(et);if(ot&&_e==="reference")return et===_;if((ot||rt)&&et===_)return!0;let at;for(at in et)if(!(at in _))return!1;if(rt&&_e==="shallow"&&tt==="shallow"){for(at in nt?_:et)if(!is.equ(et[at],_[at],{strict:nt,objects:"reference"}))return!1}else for(at in nt?_:et)if(et[at]!==_[at])return!1;if(is.und(at)){if(ot&&et.length===0&&_.length===0||rt&&Object.keys(et).length===0&&Object.keys(_).length===0)return!0;if(et!==_)return!1}return!0}};function buildGraph(et){const _={nodes:{},materials:{}};return et&&et.traverse(_e=>{_e.name&&(_.nodes[_e.name]=_e),_e.material&&!_.materials[_e.material.name]&&(_.materials[_e.material.name]=_e.material)}),_}function dispose(et){et.dispose&&et.type!=="Scene"&&et.dispose();for(const _ in et)_.dispose==null||_.dispose(),delete et[_]}function prepare(et,_){const _e=et;return _e.__r3f={type:"",root:null,previousAttach:null,memoizedProps:{},eventCount:0,handlers:{},objects:[],parent:null,..._},et}function resolve(et,_){let _e=et;if(_.includes("-")){const tt=_.split("-"),nt=tt.pop();return _e=tt.reduce((rt,ot)=>rt[ot],et),{target:_e,key:nt}}else return{target:_e,key:_}}const INDEX_REGEX=/-\d+$/;function attach(et,_,_e){if(is.str(_e)){if(INDEX_REGEX.test(_e)){const rt=_e.replace(INDEX_REGEX,""),{target:ot,key:at}=resolve(et,rt);Array.isArray(ot[at])||(ot[at]=[])}const{target:tt,key:nt}=resolve(et,_e);_.__r3f.previousAttach=tt[nt],tt[nt]=_}else _.__r3f.previousAttach=_e(et,_)}function detach(et,_,_e){var tt,nt;if(is.str(_e)){const{target:rt,key:ot}=resolve(et,_e),at=_.__r3f.previousAttach;at===void 0?delete rt[ot]:rt[ot]=at}else(tt=_.__r3f)==null||tt.previousAttach==null||tt.previousAttach(et,_);(nt=_.__r3f)==null||delete nt.previousAttach}function diffProps(et,{children:_,key:_e,ref:tt,...nt},{children:rt,key:ot,ref:at,...lt}={},ut=!1){const dt=et.__r3f,st=Object.entries(nt),it=[];if(ut){const ft=Object.keys(lt);for(let ht=0;ht<ft.length;ht++)nt.hasOwnProperty(ft[ht])||st.unshift([ft[ht],DEFAULT+"remove"])}st.forEach(([ft,ht])=>{var mt;if((mt=et.__r3f)!=null&&mt.primitive&&ft==="object"||is.equ(ht,lt[ft]))return;if(/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(ft))return it.push([ft,ht,!0,[]]);let pt=[];ft.includes("-")&&(pt=ft.split("-")),it.push([ft,ht,!1,pt]);for(const _t in nt){const vt=nt[_t];_t.startsWith(`${ft}-`)&&it.push([_t,vt,!1,_t.split("-")])}});const ct={...nt};return dt!=null&&dt.memoizedProps&&dt!=null&&dt.memoizedProps.args&&(ct.args=dt.memoizedProps.args),dt!=null&&dt.memoizedProps&&dt!=null&&dt.memoizedProps.attach&&(ct.attach=dt.memoizedProps.attach),{memoized:ct,changes:it}}const __DEV__=typeof process<"u"&&!1;function applyProps$1(et,_){var _e;const tt=et.__r3f,nt=tt==null?void 0:tt.root,rt=nt==null||nt.getState==null?void 0:nt.getState(),{memoized:ot,changes:at}=isDiffSet(_)?_:diffProps(et,_),lt=tt==null?void 0:tt.eventCount;et.__r3f&&(et.__r3f.memoizedProps=ot);for(let dt=0;dt<at.length;dt++){let[st,it,ct,ft]=at[dt];if(hasColorSpace(et)){const _t="srgb",vt="srgb-linear";st==="encoding"?(st="colorSpace",it=it===3001?_t:vt):st==="outputEncoding"&&(st="outputColorSpace",it=it===3001?_t:vt)}let ht=et,mt=ht[st];if(ft.length&&(mt=ft.reduce((pt,_t)=>pt[_t],et),!(mt&&mt.set))){const[pt,..._t]=ft.reverse();ht=_t.reverse().reduce((vt,bt)=>vt[bt],et),st=pt}if(it===DEFAULT+"remove")if(ht.constructor){let pt=DEFAULTS.get(ht.constructor);pt||(pt=new ht.constructor,DEFAULTS.set(ht.constructor,pt)),it=pt[st]}else it=0;if(ct&&tt)it?tt.handlers[st]=it:delete tt.handlers[st],tt.eventCount=Object.keys(tt.handlers).length;else if(mt&&mt.set&&(mt.copy||mt instanceof Layers)){if(Array.isArray(it))mt.fromArray?mt.fromArray(it):mt.set(...it);else if(mt.copy&&it&&it.constructor&&(__DEV__?mt.constructor.name===it.constructor.name:mt.constructor===it.constructor))mt.copy(it);else if(it!==void 0){const pt=mt instanceof Color$1;!pt&&mt.setScalar?mt.setScalar(it):mt instanceof Layers&&it instanceof Layers?mt.mask=it.mask:mt.set(it),!getColorManagement()&&rt&&!rt.linear&&pt&&mt.convertSRGBToLinear()}}else if(ht[st]=it,ht[st]instanceof Texture&&ht[st].format===RGBAFormat&&ht[st].type===UnsignedByteType&&rt){const pt=ht[st];hasColorSpace(pt)&&hasColorSpace(rt.gl)?pt.colorSpace=rt.gl.outputColorSpace:pt.encoding=rt.gl.outputEncoding}invalidateInstance(et)}if(tt&&tt.parent&&et.raycast&&lt!==tt.eventCount){const dt=findInitialRoot(et).getState().internal,st=dt.interaction.indexOf(et);st>-1&&dt.interaction.splice(st,1),tt.eventCount&&dt.interaction.push(et)}return!(at.length===1&&at[0][0]==="onUpdate")&&at.length&&(_e=et.__r3f)!=null&&_e.parent&&updateInstance(et),et}function invalidateInstance(et){var _,_e;const tt=(_=et.__r3f)==null||(_e=_.root)==null||_e.getState==null?void 0:_e.getState();tt&&tt.internal.frames===0&&tt.invalidate()}function updateInstance(et){et.onUpdate==null||et.onUpdate(et)}function updateCamera(et,_){et.manual||(isOrthographicCamera(et)?(et.left=_.width/-2,et.right=_.width/2,et.top=_.height/2,et.bottom=_.height/-2):et.aspect=_.width/_.height,et.updateProjectionMatrix(),et.updateMatrixWorld())}function makeId(et){return(et.eventObject||et.object).uuid+"/"+et.index+et.instanceId}function getEventPriority(){var et;const _=typeof self<"u"&&self||typeof window<"u"&&window;if(!_)return constantsExports.DefaultEventPriority;switch((et=_.event)==null?void 0:et.type){case"click":case"contextmenu":case"dblclick":case"pointercancel":case"pointerdown":case"pointerup":return constantsExports.DiscreteEventPriority;case"pointermove":case"pointerout":case"pointerover":case"pointerenter":case"pointerleave":case"wheel":return constantsExports.ContinuousEventPriority;default:return constantsExports.DefaultEventPriority}}function releaseInternalPointerCapture(et,_,_e,tt){const nt=_e.get(_);nt&&(_e.delete(_),_e.size===0&&(et.delete(tt),nt.target.releasePointerCapture(tt)))}function removeInteractivity(et,_){const{internal:_e}=et.getState();_e.interaction=_e.interaction.filter(tt=>tt!==_),_e.initialHits=_e.initialHits.filter(tt=>tt!==_),_e.hovered.forEach((tt,nt)=>{(tt.eventObject===_||tt.object===_)&&_e.hovered.delete(nt)}),_e.capturedMap.forEach((tt,nt)=>{releaseInternalPointerCapture(_e.capturedMap,_,tt,nt)})}function createEvents(et){function _(lt){const{internal:ut}=et.getState(),dt=lt.offsetX-ut.initialClick[0],st=lt.offsetY-ut.initialClick[1];return Math.round(Math.sqrt(dt*dt+st*st))}function _e(lt){return lt.filter(ut=>["Move","Over","Enter","Out","Leave"].some(dt=>{var st;return(st=ut.__r3f)==null?void 0:st.handlers["onPointer"+dt]}))}function tt(lt,ut){const dt=et.getState(),st=new Set,it=[],ct=ut?ut(dt.internal.interaction):dt.internal.interaction;for(let pt=0;pt<ct.length;pt++){const _t=getRootState(ct[pt]);_t&&(_t.raycaster.camera=void 0)}dt.previousRoot||dt.events.compute==null||dt.events.compute(lt,dt);function ft(pt){const _t=getRootState(pt);if(!_t||!_t.events.enabled||_t.raycaster.camera===null)return[];if(_t.raycaster.camera===void 0){var vt;_t.events.compute==null||_t.events.compute(lt,_t,(vt=_t.previousRoot)==null?void 0:vt.getState()),_t.raycaster.camera===void 0&&(_t.raycaster.camera=null)}return _t.raycaster.camera?_t.raycaster.intersectObject(pt,!0):[]}let ht=ct.flatMap(ft).sort((pt,_t)=>{const vt=getRootState(pt.object),bt=getRootState(_t.object);return!vt||!bt?pt.distance-_t.distance:bt.events.priority-vt.events.priority||pt.distance-_t.distance}).filter(pt=>{const _t=makeId(pt);return st.has(_t)?!1:(st.add(_t),!0)});dt.events.filter&&(ht=dt.events.filter(ht,dt));for(const pt of ht){let _t=pt.object;for(;_t;){var mt;(mt=_t.__r3f)!=null&&mt.eventCount&&it.push({...pt,eventObject:_t}),_t=_t.parent}}if("pointerId"in lt&&dt.internal.capturedMap.has(lt.pointerId))for(let pt of dt.internal.capturedMap.get(lt.pointerId).values())st.has(makeId(pt.intersection))||it.push(pt.intersection);return it}function nt(lt,ut,dt,st){const it=et.getState();if(lt.length){const ct={stopped:!1};for(const ft of lt){const ht=getRootState(ft.object)||it,{raycaster:mt,pointer:pt,camera:_t,internal:vt}=ht,bt=new Vector3(pt.x,pt.y,0).unproject(_t),wt=Tt=>{var Ct,It;return(Ct=(It=vt.capturedMap.get(Tt))==null?void 0:It.has(ft.eventObject))!=null?Ct:!1},xt=Tt=>{const Ct={intersection:ft,target:ut.target};vt.capturedMap.has(Tt)?vt.capturedMap.get(Tt).set(ft.eventObject,Ct):vt.capturedMap.set(Tt,new Map([[ft.eventObject,Ct]])),ut.target.setPointerCapture(Tt)},Mt=Tt=>{const Ct=vt.capturedMap.get(Tt);Ct&&releaseInternalPointerCapture(vt.capturedMap,ft.eventObject,Ct,Tt)};let At={};for(let Tt in ut){let Ct=ut[Tt];typeof Ct!="function"&&(At[Tt]=Ct)}let St={...ft,...At,pointer:pt,intersections:lt,stopped:ct.stopped,delta:dt,unprojectedPoint:bt,ray:mt.ray,camera:_t,stopPropagation(){const Tt="pointerId"in ut&&vt.capturedMap.get(ut.pointerId);if((!Tt||Tt.has(ft.eventObject))&&(St.stopped=ct.stopped=!0,vt.hovered.size&&Array.from(vt.hovered.values()).find(Ct=>Ct.eventObject===ft.eventObject))){const Ct=lt.slice(0,lt.indexOf(ft));rt([...Ct,ft])}},target:{hasPointerCapture:wt,setPointerCapture:xt,releasePointerCapture:Mt},currentTarget:{hasPointerCapture:wt,setPointerCapture:xt,releasePointerCapture:Mt},nativeEvent:ut};if(st(St),ct.stopped===!0)break}}return lt}function rt(lt){const{internal:ut}=et.getState();for(const dt of ut.hovered.values())if(!lt.length||!lt.find(st=>st.object===dt.object&&st.index===dt.index&&st.instanceId===dt.instanceId)){const it=dt.eventObject.__r3f,ct=it==null?void 0:it.handlers;if(ut.hovered.delete(makeId(dt)),it!=null&&it.eventCount){const ft={...dt,intersections:lt};ct.onPointerOut==null||ct.onPointerOut(ft),ct.onPointerLeave==null||ct.onPointerLeave(ft)}}}function ot(lt,ut){for(let dt=0;dt<ut.length;dt++){const st=ut[dt].__r3f;st==null||st.handlers.onPointerMissed==null||st.handlers.onPointerMissed(lt)}}function at(lt){switch(lt){case"onPointerLeave":case"onPointerCancel":return()=>rt([]);case"onLostPointerCapture":return ut=>{const{internal:dt}=et.getState();"pointerId"in ut&&dt.capturedMap.has(ut.pointerId)&&requestAnimationFrame(()=>{dt.capturedMap.has(ut.pointerId)&&(dt.capturedMap.delete(ut.pointerId),rt([]))})}}return function(dt){const{onPointerMissed:st,internal:it}=et.getState();it.lastEvent.current=dt;const ct=lt==="onPointerMove",ft=lt==="onClick"||lt==="onContextMenu"||lt==="onDoubleClick",mt=tt(dt,ct?_e:void 0),pt=ft?_(dt):0;lt==="onPointerDown"&&(it.initialClick=[dt.offsetX,dt.offsetY],it.initialHits=mt.map(vt=>vt.eventObject)),ft&&!mt.length&&pt<=2&&(ot(dt,it.interaction),st&&st(dt)),ct&&rt(mt);function _t(vt){const bt=vt.eventObject,wt=bt.__r3f,xt=wt==null?void 0:wt.handlers;if(wt!=null&&wt.eventCount)if(ct){if(xt.onPointerOver||xt.onPointerEnter||xt.onPointerOut||xt.onPointerLeave){const Mt=makeId(vt),At=it.hovered.get(Mt);At?At.stopped&&vt.stopPropagation():(it.hovered.set(Mt,vt),xt.onPointerOver==null||xt.onPointerOver(vt),xt.onPointerEnter==null||xt.onPointerEnter(vt))}xt.onPointerMove==null||xt.onPointerMove(vt)}else{const Mt=xt[lt];Mt?(!ft||it.initialHits.includes(bt))&&(ot(dt,it.interaction.filter(At=>!it.initialHits.includes(At))),Mt(vt)):ft&&it.initialHits.includes(bt)&&ot(dt,it.interaction.filter(At=>!it.initialHits.includes(At)))}}nt(mt,dt,pt,_t)}}return{handlePointer:at}}const privateKeys=["set","get","setSize","setFrameloop","setDpr","events","invalidate","advance","size","viewport"],isRenderer=et=>!!(et!=null&&et.render),context=reactExports.createContext(null),createStore=(et,_)=>{const _e=create((at,lt)=>{const ut=new Vector3,dt=new Vector3,st=new Vector3;function it(pt=lt().camera,_t=dt,vt=lt().size){const{width:bt,height:wt,top:xt,left:Mt}=vt,At=bt/wt;_t instanceof Vector3?st.copy(_t):st.set(..._t);const St=pt.getWorldPosition(ut).distanceTo(st);if(isOrthographicCamera(pt))return{width:bt/pt.zoom,height:wt/pt.zoom,top:xt,left:Mt,factor:1,distance:St,aspect:At};{const Tt=pt.fov*Math.PI/180,Ct=2*Math.tan(Tt/2)*St,It=Ct*(bt/wt);return{width:It,height:Ct,top:xt,left:Mt,factor:bt/It,distance:St,aspect:At}}}let ct;const ft=pt=>at(_t=>({performance:{..._t.performance,current:pt}})),ht=new Vector2;return{set:at,get:lt,gl:null,camera:null,raycaster:null,events:{priority:1,enabled:!0,connected:!1},xr:null,scene:null,invalidate:(pt=1)=>et(lt(),pt),advance:(pt,_t)=>_(pt,_t,lt()),legacy:!1,linear:!1,flat:!1,controls:null,clock:new Clock,pointer:ht,mouse:ht,frameloop:"always",onPointerMissed:void 0,performance:{current:1,min:.5,max:1,debounce:200,regress:()=>{const pt=lt();ct&&clearTimeout(ct),pt.performance.current!==pt.performance.min&&ft(pt.performance.min),ct=setTimeout(()=>ft(lt().performance.max),pt.performance.debounce)}},size:{width:0,height:0,top:0,left:0,updateStyle:!1},viewport:{initialDpr:0,dpr:0,width:0,height:0,top:0,left:0,aspect:0,distance:0,factor:0,getCurrentViewport:it},setEvents:pt=>at(_t=>({..._t,events:{..._t.events,...pt}})),setSize:(pt,_t,vt,bt,wt)=>{const xt=lt().camera,Mt={width:pt,height:_t,top:bt||0,left:wt||0,updateStyle:vt};at(At=>({size:Mt,viewport:{...At.viewport,...it(xt,dt,Mt)}}))},setDpr:pt=>at(_t=>{const vt=calculateDpr(pt);return{viewport:{..._t.viewport,dpr:vt,initialDpr:_t.viewport.initialDpr||vt}}}),setFrameloop:(pt="always")=>{const _t=lt().clock;_t.stop(),_t.elapsedTime=0,pt!=="never"&&(_t.start(),_t.elapsedTime=0),at(()=>({frameloop:pt}))},previousRoot:void 0,internal:{active:!1,priority:0,frames:0,lastEvent:reactExports.createRef(),interaction:[],hovered:new Map,subscribers:[],initialClick:[0,0],initialHits:[],capturedMap:new Map,subscribe:(pt,_t,vt)=>{const bt=lt().internal;return bt.priority=bt.priority+(_t>0?1:0),bt.subscribers.push({ref:pt,priority:_t,store:vt}),bt.subscribers=bt.subscribers.sort((wt,xt)=>wt.priority-xt.priority),()=>{const wt=lt().internal;wt!=null&&wt.subscribers&&(wt.priority=wt.priority-(_t>0?1:0),wt.subscribers=wt.subscribers.filter(xt=>xt.ref!==pt))}}}}}),tt=_e.getState();let nt=tt.size,rt=tt.viewport.dpr,ot=tt.camera;return _e.subscribe(()=>{const{camera:at,size:lt,viewport:ut,gl:dt,set:st}=_e.getState();if(lt.width!==nt.width||lt.height!==nt.height||ut.dpr!==rt){var it;nt=lt,rt=ut.dpr,updateCamera(at,lt),dt.setPixelRatio(ut.dpr);const ct=(it=lt.updateStyle)!=null?it:typeof HTMLCanvasElement<"u"&&dt.domElement instanceof HTMLCanvasElement;dt.setSize(lt.width,lt.height,ct)}at!==ot&&(ot=at,st(ct=>({viewport:{...ct.viewport,...ct.viewport.getCurrentViewport(at)}})))}),_e.subscribe(at=>et(at)),_e};let i$3,globalEffects=new Set,globalAfterEffects=new Set,globalTailEffects=new Set;function run(et,_){if(et.size)for(const{callback:_e}of et.values())_e(_)}function flushGlobalEffects(et,_){switch(et){case"before":return run(globalEffects,_);case"after":return run(globalAfterEffects,_);case"tail":return run(globalTailEffects,_)}}let subscribers,subscription;function render$1(et,_,_e){let tt=_.clock.getDelta();for(_.frameloop==="never"&&typeof et=="number"&&(tt=et-_.clock.elapsedTime,_.clock.oldTime=_.clock.elapsedTime,_.clock.elapsedTime=et),subscribers=_.internal.subscribers,i$3=0;i$3<subscribers.length;i$3++)subscription=subscribers[i$3],subscription.ref.current(subscription.store.getState(),tt,_e);return!_.internal.priority&&_.gl.render&&_.gl.render(_.scene,_.camera),_.internal.frames=Math.max(0,_.internal.frames-1),_.frameloop==="always"?1:_.internal.frames}function createLoop(et){let _=!1,_e=!1,tt,nt,rt;function ot(ut){nt=requestAnimationFrame(ot),_=!0,tt=0,flushGlobalEffects("before",ut),_e=!0;for(const st of et.values()){var dt;rt=st.store.getState(),rt.internal.active&&(rt.frameloop==="always"||rt.internal.frames>0)&&!((dt=rt.gl.xr)!=null&&dt.isPresenting)&&(tt+=render$1(ut,rt))}if(_e=!1,flushGlobalEffects("after",ut),tt===0)return flushGlobalEffects("tail",ut),_=!1,cancelAnimationFrame(nt)}function at(ut,dt=1){var st;if(!ut)return et.forEach(it=>at(it.store.getState(),dt));(st=ut.gl.xr)!=null&&st.isPresenting||!ut.internal.active||ut.frameloop==="never"||(dt>1?ut.internal.frames=Math.min(60,ut.internal.frames+dt):_e?ut.internal.frames=2:ut.internal.frames=1,_||(_=!0,requestAnimationFrame(ot)))}function lt(ut,dt=!0,st,it){if(dt&&flushGlobalEffects("before",ut),st)render$1(ut,st,it);else for(const ct of et.values())render$1(ut,ct.store.getState());dt&&flushGlobalEffects("after",ut)}return{loop:ot,invalidate:at,advance:lt}}function useStore(){const et=reactExports.useContext(context);if(!et)throw new Error("R3F: Hooks can only be used within the Canvas component!");return et}function useThree(et=_e=>_e,_){return useStore()(et,_)}function useFrame(et,_=0){const _e=useStore(),tt=_e.getState().internal.subscribe,nt=useMutableCallback(et);return useIsomorphicLayoutEffect(()=>tt(nt,_,_e),[_,tt,_e]),null}const memoizedLoaders=new WeakMap;function loadingFn(et,_){return function(_e,...tt){let nt=memoizedLoaders.get(_e);return nt||(nt=new _e,memoizedLoaders.set(_e,nt)),et&&et(nt),Promise.all(tt.map(rt=>new Promise((ot,at)=>nt.load(rt,lt=>{lt.scene&&Object.assign(lt,buildGraph(lt.scene)),ot(lt)},_,lt=>at(new Error(`Could not load ${rt}: ${lt==null?void 0:lt.message}`))))))}}function useLoader(et,_,_e,tt){const nt=Array.isArray(_)?_:[_],rt=suspend(loadingFn(_e,tt),[et,...nt],{equal:is.equ});return Array.isArray(_)?rt:rt[0]}useLoader.preload=function(et,_,_e){const tt=Array.isArray(_)?_:[_];return preload(loadingFn(_e),[et,...tt])};useLoader.clear=function(et,_){const _e=Array.isArray(_)?_:[_];return clear([et,..._e])};const roots=new Map,{invalidate,advance}=createLoop(roots),{reconciler,applyProps}=createRenderer(roots,getEventPriority),shallowLoose={objects:"shallow",strict:!1},createRendererInstance=(et,_)=>{const _e=typeof et=="function"?et(_):et;return isRenderer(_e)?_e:new WebGLRenderer({powerPreference:"high-performance",canvas:_,antialias:!0,alpha:!0,...et})};function computeInitialSize(et,_){const _e=typeof HTMLCanvasElement<"u"&&et instanceof HTMLCanvasElement;if(_){const{width:tt,height:nt,top:rt,left:ot,updateStyle:at=_e}=_;return{width:tt,height:nt,top:rt,left:ot,updateStyle:at}}else if(typeof HTMLCanvasElement<"u"&&et instanceof HTMLCanvasElement&&et.parentElement){const{width:tt,height:nt,top:rt,left:ot}=et.parentElement.getBoundingClientRect();return{width:tt,height:nt,top:rt,left:ot,updateStyle:_e}}else if(typeof OffscreenCanvas<"u"&&et instanceof OffscreenCanvas)return{width:et.width,height:et.height,top:0,left:0,updateStyle:_e};return{width:0,height:0,top:0,left:0}}function createRoot(et){const _=roots.get(et),_e=_==null?void 0:_.fiber,tt=_==null?void 0:_.store;_&&console.warn("R3F.createRoot should only be called once!");const nt=typeof reportError=="function"?reportError:console.error,rt=tt||createStore(invalidate,advance),ot=_e||reconciler.createContainer(rt,constantsExports.ConcurrentRoot,null,!1,null,"",nt,null);_||roots.set(et,{fiber:ot,store:rt});let at,lt=!1,ut;return{configure(dt={}){let{gl:st,size:it,scene:ct,events:ft,onCreated:ht,shadows:mt=!1,linear:pt=!1,flat:_t=!1,legacy:vt=!1,orthographic:bt=!1,frameloop:wt="always",dpr:xt=[1,2],performance:Mt,raycaster:At,camera:St,onPointerMissed:Tt}=dt,Ct=rt.getState(),It=Ct.gl;Ct.gl||Ct.set({gl:It=createRendererInstance(st,et)});let $t=Ct.raycaster;$t||Ct.set({raycaster:$t=new Raycaster});const{params:Nt,...Bt}=At||{};if(is.equ(Bt,$t,shallowLoose)||applyProps($t,{...Bt}),is.equ(Nt,$t.params,shallowLoose)||applyProps($t,{params:{...$t.params,...Nt}}),!Ct.camera||Ct.camera===ut&&!is.equ(ut,St,shallowLoose)){ut=St;const Yt=St instanceof Camera,en=Yt?St:bt?new OrthographicCamera$1(0,0,0,0,.1,1e3):new PerspectiveCamera(75,0,.1,1e3);Yt||(en.position.z=5,St&&(applyProps(en,St),("aspect"in St||"left"in St||"right"in St||"bottom"in St||"top"in St)&&(en.manual=!0,en.updateProjectionMatrix())),!Ct.camera&&!(St!=null&&St.rotation)&&en.lookAt(0,0,0)),Ct.set({camera:en}),$t.camera=en}if(!Ct.scene){let Yt;ct instanceof Scene$1?Yt=ct:(Yt=new Scene$1,ct&&applyProps(Yt,ct)),Ct.set({scene:prepare(Yt)})}if(!Ct.xr){var Ot;const Yt=(Un,mn)=>{const vn=rt.getState();vn.frameloop!=="never"&&advance(Un,!0,vn,mn)},en=()=>{const Un=rt.getState();Un.gl.xr.enabled=Un.gl.xr.isPresenting,Un.gl.xr.setAnimationLoop(Un.gl.xr.isPresenting?Yt:null),Un.gl.xr.isPresenting||invalidate(Un)},bn={connect(){const Un=rt.getState().gl;Un.xr.addEventListener("sessionstart",en),Un.xr.addEventListener("sessionend",en)},disconnect(){const Un=rt.getState().gl;Un.xr.removeEventListener("sessionstart",en),Un.xr.removeEventListener("sessionend",en)}};typeof((Ot=It.xr)==null?void 0:Ot.addEventListener)=="function"&&bn.connect(),Ct.set({xr:bn})}if(It.shadowMap){const Yt=It.shadowMap.enabled,en=It.shadowMap.type;if(It.shadowMap.enabled=!!mt,is.boo(mt))It.shadowMap.type=PCFSoftShadowMap;else if(is.str(mt)){var Ut;const bn={basic:BasicShadowMap,percentage:PCFShadowMap,soft:PCFSoftShadowMap,variance:VSMShadowMap};It.shadowMap.type=(Ut=bn[mt])!=null?Ut:PCFSoftShadowMap}else is.obj(mt)&&Object.assign(It.shadowMap,mt);(Yt!==It.shadowMap.enabled||en!==It.shadowMap.type)&&(It.shadowMap.needsUpdate=!0)}const Lt=getColorManagement();Lt&&("enabled"in Lt?Lt.enabled=!vt:"legacyMode"in Lt&&(Lt.legacyMode=vt)),lt||applyProps(It,{outputEncoding:pt?3e3:3001,toneMapping:_t?NoToneMapping:ACESFilmicToneMapping}),Ct.legacy!==vt&&Ct.set(()=>({legacy:vt})),Ct.linear!==pt&&Ct.set(()=>({linear:pt})),Ct.flat!==_t&&Ct.set(()=>({flat:_t})),st&&!is.fun(st)&&!isRenderer(st)&&!is.equ(st,It,shallowLoose)&&applyProps(It,st),ft&&!Ct.events.handlers&&Ct.set({events:ft(rt)});const zt=computeInitialSize(et,it);return is.equ(zt,Ct.size,shallowLoose)||Ct.setSize(zt.width,zt.height,zt.updateStyle,zt.top,zt.left),xt&&Ct.viewport.dpr!==calculateDpr(xt)&&Ct.setDpr(xt),Ct.frameloop!==wt&&Ct.setFrameloop(wt),Ct.onPointerMissed||Ct.set({onPointerMissed:Tt}),Mt&&!is.equ(Mt,Ct.performance,shallowLoose)&&Ct.set(Yt=>({performance:{...Yt.performance,...Mt}})),at=ht,lt=!0,this},render(dt){return lt||this.configure(),reconciler.updateContainer(jsxRuntimeExports.jsx(Provider,{store:rt,children:dt,onCreated:at,rootElement:et}),ot,null,()=>{}),rt},unmount(){unmountComponentAtNode(et)}}}function Provider({store:et,children:_,onCreated:_e,rootElement:tt}){return useIsomorphicLayoutEffect(()=>{const nt=et.getState();nt.set(rt=>({internal:{...rt.internal,active:!0}})),_e&&_e(nt),et.getState().events.connected||nt.events.connect==null||nt.events.connect(tt)},[]),jsxRuntimeExports.jsx(context.Provider,{value:et,children:_})}function unmountComponentAtNode(et,_){const _e=roots.get(et),tt=_e==null?void 0:_e.fiber;if(tt){const nt=_e==null?void 0:_e.store.getState();nt&&(nt.internal.active=!1),reconciler.updateContainer(null,tt,null,()=>{nt&&setTimeout(()=>{try{var rt,ot,at,lt;nt.events.disconnect==null||nt.events.disconnect(),(rt=nt.gl)==null||(ot=rt.renderLists)==null||ot.dispose==null||ot.dispose(),(at=nt.gl)==null||at.forceContextLoss==null||at.forceContextLoss(),(lt=nt.gl)!=null&&lt.xr&&nt.xr.disconnect(),dispose(nt),roots.delete(et)}catch{}},500)})}}function createPortal(et,_,_e){return jsxRuntimeExports.jsx(Portal$2,{children:et,container:_,state:_e},_.uuid)}function Portal$2({state:et={},children:_,container:_e}){const{events:tt,size:nt,...rt}=et,ot=useStore(),[at]=reactExports.useState(()=>new Raycaster),[lt]=reactExports.useState(()=>new Vector2),ut=reactExports.useCallback((st,it)=>{const ct={...st};Object.keys(st).forEach(ht=>{(privateKeys.includes(ht)||st[ht]!==it[ht]&&it[ht])&&delete ct[ht]});let ft;if(it&&nt){const ht=it.camera;ft=st.viewport.getCurrentViewport(ht,new Vector3,nt),ht!==st.camera&&updateCamera(ht,nt)}return{...ct,scene:_e,raycaster:at,pointer:lt,mouse:lt,previousRoot:ot,events:{...st.events,...it==null?void 0:it.events,...tt},size:{...st.size,...nt},viewport:{...st.viewport,...ft},...rt}},[et]),[dt]=reactExports.useState(()=>{const st=ot.getState();return create((ct,ft)=>({...st,scene:_e,raycaster:at,pointer:lt,mouse:lt,previousRoot:ot,events:{...st.events,...tt},size:{...st.size,...nt},...rt,set:ct,get:ft,setEvents:ht=>ct(mt=>({...mt,events:{...mt.events,...ht}}))}))});return reactExports.useEffect(()=>{const st=ot.subscribe(it=>dt.setState(ct=>ut(it,ct)));return()=>{st()}},[ut]),reactExports.useEffect(()=>{dt.setState(st=>ut(ot.getState(),st))},[ut]),reactExports.useEffect(()=>()=>{dt.destroy()},[]),jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment,{children:reconciler.createPortal(jsxRuntimeExports.jsx(context.Provider,{value:dt,children:_}),dt,null)})}reconciler.injectIntoDevTools({bundleType:0,rendererPackageName:"@react-three/fiber",version:reactExports.version});function debounce$1(et,_,_e){var tt,nt,rt,ot,at;_==null&&(_=100);function lt(){var dt=Date.now()-ot;dt<_&&dt>=0?tt=setTimeout(lt,_-dt):(tt=null,_e||(at=et.apply(rt,nt),rt=nt=null))}var ut=function(){rt=this,nt=arguments,ot=Date.now();var dt=_e&&!tt;return tt||(tt=setTimeout(lt,_)),dt&&(at=et.apply(rt,nt),rt=nt=null),at};return ut.clear=function(){tt&&(clearTimeout(tt),tt=null)},ut.flush=function(){tt&&(at=et.apply(rt,nt),rt=nt=null,clearTimeout(tt),tt=null)},ut}debounce$1.debounce=debounce$1;var debounce_1=debounce$1;const createDebounce=getDefaultExportFromCjs(debounce_1);function useMeasure(et){let{debounce:_,scroll:_e,polyfill:tt,offsetSize:nt}=et===void 0?{debounce:0,scroll:!1,offsetSize:!1}:et;const rt=tt||(typeof window>"u"?class{}:window.ResizeObserver);if(!rt)throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");const[ot,at]=reactExports.useState({left:0,top:0,width:0,height:0,bottom:0,right:0,x:0,y:0}),lt=reactExports.useRef({element:null,scrollContainers:null,resizeObserver:null,lastBounds:ot}),ut=_?typeof _=="number"?_:_.scroll:null,dt=_?typeof _=="number"?_:_.resize:null,st=reactExports.useRef(!1);reactExports.useEffect(()=>(st.current=!0,()=>void(st.current=!1)));const[it,ct,ft]=reactExports.useMemo(()=>{const _t=()=>{if(!lt.current.element)return;const{left:vt,top:bt,width:wt,height:xt,bottom:Mt,right:At,x:St,y:Tt}=lt.current.element.getBoundingClientRect(),Ct={left:vt,top:bt,width:wt,height:xt,bottom:Mt,right:At,x:St,y:Tt};lt.current.element instanceof HTMLElement&&nt&&(Ct.height=lt.current.element.offsetHeight,Ct.width=lt.current.element.offsetWidth),Object.freeze(Ct),st.current&&!areBoundsEqual(lt.current.lastBounds,Ct)&&at(lt.current.lastBounds=Ct)};return[_t,dt?createDebounce(_t,dt):_t,ut?createDebounce(_t,ut):_t]},[at,nt,ut,dt]);function ht(){lt.current.scrollContainers&&(lt.current.scrollContainers.forEach(_t=>_t.removeEventListener("scroll",ft,!0)),lt.current.scrollContainers=null),lt.current.resizeObserver&&(lt.current.resizeObserver.disconnect(),lt.current.resizeObserver=null)}function mt(){lt.current.element&&(lt.current.resizeObserver=new rt(ft),lt.current.resizeObserver.observe(lt.current.element),_e&&lt.current.scrollContainers&&lt.current.scrollContainers.forEach(_t=>_t.addEventListener("scroll",ft,{capture:!0,passive:!0})))}const pt=_t=>{!_t||_t===lt.current.element||(ht(),lt.current.element=_t,lt.current.scrollContainers=findScrollContainers(_t),mt())};return useOnWindowScroll(ft,!!_e),useOnWindowResize(ct),reactExports.useEffect(()=>{ht(),mt()},[_e,ft,ct]),reactExports.useEffect(()=>ht,[]),[pt,ot,it]}function useOnWindowResize(et){reactExports.useEffect(()=>{const _=et;return window.addEventListener("resize",_),()=>void window.removeEventListener("resize",_)},[et])}function useOnWindowScroll(et,_){reactExports.useEffect(()=>{if(_){const _e=et;return window.addEventListener("scroll",_e,{capture:!0,passive:!0}),()=>void window.removeEventListener("scroll",_e,!0)}},[et,_])}function findScrollContainers(et){const _=[];if(!et||et===document.body)return _;const{overflow:_e,overflowX:tt,overflowY:nt}=window.getComputedStyle(et);return[_e,tt,nt].some(rt=>rt==="auto"||rt==="scroll")&&_.push(et),[..._,...findScrollContainers(et.parentElement)]}const keys=["x","y","top","bottom","left","right","width","height"],areBoundsEqual=(et,_)=>keys.every(_e=>et[_e]===_[_e]);var __defProp$2=Object.defineProperty,__defProps=Object.defineProperties,__getOwnPropDescs=Object.getOwnPropertyDescriptors,__getOwnPropSymbols=Object.getOwnPropertySymbols,__hasOwnProp=Object.prototype.hasOwnProperty,__propIsEnum=Object.prototype.propertyIsEnumerable,__defNormalProp$2=(et,_,_e)=>_ in et?__defProp$2(et,_,{enumerable:!0,configurable:!0,writable:!0,value:_e}):et[_]=_e,__spreadValues=(et,_)=>{for(var _e in _||(_={}))__hasOwnProp.call(_,_e)&&__defNormalProp$2(et,_e,_[_e]);if(__getOwnPropSymbols)for(var _e of __getOwnPropSymbols(_))__propIsEnum.call(_,_e)&&__defNormalProp$2(et,_e,_[_e]);return et},__spreadProps=(et,_)=>__defProps(et,__getOwnPropDescs(_)),_a,_b;typeof window<"u"&&((_a=window.document)!=null&&_a.createElement||((_b=window.navigator)==null?void 0:_b.product)==="ReactNative")?reactExports.useLayoutEffect:reactExports.useEffect;function traverseFiber(et,_,_e){if(!et)return;if(_e(et)===!0)return et;let tt=et.child;for(;tt;){const nt=traverseFiber(tt,_,_e);if(nt)return nt;tt=tt.sibling}}function wrapContext(et){try{return Object.defineProperties(et,{_currentRenderer:{get(){return null},set(){}},_currentRenderer2:{get(){return null},set(){}}})}catch{return et}}const error=console.error;console.error=function(){const et=[...arguments].join("");if(et!=null&&et.startsWith("Warning:")&&et.includes("useContext")){console.error=error;return}return error.apply(this,arguments)};const FiberContext=wrapContext(reactExports.createContext(null));class FiberProvider extends reactExports.Component{render(){return reactExports.createElement(FiberContext.Provider,{value:this._reactInternals},this.props.children)}}function useFiber(){const et=reactExports.useContext(FiberContext);if(et===null)throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");const _=reactExports.useId();return reactExports.useMemo(()=>{for(const tt of[et,et==null?void 0:et.alternate]){if(!tt)continue;const nt=traverseFiber(tt,!1,rt=>{let ot=rt.memoizedState;for(;ot;){if(ot.memoizedState===_)return!0;ot=ot.next}});if(nt)return nt}},[et,_])}function useContextMap(){const et=useFiber(),[_]=reactExports.useState(()=>new Map);_.clear();let _e=et;for(;_e;){if(_e.type&&typeof _e.type=="object"){const nt=_e.type._context===void 0&&_e.type.Provider===_e.type?_e.type:_e.type._context;nt&&nt!==FiberContext&&!_.has(nt)&&_.set(nt,reactExports.useContext(wrapContext(nt)))}_e=_e.return}return _}function useContextBridge(){const et=useContextMap();return reactExports.useMemo(()=>Array.from(et.keys()).reduce((_,_e)=>tt=>reactExports.createElement(_,null,reactExports.createElement(_e.Provider,__spreadProps(__spreadValues({},tt),{value:et.get(_e)}))),_=>reactExports.createElement(FiberProvider,__spreadValues({},_))),[et])}const DOM_EVENTS={onClick:["click",!1],onContextMenu:["contextmenu",!1],onDoubleClick:["dblclick",!1],onWheel:["wheel",!0],onPointerDown:["pointerdown",!0],onPointerUp:["pointerup",!0],onPointerLeave:["pointerleave",!0],onPointerMove:["pointermove",!0],onPointerCancel:["pointercancel",!0],onLostPointerCapture:["lostpointercapture",!0]};function createPointerEvents(et){const{handlePointer:_}=createEvents(et);return{priority:1,enabled:!0,compute(_e,tt,nt){tt.pointer.set(_e.offsetX/tt.size.width*2-1,-(_e.offsetY/tt.size.height)*2+1),tt.raycaster.setFromCamera(tt.pointer,tt.camera)},connected:void 0,handlers:Object.keys(DOM_EVENTS).reduce((_e,tt)=>({..._e,[tt]:_(tt)}),{}),update:()=>{var _e;const{events:tt,internal:nt}=et.getState();(_e=nt.lastEvent)!=null&&_e.current&&tt.handlers&&tt.handlers.onPointerMove(nt.lastEvent.current)},connect:_e=>{var tt;const{set:nt,events:rt}=et.getState();rt.disconnect==null||rt.disconnect(),nt(ot=>({events:{...ot.events,connected:_e}})),Object.entries((tt=rt.handlers)!=null?tt:[]).forEach(([ot,at])=>{const[lt,ut]=DOM_EVENTS[ot];_e.addEventListener(lt,at,{passive:ut})})},disconnect:()=>{const{set:_e,events:tt}=et.getState();if(tt.connected){var nt;Object.entries((nt=tt.handlers)!=null?nt:[]).forEach(([rt,ot])=>{if(tt&&tt.connected instanceof HTMLElement){const[at]=DOM_EVENTS[rt];tt.connected.removeEventListener(at,ot)}}),_e(rt=>({events:{...rt.events,connected:void 0}}))}}}}const CanvasImpl=reactExports.forwardRef(function({children:_,fallback:_e,resize:tt,style:nt,gl:rt,events:ot=createPointerEvents,eventSource:at,eventPrefix:lt,shadows:ut,linear:dt,flat:st,legacy:it,orthographic:ct,frameloop:ft,dpr:ht,performance:mt,raycaster:pt,camera:_t,scene:vt,onPointerMissed:bt,onCreated:wt,...xt},Mt){reactExports.useMemo(()=>extend$2(THREE),[]);const At=useContextBridge(),[St,Tt]=useMeasure({scroll:!0,debounce:{scroll:50,resize:0},...tt}),Ct=reactExports.useRef(null),It=reactExports.useRef(null);reactExports.useImperativeHandle(Mt,()=>Ct.current);const $t=useMutableCallback(bt),[Nt,Bt]=reactExports.useState(!1),[Ot,Ut]=reactExports.useState(!1);if(Nt)throw Nt;if(Ot)throw Ot;const Lt=reactExports.useRef(null);useIsomorphicLayoutEffect(()=>{const Yt=Ct.current;Tt.width>0&&Tt.height>0&&Yt&&(Lt.current||(Lt.current=createRoot(Yt)),Lt.current.configure({gl:rt,events:ot,shadows:ut,linear:dt,flat:st,legacy:it,orthographic:ct,frameloop:ft,dpr:ht,performance:mt,raycaster:pt,camera:_t,scene:vt,size:Tt,onPointerMissed:(...en)=>$t.current==null?void 0:$t.current(...en),onCreated:en=>{en.events.connect==null||en.events.connect(at?isRef(at)?at.current:at:It.current),lt&&en.setEvents({compute:(bn,Un)=>{const mn=bn[lt+"X"],vn=bn[lt+"Y"];Un.pointer.set(mn/Un.size.width*2-1,-(vn/Un.size.height)*2+1),Un.raycaster.setFromCamera(Un.pointer,Un.camera)}}),wt==null||wt(en)}}),Lt.current.render(jsxRuntimeExports.jsx(At,{children:jsxRuntimeExports.jsx(ErrorBoundary,{set:Ut,children:jsxRuntimeExports.jsx(reactExports.Suspense,{fallback:jsxRuntimeExports.jsx(Block,{set:Bt}),children:_})})})))}),reactExports.useEffect(()=>{const Yt=Ct.current;if(Yt)return()=>unmountComponentAtNode(Yt)},[]);const zt=at?"none":"auto";return jsxRuntimeExports.jsx("div",{ref:It,style:{position:"relative",width:"100%",height:"100%",overflow:"hidden",pointerEvents:zt,...nt},...xt,children:jsxRuntimeExports.jsx("div",{ref:St,style:{width:"100%",height:"100%"},children:jsxRuntimeExports.jsx("canvas",{ref:Ct,style:{display:"block"},children:_e})})})}),Canvas$1=reactExports.forwardRef(function(_,_e){return jsxRuntimeExports.jsx(FiberProvider,{children:jsxRuntimeExports.jsx(CanvasImpl,{..._,ref:_e})})});function commonjsRequire(et){throw new Error('Could not dynamically require "'+et+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var object_hash={exports:{}};(function(et,_){(function(_e){et.exports=_e()})(function(){return function _e(tt,nt,rt){function ot(ut,dt){if(!nt[ut]){if(!tt[ut]){var st=typeof commonjsRequire=="function"&&commonjsRequire;if(!dt&&st)return st(ut,!0);if(at)return at(ut,!0);throw new Error("Cannot find module '"+ut+"'")}dt=nt[ut]={exports:{}},tt[ut][0].call(dt.exports,function(it){var ct=tt[ut][1][it];return ot(ct||it)},dt,dt.exports,_e,tt,nt,rt)}return nt[ut].exports}for(var at=typeof commonjsRequire=="function"&&commonjsRequire,lt=0;lt<rt.length;lt++)ot(rt[lt]);return ot}({1:[function(_e,tt,nt){(function(rt,ot,at,lt,ut,dt,st,it,ct){var ft=_e("crypto");function ht(xt,Mt){Mt=_t(xt,Mt);var At;return(At=Mt.algorithm!=="passthrough"?ft.createHash(Mt.algorithm):new wt).write===void 0&&(At.write=At.update,At.end=At.update),bt(Mt,At).dispatch(xt),At.update||At.end(""),At.digest?At.digest(Mt.encoding==="buffer"?void 0:Mt.encoding):(xt=At.read(),Mt.encoding!=="buffer"?xt.toString(Mt.encoding):xt)}(nt=tt.exports=ht).sha1=function(xt){return ht(xt)},nt.keys=function(xt){return ht(xt,{excludeValues:!0,algorithm:"sha1",encoding:"hex"})},nt.MD5=function(xt){return ht(xt,{algorithm:"md5",encoding:"hex"})},nt.keysMD5=function(xt){return ht(xt,{algorithm:"md5",encoding:"hex",excludeValues:!0})};var mt=ft.getHashes?ft.getHashes().slice():["sha1","md5"],pt=(mt.push("passthrough"),["buffer","hex","binary","base64"]);function _t(xt,Mt){var At={};if(At.algorithm=(Mt=Mt||{}).algorithm||"sha1",At.encoding=Mt.encoding||"hex",At.excludeValues=!!Mt.excludeValues,At.algorithm=At.algorithm.toLowerCase(),At.encoding=At.encoding.toLowerCase(),At.ignoreUnknown=Mt.ignoreUnknown===!0,At.respectType=Mt.respectType!==!1,At.respectFunctionNames=Mt.respectFunctionNames!==!1,At.respectFunctionProperties=Mt.respectFunctionProperties!==!1,At.unorderedArrays=Mt.unorderedArrays===!0,At.unorderedSets=Mt.unorderedSets!==!1,At.unorderedObjects=Mt.unorderedObjects!==!1,At.replacer=Mt.replacer||void 0,At.excludeKeys=Mt.excludeKeys||void 0,xt===void 0)throw new Error("Object argument required.");for(var St=0;St<mt.length;++St)mt[St].toLowerCase()===At.algorithm.toLowerCase()&&(At.algorithm=mt[St]);if(mt.indexOf(At.algorithm)===-1)throw new Error('Algorithm "'+At.algorithm+'"  not supported. supported values: '+mt.join(", "));if(pt.indexOf(At.encoding)===-1&&At.algorithm!=="passthrough")throw new Error('Encoding "'+At.encoding+'"  not supported. supported values: '+pt.join(", "));return At}function vt(xt){if(typeof xt=="function")return/^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(xt))!=null}function bt(xt,Mt,At){At=At||[];function St(Tt){return Mt.update?Mt.update(Tt,"utf8"):Mt.write(Tt,"utf8")}return{dispatch:function(Tt){return this["_"+((Tt=xt.replacer?xt.replacer(Tt):Tt)===null?"null":typeof Tt)](Tt)},_object:function(Tt){var Ct,It=Object.prototype.toString.call(Tt),$t=/\[object (.*)\]/i.exec(It);if($t=($t=$t?$t[1]:"unknown:["+It+"]").toLowerCase(),0<=(It=At.indexOf(Tt)))return this.dispatch("[CIRCULAR:"+It+"]");if(At.push(Tt),at!==void 0&&at.isBuffer&&at.isBuffer(Tt))return St("buffer:"),St(Tt);if($t==="object"||$t==="function"||$t==="asyncfunction")return It=Object.keys(Tt),xt.unorderedObjects&&(It=It.sort()),xt.respectType===!1||vt(Tt)||It.splice(0,0,"prototype","__proto__","constructor"),xt.excludeKeys&&(It=It.filter(function(Nt){return!xt.excludeKeys(Nt)})),St("object:"+It.length+":"),Ct=this,It.forEach(function(Nt){Ct.dispatch(Nt),St(":"),xt.excludeValues||Ct.dispatch(Tt[Nt]),St(",")});if(!this["_"+$t]){if(xt.ignoreUnknown)return St("["+$t+"]");throw new Error('Unknown object type "'+$t+'"')}this["_"+$t](Tt)},_array:function(Tt,Nt){Nt=Nt!==void 0?Nt:xt.unorderedArrays!==!1;var It=this;if(St("array:"+Tt.length+":"),!Nt||Tt.length<=1)return Tt.forEach(function(Bt){return It.dispatch(Bt)});var $t=[],Nt=Tt.map(function(Bt){var Ot=new wt,Ut=At.slice();return bt(xt,Ot,Ut).dispatch(Bt),$t=$t.concat(Ut.slice(At.length)),Ot.read().toString()});return At=At.concat($t),Nt.sort(),this._array(Nt,!1)},_date:function(Tt){return St("date:"+Tt.toJSON())},_symbol:function(Tt){return St("symbol:"+Tt.toString())},_error:function(Tt){return St("error:"+Tt.toString())},_boolean:function(Tt){return St("bool:"+Tt.toString())},_string:function(Tt){St("string:"+Tt.length+":"),St(Tt.toString())},_function:function(Tt){St("fn:"),vt(Tt)?this.dispatch("[native]"):this.dispatch(Tt.toString()),xt.respectFunctionNames!==!1&&this.dispatch("function-name:"+String(Tt.name)),xt.respectFunctionProperties&&this._object(Tt)},_number:function(Tt){return St("number:"+Tt.toString())},_xml:function(Tt){return St("xml:"+Tt.toString())},_null:function(){return St("Null")},_undefined:function(){return St("Undefined")},_regexp:function(Tt){return St("regex:"+Tt.toString())},_uint8array:function(Tt){return St("uint8array:"),this.dispatch(Array.prototype.slice.call(Tt))},_uint8clampedarray:function(Tt){return St("uint8clampedarray:"),this.dispatch(Array.prototype.slice.call(Tt))},_int8array:function(Tt){return St("int8array:"),this.dispatch(Array.prototype.slice.call(Tt))},_uint16array:function(Tt){return St("uint16array:"),this.dispatch(Array.prototype.slice.call(Tt))},_int16array:function(Tt){return St("int16array:"),this.dispatch(Array.prototype.slice.call(Tt))},_uint32array:function(Tt){return St("uint32array:"),this.dispatch(Array.prototype.slice.call(Tt))},_int32array:function(Tt){return St("int32array:"),this.dispatch(Array.prototype.slice.call(Tt))},_float32array:function(Tt){return St("float32array:"),this.dispatch(Array.prototype.slice.call(Tt))},_float64array:function(Tt){return St("float64array:"),this.dispatch(Array.prototype.slice.call(Tt))},_arraybuffer:function(Tt){return St("arraybuffer:"),this.dispatch(new Uint8Array(Tt))},_url:function(Tt){return St("url:"+Tt.toString())},_map:function(Tt){return St("map:"),Tt=Array.from(Tt),this._array(Tt,xt.unorderedSets!==!1)},_set:function(Tt){return St("set:"),Tt=Array.from(Tt),this._array(Tt,xt.unorderedSets!==!1)},_file:function(Tt){return St("file:"),this.dispatch([Tt.name,Tt.size,Tt.type,Tt.lastModfied])},_blob:function(){if(xt.ignoreUnknown)return St("[blob]");throw Error(`Hashing Blob objects is currently not supported
(see https://github.com/puleos/object-hash/issues/26)
Use "options.replacer" or "options.ignoreUnknown"
`)},_domwindow:function(){return St("domwindow")},_bigint:function(Tt){return St("bigint:"+Tt.toString())},_process:function(){return St("process")},_timer:function(){return St("timer")},_pipe:function(){return St("pipe")},_tcp:function(){return St("tcp")},_udp:function(){return St("udp")},_tty:function(){return St("tty")},_statwatcher:function(){return St("statwatcher")},_securecontext:function(){return St("securecontext")},_connection:function(){return St("connection")},_zlib:function(){return St("zlib")},_context:function(){return St("context")},_nodescript:function(){return St("nodescript")},_httpparser:function(){return St("httpparser")},_dataview:function(){return St("dataview")},_signal:function(){return St("signal")},_fsevent:function(){return St("fsevent")},_tlswrap:function(){return St("tlswrap")}}}function wt(){return{buf:"",write:function(xt){this.buf+=xt},end:function(xt){this.buf+=xt},read:function(){return this.buf}}}nt.writeToStream=function(xt,Mt,At){return At===void 0&&(At=Mt,Mt={}),bt(Mt=_t(xt,Mt),At).dispatch(xt)}}).call(this,_e("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},_e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/fake_9a5aa49d.js","/")},{buffer:3,crypto:5,lYpoI2:11}],2:[function(_e,tt,nt){(function(rt,ot,at,lt,ut,dt,st,it,ct){(function(ft){var ht=typeof Uint8Array<"u"?Uint8Array:Array,mt=43,pt=47,_t=48,vt=97,bt=65,wt=45,xt=95;function Mt(At){return At=At.charCodeAt(0),At===mt||At===wt?62:At===pt||At===xt?63:At<_t?-1:At<_t+10?At-_t+26+26:At<bt+26?At-bt:At<vt+26?At-vt+26:void 0}ft.toByteArray=function(At){var St,Tt;if(0<At.length%4)throw new Error("Invalid string. Length must be a multiple of 4");var Ct=At.length,Ct=At.charAt(Ct-2)==="="?2:At.charAt(Ct-1)==="="?1:0,It=new ht(3*At.length/4-Ct),$t=0<Ct?At.length-4:At.length,Nt=0;function Bt(Ot){It[Nt++]=Ot}for(St=0;St<$t;St+=4,0)Bt((16711680&(Tt=Mt(At.charAt(St))<<18|Mt(At.charAt(St+1))<<12|Mt(At.charAt(St+2))<<6|Mt(At.charAt(St+3))))>>16),Bt((65280&Tt)>>8),Bt(255&Tt);return Ct==2?Bt(255&(Tt=Mt(At.charAt(St))<<2|Mt(At.charAt(St+1))>>4)):Ct==1&&(Bt((Tt=Mt(At.charAt(St))<<10|Mt(At.charAt(St+1))<<4|Mt(At.charAt(St+2))>>2)>>8&255),Bt(255&Tt)),It},ft.fromByteArray=function(At){var St,Tt,Ct,It,$t=At.length%3,Nt="";function Bt(Ot){return"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(Ot)}for(St=0,Ct=At.length-$t;St<Ct;St+=3)Tt=(At[St]<<16)+(At[St+1]<<8)+At[St+2],Nt+=Bt((It=Tt)>>18&63)+Bt(It>>12&63)+Bt(It>>6&63)+Bt(63&It);switch($t){case 1:Nt=(Nt+=Bt((Tt=At[At.length-1])>>2))+Bt(Tt<<4&63)+"==";break;case 2:Nt=(Nt=(Nt+=Bt((Tt=(At[At.length-2]<<8)+At[At.length-1])>>10))+Bt(Tt>>4&63))+Bt(Tt<<2&63)+"="}return Nt}})(nt===void 0?this.base64js={}:nt)}).call(this,_e("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},_e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js","/node_modules/gulp-browserify/node_modules/base64-js/lib")},{buffer:3,lYpoI2:11}],3:[function(_e,tt,nt){(function(rt,ot,mt,lt,ut,dt,st,it,ct){var ft=_e("base64-js"),ht=_e("ieee754");function mt(jt,Kt,nn){if(!(this instanceof mt))return new mt(jt,Kt,nn);var Vt,on,dn,Ln,Sn=typeof jt;if(Kt==="base64"&&Sn=="string")for(jt=(Ln=jt).trim?Ln.trim():Ln.replace(/^\s+|\s+$/g,"");jt.length%4!=0;)jt+="=";if(Sn=="number")Vt=Lt(jt);else if(Sn=="string")Vt=mt.byteLength(jt,Kt);else{if(Sn!="object")throw new Error("First argument needs to be a number, array or string.");Vt=Lt(jt.length)}if(mt._useTypedArrays?on=mt._augment(new Uint8Array(Vt)):((on=this).length=Vt,on._isBuffer=!0),mt._useTypedArrays&&typeof jt.byteLength=="number")on._set(jt);else if(zt(Ln=jt)||mt.isBuffer(Ln)||Ln&&typeof Ln=="object"&&typeof Ln.length=="number")for(dn=0;dn<Vt;dn++)mt.isBuffer(jt)?on[dn]=jt.readUInt8(dn):on[dn]=jt[dn];else if(Sn=="string")on.write(jt,0,Kt);else if(Sn=="number"&&!mt._useTypedArrays&&!nn)for(dn=0;dn<Vt;dn++)on[dn]=0;return on}function pt(jt,Kt,nn,Vt){return mt._charsWritten=Un(function(on){for(var dn=[],Ln=0;Ln<on.length;Ln++)dn.push(255&on.charCodeAt(Ln));return dn}(Kt),jt,nn,Vt)}function _t(jt,Kt,nn,Vt){return mt._charsWritten=Un(function(on){for(var dn,Ln,Sn=[],Xn=0;Xn<on.length;Xn++)Ln=on.charCodeAt(Xn),dn=Ln>>8,Ln=Ln%256,Sn.push(Ln),Sn.push(dn);return Sn}(Kt),jt,nn,Vt)}function vt(jt,Kt,nn){var Vt="";nn=Math.min(jt.length,nn);for(var on=Kt;on<nn;on++)Vt+=String.fromCharCode(jt[on]);return Vt}function bt(jt,Kt,nn,dn){dn||(En(typeof nn=="boolean","missing or invalid endian"),En(Kt!=null,"missing offset"),En(Kt+1<jt.length,"Trying to read beyond buffer length"));var on,dn=jt.length;if(!(dn<=Kt))return nn?(on=jt[Kt],Kt+1<dn&&(on|=jt[Kt+1]<<8)):(on=jt[Kt]<<8,Kt+1<dn&&(on|=jt[Kt+1])),on}function wt(jt,Kt,nn,dn){dn||(En(typeof nn=="boolean","missing or invalid endian"),En(Kt!=null,"missing offset"),En(Kt+3<jt.length,"Trying to read beyond buffer length"));var on,dn=jt.length;if(!(dn<=Kt))return nn?(Kt+2<dn&&(on=jt[Kt+2]<<16),Kt+1<dn&&(on|=jt[Kt+1]<<8),on|=jt[Kt],Kt+3<dn&&(on+=jt[Kt+3]<<24>>>0)):(Kt+1<dn&&(on=jt[Kt+1]<<16),Kt+2<dn&&(on|=jt[Kt+2]<<8),Kt+3<dn&&(on|=jt[Kt+3]),on+=jt[Kt]<<24>>>0),on}function xt(jt,Kt,nn,Vt){if(Vt||(En(typeof nn=="boolean","missing or invalid endian"),En(Kt!=null,"missing offset"),En(Kt+1<jt.length,"Trying to read beyond buffer length")),!(jt.length<=Kt))return Vt=bt(jt,Kt,nn,!0),32768&Vt?-1*(65535-Vt+1):Vt}function Mt(jt,Kt,nn,Vt){if(Vt||(En(typeof nn=="boolean","missing or invalid endian"),En(Kt!=null,"missing offset"),En(Kt+3<jt.length,"Trying to read beyond buffer length")),!(jt.length<=Kt))return Vt=wt(jt,Kt,nn,!0),2147483648&Vt?-1*(4294967295-Vt+1):Vt}function At(jt,Kt,nn,Vt){return Vt||(En(typeof nn=="boolean","missing or invalid endian"),En(Kt+3<jt.length,"Trying to read beyond buffer length")),ht.read(jt,Kt,nn,23,4)}function St(jt,Kt,nn,Vt){return Vt||(En(typeof nn=="boolean","missing or invalid endian"),En(Kt+7<jt.length,"Trying to read beyond buffer length")),ht.read(jt,Kt,nn,52,8)}function Tt(jt,Kt,nn,Vt,on){if(on||(En(Kt!=null,"missing value"),En(typeof Vt=="boolean","missing or invalid endian"),En(nn!=null,"missing offset"),En(nn+1<jt.length,"trying to write beyond buffer length"),vn(Kt,65535)),on=jt.length,!(on<=nn))for(var dn=0,Ln=Math.min(on-nn,2);dn<Ln;dn++)jt[nn+dn]=(Kt&255<<8*(Vt?dn:1-dn))>>>8*(Vt?dn:1-dn)}function Ct(jt,Kt,nn,Vt,on){if(on||(En(Kt!=null,"missing value"),En(typeof Vt=="boolean","missing or invalid endian"),En(nn!=null,"missing offset"),En(nn+3<jt.length,"trying to write beyond buffer length"),vn(Kt,4294967295)),on=jt.length,!(on<=nn))for(var dn=0,Ln=Math.min(on-nn,4);dn<Ln;dn++)jt[nn+dn]=Kt>>>8*(Vt?dn:3-dn)&255}function It(jt,Kt,nn,Vt,on){on||(En(Kt!=null,"missing value"),En(typeof Vt=="boolean","missing or invalid endian"),En(nn!=null,"missing offset"),En(nn+1<jt.length,"Trying to write beyond buffer length"),In(Kt,32767,-32768)),jt.length<=nn||Tt(jt,0<=Kt?Kt:65535+Kt+1,nn,Vt,on)}function $t(jt,Kt,nn,Vt,on){on||(En(Kt!=null,"missing value"),En(typeof Vt=="boolean","missing or invalid endian"),En(nn!=null,"missing offset"),En(nn+3<jt.length,"Trying to write beyond buffer length"),In(Kt,2147483647,-2147483648)),jt.length<=nn||Ct(jt,0<=Kt?Kt:4294967295+Kt+1,nn,Vt,on)}function Nt(jt,Kt,nn,Vt,on){on||(En(Kt!=null,"missing value"),En(typeof Vt=="boolean","missing or invalid endian"),En(nn!=null,"missing offset"),En(nn+3<jt.length,"Trying to write beyond buffer length"),Cn(Kt,34028234663852886e22,-34028234663852886e22)),jt.length<=nn||ht.write(jt,Kt,nn,Vt,23,4)}function Bt(jt,Kt,nn,Vt,on){on||(En(Kt!=null,"missing value"),En(typeof Vt=="boolean","missing or invalid endian"),En(nn!=null,"missing offset"),En(nn+7<jt.length,"Trying to write beyond buffer length"),Cn(Kt,17976931348623157e292,-17976931348623157e292)),jt.length<=nn||ht.write(jt,Kt,nn,Vt,52,8)}nt.Buffer=mt,nt.SlowBuffer=mt,nt.INSPECT_MAX_BYTES=50,mt.poolSize=8192,mt._useTypedArrays=function(){try{var jt=new ArrayBuffer(0),Kt=new Uint8Array(jt);return Kt.foo=function(){return 42},Kt.foo()===42&&typeof Kt.subarray=="function"}catch{return!1}}(),mt.isEncoding=function(jt){switch(String(jt).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"raw":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},mt.isBuffer=function(jt){return!(jt==null||!jt._isBuffer)},mt.byteLength=function(jt,Kt){var nn;switch(jt+="",Kt||"utf8"){case"hex":nn=jt.length/2;break;case"utf8":case"utf-8":nn=en(jt).length;break;case"ascii":case"binary":case"raw":nn=jt.length;break;case"base64":nn=bn(jt).length;break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":nn=2*jt.length;break;default:throw new Error("Unknown encoding")}return nn},mt.concat=function(jt,Kt){if(En(zt(jt),`Usage: Buffer.concat(list, [totalLength])
list should be an Array.`),jt.length===0)return new mt(0);if(jt.length===1)return jt[0];if(typeof Kt!="number")for(on=Kt=0;on<jt.length;on++)Kt+=jt[on].length;for(var nn=new mt(Kt),Vt=0,on=0;on<jt.length;on++){var dn=jt[on];dn.copy(nn,Vt),Vt+=dn.length}return nn},mt.prototype.write=function(jt,Kt,nn,Vt){isFinite(Kt)?isFinite(nn)||(Vt=nn,nn=void 0):(Xn=Vt,Vt=Kt,Kt=nn,nn=Xn),Kt=Number(Kt)||0;var on,dn,Ln,Sn,Xn=this.length-Kt;switch((!nn||Xn<(nn=Number(nn)))&&(nn=Xn),Vt=String(Vt||"utf8").toLowerCase()){case"hex":on=function(Vn,Hn,Zt,Gt){Zt=Number(Zt)||0;var fn=Vn.length-Zt;(!Gt||fn<(Gt=Number(Gt)))&&(Gt=fn),En((fn=Hn.length)%2==0,"Invalid hex string"),fn/2<Gt&&(Gt=fn/2);for(var hn=0;hn<Gt;hn++){var xn=parseInt(Hn.substr(2*hn,2),16);En(!isNaN(xn),"Invalid hex string"),Vn[Zt+hn]=xn}return mt._charsWritten=2*hn,hn}(this,jt,Kt,nn);break;case"utf8":case"utf-8":dn=this,Ln=Kt,Sn=nn,on=mt._charsWritten=Un(en(jt),dn,Ln,Sn);break;case"ascii":case"binary":on=pt(this,jt,Kt,nn);break;case"base64":dn=this,Ln=Kt,Sn=nn,on=mt._charsWritten=Un(bn(jt),dn,Ln,Sn);break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":on=_t(this,jt,Kt,nn);break;default:throw new Error("Unknown encoding")}return on},mt.prototype.toString=function(jt,Kt,nn){var Vt,on,dn,Ln,Sn=this;if(jt=String(jt||"utf8").toLowerCase(),Kt=Number(Kt)||0,(nn=nn!==void 0?Number(nn):Sn.length)===Kt)return"";switch(jt){case"hex":Vt=function(Xn,Vn,Hn){var Zt=Xn.length;(!Vn||Vn<0)&&(Vn=0),(!Hn||Hn<0||Zt<Hn)&&(Hn=Zt);for(var Gt="",fn=Vn;fn<Hn;fn++)Gt+=Yt(Xn[fn]);return Gt}(Sn,Kt,nn);break;case"utf8":case"utf-8":Vt=function(Xn,Vn,Hn){var Zt="",Gt="";Hn=Math.min(Xn.length,Hn);for(var fn=Vn;fn<Hn;fn++)Xn[fn]<=127?(Zt+=mn(Gt)+String.fromCharCode(Xn[fn]),Gt=""):Gt+="%"+Xn[fn].toString(16);return Zt+mn(Gt)}(Sn,Kt,nn);break;case"ascii":case"binary":Vt=vt(Sn,Kt,nn);break;case"base64":on=Sn,Ln=nn,Vt=(dn=Kt)===0&&Ln===on.length?ft.fromByteArray(on):ft.fromByteArray(on.slice(dn,Ln));break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":Vt=function(Xn,Vn,Hn){for(var Zt=Xn.slice(Vn,Hn),Gt="",fn=0;fn<Zt.length;fn+=2)Gt+=String.fromCharCode(Zt[fn]+256*Zt[fn+1]);return Gt}(Sn,Kt,nn);break;default:throw new Error("Unknown encoding")}return Vt},mt.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}},mt.prototype.copy=function(jt,Kt,nn,Vt){if(Kt=Kt||0,(Vt=Vt||Vt===0?Vt:this.length)!==(nn=nn||0)&&jt.length!==0&&this.length!==0){En(nn<=Vt,"sourceEnd < sourceStart"),En(0<=Kt&&Kt<jt.length,"targetStart out of bounds"),En(0<=nn&&nn<this.length,"sourceStart out of bounds"),En(0<=Vt&&Vt<=this.length,"sourceEnd out of bounds"),Vt>this.length&&(Vt=this.length);var on=(Vt=jt.length-Kt<Vt-nn?jt.length-Kt+nn:Vt)-nn;if(on<100||!mt._useTypedArrays)for(var dn=0;dn<on;dn++)jt[dn+Kt]=this[dn+nn];else jt._set(this.subarray(nn,nn+on),Kt)}},mt.prototype.slice=function(jt,Kt){var nn=this.length;if(jt=Ut(jt,nn,0),Kt=Ut(Kt,nn,nn),mt._useTypedArrays)return mt._augment(this.subarray(jt,Kt));for(var Vt=Kt-jt,on=new mt(Vt,void 0,!0),dn=0;dn<Vt;dn++)on[dn]=this[dn+jt];return on},mt.prototype.get=function(jt){return console.log(".get() is deprecated. Access using array indexes instead."),this.readUInt8(jt)},mt.prototype.set=function(jt,Kt){return console.log(".set() is deprecated. Access using array indexes instead."),this.writeUInt8(jt,Kt)},mt.prototype.readUInt8=function(jt,Kt){if(Kt||(En(jt!=null,"missing offset"),En(jt<this.length,"Trying to read beyond buffer length")),!(jt>=this.length))return this[jt]},mt.prototype.readUInt16LE=function(jt,Kt){return bt(this,jt,!0,Kt)},mt.prototype.readUInt16BE=function(jt,Kt){return bt(this,jt,!1,Kt)},mt.prototype.readUInt32LE=function(jt,Kt){return wt(this,jt,!0,Kt)},mt.prototype.readUInt32BE=function(jt,Kt){return wt(this,jt,!1,Kt)},mt.prototype.readInt8=function(jt,Kt){if(Kt||(En(jt!=null,"missing offset"),En(jt<this.length,"Trying to read beyond buffer length")),!(jt>=this.length))return 128&this[jt]?-1*(255-this[jt]+1):this[jt]},mt.prototype.readInt16LE=function(jt,Kt){return xt(this,jt,!0,Kt)},mt.prototype.readInt16BE=function(jt,Kt){return xt(this,jt,!1,Kt)},mt.prototype.readInt32LE=function(jt,Kt){return Mt(this,jt,!0,Kt)},mt.prototype.readInt32BE=function(jt,Kt){return Mt(this,jt,!1,Kt)},mt.prototype.readFloatLE=function(jt,Kt){return At(this,jt,!0,Kt)},mt.prototype.readFloatBE=function(jt,Kt){return At(this,jt,!1,Kt)},mt.prototype.readDoubleLE=function(jt,Kt){return St(this,jt,!0,Kt)},mt.prototype.readDoubleBE=function(jt,Kt){return St(this,jt,!1,Kt)},mt.prototype.writeUInt8=function(jt,Kt,nn){nn||(En(jt!=null,"missing value"),En(Kt!=null,"missing offset"),En(Kt<this.length,"trying to write beyond buffer length"),vn(jt,255)),Kt>=this.length||(this[Kt]=jt)},mt.prototype.writeUInt16LE=function(jt,Kt,nn){Tt(this,jt,Kt,!0,nn)},mt.prototype.writeUInt16BE=function(jt,Kt,nn){Tt(this,jt,Kt,!1,nn)},mt.prototype.writeUInt32LE=function(jt,Kt,nn){Ct(this,jt,Kt,!0,nn)},mt.prototype.writeUInt32BE=function(jt,Kt,nn){Ct(this,jt,Kt,!1,nn)},mt.prototype.writeInt8=function(jt,Kt,nn){nn||(En(jt!=null,"missing value"),En(Kt!=null,"missing offset"),En(Kt<this.length,"Trying to write beyond buffer length"),In(jt,127,-128)),Kt>=this.length||(0<=jt?this.writeUInt8(jt,Kt,nn):this.writeUInt8(255+jt+1,Kt,nn))},mt.prototype.writeInt16LE=function(jt,Kt,nn){It(this,jt,Kt,!0,nn)},mt.prototype.writeInt16BE=function(jt,Kt,nn){It(this,jt,Kt,!1,nn)},mt.prototype.writeInt32LE=function(jt,Kt,nn){$t(this,jt,Kt,!0,nn)},mt.prototype.writeInt32BE=function(jt,Kt,nn){$t(this,jt,Kt,!1,nn)},mt.prototype.writeFloatLE=function(jt,Kt,nn){Nt(this,jt,Kt,!0,nn)},mt.prototype.writeFloatBE=function(jt,Kt,nn){Nt(this,jt,Kt,!1,nn)},mt.prototype.writeDoubleLE=function(jt,Kt,nn){Bt(this,jt,Kt,!0,nn)},mt.prototype.writeDoubleBE=function(jt,Kt,nn){Bt(this,jt,Kt,!1,nn)},mt.prototype.fill=function(jt,Kt,nn){if(Kt=Kt||0,nn=nn||this.length,En(typeof(jt=typeof(jt=jt||0)=="string"?jt.charCodeAt(0):jt)=="number"&&!isNaN(jt),"value is not a number"),En(Kt<=nn,"end < start"),nn!==Kt&&this.length!==0){En(0<=Kt&&Kt<this.length,"start out of bounds"),En(0<=nn&&nn<=this.length,"end out of bounds");for(var Vt=Kt;Vt<nn;Vt++)this[Vt]=jt}},mt.prototype.inspect=function(){for(var jt=[],Kt=this.length,nn=0;nn<Kt;nn++)if(jt[nn]=Yt(this[nn]),nn===nt.INSPECT_MAX_BYTES){jt[nn+1]="...";break}return"<Buffer "+jt.join(" ")+">"},mt.prototype.toArrayBuffer=function(){if(typeof Uint8Array>"u")throw new Error("Buffer.toArrayBuffer not supported in this browser");if(mt._useTypedArrays)return new mt(this).buffer;for(var jt=new Uint8Array(this.length),Kt=0,nn=jt.length;Kt<nn;Kt+=1)jt[Kt]=this[Kt];return jt.buffer};var Ot=mt.prototype;function Ut(jt,Kt,nn){return typeof jt!="number"?nn:Kt<=(jt=~~jt)?Kt:0<=jt||0<=(jt+=Kt)?jt:0}function Lt(jt){return(jt=~~Math.ceil(+jt))<0?0:jt}function zt(jt){return(Array.isArray||function(Kt){return Object.prototype.toString.call(Kt)==="[object Array]"})(jt)}function Yt(jt){return jt<16?"0"+jt.toString(16):jt.toString(16)}function en(jt){for(var Kt=[],nn=0;nn<jt.length;nn++){var Vt=jt.charCodeAt(nn);if(Vt<=127)Kt.push(jt.charCodeAt(nn));else for(var on=nn,dn=(55296<=Vt&&Vt<=57343&&nn++,encodeURIComponent(jt.slice(on,nn+1)).substr(1).split("%")),Ln=0;Ln<dn.length;Ln++)Kt.push(parseInt(dn[Ln],16))}return Kt}function bn(jt){return ft.toByteArray(jt)}function Un(jt,Kt,nn,Vt){for(var on=0;on<Vt&&!(on+nn>=Kt.length||on>=jt.length);on++)Kt[on+nn]=jt[on];return on}function mn(jt){try{return decodeURIComponent(jt)}catch{return""}}function vn(jt,Kt){En(typeof jt=="number","cannot write a non-number as a number"),En(0<=jt,"specified a negative value for writing an unsigned value"),En(jt<=Kt,"value is larger than maximum value for type"),En(Math.floor(jt)===jt,"value has a fractional component")}function In(jt,Kt,nn){En(typeof jt=="number","cannot write a non-number as a number"),En(jt<=Kt,"value larger than maximum allowed value"),En(nn<=jt,"value smaller than minimum allowed value"),En(Math.floor(jt)===jt,"value has a fractional component")}function Cn(jt,Kt,nn){En(typeof jt=="number","cannot write a non-number as a number"),En(jt<=Kt,"value larger than maximum allowed value"),En(nn<=jt,"value smaller than minimum allowed value")}function En(jt,Kt){if(!jt)throw new Error(Kt||"Failed assertion")}mt._augment=function(jt){return jt._isBuffer=!0,jt._get=jt.get,jt._set=jt.set,jt.get=Ot.get,jt.set=Ot.set,jt.write=Ot.write,jt.toString=Ot.toString,jt.toLocaleString=Ot.toString,jt.toJSON=Ot.toJSON,jt.copy=Ot.copy,jt.slice=Ot.slice,jt.readUInt8=Ot.readUInt8,jt.readUInt16LE=Ot.readUInt16LE,jt.readUInt16BE=Ot.readUInt16BE,jt.readUInt32LE=Ot.readUInt32LE,jt.readUInt32BE=Ot.readUInt32BE,jt.readInt8=Ot.readInt8,jt.readInt16LE=Ot.readInt16LE,jt.readInt16BE=Ot.readInt16BE,jt.readInt32LE=Ot.readInt32LE,jt.readInt32BE=Ot.readInt32BE,jt.readFloatLE=Ot.readFloatLE,jt.readFloatBE=Ot.readFloatBE,jt.readDoubleLE=Ot.readDoubleLE,jt.readDoubleBE=Ot.readDoubleBE,jt.writeUInt8=Ot.writeUInt8,jt.writeUInt16LE=Ot.writeUInt16LE,jt.writeUInt16BE=Ot.writeUInt16BE,jt.writeUInt32LE=Ot.writeUInt32LE,jt.writeUInt32BE=Ot.writeUInt32BE,jt.writeInt8=Ot.writeInt8,jt.writeInt16LE=Ot.writeInt16LE,jt.writeInt16BE=Ot.writeInt16BE,jt.writeInt32LE=Ot.writeInt32LE,jt.writeInt32BE=Ot.writeInt32BE,jt.writeFloatLE=Ot.writeFloatLE,jt.writeFloatBE=Ot.writeFloatBE,jt.writeDoubleLE=Ot.writeDoubleLE,jt.writeDoubleBE=Ot.writeDoubleBE,jt.fill=Ot.fill,jt.inspect=Ot.inspect,jt.toArrayBuffer=Ot.toArrayBuffer,jt}}).call(this,_e("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},_e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/buffer/index.js","/node_modules/gulp-browserify/node_modules/buffer")},{"base64-js":2,buffer:3,ieee754:10,lYpoI2:11}],4:[function(_e,tt,nt){(function(rt,ot,ft,lt,ut,dt,st,it,ct){var ft=_e("buffer").Buffer,ht=4,mt=new ft(ht);mt.fill(0),tt.exports={hash:function(pt,_t,vt,bt){for(var wt=_t(function(Tt,Ct){Tt.length%ht!=0&&(It=Tt.length+(ht-Tt.length%ht),Tt=ft.concat([Tt,mt],It));for(var It,$t=[],Nt=Ct?Tt.readInt32BE:Tt.readInt32LE,Bt=0;Bt<Tt.length;Bt+=ht)$t.push(Nt.call(Tt,Bt));return $t}(pt=ft.isBuffer(pt)?pt:new ft(pt),bt),8*pt.length),_t=bt,xt=new ft(vt),Mt=_t?xt.writeInt32BE:xt.writeInt32LE,At=0;At<wt.length;At++)Mt.call(xt,wt[At],4*At,!0);return xt}}}).call(this,_e("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},_e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{buffer:3,lYpoI2:11}],5:[function(_e,tt,nt){(function(rt,ot,ft,lt,ut,dt,st,it,ct){var ft=_e("buffer").Buffer,ht=_e("./sha"),mt=_e("./sha256"),pt=_e("./rng"),_t={sha1:ht,sha256:mt,md5:_e("./md5")},vt=64,bt=new ft(vt);function wt(Tt,Ct){var It=_t[Tt=Tt||"sha1"],$t=[];return It||xt("algorithm:",Tt,"is not yet supported"),{update:function(Nt){return ft.isBuffer(Nt)||(Nt=new ft(Nt)),$t.push(Nt),Nt.length,this},digest:function(Nt){var Bt=ft.concat($t),Bt=Ct?function(Ot,Ut,Lt){ft.isBuffer(Ut)||(Ut=new ft(Ut)),ft.isBuffer(Lt)||(Lt=new ft(Lt)),Ut.length>vt?Ut=Ot(Ut):Ut.length<vt&&(Ut=ft.concat([Ut,bt],vt));for(var zt=new ft(vt),Yt=new ft(vt),en=0;en<vt;en++)zt[en]=54^Ut[en],Yt[en]=92^Ut[en];return Lt=Ot(ft.concat([zt,Lt])),Ot(ft.concat([Yt,Lt]))}(It,Ct,Bt):It(Bt);return $t=null,Nt?Bt.toString(Nt):Bt}}}function xt(){var Tt=[].slice.call(arguments).join(" ");throw new Error([Tt,"we accept pull requests","http://github.com/dominictarr/crypto-browserify"].join(`
`))}bt.fill(0),nt.createHash=function(Tt){return wt(Tt)},nt.createHmac=wt,nt.randomBytes=function(Tt,Ct){if(!Ct||!Ct.call)return new ft(pt(Tt));try{Ct.call(this,void 0,new ft(pt(Tt)))}catch(It){Ct(It)}};var Mt,At=["createCredentials","createCipher","createCipheriv","createDecipher","createDecipheriv","createSign","createVerify","createDiffieHellman","pbkdf2"],St=function(Tt){nt[Tt]=function(){xt("sorry,",Tt,"is not implemented yet")}};for(Mt in At)St(At[Mt])}).call(this,_e("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},_e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./md5":6,"./rng":7,"./sha":8,"./sha256":9,buffer:3,lYpoI2:11}],6:[function(_e,tt,nt){(function(rt,ot,at,lt,ut,dt,st,it,ct){var ft=_e("./helpers");function ht(xt,Mt){xt[Mt>>5]|=128<<Mt%32,xt[14+(Mt+64>>>9<<4)]=Mt;for(var At=1732584193,St=-271733879,Tt=-1732584194,Ct=271733878,It=0;It<xt.length;It+=16){var $t=At,Nt=St,Bt=Tt,Ot=Ct,At=pt(At,St,Tt,Ct,xt[It+0],7,-680876936),Ct=pt(Ct,At,St,Tt,xt[It+1],12,-389564586),Tt=pt(Tt,Ct,At,St,xt[It+2],17,606105819),St=pt(St,Tt,Ct,At,xt[It+3],22,-1044525330);At=pt(At,St,Tt,Ct,xt[It+4],7,-176418897),Ct=pt(Ct,At,St,Tt,xt[It+5],12,1200080426),Tt=pt(Tt,Ct,At,St,xt[It+6],17,-1473231341),St=pt(St,Tt,Ct,At,xt[It+7],22,-45705983),At=pt(At,St,Tt,Ct,xt[It+8],7,1770035416),Ct=pt(Ct,At,St,Tt,xt[It+9],12,-1958414417),Tt=pt(Tt,Ct,At,St,xt[It+10],17,-42063),St=pt(St,Tt,Ct,At,xt[It+11],22,-1990404162),At=pt(At,St,Tt,Ct,xt[It+12],7,1804603682),Ct=pt(Ct,At,St,Tt,xt[It+13],12,-40341101),Tt=pt(Tt,Ct,At,St,xt[It+14],17,-1502002290),At=_t(At,St=pt(St,Tt,Ct,At,xt[It+15],22,1236535329),Tt,Ct,xt[It+1],5,-165796510),Ct=_t(Ct,At,St,Tt,xt[It+6],9,-1069501632),Tt=_t(Tt,Ct,At,St,xt[It+11],14,643717713),St=_t(St,Tt,Ct,At,xt[It+0],20,-373897302),At=_t(At,St,Tt,Ct,xt[It+5],5,-701558691),Ct=_t(Ct,At,St,Tt,xt[It+10],9,38016083),Tt=_t(Tt,Ct,At,St,xt[It+15],14,-660478335),St=_t(St,Tt,Ct,At,xt[It+4],20,-405537848),At=_t(At,St,Tt,Ct,xt[It+9],5,568446438),Ct=_t(Ct,At,St,Tt,xt[It+14],9,-1019803690),Tt=_t(Tt,Ct,At,St,xt[It+3],14,-187363961),St=_t(St,Tt,Ct,At,xt[It+8],20,1163531501),At=_t(At,St,Tt,Ct,xt[It+13],5,-1444681467),Ct=_t(Ct,At,St,Tt,xt[It+2],9,-51403784),Tt=_t(Tt,Ct,At,St,xt[It+7],14,1735328473),At=vt(At,St=_t(St,Tt,Ct,At,xt[It+12],20,-1926607734),Tt,Ct,xt[It+5],4,-378558),Ct=vt(Ct,At,St,Tt,xt[It+8],11,-2022574463),Tt=vt(Tt,Ct,At,St,xt[It+11],16,1839030562),St=vt(St,Tt,Ct,At,xt[It+14],23,-35309556),At=vt(At,St,Tt,Ct,xt[It+1],4,-1530992060),Ct=vt(Ct,At,St,Tt,xt[It+4],11,1272893353),Tt=vt(Tt,Ct,At,St,xt[It+7],16,-155497632),St=vt(St,Tt,Ct,At,xt[It+10],23,-1094730640),At=vt(At,St,Tt,Ct,xt[It+13],4,681279174),Ct=vt(Ct,At,St,Tt,xt[It+0],11,-358537222),Tt=vt(Tt,Ct,At,St,xt[It+3],16,-722521979),St=vt(St,Tt,Ct,At,xt[It+6],23,76029189),At=vt(At,St,Tt,Ct,xt[It+9],4,-640364487),Ct=vt(Ct,At,St,Tt,xt[It+12],11,-421815835),Tt=vt(Tt,Ct,At,St,xt[It+15],16,530742520),At=bt(At,St=vt(St,Tt,Ct,At,xt[It+2],23,-995338651),Tt,Ct,xt[It+0],6,-198630844),Ct=bt(Ct,At,St,Tt,xt[It+7],10,1126891415),Tt=bt(Tt,Ct,At,St,xt[It+14],15,-1416354905),St=bt(St,Tt,Ct,At,xt[It+5],21,-57434055),At=bt(At,St,Tt,Ct,xt[It+12],6,1700485571),Ct=bt(Ct,At,St,Tt,xt[It+3],10,-1894986606),Tt=bt(Tt,Ct,At,St,xt[It+10],15,-1051523),St=bt(St,Tt,Ct,At,xt[It+1],21,-2054922799),At=bt(At,St,Tt,Ct,xt[It+8],6,1873313359),Ct=bt(Ct,At,St,Tt,xt[It+15],10,-30611744),Tt=bt(Tt,Ct,At,St,xt[It+6],15,-1560198380),St=bt(St,Tt,Ct,At,xt[It+13],21,1309151649),At=bt(At,St,Tt,Ct,xt[It+4],6,-145523070),Ct=bt(Ct,At,St,Tt,xt[It+11],10,-1120210379),Tt=bt(Tt,Ct,At,St,xt[It+2],15,718787259),St=bt(St,Tt,Ct,At,xt[It+9],21,-343485551),At=wt(At,$t),St=wt(St,Nt),Tt=wt(Tt,Bt),Ct=wt(Ct,Ot)}return Array(At,St,Tt,Ct)}function mt(xt,Mt,At,St,Tt,Ct){return wt((Mt=wt(wt(Mt,xt),wt(St,Ct)))<<Tt|Mt>>>32-Tt,At)}function pt(xt,Mt,At,St,Tt,Ct,It){return mt(Mt&At|~Mt&St,xt,Mt,Tt,Ct,It)}function _t(xt,Mt,At,St,Tt,Ct,It){return mt(Mt&St|At&~St,xt,Mt,Tt,Ct,It)}function vt(xt,Mt,At,St,Tt,Ct,It){return mt(Mt^At^St,xt,Mt,Tt,Ct,It)}function bt(xt,Mt,At,St,Tt,Ct,It){return mt(At^(Mt|~St),xt,Mt,Tt,Ct,It)}function wt(xt,Mt){var At=(65535&xt)+(65535&Mt);return(xt>>16)+(Mt>>16)+(At>>16)<<16|65535&At}tt.exports=function(xt){return ft.hash(xt,ht,16)}}).call(this,_e("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},_e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./helpers":4,buffer:3,lYpoI2:11}],7:[function(_e,tt,nt){(function(rt,ot,at,lt,ut,dt,st,it,ct){tt.exports=function(ft){for(var ht,mt=new Array(ft),pt=0;pt<ft;pt++)!(3&pt)&&(ht=4294967296*Math.random()),mt[pt]=ht>>>((3&pt)<<3)&255;return mt}}).call(this,_e("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},_e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{buffer:3,lYpoI2:11}],8:[function(_e,tt,nt){(function(rt,ot,at,lt,ut,dt,st,it,ct){var ft=_e("./helpers");function ht(_t,vt){_t[vt>>5]|=128<<24-vt%32,_t[15+(vt+64>>9<<4)]=vt;for(var bt,wt,xt,Mt=Array(80),At=1732584193,St=-271733879,Tt=-1732584194,Ct=271733878,It=-1009589776,$t=0;$t<_t.length;$t+=16){for(var Nt=At,Bt=St,Ot=Tt,Ut=Ct,Lt=It,zt=0;zt<80;zt++){Mt[zt]=zt<16?_t[$t+zt]:pt(Mt[zt-3]^Mt[zt-8]^Mt[zt-14]^Mt[zt-16],1);var Yt=mt(mt(pt(At,5),(Yt=St,wt=Tt,xt=Ct,(bt=zt)<20?Yt&wt|~Yt&xt:!(bt<40)&&bt<60?Yt&wt|Yt&xt|wt&xt:Yt^wt^xt)),mt(mt(It,Mt[zt]),(bt=zt)<20?1518500249:bt<40?1859775393:bt<60?-1894007588:-899497514)),It=Ct,Ct=Tt,Tt=pt(St,30),St=At,At=Yt}At=mt(At,Nt),St=mt(St,Bt),Tt=mt(Tt,Ot),Ct=mt(Ct,Ut),It=mt(It,Lt)}return Array(At,St,Tt,Ct,It)}function mt(_t,vt){var bt=(65535&_t)+(65535&vt);return(_t>>16)+(vt>>16)+(bt>>16)<<16|65535&bt}function pt(_t,vt){return _t<<vt|_t>>>32-vt}tt.exports=function(_t){return ft.hash(_t,ht,20,!0)}}).call(this,_e("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},_e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./helpers":4,buffer:3,lYpoI2:11}],9:[function(_e,tt,nt){(function(rt,ot,at,lt,ut,dt,st,it,ct){function ft(vt,bt){var wt=(65535&vt)+(65535&bt);return(vt>>16)+(bt>>16)+(wt>>16)<<16|65535&wt}function ht(vt,bt){var wt,xt=new Array(1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298),Mt=new Array(1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225),At=new Array(64);vt[bt>>5]|=128<<24-bt%32,vt[15+(bt+64>>9<<4)]=bt;for(var St,Tt,Ct=0;Ct<vt.length;Ct+=16){for(var It=Mt[0],$t=Mt[1],Nt=Mt[2],Bt=Mt[3],Ot=Mt[4],Ut=Mt[5],Lt=Mt[6],zt=Mt[7],Yt=0;Yt<64;Yt++)At[Yt]=Yt<16?vt[Yt+Ct]:ft(ft(ft((Tt=At[Yt-2],pt(Tt,17)^pt(Tt,19)^_t(Tt,10)),At[Yt-7]),(Tt=At[Yt-15],pt(Tt,7)^pt(Tt,18)^_t(Tt,3))),At[Yt-16]),wt=ft(ft(ft(ft(zt,pt(Tt=Ot,6)^pt(Tt,11)^pt(Tt,25)),Ot&Ut^~Ot&Lt),xt[Yt]),At[Yt]),St=ft(pt(St=It,2)^pt(St,13)^pt(St,22),It&$t^It&Nt^$t&Nt),zt=Lt,Lt=Ut,Ut=Ot,Ot=ft(Bt,wt),Bt=Nt,Nt=$t,$t=It,It=ft(wt,St);Mt[0]=ft(It,Mt[0]),Mt[1]=ft($t,Mt[1]),Mt[2]=ft(Nt,Mt[2]),Mt[3]=ft(Bt,Mt[3]),Mt[4]=ft(Ot,Mt[4]),Mt[5]=ft(Ut,Mt[5]),Mt[6]=ft(Lt,Mt[6]),Mt[7]=ft(zt,Mt[7])}return Mt}var mt=_e("./helpers"),pt=function(vt,bt){return vt>>>bt|vt<<32-bt},_t=function(vt,bt){return vt>>>bt};tt.exports=function(vt){return mt.hash(vt,ht,32,!0)}}).call(this,_e("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},_e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./helpers":4,buffer:3,lYpoI2:11}],10:[function(_e,tt,nt){(function(rt,ot,at,lt,ut,dt,st,it,ct){nt.read=function(ft,ht,mt,pt,Ct){var vt,bt,wt=8*Ct-pt-1,xt=(1<<wt)-1,Mt=xt>>1,At=-7,St=mt?Ct-1:0,Tt=mt?-1:1,Ct=ft[ht+St];for(St+=Tt,vt=Ct&(1<<-At)-1,Ct>>=-At,At+=wt;0<At;vt=256*vt+ft[ht+St],St+=Tt,At-=8);for(bt=vt&(1<<-At)-1,vt>>=-At,At+=pt;0<At;bt=256*bt+ft[ht+St],St+=Tt,At-=8);if(vt===0)vt=1-Mt;else{if(vt===xt)return bt?NaN:1/0*(Ct?-1:1);bt+=Math.pow(2,pt),vt-=Mt}return(Ct?-1:1)*bt*Math.pow(2,vt-pt)},nt.write=function(ft,ht,mt,pt,_t,It){var bt,wt,xt=8*It-_t-1,Mt=(1<<xt)-1,At=Mt>>1,St=_t===23?Math.pow(2,-24)-Math.pow(2,-77):0,Tt=pt?0:It-1,Ct=pt?1:-1,It=ht<0||ht===0&&1/ht<0?1:0;for(ht=Math.abs(ht),isNaN(ht)||ht===1/0?(wt=isNaN(ht)?1:0,bt=Mt):(bt=Math.floor(Math.log(ht)/Math.LN2),ht*(pt=Math.pow(2,-bt))<1&&(bt--,pt*=2),2<=(ht+=1<=bt+At?St/pt:St*Math.pow(2,1-At))*pt&&(bt++,pt/=2),Mt<=bt+At?(wt=0,bt=Mt):1<=bt+At?(wt=(ht*pt-1)*Math.pow(2,_t),bt+=At):(wt=ht*Math.pow(2,At-1)*Math.pow(2,_t),bt=0));8<=_t;ft[mt+Tt]=255&wt,Tt+=Ct,wt/=256,_t-=8);for(bt=bt<<_t|wt,xt+=_t;0<xt;ft[mt+Tt]=255&bt,Tt+=Ct,bt/=256,xt-=8);ft[mt+Tt-Ct]|=128*It}}).call(this,_e("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},_e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/ieee754/index.js","/node_modules/gulp-browserify/node_modules/ieee754")},{buffer:3,lYpoI2:11}],11:[function(_e,tt,nt){(function(rt,ot,at,lt,ut,dt,st,it,ct){var ft,ht,mt;function pt(){}(rt=tt.exports={}).nextTick=(ht=typeof window<"u"&&window.setImmediate,mt=typeof window<"u"&&window.postMessage&&window.addEventListener,ht?function(_t){return window.setImmediate(_t)}:mt?(ft=[],window.addEventListener("message",function(_t){var vt=_t.source;vt!==window&&vt!==null||_t.data!=="process-tick"||(_t.stopPropagation(),0<ft.length&&ft.shift()())},!0),function(_t){ft.push(_t),window.postMessage("process-tick","*")}):function(_t){setTimeout(_t,0)}),rt.title="browser",rt.browser=!0,rt.env={},rt.argv=[],rt.on=pt,rt.addListener=pt,rt.once=pt,rt.off=pt,rt.removeListener=pt,rt.removeAllListeners=pt,rt.emit=pt,rt.binding=function(_t){throw new Error("process.binding is not supported")},rt.cwd=function(){return"/"},rt.chdir=function(_t){throw new Error("process.chdir is not supported")}}).call(this,_e("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},_e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/process/browser.js","/node_modules/gulp-browserify/node_modules/process")},{buffer:3,lYpoI2:11}]},{},[1])(1)})})(object_hash);var object_hashExports=object_hash.exports;const objectHash=getDefaultExportFromCjs(object_hashExports);var literals=["precision","highp","mediump","lowp","attribute","const","uniform","varying","break","continue","do","for","while","if","else","in","out","inout","float","int","uint","void","bool","true","false","discard","return","mat2","mat3","mat4","vec2","vec3","vec4","ivec2","ivec3","ivec4","bvec2","bvec3","bvec4","sampler1D","sampler2D","sampler3D","samplerCube","sampler1DShadow","sampler2DShadow","struct","asm","class","union","enum","typedef","template","this","packed","goto","switch","default","inline","noinline","volatile","public","static","extern","external","interface","long","short","double","half","fixed","unsigned","input","output","hvec2","hvec3","hvec4","dvec2","dvec3","dvec4","fvec2","fvec3","fvec4","sampler2DRect","sampler3DRect","sampler2DRectShadow","sizeof","cast","namespace","using"],operators$1=["<<=",">>=","++","--","<<",">>","<=",">=","==","!=","&&","||","+=","-=","*=","/=","%=","&=","^^","^=","|=","(",")","[","]",".","!","~","*","/","%","+","-","<",">","&","^","|","?",":","=",",",";","{","}"],builtins=["abs","acos","all","any","asin","atan","ceil","clamp","cos","cross","dFdx","dFdy","degrees","distance","dot","equal","exp","exp2","faceforward","floor","fract","gl_BackColor","gl_BackLightModelProduct","gl_BackLightProduct","gl_BackMaterial","gl_BackSecondaryColor","gl_ClipPlane","gl_ClipVertex","gl_Color","gl_DepthRange","gl_DepthRangeParameters","gl_EyePlaneQ","gl_EyePlaneR","gl_EyePlaneS","gl_EyePlaneT","gl_Fog","gl_FogCoord","gl_FogFragCoord","gl_FogParameters","gl_FragColor","gl_FragCoord","gl_FragData","gl_FragDepth","gl_FragDepthEXT","gl_FrontColor","gl_FrontFacing","gl_FrontLightModelProduct","gl_FrontLightProduct","gl_FrontMaterial","gl_FrontSecondaryColor","gl_LightModel","gl_LightModelParameters","gl_LightModelProducts","gl_LightProducts","gl_LightSource","gl_LightSourceParameters","gl_MaterialParameters","gl_MaxClipPlanes","gl_MaxCombinedTextureImageUnits","gl_MaxDrawBuffers","gl_MaxFragmentUniformComponents","gl_MaxLights","gl_MaxTextureCoords","gl_MaxTextureImageUnits","gl_MaxTextureUnits","gl_MaxVaryingFloats","gl_MaxVertexAttribs","gl_MaxVertexTextureImageUnits","gl_MaxVertexUniformComponents","gl_ModelViewMatrix","gl_ModelViewMatrixInverse","gl_ModelViewMatrixInverseTranspose","gl_ModelViewMatrixTranspose","gl_ModelViewProjectionMatrix","gl_ModelViewProjectionMatrixInverse","gl_ModelViewProjectionMatrixInverseTranspose","gl_ModelViewProjectionMatrixTranspose","gl_MultiTexCoord0","gl_MultiTexCoord1","gl_MultiTexCoord2","gl_MultiTexCoord3","gl_MultiTexCoord4","gl_MultiTexCoord5","gl_MultiTexCoord6","gl_MultiTexCoord7","gl_Normal","gl_NormalMatrix","gl_NormalScale","gl_ObjectPlaneQ","gl_ObjectPlaneR","gl_ObjectPlaneS","gl_ObjectPlaneT","gl_Point","gl_PointCoord","gl_PointParameters","gl_PointSize","gl_Position","gl_ProjectionMatrix","gl_ProjectionMatrixInverse","gl_ProjectionMatrixInverseTranspose","gl_ProjectionMatrixTranspose","gl_SecondaryColor","gl_TexCoord","gl_TextureEnvColor","gl_TextureMatrix","gl_TextureMatrixInverse","gl_TextureMatrixInverseTranspose","gl_TextureMatrixTranspose","gl_Vertex","greaterThan","greaterThanEqual","inversesqrt","length","lessThan","lessThanEqual","log","log2","matrixCompMult","max","min","mix","mod","normalize","not","notEqual","pow","radians","reflect","refract","sign","sin","smoothstep","sqrt","step","tan","texture2D","texture2DLod","texture2DProj","texture2DProjLod","textureCube","textureCubeLod","texture2DLodEXT","texture2DProjLodEXT","textureCubeLodEXT","texture2DGradEXT","texture2DProjGradEXT","textureCubeGradEXT"],v100$1=literals,literals300es$1=v100$1.slice().concat(["layout","centroid","smooth","case","mat2x2","mat2x3","mat2x4","mat3x2","mat3x3","mat3x4","mat4x2","mat4x3","mat4x4","uvec2","uvec3","uvec4","samplerCubeShadow","sampler2DArray","sampler2DArrayShadow","isampler2D","isampler3D","isamplerCube","isampler2DArray","usampler2D","usampler3D","usamplerCube","usampler2DArray","coherent","restrict","readonly","writeonly","resource","atomic_uint","noperspective","patch","sample","subroutine","common","partition","active","filter","image1D","image2D","image3D","imageCube","iimage1D","iimage2D","iimage3D","iimageCube","uimage1D","uimage2D","uimage3D","uimageCube","image1DArray","image2DArray","iimage1DArray","iimage2DArray","uimage1DArray","uimage2DArray","image1DShadow","image2DShadow","image1DArrayShadow","image2DArrayShadow","imageBuffer","iimageBuffer","uimageBuffer","sampler1DArray","sampler1DArrayShadow","isampler1D","isampler1DArray","usampler1D","usampler1DArray","isampler2DRect","usampler2DRect","samplerBuffer","isamplerBuffer","usamplerBuffer","sampler2DMS","isampler2DMS","usampler2DMS","sampler2DMSArray","isampler2DMSArray","usampler2DMSArray"]),v100=builtins;v100=v100.slice().filter(function(et){return!/^(gl\_|texture)/.test(et)});var builtins300es$1=v100.concat(["gl_VertexID","gl_InstanceID","gl_Position","gl_PointSize","gl_FragCoord","gl_FrontFacing","gl_FragDepth","gl_PointCoord","gl_MaxVertexAttribs","gl_MaxVertexUniformVectors","gl_MaxVertexOutputVectors","gl_MaxFragmentInputVectors","gl_MaxVertexTextureImageUnits","gl_MaxCombinedTextureImageUnits","gl_MaxTextureImageUnits","gl_MaxFragmentUniformVectors","gl_MaxDrawBuffers","gl_MinProgramTexelOffset","gl_MaxProgramTexelOffset","gl_DepthRangeParameters","gl_DepthRange","trunc","round","roundEven","isnan","isinf","floatBitsToInt","floatBitsToUint","intBitsToFloat","uintBitsToFloat","packSnorm2x16","unpackSnorm2x16","packUnorm2x16","unpackUnorm2x16","packHalf2x16","unpackHalf2x16","outerProduct","transpose","determinant","inverse","texture","textureSize","textureProj","textureLod","textureOffset","texelFetch","texelFetchOffset","textureProjOffset","textureLodOffset","textureProjLod","textureProjLodOffset","textureGrad","textureGradOffset","textureProjGrad","textureProjGradOffset"]),glslTokenizer=tokenize$3,literals100=literals,operators=operators$1,builtins100=builtins,literals300es=literals300es$1,builtins300es=builtins300es$1,NORMAL=999,TOKEN=9999,BLOCK_COMMENT=0,LINE_COMMENT=1,PREPROCESSOR=2,OPERATOR=3,INTEGER=4,FLOAT=5,IDENT=6,BUILTIN=7,KEYWORD=8,WHITESPACE=9,EOF=10,HEX=11,map=["block-comment","line-comment","preprocessor","operator","integer","float","ident","builtin","keyword","whitespace","eof","integer"];function tokenize$3(et){var _=0,_e=0,tt=NORMAL,nt,rt,ot=[],at=[],lt=1,ut=0,dt=0,st=!1,it=!1,ct="",ft;et=et||{};var ht=builtins100,mt=literals100;et.version==="300 es"&&(ht=builtins300es,mt=literals300es);for(var pt={},_t={},_=0;_<ht.length;_++)pt[ht[_]]=!0;for(var _=0;_<mt.length;_++)_t[mt[_]]=!0;return function(Ut){return at=[],Ut!==null?bt(Ut):wt()};function vt(Ut){Ut.length&&at.push({type:map[tt],data:Ut,position:dt,line:lt,column:ut})}function bt(Ut){_=0,Ut.toString&&(Ut=Ut.toString()),ct+=Ut.replace(/\r\n/g,`
`),ft=ct.length;for(var Lt;nt=ct[_],_<ft;){switch(Lt=_,tt){case BLOCK_COMMENT:_=Tt();break;case LINE_COMMENT:_=St();break;case PREPROCESSOR:_=At();break;case OPERATOR:_=Ct();break;case INTEGER:_=Nt();break;case HEX:_=$t();break;case FLOAT:_=Bt();break;case TOKEN:_=Ot();break;case WHITESPACE:_=Mt();break;case NORMAL:_=xt();break}if(Lt!==_)switch(ct[Lt]){case`
`:ut=0,++lt;break;default:++ut;break}}return _e+=_,ct=ct.slice(_),at}function wt(Ut){return ot.length&&vt(ot.join("")),tt=EOF,vt("(eof)"),at}function xt(){return ot=ot.length?[]:ot,rt==="/"&&nt==="*"?(dt=_e+_-1,tt=BLOCK_COMMENT,rt=nt,_+1):rt==="/"&&nt==="/"?(dt=_e+_-1,tt=LINE_COMMENT,rt=nt,_+1):nt==="#"?(tt=PREPROCESSOR,dt=_e+_,_):/\s/.test(nt)?(tt=WHITESPACE,dt=_e+_,_):(st=/\d/.test(nt),it=/[^\w_]/.test(nt),dt=_e+_,tt=st?INTEGER:it?OPERATOR:TOKEN,_)}function Mt(){return/[^\s]/g.test(nt)?(vt(ot.join("")),tt=NORMAL,_):(ot.push(nt),rt=nt,_+1)}function At(){return(nt==="\r"||nt===`
`)&&rt!=="\\"?(vt(ot.join("")),tt=NORMAL,_):(ot.push(nt),rt=nt,_+1)}function St(){return At()}function Tt(){return nt==="/"&&rt==="*"?(ot.push(nt),vt(ot.join("")),tt=NORMAL,_+1):(ot.push(nt),rt=nt,_+1)}function Ct(){if(rt==="."&&/\d/.test(nt))return tt=FLOAT,_;if(rt==="/"&&nt==="*")return tt=BLOCK_COMMENT,_;if(rt==="/"&&nt==="/")return tt=LINE_COMMENT,_;if(nt==="."&&ot.length){for(;It(ot););return tt=FLOAT,_}if(nt===";"||nt===")"||nt==="("){if(ot.length)for(;It(ot););return vt(nt),tt=NORMAL,_+1}var Ut=ot.length===2&&nt!=="=";if(/[\w_\d\s]/.test(nt)||Ut){for(;It(ot););return tt=NORMAL,_}return ot.push(nt),rt=nt,_+1}function It(Ut){var Lt=0,zt,Yt;do{if(zt=operators.indexOf(Ut.slice(0,Ut.length+Lt).join("")),Yt=operators[zt],zt===-1){if(Lt--+Ut.length>0)continue;Yt=Ut.slice(0,1).join("")}return vt(Yt),dt+=Yt.length,ot=ot.slice(Yt.length),ot.length}while(!0)}function $t(){return/[^a-fA-F0-9]/.test(nt)?(vt(ot.join("")),tt=NORMAL,_):(ot.push(nt),rt=nt,_+1)}function Nt(){return nt==="."||/[eE]/.test(nt)?(ot.push(nt),tt=FLOAT,rt=nt,_+1):nt==="x"&&ot.length===1&&ot[0]==="0"?(tt=HEX,ot.push(nt),rt=nt,_+1):/[^\d]/.test(nt)?(vt(ot.join("")),tt=NORMAL,_):(ot.push(nt),rt=nt,_+1)}function Bt(){return nt==="f"&&(ot.push(nt),rt=nt,_+=1),/[eE]/.test(nt)||(nt==="-"||nt==="+")&&/[eE]/.test(rt)?(ot.push(nt),rt=nt,_+1):/[^\d]/.test(nt)?(vt(ot.join("")),tt=NORMAL,_):(ot.push(nt),rt=nt,_+1)}function Ot(){if(/[^\d\w_]/.test(nt)){var Ut=ot.join("");return _t[Ut]?tt=KEYWORD:pt[Ut]?tt=BUILTIN:tt=IDENT,vt(ot.join("")),tt=NORMAL,_}return ot.push(nt),rt=nt,_+1}}var tokenize$1=glslTokenizer,string$1=tokenizeString;function tokenizeString(et,_){var _e=tokenize$1(_),tt=[];return tt=tt.concat(_e(et)),tt=tt.concat(_e(null)),tt}const tokenize$2=getDefaultExportFromCjs(string$1);var glslTokenString=toString$1;function toString$1(et){for(var _=[],_e=0;_e<et.length;_e++)et[_e].type!=="eof"&&_.push(et[_e].data);return _.join("")}const stringify=getDefaultExportFromCjs(glslTokenString);var glslTokenFunctions=functions;function functions(et){var _=null,_e=null,tt=0,nt=0,rt=0,ot=0,at=0,lt=[],ut,dt,st;for(ut=0,dt;ut<et.length;ut++)if(st=et[ut],st.data==="{"){if(tt&&tt++||(dt=ct(ut,findOp(")"),findOp()),dt<0)||(ot=dt,dt=ct(dt,findOp("("),findOp(")")),dt<0)||(at=dt,dt=ct(dt,findGlyph),dt<0)||et[dt].type!=="ident"||(_e=et[dt].data,dt=ct(dt,findGlyph),dt<0))continue;tt=1,nt=ut,_=et[dt].data,rt=dt;var it=ct(dt,findGlyph);switch(et[it]&&et[it].data){case"lowp":case"highp":case"mediump":rt=it}}else if(tt&&st.data==="}"){if(--tt)continue;lt.push({name:_e,type:_,body:[nt+1,ut],args:[at,ot+1],outer:[rt,ut+1]})}for(ut=0;ut<et.length;ut++)if(st=et[ut],st.data===";"){if(dt=ct(ut,findOp(")"),findOp()),dt<0||(ot=dt,dt=ct(dt,findOp("("),findOp(")")),dt<0)||(at=dt,dt=ct(dt,findGlyph),dt<0)||et[dt].type!=="ident"||(_e=et[dt].data,dt=ct(dt,findGlyph),dt<0)||et[dt].type==="operator"||et[dt].data==="return")continue;_=et[dt].data,lt.push({name:_e,type:_,body:!1,args:[at,ot+1],outer:[dt,ut+1]})}return lt.sort(function(ft,ht){return ft.outer[0]-ht.outer[0]});function ct(ft,ht,mt){for(var pt=ft-1;pt>=0;pt--){if(ht(et[pt]))return pt;if(mt&&mt(et[pt]))return-1}return-1}}function findOp(et){return function(_){return _.type==="operator"&&(!et||_.data===et)}}function findGlyph(et){return et.type!=="whitespace"}const tokenFunctions=getDefaultExportFromCjs(glslTokenFunctions);function _toPrimitive$1(et,_){if(typeof et!="object"||et===null)return et;var _e=et[Symbol.toPrimitive];if(_e!==void 0){var tt=_e.call(et,_||"default");if(typeof tt!="object")return tt;throw new TypeError("@@toPrimitive must return a primitive value.")}return(_==="string"?String:Number)(et)}function _toPropertyKey$1(et){var _=_toPrimitive$1(et,"string");return typeof _=="symbol"?_:String(_)}function _defineProperty$5(et,_,_e){return _=_toPropertyKey$1(_),_ in et?Object.defineProperty(et,_,{value:_e,enumerable:!0,configurable:!0,writable:!0}):et[_]=_e,et}function ownKeys$4(et,_){var _e=Object.keys(et);if(Object.getOwnPropertySymbols){var tt=Object.getOwnPropertySymbols(et);_&&(tt=tt.filter(function(nt){return Object.getOwnPropertyDescriptor(et,nt).enumerable})),_e.push.apply(_e,tt)}return _e}function _objectSpread2$2(et){for(var _=1;_<arguments.length;_++){var _e=arguments[_]!=null?arguments[_]:{};_%2?ownKeys$4(Object(_e),!0).forEach(function(tt){_defineProperty$5(et,tt,_e[tt])}):Object.getOwnPropertyDescriptors?Object.defineProperties(et,Object.getOwnPropertyDescriptors(_e)):ownKeys$4(Object(_e)).forEach(function(tt){Object.defineProperty(et,tt,Object.getOwnPropertyDescriptor(_e,tt))})}return et}function _objectWithoutPropertiesLoose$3(et,_){if(et==null)return{};var _e={},tt=Object.keys(et),nt,rt;for(rt=0;rt<tt.length;rt++)nt=tt[rt],!(_.indexOf(nt)>=0)&&(_e[nt]=et[nt]);return _e}function _objectWithoutProperties$3(et,_){if(et==null)return{};var _e=_objectWithoutPropertiesLoose$3(et,_),tt,nt;if(Object.getOwnPropertySymbols){var rt=Object.getOwnPropertySymbols(et);for(nt=0;nt<rt.length;nt++)tt=rt[nt],!(_.indexOf(tt)>=0)&&Object.prototype.propertyIsEnumerable.call(et,tt)&&(_e[tt]=et[tt])}return _e}function _classCallCheck$1(et,_){if(!(et instanceof _))throw new TypeError("Cannot call a class as a function")}function _defineProperties(et,_){for(var _e=0;_e<_.length;_e++){var tt=_[_e];tt.enumerable=tt.enumerable||!1,tt.configurable=!0,"value"in tt&&(tt.writable=!0),Object.defineProperty(et,_toPropertyKey$1(tt.key),tt)}}function _createClass(et,_,_e){return _&&_defineProperties(et.prototype,_),Object.defineProperty(et,"prototype",{writable:!1}),et}function _assertThisInitialized(et){if(et===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return et}function _setPrototypeOf(et,_){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(tt,nt){return tt.__proto__=nt,tt},_setPrototypeOf(et,_)}function _inherits(et,_){if(typeof _!="function"&&_!==null)throw new TypeError("Super expression must either be null or a function");et.prototype=Object.create(_&&_.prototype,{constructor:{value:et,writable:!0,configurable:!0}}),Object.defineProperty(et,"prototype",{writable:!1}),_&&_setPrototypeOf(et,_)}function _getPrototypeOf(et){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(_e){return _e.__proto__||Object.getPrototypeOf(_e)},_getPrototypeOf(et)}function _isNativeReflectConstruct(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}function _possibleConstructorReturn(et,_){if(_&&(typeof _=="object"||typeof _=="function"))return _;if(_!==void 0)throw new TypeError("Derived constructors may only return object or undefined");return _assertThisInitialized(et)}function _createSuper(et){var _=_isNativeReflectConstruct();return function(){var tt=_getPrototypeOf(et),nt;if(_){var rt=_getPrototypeOf(this).constructor;nt=Reflect.construct(tt,arguments,rt)}else nt=tt.apply(this,arguments);return _possibleConstructorReturn(this,nt)}}var keywords={position:"csm_Position",positionRaw:"csm_PositionRaw",pointSize:"csm_PointSize",fragColor:"csm_FragColor",diffuseColor:"csm_DiffuseColor",normal:"csm_Normal",roughness:"csm_Roughness",metalness:"csm_Metalness",emissive:"csm_Emissive",ao:"csm_AO",bump:"csm_Bump",depthAlpha:"csm_DepthAlpha"},_defaultPatchMap,_shaderMaterial_Patch,defaultPatchMap=(_defaultPatchMap={},_defineProperty$5(_defaultPatchMap,"".concat(keywords.normal),{"#include <beginnormal_vertex>":`
    vec3 objectNormal = `.concat(keywords.normal,`;
    #ifdef USE_TANGENT
	    vec3 objectTangent = vec3( tangent.xyz );
    #endif
    `)}),_defineProperty$5(_defaultPatchMap,"".concat(keywords.position),{"#include <begin_vertex>":`
    vec3 transformed = `.concat(keywords.position,`;
  `)}),_defineProperty$5(_defaultPatchMap,"".concat(keywords.positionRaw),{"#include <begin_vertex>":`
    vec4 csm_internal_positionUnprojected = `.concat(keywords.positionRaw,`;
    mat4x4 csm_internal_unprojectMatrix = projectionMatrix * modelViewMatrix;
    #ifdef USE_INSTANCING
      csm_internal_unprojectMatrix = csm_internal_unprojectMatrix * instanceMatrix;
    #endif
    csm_internal_positionUnprojected = inverse(csm_internal_unprojectMatrix) * csm_internal_positionUnprojected;
    vec3 transformed = csm_internal_positionUnprojected.xyz;
  `)}),_defineProperty$5(_defaultPatchMap,"".concat(keywords.pointSize),{"gl_PointSize = size;":`
    gl_PointSize = `.concat(keywords.pointSize,`;
    `)}),_defineProperty$5(_defaultPatchMap,"".concat(keywords.diffuseColor),{"#include <color_fragment>":`
    #include <color_fragment>
    diffuseColor = `.concat(keywords.diffuseColor,`;
  `)}),_defineProperty$5(_defaultPatchMap,"".concat(keywords.fragColor),{"#include <dithering_fragment>":`
    #include <dithering_fragment>
    gl_FragColor  = `.concat(keywords.fragColor,`;
  `)}),_defineProperty$5(_defaultPatchMap,"".concat(keywords.emissive),{"vec3 totalEmissiveRadiance = emissive;":`
    vec3 totalEmissiveRadiance = `.concat(keywords.emissive,`;
    `)}),_defineProperty$5(_defaultPatchMap,"".concat(keywords.roughness),{"#include <roughnessmap_fragment>":`
    #include <roughnessmap_fragment>
    roughnessFactor = `.concat(keywords.roughness,`;
    `)}),_defineProperty$5(_defaultPatchMap,"".concat(keywords.metalness),{"#include <metalnessmap_fragment>":`
    #include <metalnessmap_fragment>
    metalnessFactor = `.concat(keywords.metalness,`;
    `)}),_defineProperty$5(_defaultPatchMap,"".concat(keywords.ao),{"#include <aomap_fragment>":`
    #include <aomap_fragment>
    reflectedLight.indirectDiffuse *= 1. - `.concat(keywords.ao,`;
    `)}),_defineProperty$5(_defaultPatchMap,"".concat(keywords.bump),{"#include <normal_fragment_maps>":`
    #include <normal_fragment_maps>

    vec3 csm_internal_orthogonal = `.concat(keywords.bump," - (dot(").concat(keywords.bump,`, normal) * normal);
    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;
    normal = normalize(normal - csm_internal_projectedbump);
    `)}),_defineProperty$5(_defaultPatchMap,"".concat(keywords.depthAlpha),{"gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );":`
      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * `.concat(keywords.depthAlpha,` );
    `),"gl_FragColor = packDepthToRGBA( fragCoordZ );":`
      gl_FragColor = packDepthToRGBA( fragCoordZ );
      gl_FragColor.a *= `.concat(keywords.depthAlpha,`;
    `)}),_defaultPatchMap),shaderMaterial_PatchMap=(_shaderMaterial_Patch={},_defineProperty$5(_shaderMaterial_Patch,"".concat(keywords.position),{"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );":`
    gl_Position = projectionMatrix * modelViewMatrix * vec4( `.concat(keywords.position,`, 1.0 );
  `)}),_defineProperty$5(_shaderMaterial_Patch,"".concat(keywords.positionRaw),{"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );":`
    gl_Position = `.concat(keywords.position,`;
  `)}),_defineProperty$5(_shaderMaterial_Patch,"".concat(keywords.diffuseColor),{"gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );":`
    gl_FragColor = `.concat(keywords.diffuseColor,`;
  `)}),_defineProperty$5(_shaderMaterial_Patch,"".concat(keywords.fragColor),{"gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );":`
    gl_FragColor = `.concat(keywords.fragColor,`;
  `)}),_shaderMaterial_Patch),defaultDefinitions=`

#ifdef IS_VERTEX
    // csm_Position & csm_PositionRaw
    #ifdef IS_UNKNOWN
        vec3 csm_Position = vec3(0.0);
        vec4 csm_PositionRaw = vec4(0.0);
        vec3 csm_Normal = vec3(0.0);
    #else
        vec3 csm_Position = position;
        vec4 csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);
        vec3 csm_Normal = normal;
    #endif

    // csm_PointSize
    #ifdef IS_POINTSMATERIAL
        float csm_PointSize = size;
    #endif
#else
    // csm_DiffuseColor & csm_FragColor
    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL
        vec4 csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);
        vec4 csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #else
        #ifdef USE_MAP
            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);

            #ifdef DECODE_VIDEO_TEXTURE
            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)
            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);
            #endif

            vec4 csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
            vec4 csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
        #else
            vec4 csm_DiffuseColor = vec4(diffuse, opacity);
            vec4 csm_FragColor = vec4(diffuse, opacity);
        #endif
    #endif

    // csm_Emissive, csm_Roughness, csm_Metalness
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL
        vec3 csm_Emissive = emissive;
        float csm_Roughness = roughness;
        float csm_Metalness = metalness;
    #endif

    // csm_AO
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL
        float csm_AO = 0.0;
    #endif

    // csm_Bump
    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL 
        vec3 csm_Bump = vec3(0.0);
    #endif

    float csm_DepthAlpha = 1.0;
#endif
`,defaultVertDefinitions=`
    varying mat4 csm_internal_vModelViewMatrix;
`,defaultVertMain=`
    csm_internal_vModelViewMatrix = modelViewMatrix;
`,defaultFragDefinitions=`
    varying mat4 csm_internal_vModelViewMatrix;
`,defaultFragMain=`
    
`,_defaultAvailabilityM,defaultAvailabilityMap=(_defaultAvailabilityM={},_defineProperty$5(_defaultAvailabilityM,"".concat(keywords.position),"*"),_defineProperty$5(_defaultAvailabilityM,"".concat(keywords.positionRaw),"*"),_defineProperty$5(_defaultAvailabilityM,"".concat(keywords.normal),"*"),_defineProperty$5(_defaultAvailabilityM,"".concat(keywords.pointSize),["PointsMaterial"]),_defineProperty$5(_defaultAvailabilityM,"".concat(keywords.diffuseColor),"*"),_defineProperty$5(_defaultAvailabilityM,"".concat(keywords.fragColor),"*"),_defineProperty$5(_defaultAvailabilityM,"".concat(keywords.emissive),["MeshStandardMaterial","MeshPhysicalMaterial"]),_defineProperty$5(_defaultAvailabilityM,"".concat(keywords.roughness),["MeshStandardMaterial","MeshPhysicalMaterial"]),_defineProperty$5(_defaultAvailabilityM,"".concat(keywords.metalness),["MeshStandardMaterial","MeshPhysicalMaterial"]),_defineProperty$5(_defaultAvailabilityM,"".concat(keywords.ao),["MeshStandardMaterial","MeshPhysicalMaterial","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial"]),_defineProperty$5(_defaultAvailabilityM,"".concat(keywords.bump),["MeshLambertMaterial","MeshMatcapMaterial","MeshNormalMaterial","MeshPhongMaterial","MeshPhysicalMaterial","MeshStandardMaterial","MeshToonMaterial","ShadowMaterial"]),_defineProperty$5(_defaultAvailabilityM,"".concat(keywords.depthAlpha),"*"),_defaultAvailabilityM),_excluded$e=["baseMaterial","fragmentShader","vertexShader","uniforms","patchMap","cacheKey","silent"],replaceAll=function(_,_e,tt){return _.split(_e).join(tt)},escapeRegExpMatch=function(_){return _.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")},isExactMatch=function(_,_e){return new RegExp("\\b".concat(escapeRegExpMatch(_e),"\\b")).test(_)};function isConstructor(et){try{new et}catch(_){if(_.message.indexOf("is not a constructor")>=0)return!1}return!0}function copyObject(et,_){var _e=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1;Object.assign(et,_);var tt=Object.getPrototypeOf(_);Object.entries(Object.getOwnPropertyDescriptors(tt)).filter(function(nt){var rt=typeof nt[1].get=="function",ot=typeof nt[1].set=="function",at=typeof nt[1].value=="function",lt=nt[0]==="constructor";return(rt||ot||at)&&!lt}).forEach(function(nt){if(typeof et[nt[0]]=="function"){_e||console.warn("Function ".concat(nt[0]," already exists on CSM, renaming to base_").concat(nt[0]));var rt="base_".concat(nt[0]);et[rt]=nt[1].value.bind(et);return}Object.defineProperty(et,nt[0],nt[1])})}function isFunctionEmpty(et){var _=et.toString().trim(),_e=_.substring(_.indexOf("{")+1,_.lastIndexOf("}"));return _e.trim().length===0}function stripSpaces(et){return et.replace(/\s/g,"")}function replaceLastOccurrence(et,_,_e){var tt=et.lastIndexOf(_);return tt===-1?et:et.substring(0,tt)+_e+et.substring(tt+_.length)}var CustomShaderMaterial$1=function(et){_inherits(_e,et);var _=_createSuper(_e);function _e(tt){var nt,rt=tt.baseMaterial,ot=tt.fragmentShader,at=tt.vertexShader,lt=tt.uniforms,ut=tt.patchMap,dt=tt.cacheKey,st=tt.silent,it=_objectWithoutProperties$3(tt,_excluded$e);_classCallCheck$1(this,_e);var ct;if(isConstructor(rt)?ct=new rt(it):(ct=rt,Object.assign(ct,it)),ct.type==="RawShaderMaterial")throw new Error("CustomShaderMaterial does not support RawShaderMaterial");nt=_.call(this),copyObject(_assertThisInitialized(nt),ct,st),nt.__csm={patchMap:ut||{},fragmentShader:ot||"",vertexShader:at||"",cacheKey:dt,baseMaterial:rt,instanceID:MathUtils.generateUUID(),type:ct.type,isAlreadyExtended:!isFunctionEmpty(ct.onBeforeCompile),cacheHash:"",silent:st},nt.uniforms=_objectSpread2$2(_objectSpread2$2({},nt.uniforms||{}),lt||{});{var ft=nt.__csm,ht=ft.fragmentShader,mt=ft.vertexShader,pt=nt.uniforms;nt.__csm.cacheHash=nt.getCacheHash(),nt.generateMaterial(ht,mt,pt)}return nt}return _createClass(_e,[{key:"update",value:function(){var nt=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};this.uniforms=nt.uniforms||this.uniforms,Object.assign(this.__csm,nt);var rt=this.__csm,ot=rt.fragmentShader,at=rt.vertexShader,lt=this.uniforms,ut=this.getCacheHash();this.__csm.cacheHash=ut,this.generateMaterial(ot,at,lt)}},{key:"clone",value:function(){var nt={baseMaterial:this.__csm.baseMaterial,fragmentShader:this.__csm.fragmentShader,vertexShader:this.__csm.vertexShader,uniforms:this.uniforms,silent:this.__csm.silent,patchMap:this.__csm.patchMap,cacheKey:this.__csm.cacheKey},rt=new this.constructor(nt);return Object.assign(this,rt),rt}},{key:"getCacheHash",value:function(){var nt=this.__csm,rt=nt.fragmentShader,ot=nt.vertexShader,at=this.uniforms,lt=Object.values(at).reduce(function(dt,st){var it=st.value;return dt+JSON.stringify(it)},""),ut=stripSpaces(rt)+stripSpaces(ot)+lt;return ut.trim().length>0?objectHash(ut):this.customProgramCacheKey()}},{key:"generateMaterial",value:function(nt,rt,ot){var at=this,lt=this.parseShader(nt),ut=this.parseShader(rt);this.uniforms=ot||{},this.customProgramCacheKey=function(){return at.__csm.cacheHash};var dt=function(ct){try{if(lt){var ft=at.patchShader(lt,ct.fragmentShader,!0);ct.fragmentShader=at.getMaterialDefine()+ft}if(ut){var ht=at.patchShader(ut,ct.vertexShader);ct.vertexShader=`#define IS_VERTEX;
`+ht,ct.vertexShader=at.getMaterialDefine()+ct.vertexShader}ct.uniforms=_objectSpread2$2(_objectSpread2$2({},ct.uniforms),at.uniforms),at.uniforms=ct.uniforms}catch(mt){console.error(mt)}};if(this.__csm.isAlreadyExtended){var st=this.onBeforeCompile;this.onBeforeCompile=function(it,ct){st(it,ct),dt(it)}}else this.onBeforeCompile=dt;this.needsUpdate=!0}},{key:"patchShader",value:function(nt,rt,ot){var at=this,lt=rt,ut=_objectSpread2$2(_objectSpread2$2({},this.getPatchMapForMaterial()),this.__csm.patchMap);Object.keys(ut).forEach(function(it){Object.keys(ut[it]).forEach(function(ct){var ft=defaultAvailabilityMap[it],ht=at.__csm.type;if(it==="*"||isExactMatch(nt.main,it))if(!ft||Array.isArray(ft)&&ft.includes(ht)||ft==="*")lt=replaceAll(lt,ct,ut[it][ct]);else throw new Error("CSM: ".concat(it," is not available in ").concat(ht,". Shader cannot compile."))})}),lt=lt.replace("void main() {",`
        #ifndef CSM_IS_HEAD_DEFAULTS_DEFINED
          `.concat(ot?defaultFragDefinitions:defaultVertDefinitions,`
          #define CSM_IS_HEAD_DEFAULTS_DEFINED 1
        #endif

        `).concat(nt.header,`
        
        void main() {
          #ifndef CSM_IS_DEFAULTS_DEFINED
            `).concat(defaultDefinitions,`
            #define CSM_IS_DEFAULTS_DEFINED 1
          #endif
          
          #ifndef CSM_IS_MAIN_DEFAULTS_DEFINED
            `).concat(ot?defaultFragMain:defaultVertMain,`
            #define CSM_IS_MAIN_DEFAULTS_DEFINED 1
          #endif

          // CSM_START
      `));var dt=this.__csm.isAlreadyExtended,st=lt.includes("// CSM_END");return dt&&st?lt=replaceLastOccurrence(lt,"// CSM_END",`
          // CSM_END
          `.concat(nt.main,`
          // CSM_END
        `)):lt=lt.replace("// CSM_START",`
        // CSM_START
        `.concat(nt.main,`
        // CSM_END
          `)),lt=nt.defines+lt,lt}},{key:"parseShader",value:function(nt){if(nt){var rt=nt.replace(/\/\*\*(.*?)\*\/|\/\/(.*?)\n/gm,""),ot=tokenize$2(rt),at=tokenFunctions(ot),lt=at.map(function(st){return st.name}).indexOf("main"),ut=stringify(ot.slice(0,lt>=0?at[lt].outer[0]:void 0)),dt=lt>=0?this.getShaderFromIndex(ot,at[lt].body):"";return{defines:"",header:ut,main:dt}}}},{key:"getMaterialDefine",value:function(){var nt=this.__csm.type;return nt?"#define IS_".concat(nt.toUpperCase(),`;
`):`#define IS_UNKNOWN;
`}},{key:"getPatchMapForMaterial",value:function(){switch(this.__csm.type){case"ShaderMaterial":return shaderMaterial_PatchMap;default:return defaultPatchMap}}},{key:"getShaderFromIndex",value:function(nt,rt){return stringify(nt.slice(rt[0],rt[1]))}}]),_e}(Material);function _extends$2(){return _extends$2=Object.assign?Object.assign.bind():function(et){for(var _=1;_<arguments.length;_++){var _e=arguments[_];for(var tt in _e)Object.prototype.hasOwnProperty.call(_e,tt)&&(et[tt]=_e[tt])}return et},_extends$2.apply(this,arguments)}var _excluded$d=["baseMaterial","fragmentShader","vertexShader","uniforms","cacheKey","attach"],CustomShaderMaterial=reactExports.forwardRef(function(et,_){var _e=et.baseMaterial,tt=et.fragmentShader,nt=et.vertexShader,rt=et.uniforms,ot=et.cacheKey,at=et.attach,lt=at===void 0?"material":at,ut=_objectWithoutProperties$3(et,_excluded$d),dt=reactExports.useMemo(function(){return{fragmentShader:tt,vertexShader:nt,uniforms:rt,cacheKey:ot}},[tt,nt,rt,ot]),st=reactExports.useMemo(function(){return new CustomShaderMaterial$1(_objectSpread2$2(_objectSpread2$2({baseMaterial:_e},dt),ut))},[_e,dt]);return reactExports.useEffect(function(){return function(){return st.dispose()}},[st]),reactExports.createElement("primitive",_extends$2({object:st,ref:_,attach:lt},ut))});function _extends$1(){return _extends$1=Object.assign?Object.assign.bind():function(et){for(var _=1;_<arguments.length;_++){var _e=arguments[_];for(var tt in _e)({}).hasOwnProperty.call(_e,tt)&&(et[tt]=_e[tt])}return et},_extends$1.apply(null,arguments)}function clamp$3(et,_,_e){return Math.max(_,Math.min(et,_e))}const V$2={toVector(et,_){return et===void 0&&(et=_),Array.isArray(et)?et:[et,et]},add(et,_){return[et[0]+_[0],et[1]+_[1]]},sub(et,_){return[et[0]-_[0],et[1]-_[1]]},addTo(et,_){et[0]+=_[0],et[1]+=_[1]},subTo(et,_){et[0]-=_[0],et[1]-=_[1]}};function rubberband(et,_,_e){return _===0||Math.abs(_)===1/0?Math.pow(et,_e*5):et*_*_e/(_+_e*et)}function rubberbandIfOutOfBounds(et,_,_e,tt=.15){return tt===0?clamp$3(et,_,_e):et<_?-rubberband(_-et,_e-_,tt)+_:et>_e?+rubberband(et-_e,_e-_,tt)+_e:et}function computeRubberband(et,[_,_e],[tt,nt]){const[[rt,ot],[at,lt]]=et;return[rubberbandIfOutOfBounds(_,rt,ot,tt),rubberbandIfOutOfBounds(_e,at,lt,nt)]}function _toPrimitive(et,_){if(typeof et!="object"||et===null)return et;var _e=et[Symbol.toPrimitive];if(_e!==void 0){var tt=_e.call(et,_||"default");if(typeof tt!="object")return tt;throw new TypeError("@@toPrimitive must return a primitive value.")}return(_==="string"?String:Number)(et)}function _toPropertyKey(et){var _=_toPrimitive(et,"string");return typeof _=="symbol"?_:String(_)}function _defineProperty$4(et,_,_e){return _=_toPropertyKey(_),_ in et?Object.defineProperty(et,_,{value:_e,enumerable:!0,configurable:!0,writable:!0}):et[_]=_e,et}function ownKeys$3(et,_){var _e=Object.keys(et);if(Object.getOwnPropertySymbols){var tt=Object.getOwnPropertySymbols(et);_&&(tt=tt.filter(function(nt){return Object.getOwnPropertyDescriptor(et,nt).enumerable})),_e.push.apply(_e,tt)}return _e}function _objectSpread2$1(et){for(var _=1;_<arguments.length;_++){var _e=arguments[_]!=null?arguments[_]:{};_%2?ownKeys$3(Object(_e),!0).forEach(function(tt){_defineProperty$4(et,tt,_e[tt])}):Object.getOwnPropertyDescriptors?Object.defineProperties(et,Object.getOwnPropertyDescriptors(_e)):ownKeys$3(Object(_e)).forEach(function(tt){Object.defineProperty(et,tt,Object.getOwnPropertyDescriptor(_e,tt))})}return et}const EVENT_TYPE_MAP={pointer:{start:"down",change:"move",end:"up"},mouse:{start:"down",change:"move",end:"up"},touch:{start:"start",change:"move",end:"end"},gesture:{start:"start",change:"change",end:"end"}};function capitalize(et){return et?et[0].toUpperCase()+et.slice(1):""}const actionsWithoutCaptureSupported=["enter","leave"];function hasCapture(et=!1,_){return et&&!actionsWithoutCaptureSupported.includes(_)}function toHandlerProp(et,_="",_e=!1){const tt=EVENT_TYPE_MAP[et],nt=tt&&tt[_]||_;return"on"+capitalize(et)+capitalize(nt)+(hasCapture(_e,nt)?"Capture":"")}const pointerCaptureEvents=["gotpointercapture","lostpointercapture"];function parseProp(et){let _=et.substring(2).toLowerCase();const _e=!!~_.indexOf("passive");_e&&(_=_.replace("passive",""));const tt=pointerCaptureEvents.includes(_)?"capturecapture":"capture",nt=!!~_.indexOf(tt);return nt&&(_=_.replace("capture","")),{device:_,capture:nt,passive:_e}}function toDomEventType(et,_=""){const _e=EVENT_TYPE_MAP[et],tt=_e&&_e[_]||_;return et+tt}function isTouch(et){return"touches"in et}function getPointerType(et){return isTouch(et)?"touch":"pointerType"in et?et.pointerType:"mouse"}function getCurrentTargetTouchList(et){return Array.from(et.touches).filter(_=>{var _e,tt;return _.target===et.currentTarget||((_e=et.currentTarget)===null||_e===void 0||(tt=_e.contains)===null||tt===void 0?void 0:tt.call(_e,_.target))})}function getTouchList(et){return et.type==="touchend"||et.type==="touchcancel"?et.changedTouches:et.targetTouches}function getValueEvent(et){return isTouch(et)?getTouchList(et)[0]:et}function touchIds(et){return getCurrentTargetTouchList(et).map(_=>_.identifier)}function pointerId(et){const _=getValueEvent(et);return isTouch(et)?_.identifier:_.pointerId}function pointerValues(et){const _=getValueEvent(et);return[_.clientX,_.clientY]}function getEventDetails(et){const _={};if("buttons"in et&&(_.buttons=et.buttons),"shiftKey"in et){const{shiftKey:_e,altKey:tt,metaKey:nt,ctrlKey:rt}=et;Object.assign(_,{shiftKey:_e,altKey:tt,metaKey:nt,ctrlKey:rt})}return _}function call(et,..._){return typeof et=="function"?et(..._):et}function noop$2(){}function chain(...et){return et.length===0?noop$2:et.length===1?et[0]:function(){let _;for(const _e of et)_=_e.apply(this,arguments)||_;return _}}function assignDefault(et,_){return Object.assign({},_,et||{})}const BEFORE_LAST_KINEMATICS_DELAY=32;class Engine{constructor(_,_e,tt){this.ctrl=_,this.args=_e,this.key=tt,this.state||(this.state={},this.computeValues([0,0]),this.computeInitial(),this.init&&this.init(),this.reset())}get state(){return this.ctrl.state[this.key]}set state(_){this.ctrl.state[this.key]=_}get shared(){return this.ctrl.state.shared}get eventStore(){return this.ctrl.gestureEventStores[this.key]}get timeoutStore(){return this.ctrl.gestureTimeoutStores[this.key]}get config(){return this.ctrl.config[this.key]}get sharedConfig(){return this.ctrl.config.shared}get handler(){return this.ctrl.handlers[this.key]}reset(){const{state:_,shared:_e,ingKey:tt,args:nt}=this;_e[tt]=_._active=_.active=_._blocked=_._force=!1,_._step=[!1,!1],_.intentional=!1,_._movement=[0,0],_._distance=[0,0],_._direction=[0,0],_._delta=[0,0],_._bounds=[[-1/0,1/0],[-1/0,1/0]],_.args=nt,_.axis=void 0,_.memo=void 0,_.elapsedTime=_.timeDelta=0,_.direction=[0,0],_.distance=[0,0],_.overflow=[0,0],_._movementBound=[!1,!1],_.velocity=[0,0],_.movement=[0,0],_.delta=[0,0],_.timeStamp=0}start(_){const _e=this.state,tt=this.config;_e._active||(this.reset(),this.computeInitial(),_e._active=!0,_e.target=_.target,_e.currentTarget=_.currentTarget,_e.lastOffset=tt.from?call(tt.from,_e):_e.offset,_e.offset=_e.lastOffset,_e.startTime=_e.timeStamp=_.timeStamp)}computeValues(_){const _e=this.state;_e._values=_,_e.values=this.config.transform(_)}computeInitial(){const _=this.state;_._initial=_._values,_.initial=_.values}compute(_){const{state:_e,config:tt,shared:nt}=this;_e.args=this.args;let rt=0;if(_&&(_e.event=_,tt.preventDefault&&_.cancelable&&_e.event.preventDefault(),_e.type=_.type,nt.touches=this.ctrl.pointerIds.size||this.ctrl.touchIds.size,nt.locked=!!document.pointerLockElement,Object.assign(nt,getEventDetails(_)),nt.down=nt.pressed=nt.buttons%2===1||nt.touches>0,rt=_.timeStamp-_e.timeStamp,_e.timeStamp=_.timeStamp,_e.elapsedTime=_e.timeStamp-_e.startTime),_e._active){const xt=_e._delta.map(Math.abs);V$2.addTo(_e._distance,xt)}this.axisIntent&&this.axisIntent(_);const[ot,at]=_e._movement,[lt,ut]=tt.threshold,{_step:dt,values:st}=_e;if(tt.hasCustomTransform?(dt[0]===!1&&(dt[0]=Math.abs(ot)>=lt&&st[0]),dt[1]===!1&&(dt[1]=Math.abs(at)>=ut&&st[1])):(dt[0]===!1&&(dt[0]=Math.abs(ot)>=lt&&Math.sign(ot)*lt),dt[1]===!1&&(dt[1]=Math.abs(at)>=ut&&Math.sign(at)*ut)),_e.intentional=dt[0]!==!1||dt[1]!==!1,!_e.intentional)return;const it=[0,0];if(tt.hasCustomTransform){const[xt,Mt]=st;it[0]=dt[0]!==!1?xt-dt[0]:0,it[1]=dt[1]!==!1?Mt-dt[1]:0}else it[0]=dt[0]!==!1?ot-dt[0]:0,it[1]=dt[1]!==!1?at-dt[1]:0;this.restrictToAxis&&!_e._blocked&&this.restrictToAxis(it);const ct=_e.offset,ft=_e._active&&!_e._blocked||_e.active;ft&&(_e.first=_e._active&&!_e.active,_e.last=!_e._active&&_e.active,_e.active=nt[this.ingKey]=_e._active,_&&(_e.first&&("bounds"in tt&&(_e._bounds=call(tt.bounds,_e)),this.setup&&this.setup()),_e.movement=it,this.computeOffset()));const[ht,mt]=_e.offset,[[pt,_t],[vt,bt]]=_e._bounds;_e.overflow=[ht<pt?-1:ht>_t?1:0,mt<vt?-1:mt>bt?1:0],_e._movementBound[0]=_e.overflow[0]?_e._movementBound[0]===!1?_e._movement[0]:_e._movementBound[0]:!1,_e._movementBound[1]=_e.overflow[1]?_e._movementBound[1]===!1?_e._movement[1]:_e._movementBound[1]:!1;const wt=_e._active?tt.rubberband||[0,0]:[0,0];if(_e.offset=computeRubberband(_e._bounds,_e.offset,wt),_e.delta=V$2.sub(_e.offset,ct),this.computeMovement(),ft&&(!_e.last||rt>BEFORE_LAST_KINEMATICS_DELAY)){_e.delta=V$2.sub(_e.offset,ct);const xt=_e.delta.map(Math.abs);V$2.addTo(_e.distance,xt),_e.direction=_e.delta.map(Math.sign),_e._direction=_e._delta.map(Math.sign),!_e.first&&rt>0&&(_e.velocity=[xt[0]/rt,xt[1]/rt],_e.timeDelta=rt)}}emit(){const _=this.state,_e=this.shared,tt=this.config;if(_._active||this.clean(),(_._blocked||!_.intentional)&&!_._force&&!tt.triggerAllEvents)return;const nt=this.handler(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({},_e),_),{},{[this.aliasKey]:_.values}));nt!==void 0&&(_.memo=nt)}clean(){this.eventStore.clean(),this.timeoutStore.clean()}}function selectAxis([et,_],_e){const tt=Math.abs(et),nt=Math.abs(_);if(tt>nt&&tt>_e)return"x";if(nt>tt&&nt>_e)return"y"}class CoordinatesEngine extends Engine{constructor(..._){super(..._),_defineProperty$4(this,"aliasKey","xy")}reset(){super.reset(),this.state.axis=void 0}init(){this.state.offset=[0,0],this.state.lastOffset=[0,0]}computeOffset(){this.state.offset=V$2.add(this.state.lastOffset,this.state.movement)}computeMovement(){this.state.movement=V$2.sub(this.state.offset,this.state.lastOffset)}axisIntent(_){const _e=this.state,tt=this.config;if(!_e.axis&&_){const nt=typeof tt.axisThreshold=="object"?tt.axisThreshold[getPointerType(_)]:tt.axisThreshold;_e.axis=selectAxis(_e._movement,nt)}_e._blocked=(tt.lockDirection||!!tt.axis)&&!_e.axis||!!tt.axis&&tt.axis!==_e.axis}restrictToAxis(_){if(this.config.axis||this.config.lockDirection)switch(this.state.axis){case"x":_[1]=0;break;case"y":_[0]=0;break}}}const identity=et=>et,DEFAULT_RUBBERBAND=.15,commonConfigResolver={enabled(et=!0){return et},eventOptions(et,_,_e){return _objectSpread2$1(_objectSpread2$1({},_e.shared.eventOptions),et)},preventDefault(et=!1){return et},triggerAllEvents(et=!1){return et},rubberband(et=0){switch(et){case!0:return[DEFAULT_RUBBERBAND,DEFAULT_RUBBERBAND];case!1:return[0,0];default:return V$2.toVector(et)}},from(et){if(typeof et=="function")return et;if(et!=null)return V$2.toVector(et)},transform(et,_,_e){const tt=et||_e.shared.transform;return this.hasCustomTransform=!!tt,tt||identity},threshold(et){return V$2.toVector(et,0)}},DEFAULT_AXIS_THRESHOLD=0,coordinatesConfigResolver=_objectSpread2$1(_objectSpread2$1({},commonConfigResolver),{},{axis(et,_,{axis:_e}){if(this.lockDirection=_e==="lock",!this.lockDirection)return _e},axisThreshold(et=DEFAULT_AXIS_THRESHOLD){return et},bounds(et={}){if(typeof et=="function")return rt=>coordinatesConfigResolver.bounds(et(rt));if("current"in et)return()=>et.current;if(typeof HTMLElement=="function"&&et instanceof HTMLElement)return et;const{left:_=-1/0,right:_e=1/0,top:tt=-1/0,bottom:nt=1/0}=et;return[[_,_e],[tt,nt]]}}),KEYS_DELTA_MAP={ArrowRight:(et,_=1)=>[et*_,0],ArrowLeft:(et,_=1)=>[-1*et*_,0],ArrowUp:(et,_=1)=>[0,-1*et*_],ArrowDown:(et,_=1)=>[0,et*_]};class DragEngine extends CoordinatesEngine{constructor(..._){super(..._),_defineProperty$4(this,"ingKey","dragging")}reset(){super.reset();const _=this.state;_._pointerId=void 0,_._pointerActive=!1,_._keyboardActive=!1,_._preventScroll=!1,_._delayed=!1,_.swipe=[0,0],_.tap=!1,_.canceled=!1,_.cancel=this.cancel.bind(this)}setup(){const _=this.state;if(_._bounds instanceof HTMLElement){const _e=_._bounds.getBoundingClientRect(),tt=_.currentTarget.getBoundingClientRect(),nt={left:_e.left-tt.left+_.offset[0],right:_e.right-tt.right+_.offset[0],top:_e.top-tt.top+_.offset[1],bottom:_e.bottom-tt.bottom+_.offset[1]};_._bounds=coordinatesConfigResolver.bounds(nt)}}cancel(){const _=this.state;_.canceled||(_.canceled=!0,_._active=!1,setTimeout(()=>{this.compute(),this.emit()},0))}setActive(){this.state._active=this.state._pointerActive||this.state._keyboardActive}clean(){this.pointerClean(),this.state._pointerActive=!1,this.state._keyboardActive=!1,super.clean()}pointerDown(_){const _e=this.config,tt=this.state;if(_.buttons!=null&&(Array.isArray(_e.pointerButtons)?!_e.pointerButtons.includes(_.buttons):_e.pointerButtons!==-1&&_e.pointerButtons!==_.buttons))return;const nt=this.ctrl.setEventIds(_);_e.pointerCapture&&_.target.setPointerCapture(_.pointerId),!(nt&&nt.size>1&&tt._pointerActive)&&(this.start(_),this.setupPointer(_),tt._pointerId=pointerId(_),tt._pointerActive=!0,this.computeValues(pointerValues(_)),this.computeInitial(),_e.preventScrollAxis&&getPointerType(_)!=="mouse"?(tt._active=!1,this.setupScrollPrevention(_)):_e.delay>0?(this.setupDelayTrigger(_),_e.triggerAllEvents&&(this.compute(_),this.emit())):this.startPointerDrag(_))}startPointerDrag(_){const _e=this.state;_e._active=!0,_e._preventScroll=!0,_e._delayed=!1,this.compute(_),this.emit()}pointerMove(_){const _e=this.state,tt=this.config;if(!_e._pointerActive)return;const nt=pointerId(_);if(_e._pointerId!==void 0&&nt!==_e._pointerId)return;const rt=pointerValues(_);if(document.pointerLockElement===_.target?_e._delta=[_.movementX,_.movementY]:(_e._delta=V$2.sub(rt,_e._values),this.computeValues(rt)),V$2.addTo(_e._movement,_e._delta),this.compute(_),_e._delayed&&_e.intentional){this.timeoutStore.remove("dragDelay"),_e.active=!1,this.startPointerDrag(_);return}if(tt.preventScrollAxis&&!_e._preventScroll)if(_e.axis)if(_e.axis===tt.preventScrollAxis||tt.preventScrollAxis==="xy"){_e._active=!1,this.clean();return}else{this.timeoutStore.remove("startPointerDrag"),this.startPointerDrag(_);return}else return;this.emit()}pointerUp(_){this.ctrl.setEventIds(_);try{this.config.pointerCapture&&_.target.hasPointerCapture(_.pointerId)&&_.target.releasePointerCapture(_.pointerId)}catch{}const _e=this.state,tt=this.config;if(!_e._active||!_e._pointerActive)return;const nt=pointerId(_);if(_e._pointerId!==void 0&&nt!==_e._pointerId)return;this.state._pointerActive=!1,this.setActive(),this.compute(_);const[rt,ot]=_e._distance;if(_e.tap=rt<=tt.tapsThreshold&&ot<=tt.tapsThreshold,_e.tap&&tt.filterTaps)_e._force=!0;else{const[at,lt]=_e._delta,[ut,dt]=_e._movement,[st,it]=tt.swipe.velocity,[ct,ft]=tt.swipe.distance,ht=tt.swipe.duration;if(_e.elapsedTime<ht){const mt=Math.abs(at/_e.timeDelta),pt=Math.abs(lt/_e.timeDelta);mt>st&&Math.abs(ut)>ct&&(_e.swipe[0]=Math.sign(at)),pt>it&&Math.abs(dt)>ft&&(_e.swipe[1]=Math.sign(lt))}}this.emit()}pointerClick(_){!this.state.tap&&_.detail>0&&(_.preventDefault(),_.stopPropagation())}setupPointer(_){const _e=this.config,tt=_e.device;_e.pointerLock&&_.currentTarget.requestPointerLock(),_e.pointerCapture||(this.eventStore.add(this.sharedConfig.window,tt,"change",this.pointerMove.bind(this)),this.eventStore.add(this.sharedConfig.window,tt,"end",this.pointerUp.bind(this)),this.eventStore.add(this.sharedConfig.window,tt,"cancel",this.pointerUp.bind(this)))}pointerClean(){this.config.pointerLock&&document.pointerLockElement===this.state.currentTarget&&document.exitPointerLock()}preventScroll(_){this.state._preventScroll&&_.cancelable&&_.preventDefault()}setupScrollPrevention(_){this.state._preventScroll=!1,persistEvent(_);const _e=this.eventStore.add(this.sharedConfig.window,"touch","change",this.preventScroll.bind(this),{passive:!1});this.eventStore.add(this.sharedConfig.window,"touch","end",_e),this.eventStore.add(this.sharedConfig.window,"touch","cancel",_e),this.timeoutStore.add("startPointerDrag",this.startPointerDrag.bind(this),this.config.preventScrollDelay,_)}setupDelayTrigger(_){this.state._delayed=!0,this.timeoutStore.add("dragDelay",()=>{this.state._step=[0,0],this.startPointerDrag(_)},this.config.delay)}keyDown(_){const _e=KEYS_DELTA_MAP[_.key];if(_e){const tt=this.state,nt=_.shiftKey?10:_.altKey?.1:1;this.start(_),tt._delta=_e(this.config.keyboardDisplacement,nt),tt._keyboardActive=!0,V$2.addTo(tt._movement,tt._delta),this.compute(_),this.emit()}}keyUp(_){_.key in KEYS_DELTA_MAP&&(this.state._keyboardActive=!1,this.setActive(),this.compute(_),this.emit())}bind(_){const _e=this.config.device;_(_e,"start",this.pointerDown.bind(this)),this.config.pointerCapture&&(_(_e,"change",this.pointerMove.bind(this)),_(_e,"end",this.pointerUp.bind(this)),_(_e,"cancel",this.pointerUp.bind(this)),_("lostPointerCapture","",this.pointerUp.bind(this))),this.config.keys&&(_("key","down",this.keyDown.bind(this)),_("key","up",this.keyUp.bind(this))),this.config.filterTaps&&_("click","",this.pointerClick.bind(this),{capture:!0,passive:!1})}}function persistEvent(et){"persist"in et&&typeof et.persist=="function"&&et.persist()}const isBrowser=typeof window<"u"&&window.document&&window.document.createElement;function supportsTouchEvents(){return isBrowser&&"ontouchstart"in window}function isTouchScreen(){return supportsTouchEvents()||isBrowser&&window.navigator.maxTouchPoints>1}function supportsPointerEvents(){return isBrowser&&"onpointerdown"in window}function supportsPointerLock(){return isBrowser&&"exitPointerLock"in window.document}function supportsGestureEvents(){try{return"constructor"in GestureEvent}catch{return!1}}const SUPPORT={isBrowser,gesture:supportsGestureEvents(),touch:supportsTouchEvents(),touchscreen:isTouchScreen(),pointer:supportsPointerEvents(),pointerLock:supportsPointerLock()},DEFAULT_PREVENT_SCROLL_DELAY=250,DEFAULT_DRAG_DELAY=180,DEFAULT_SWIPE_VELOCITY=.5,DEFAULT_SWIPE_DISTANCE=50,DEFAULT_SWIPE_DURATION=250,DEFAULT_KEYBOARD_DISPLACEMENT=10,DEFAULT_DRAG_AXIS_THRESHOLD={mouse:0,touch:0,pen:8},dragConfigResolver=_objectSpread2$1(_objectSpread2$1({},coordinatesConfigResolver),{},{device(et,_,{pointer:{touch:_e=!1,lock:tt=!1,mouse:nt=!1}={}}){return this.pointerLock=tt&&SUPPORT.pointerLock,SUPPORT.touch&&_e?"touch":this.pointerLock?"mouse":SUPPORT.pointer&&!nt?"pointer":SUPPORT.touch?"touch":"mouse"},preventScrollAxis(et,_,{preventScroll:_e}){if(this.preventScrollDelay=typeof _e=="number"?_e:_e||_e===void 0&&et?DEFAULT_PREVENT_SCROLL_DELAY:void 0,!(!SUPPORT.touchscreen||_e===!1))return et||(_e!==void 0?"y":void 0)},pointerCapture(et,_,{pointer:{capture:_e=!0,buttons:tt=1,keys:nt=!0}={}}){return this.pointerButtons=tt,this.keys=nt,!this.pointerLock&&this.device==="pointer"&&_e},threshold(et,_,{filterTaps:_e=!1,tapsThreshold:tt=3,axis:nt=void 0}){const rt=V$2.toVector(et,_e?tt:nt?1:0);return this.filterTaps=_e,this.tapsThreshold=tt,rt},swipe({velocity:et=DEFAULT_SWIPE_VELOCITY,distance:_=DEFAULT_SWIPE_DISTANCE,duration:_e=DEFAULT_SWIPE_DURATION}={}){return{velocity:this.transform(V$2.toVector(et)),distance:this.transform(V$2.toVector(_)),duration:_e}},delay(et=0){switch(et){case!0:return DEFAULT_DRAG_DELAY;case!1:return 0;default:return et}},axisThreshold(et){return et?_objectSpread2$1(_objectSpread2$1({},DEFAULT_DRAG_AXIS_THRESHOLD),et):DEFAULT_DRAG_AXIS_THRESHOLD},keyboardDisplacement(et=DEFAULT_KEYBOARD_DISPLACEMENT){return et}});_objectSpread2$1(_objectSpread2$1({},commonConfigResolver),{},{device(et,_,{shared:_e,pointer:{touch:tt=!1}={}}){if(_e.target&&!SUPPORT.touch&&SUPPORT.gesture)return"gesture";if(SUPPORT.touch&&tt)return"touch";if(SUPPORT.touchscreen){if(SUPPORT.pointer)return"pointer";if(SUPPORT.touch)return"touch"}},bounds(et,_,{scaleBounds:_e={},angleBounds:tt={}}){const nt=ot=>{const at=assignDefault(call(_e,ot),{min:-1/0,max:1/0});return[at.min,at.max]},rt=ot=>{const at=assignDefault(call(tt,ot),{min:-1/0,max:1/0});return[at.min,at.max]};return typeof _e!="function"&&typeof tt!="function"?[nt(),rt()]:ot=>[nt(ot),rt(ot)]},threshold(et,_,_e){return this.lockDirection=_e.axis==="lock",V$2.toVector(et,this.lockDirection?[.1,3]:0)},modifierKey(et){return et===void 0?"ctrlKey":et},pinchOnWheel(et=!0){return et}});_objectSpread2$1(_objectSpread2$1({},coordinatesConfigResolver),{},{mouseOnly:(et=!0)=>et});_objectSpread2$1(_objectSpread2$1({},coordinatesConfigResolver),{},{mouseOnly:(et=!0)=>et});const EngineMap=new Map,ConfigResolverMap=new Map;function registerAction(et){EngineMap.set(et.key,et.engine),ConfigResolverMap.set(et.key,et.resolver)}const dragAction={key:"drag",engine:DragEngine,resolver:dragConfigResolver};function _objectWithoutPropertiesLoose$2(et,_){if(et==null)return{};var _e={},tt=Object.keys(et),nt,rt;for(rt=0;rt<tt.length;rt++)nt=tt[rt],!(_.indexOf(nt)>=0)&&(_e[nt]=et[nt]);return _e}function _objectWithoutProperties$2(et,_){if(et==null)return{};var _e=_objectWithoutPropertiesLoose$2(et,_),tt,nt;if(Object.getOwnPropertySymbols){var rt=Object.getOwnPropertySymbols(et);for(nt=0;nt<rt.length;nt++)tt=rt[nt],!(_.indexOf(tt)>=0)&&Object.prototype.propertyIsEnumerable.call(et,tt)&&(_e[tt]=et[tt])}return _e}const sharedConfigResolver={target(et){if(et)return()=>"current"in et?et.current:et},enabled(et=!0){return et},window(et=SUPPORT.isBrowser?window:void 0){return et},eventOptions({passive:et=!0,capture:_=!1}={}){return{passive:et,capture:_}},transform(et){return et}},_excluded$c=["target","eventOptions","window","enabled","transform"];function resolveWith(et={},_){const _e={};for(const[tt,nt]of Object.entries(_))switch(typeof nt){case"function":_e[tt]=nt.call(_e,et[tt],tt,et);break;case"object":_e[tt]=resolveWith(et[tt],nt);break;case"boolean":nt&&(_e[tt]=et[tt]);break}return _e}function parse$2(et,_,_e={}){const tt=et,{target:nt,eventOptions:rt,window:ot,enabled:at,transform:lt}=tt,ut=_objectWithoutProperties$2(tt,_excluded$c);if(_e.shared=resolveWith({target:nt,eventOptions:rt,window:ot,enabled:at,transform:lt},sharedConfigResolver),_){const dt=ConfigResolverMap.get(_);_e[_]=resolveWith(_objectSpread2$1({shared:_e.shared},ut),dt)}else for(const dt in ut){const st=ConfigResolverMap.get(dt);st&&(_e[dt]=resolveWith(_objectSpread2$1({shared:_e.shared},ut[dt]),st))}return _e}class EventStore{constructor(_,_e){_defineProperty$4(this,"_listeners",new Set),this._ctrl=_,this._gestureKey=_e}add(_,_e,tt,nt,rt){const ot=this._listeners,at=toDomEventType(_e,tt),lt=this._gestureKey?this._ctrl.config[this._gestureKey].eventOptions:{},ut=_objectSpread2$1(_objectSpread2$1({},lt),rt);_.addEventListener(at,nt,ut);const dt=()=>{_.removeEventListener(at,nt,ut),ot.delete(dt)};return ot.add(dt),dt}clean(){this._listeners.forEach(_=>_()),this._listeners.clear()}}class TimeoutStore{constructor(){_defineProperty$4(this,"_timeouts",new Map)}add(_,_e,tt=140,...nt){this.remove(_),this._timeouts.set(_,window.setTimeout(_e,tt,...nt))}remove(_){const _e=this._timeouts.get(_);_e&&window.clearTimeout(_e)}clean(){this._timeouts.forEach(_=>void window.clearTimeout(_)),this._timeouts.clear()}}class Controller{constructor(_){_defineProperty$4(this,"gestures",new Set),_defineProperty$4(this,"_targetEventStore",new EventStore(this)),_defineProperty$4(this,"gestureEventStores",{}),_defineProperty$4(this,"gestureTimeoutStores",{}),_defineProperty$4(this,"handlers",{}),_defineProperty$4(this,"config",{}),_defineProperty$4(this,"pointerIds",new Set),_defineProperty$4(this,"touchIds",new Set),_defineProperty$4(this,"state",{shared:{shiftKey:!1,metaKey:!1,ctrlKey:!1,altKey:!1}}),resolveGestures(this,_)}setEventIds(_){if(isTouch(_))return this.touchIds=new Set(touchIds(_)),this.touchIds;if("pointerId"in _)return _.type==="pointerup"||_.type==="pointercancel"?this.pointerIds.delete(_.pointerId):_.type==="pointerdown"&&this.pointerIds.add(_.pointerId),this.pointerIds}applyHandlers(_,_e){this.handlers=_,this.nativeHandlers=_e}applyConfig(_,_e){this.config=parse$2(_,_e,this.config)}clean(){this._targetEventStore.clean();for(const _ of this.gestures)this.gestureEventStores[_].clean(),this.gestureTimeoutStores[_].clean()}effect(){return this.config.shared.target&&this.bind(),()=>this._targetEventStore.clean()}bind(..._){const _e=this.config.shared,tt={};let nt;if(!(_e.target&&(nt=_e.target(),!nt))){if(_e.enabled){for(const ot of this.gestures){const at=this.config[ot],lt=bindToProps(tt,at.eventOptions,!!nt);if(at.enabled){const ut=EngineMap.get(ot);new ut(this,_,ot).bind(lt)}}const rt=bindToProps(tt,_e.eventOptions,!!nt);for(const ot in this.nativeHandlers)rt(ot,"",at=>this.nativeHandlers[ot](_objectSpread2$1(_objectSpread2$1({},this.state.shared),{},{event:at,args:_})),void 0,!0)}for(const rt in tt)tt[rt]=chain(...tt[rt]);if(!nt)return tt;for(const rt in tt){const{device:ot,capture:at,passive:lt}=parseProp(rt);this._targetEventStore.add(nt,ot,"",tt[rt],{capture:at,passive:lt})}}}}function setupGesture(et,_){et.gestures.add(_),et.gestureEventStores[_]=new EventStore(et,_),et.gestureTimeoutStores[_]=new TimeoutStore}function resolveGestures(et,_){_.drag&&setupGesture(et,"drag"),_.wheel&&setupGesture(et,"wheel"),_.scroll&&setupGesture(et,"scroll"),_.move&&setupGesture(et,"move"),_.pinch&&setupGesture(et,"pinch"),_.hover&&setupGesture(et,"hover")}const bindToProps=(et,_,_e)=>(tt,nt,rt,ot={},at=!1)=>{var lt,ut;const dt=(lt=ot.capture)!==null&&lt!==void 0?lt:_.capture,st=(ut=ot.passive)!==null&&ut!==void 0?ut:_.passive;let it=at?tt:toHandlerProp(tt,nt,dt);_e&&st&&(it+="Passive"),et[it]=et[it]||[],et[it].push(rt)};function useRecognizers(et,_={},_e,tt){const nt=React.useMemo(()=>new Controller(et),[]);if(nt.applyHandlers(et,tt),nt.applyConfig(_,_e),React.useEffect(nt.effect.bind(nt)),React.useEffect(()=>nt.clean.bind(nt),[]),_.target===void 0)return nt.bind.bind(nt)}function useDrag$1(et,_){return registerAction(dragAction),useRecognizers({drag:et},_||{},"drag")}function _defineProperty$3(et,_,_e){return _ in et?Object.defineProperty(et,_,{value:_e,enumerable:!0,configurable:!0,writable:!0}):et[_]=_e,et}function _arrayLikeToArray$2(et,_){(_==null||_>et.length)&&(_=et.length);for(var _e=0,tt=new Array(_);_e<_;_e++)tt[_e]=et[_e];return tt}function _unsupportedIterableToArray$2(et,_){if(et){if(typeof et=="string")return _arrayLikeToArray$2(et,_);var _e=Object.prototype.toString.call(et).slice(8,-1);if(_e==="Object"&&et.constructor&&(_e=et.constructor.name),_e==="Map"||_e==="Set")return Array.from(et);if(_e==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(_e))return _arrayLikeToArray$2(et,_)}}function _arrayWithoutHoles$1(et){if(Array.isArray(et))return _arrayLikeToArray$2(et)}function _iterableToArray$1(et){if(typeof Symbol<"u"&&et[Symbol.iterator]!=null||et["@@iterator"]!=null)return Array.from(et)}function _nonIterableSpread$1(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function _toConsumableArray$1(et){return _arrayWithoutHoles$1(et)||_iterableToArray$1(et)||_unsupportedIterableToArray$2(et)||_nonIterableSpread$1()}new Vector2;new Vector2;function clamp$2(et,_,_e){return Math.max(_,Math.min(_e,et))}function repeat(et,_){return clamp$2(et-Math.floor(et/_)*_,0,_)}function deltaAngle(et,_){var _e=repeat(_-et,Math.PI*2);return _e>Math.PI&&(_e-=Math.PI*2),_e}function _classCallCheck(et,_){if(!(et instanceof _))throw new TypeError("Cannot call a class as a function")}var Grad=function et(_,_e,tt){var nt=this;_classCallCheck(this,et),_defineProperty$3(this,"dot2",function(rt,ot){return nt.x*rt+nt.y*ot}),_defineProperty$3(this,"dot3",function(rt,ot,at){return nt.x*rt+nt.y*ot+nt.z*at}),this.x=_,this.y=_e,this.z=tt},grad3=[new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)],p$3=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180],perm=new Array(512),gradP=new Array(512),seed=function(_){_>0&&_<1&&(_*=65536),_=Math.floor(_),_<256&&(_|=_<<8);for(var _e=0;_e<256;_e++){var tt;_e&1?tt=p$3[_e]^_&255:tt=p$3[_e]^_>>8&255,perm[_e]=perm[_e+256]=tt,gradP[_e]=gradP[_e+256]=grad3[tt%12]}};seed(0);function normalizeSeed(et){if(typeof et=="number")et=Math.abs(et);else if(typeof et=="string"){var _=et;et=0;for(var _e=0;_e<_.length;_e++)et=(et+(_e+1)*(_.charCodeAt(_e)%96))%2147483647}return et===0&&(et=311),et}function lcgRandom(et){var _=normalizeSeed(et);return function(){var _e=_*48271%2147483647;return _=_e,_e/2147483647}}var Generator=function et(_){var _e=this;_classCallCheck(this,et),_defineProperty$3(this,"seed",0),_defineProperty$3(this,"init",function(tt){_e.seed=tt,_e.value=lcgRandom(tt)}),_defineProperty$3(this,"value",lcgRandom(this.seed)),this.init(_)};new Generator(Math.random());var rsqw=function(_){var _e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:.01,tt=arguments.length>2&&arguments[2]!==void 0?arguments[2]:1,nt=arguments.length>3&&arguments[3]!==void 0?arguments[3]:1/(2*Math.PI);return tt/Math.atan(1/_e)*Math.atan(Math.sin(2*Math.PI*_*nt)/_e)},exp$1=function(_){return 1/(1+_+.48*_*_+.235*_*_*_)},linear=function(_){return _},sine={in:function(_){return 1-Math.cos(_*Math.PI/2)},out:function(_){return Math.sin(_*Math.PI/2)},inOut:function(_){return-(Math.cos(Math.PI*_)-1)/2}},cubic={in:function(_){return _*_*_},out:function(_){return 1-Math.pow(1-_,3)},inOut:function(_){return _<.5?4*_*_*_:1-Math.pow(-2*_+2,3)/2}},quint={in:function(_){return _*_*_*_*_},out:function(_){return 1-Math.pow(1-_,5)},inOut:function(_){return _<.5?16*_*_*_*_*_:1-Math.pow(-2*_+2,5)/2}},circ={in:function(_){return 1-Math.sqrt(1-Math.pow(_,2))},out:function(_){return Math.sqrt(1-Math.pow(_-1,2))},inOut:function(_){return _<.5?(1-Math.sqrt(1-Math.pow(2*_,2)))/2:(Math.sqrt(1-Math.pow(-2*_+2,2))+1)/2}},quart={in:function(_){return _*_*_*_},out:function(_){return 1- --_*_*_*_},inOut:function(_){return _<.5?8*_*_*_*_:1-8*--_*_*_*_}},expo={in:function(_){return _===0?0:Math.pow(2,10*_-10)},out:function(_){return _===1?1:1-Math.pow(2,-10*_)},inOut:function(_){return _===0?0:_===1?1:_<.5?Math.pow(2,20*_-10)/2:(2-Math.pow(2,-20*_+10))/2}};function damp(et,_,_e){var tt=arguments.length>3&&arguments[3]!==void 0?arguments[3]:.25,nt=arguments.length>4&&arguments[4]!==void 0?arguments[4]:.01,rt=arguments.length>5&&arguments[5]!==void 0?arguments[5]:1/0,ot=arguments.length>6&&arguments[6]!==void 0?arguments[6]:exp$1,at=arguments.length>7&&arguments[7]!==void 0?arguments[7]:.001,lt="velocity_"+_;if(et.__damp===void 0&&(et.__damp={}),et.__damp[lt]===void 0&&(et.__damp[lt]=0),Math.abs(et[_]-_e)<=at)return et[_]=_e,!1;tt=Math.max(1e-4,tt);var ut=2/tt,dt=ot(ut*nt),st=et[_]-_e,it=_e,ct=rt*tt;st=Math.min(Math.max(st,-ct),ct),_e=et[_]-st;var ft=(et.__damp[lt]+ut*st)*nt;et.__damp[lt]=(et.__damp[lt]-ut*ft)*dt;var ht=_e+(st+ft)*dt;return it-et[_]>0==ht>it&&(ht=it,et.__damp[lt]=(ht-it)/nt),et[_]=ht,!0}var isCamera=function(_){return _&&_.isCamera},isLight=function(_){return _&&_.isLight},vl3d=new Vector3,_q1=new Quaternion,_q2=new Quaternion,_m1=new Matrix4,_position=new Vector3;function dampLookAt(et,_,_e,tt,nt,rt,ot){typeof _=="number"?vl3d.setScalar(_):Array.isArray(_)?vl3d.set(_[0],_[1],_[2]):vl3d.copy(_);var at=et.parent;et.updateWorldMatrix(!0,!1),_position.setFromMatrixPosition(et.matrixWorld),isCamera(et)||isLight(et)?_m1.lookAt(_position,vl3d,et.up):_m1.lookAt(vl3d,_position,et.up),dampQ(et.quaternion,_q2.setFromRotationMatrix(_m1),_e,tt,nt,rt,ot),at&&(_m1.extractRotation(at.matrixWorld),_q1.setFromRotationMatrix(_m1),dampQ(et.quaternion,_q2.copy(et.quaternion).premultiply(_q1.invert()),_e,tt,nt,rt,ot))}function dampAngle(et,_,_e,tt,nt,rt,ot,at){return damp(et,_,et[_]+deltaAngle(et[_],_e),tt,nt,rt,ot,at)}var v2d=new Vector2,a2,b2;function damp2(et,_,_e,tt,nt,rt,ot){return typeof _=="number"?v2d.setScalar(_):Array.isArray(_)?v2d.set(_[0],_[1]):v2d.copy(_),a2=damp(et,"x",v2d.x,_e,tt,nt,rt,ot),b2=damp(et,"y",v2d.y,_e,tt,nt,rt,ot),a2||b2}var v3d=new Vector3,a3,b3,c3;function damp3(et,_,_e,tt,nt,rt,ot){return typeof _=="number"?v3d.setScalar(_):Array.isArray(_)?v3d.set(_[0],_[1],_[2]):v3d.copy(_),a3=damp(et,"x",v3d.x,_e,tt,nt,rt,ot),b3=damp(et,"y",v3d.y,_e,tt,nt,rt,ot),c3=damp(et,"z",v3d.z,_e,tt,nt,rt,ot),a3||b3||c3}var v4d=new Vector4,a4,b4,c4,d4;function damp4(et,_,_e,tt,nt,rt,ot){return typeof _=="number"?v4d.setScalar(_):Array.isArray(_)?v4d.set(_[0],_[1],_[2],_[3]):v4d.copy(_),a4=damp(et,"x",v4d.x,_e,tt,nt,rt,ot),b4=damp(et,"y",v4d.y,_e,tt,nt,rt,ot),c4=damp(et,"z",v4d.z,_e,tt,nt,rt,ot),d4=damp(et,"w",v4d.w,_e,tt,nt,rt,ot),a4||b4||c4||d4}var rot=new Euler,aE,bE,cE;function dampE(et,_,_e,tt,nt,rt,ot){return Array.isArray(_)?rot.set(_[0],_[1],_[2],_[3]):rot.copy(_),aE=dampAngle(et,"x",rot.x,_e,tt,nt,rt,ot),bE=dampAngle(et,"y",rot.y,_e,tt,nt,rt,ot),cE=dampAngle(et,"z",rot.z,_e,tt,nt,rt,ot),aE||bE||cE}var col=new Color$1,aC,bC,cC;function dampC(et,_,_e,tt,nt,rt,ot){return _ instanceof Color$1?col.copy(_):Array.isArray(_)?col.setRGB(_[0],_[1],_[2]):col.set(_),aC=damp(et,"r",col.r,_e,tt,nt,rt,ot),bC=damp(et,"g",col.g,_e,tt,nt,rt,ot),cC=damp(et,"b",col.b,_e,tt,nt,rt,ot),aC||bC||cC}var qt=new Quaternion,v4result=new Vector4,v4velocity=new Vector4,v4error=new Vector4,aQ,bQ,cQ,dQ;function dampQ(et,_,_e,tt,nt,rt,ot){var at=et;Array.isArray(_)?qt.set(_[0],_[1],_[2],_[3]):qt.copy(_);var lt=et.dot(qt)>0?1:-1;return qt.x*=lt,qt.y*=lt,qt.z*=lt,qt.w*=lt,aQ=damp(et,"x",qt.x,_e,tt,nt,rt,ot),bQ=damp(et,"y",qt.y,_e,tt,nt,rt,ot),cQ=damp(et,"z",qt.z,_e,tt,nt,rt,ot),dQ=damp(et,"w",qt.w,_e,tt,nt,rt,ot),v4result.set(et.x,et.y,et.z,et.w).normalize(),v4velocity.set(at.__damp.velocity_x,at.__damp.velocity_y,at.__damp.velocity_z,at.__damp.velocity_w),v4error.copy(v4result).multiplyScalar(v4velocity.dot(v4result)/v4result.dot(v4result)),at.__damp.velocity_x-=v4error.x,at.__damp.velocity_y-=v4error.y,at.__damp.velocity_z-=v4error.z,at.__damp.velocity_w-=v4error.w,et.set(v4result.x,v4result.y,v4result.z,v4result.w),aQ||bQ||cQ||dQ}var spherical=new Spherical,aS,bS,cS;function dampS(et,_,_e,tt,nt,rt,ot){return Array.isArray(_)?spherical.set(_[0],_[1],_[2]):spherical.copy(_),aS=damp(et,"radius",spherical.radius,_e,tt,nt,rt,ot),bS=dampAngle(et,"phi",spherical.phi,_e,tt,nt,rt,ot),cS=dampAngle(et,"theta",spherical.theta,_e,tt,nt,rt,ot),aS||bS||cS}var mat=new Matrix4,mPos=new Vector3,mRot=new Quaternion,mSca=new Vector3,aM,bM,cM;function dampM(et,_,_e,tt,nt,rt,ot){var at=et;return at.__damp===void 0&&(at.__damp={position:new Vector3,rotation:new Quaternion,scale:new Vector3},et.decompose(at.__damp.position,at.__damp.rotation,at.__damp.scale)),Array.isArray(_)?mat.set.apply(mat,_toConsumableArray$1(_)):mat.copy(_),mat.decompose(mPos,mRot,mSca),aM=damp3(at.__damp.position,mPos,_e,tt,nt,rt,ot),bM=dampQ(at.__damp.rotation,mRot,_e,tt,nt,rt,ot),cM=damp3(at.__damp.scale,mSca,_e,tt,nt,rt,ot),et.compose(at.__damp.position,at.__damp.rotation,at.__damp.scale),aM||bM||cM}var easing=Object.freeze({__proto__:null,rsqw,exp:exp$1,linear,sine,cubic,quint,circ,quart,expo,damp,dampLookAt,dampAngle,damp2,damp3,damp4,dampE,dampC,dampQ,dampS,dampM});const subscribeWithSelector=et=>(_,_e,tt)=>{const nt=tt.subscribe;return tt.subscribe=(ot,at,lt)=>{let ut=ot;if(at){const dt=(lt==null?void 0:lt.equalityFn)||Object.is;let st=ot(tt.getState());ut=it=>{const ct=ot(it);if(!dt(st,ct)){const ft=st;at(st=ct,ft)}},lt!=null&&lt.fireImmediately&&at(st,st)}return nt(ut)},et(_,_e,tt)};var __defProp$1=Object.defineProperty,__defNormalProp$1=(et,_,_e)=>_ in et?__defProp$1(et,_,{enumerable:!0,configurable:!0,writable:!0,value:_e}):et[_]=_e,__publicField$1=(et,_,_e)=>(__defNormalProp$1(et,typeof _!="symbol"?_+"":_,_e),_e);const _ray=new Ray,_plane=new Plane,TILT_LIMIT=Math.cos(70*(Math.PI/180)),moduloWrapAround=(et,_)=>(et%_+_)%_;let OrbitControls$1=class extends EventDispatcher{constructor(_,_e){super(),__publicField$1(this,"object"),__publicField$1(this,"domElement"),__publicField$1(this,"enabled",!0),__publicField$1(this,"target",new Vector3),__publicField$1(this,"minDistance",0),__publicField$1(this,"maxDistance",1/0),__publicField$1(this,"minZoom",0),__publicField$1(this,"maxZoom",1/0),__publicField$1(this,"minPolarAngle",0),__publicField$1(this,"maxPolarAngle",Math.PI),__publicField$1(this,"minAzimuthAngle",-1/0),__publicField$1(this,"maxAzimuthAngle",1/0),__publicField$1(this,"enableDamping",!1),__publicField$1(this,"dampingFactor",.05),__publicField$1(this,"enableZoom",!0),__publicField$1(this,"zoomSpeed",1),__publicField$1(this,"enableRotate",!0),__publicField$1(this,"rotateSpeed",1),__publicField$1(this,"enablePan",!0),__publicField$1(this,"panSpeed",1),__publicField$1(this,"screenSpacePanning",!0),__publicField$1(this,"keyPanSpeed",7),__publicField$1(this,"zoomToCursor",!1),__publicField$1(this,"autoRotate",!1),__publicField$1(this,"autoRotateSpeed",2),__publicField$1(this,"reverseOrbit",!1),__publicField$1(this,"reverseHorizontalOrbit",!1),__publicField$1(this,"reverseVerticalOrbit",!1),__publicField$1(this,"keys",{LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"}),__publicField$1(this,"mouseButtons",{LEFT:MOUSE.ROTATE,MIDDLE:MOUSE.DOLLY,RIGHT:MOUSE.PAN}),__publicField$1(this,"touches",{ONE:TOUCH.ROTATE,TWO:TOUCH.DOLLY_PAN}),__publicField$1(this,"target0"),__publicField$1(this,"position0"),__publicField$1(this,"zoom0"),__publicField$1(this,"_domElementKeyEvents",null),__publicField$1(this,"getPolarAngle"),__publicField$1(this,"getAzimuthalAngle"),__publicField$1(this,"setPolarAngle"),__publicField$1(this,"setAzimuthalAngle"),__publicField$1(this,"getDistance"),__publicField$1(this,"listenToKeyEvents"),__publicField$1(this,"stopListenToKeyEvents"),__publicField$1(this,"saveState"),__publicField$1(this,"reset"),__publicField$1(this,"update"),__publicField$1(this,"connect"),__publicField$1(this,"dispose"),this.object=_,this.domElement=_e,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=()=>dt.phi,this.getAzimuthalAngle=()=>dt.theta,this.setPolarAngle=cn=>{let Fn=moduloWrapAround(cn,2*Math.PI),ir=dt.phi;ir<0&&(ir+=2*Math.PI),Fn<0&&(Fn+=2*Math.PI);let ln=Math.abs(Fn-ir);2*Math.PI-ln<ln&&(Fn<ir?Fn+=2*Math.PI:ir+=2*Math.PI),st.phi=Fn-ir,tt.update()},this.setAzimuthalAngle=cn=>{let Fn=moduloWrapAround(cn,2*Math.PI),ir=dt.theta;ir<0&&(ir+=2*Math.PI),Fn<0&&(Fn+=2*Math.PI);let ln=Math.abs(Fn-ir);2*Math.PI-ln<ln&&(Fn<ir?Fn+=2*Math.PI:ir+=2*Math.PI),st.theta=Fn-ir,tt.update()},this.getDistance=()=>tt.object.position.distanceTo(tt.target),this.listenToKeyEvents=cn=>{cn.addEventListener("keydown",Wn),this._domElementKeyEvents=cn},this.stopListenToKeyEvents=()=>{this._domElementKeyEvents.removeEventListener("keydown",Wn),this._domElementKeyEvents=null},this.saveState=()=>{tt.target0.copy(tt.target),tt.position0.copy(tt.object.position),tt.zoom0=tt.object.zoom},this.reset=()=>{tt.target.copy(tt.target0),tt.object.position.copy(tt.position0),tt.object.zoom=tt.zoom0,tt.object.updateProjectionMatrix(),tt.dispatchEvent(nt),tt.update(),lt=at.NONE},this.update=(()=>{const cn=new Vector3,Fn=new Vector3(0,1,0),ir=new Quaternion().setFromUnitVectors(_.up,Fn),ln=ir.clone().invert(),On=new Vector3,Dn=new Quaternion,$n=2*Math.PI;return function(){const qn=tt.object.position;ir.setFromUnitVectors(_.up,Fn),ln.copy(ir).invert(),cn.copy(qn).sub(tt.target),cn.applyQuaternion(ir),dt.setFromVector3(cn),tt.autoRotate&&lt===at.NONE&&Nt(It()),tt.enableDamping?(dt.theta+=st.theta*tt.dampingFactor,dt.phi+=st.phi*tt.dampingFactor):(dt.theta+=st.theta,dt.phi+=st.phi);let Kn=tt.minAzimuthAngle,ar=tt.maxAzimuthAngle;isFinite(Kn)&&isFinite(ar)&&(Kn<-Math.PI?Kn+=$n:Kn>Math.PI&&(Kn-=$n),ar<-Math.PI?ar+=$n:ar>Math.PI&&(ar-=$n),Kn<=ar?dt.theta=Math.max(Kn,Math.min(ar,dt.theta)):dt.theta=dt.theta>(Kn+ar)/2?Math.max(Kn,dt.theta):Math.min(ar,dt.theta)),dt.phi=Math.max(tt.minPolarAngle,Math.min(tt.maxPolarAngle,dt.phi)),dt.makeSafe(),tt.enableDamping===!0?tt.target.addScaledVector(ct,tt.dampingFactor):tt.target.add(ct),tt.zoomToCursor&&St||tt.object.isOrthographicCamera?dt.radius=bn(dt.radius):dt.radius=bn(dt.radius*it),cn.setFromSpherical(dt),cn.applyQuaternion(ln),qn.copy(tt.target).add(cn),tt.object.matrixAutoUpdate||tt.object.updateMatrix(),tt.object.lookAt(tt.target),tt.enableDamping===!0?(st.theta*=1-tt.dampingFactor,st.phi*=1-tt.dampingFactor,ct.multiplyScalar(1-tt.dampingFactor)):(st.set(0,0,0),ct.set(0,0,0));let Ur=!1;if(tt.zoomToCursor&&St){let wr=null;if(tt.object instanceof PerspectiveCamera&&tt.object.isPerspectiveCamera){const Hr=cn.length();wr=bn(Hr*it);const Wr=Hr-wr;tt.object.position.addScaledVector(Mt,Wr),tt.object.updateMatrixWorld()}else if(tt.object.isOrthographicCamera){const Hr=new Vector3(At.x,At.y,0);Hr.unproject(tt.object),tt.object.zoom=Math.max(tt.minZoom,Math.min(tt.maxZoom,tt.object.zoom/it)),tt.object.updateProjectionMatrix(),Ur=!0;const Wr=new Vector3(At.x,At.y,0);Wr.unproject(tt.object),tt.object.position.sub(Wr).add(Hr),tt.object.updateMatrixWorld(),wr=cn.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),tt.zoomToCursor=!1;wr!==null&&(tt.screenSpacePanning?tt.target.set(0,0,-1).transformDirection(tt.object.matrix).multiplyScalar(wr).add(tt.object.position):(_ray.origin.copy(tt.object.position),_ray.direction.set(0,0,-1).transformDirection(tt.object.matrix),Math.abs(tt.object.up.dot(_ray.direction))<TILT_LIMIT?_.lookAt(tt.target):(_plane.setFromNormalAndCoplanarPoint(tt.object.up,tt.target),_ray.intersectPlane(_plane,tt.target))))}else tt.object instanceof OrthographicCamera$1&&tt.object.isOrthographicCamera&&(Ur=it!==1,Ur&&(tt.object.zoom=Math.max(tt.minZoom,Math.min(tt.maxZoom,tt.object.zoom/it)),tt.object.updateProjectionMatrix()));return it=1,St=!1,Ur||On.distanceToSquared(tt.object.position)>ut||8*(1-Dn.dot(tt.object.quaternion))>ut?(tt.dispatchEvent(nt),On.copy(tt.object.position),Dn.copy(tt.object.quaternion),Ur=!1,!0):!1}})(),this.connect=cn=>{cn===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),tt.domElement=cn,tt.domElement.style.touchAction="none",tt.domElement.addEventListener("contextmenu",Gn),tt.domElement.addEventListener("pointerdown",Gt),tt.domElement.addEventListener("pointercancel",hn),tt.domElement.addEventListener("wheel",sr)},this.dispose=()=>{var cn,Fn,ir,ln,On,Dn;tt.domElement&&(tt.domElement.style.touchAction="auto"),(cn=tt.domElement)==null||cn.removeEventListener("contextmenu",Gn),(Fn=tt.domElement)==null||Fn.removeEventListener("pointerdown",Gt),(ir=tt.domElement)==null||ir.removeEventListener("pointercancel",hn),(ln=tt.domElement)==null||ln.removeEventListener("wheel",sr),(On=tt.domElement)==null||On.ownerDocument.removeEventListener("pointermove",fn),(Dn=tt.domElement)==null||Dn.ownerDocument.removeEventListener("pointerup",hn),tt._domElementKeyEvents!==null&&tt._domElementKeyEvents.removeEventListener("keydown",Wn)};const tt=this,nt={type:"change"},rt={type:"start"},ot={type:"end"},at={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let lt=at.NONE;const ut=1e-6,dt=new Spherical,st=new Spherical;let it=1;const ct=new Vector3,ft=new Vector2,ht=new Vector2,mt=new Vector2,pt=new Vector2,_t=new Vector2,vt=new Vector2,bt=new Vector2,wt=new Vector2,xt=new Vector2,Mt=new Vector3,At=new Vector2;let St=!1;const Tt=[],Ct={};function It(){return 2*Math.PI/60/60*tt.autoRotateSpeed}function $t(){return Math.pow(.95,tt.zoomSpeed)}function Nt(cn){tt.reverseOrbit||tt.reverseHorizontalOrbit?st.theta+=cn:st.theta-=cn}function Bt(cn){tt.reverseOrbit||tt.reverseVerticalOrbit?st.phi+=cn:st.phi-=cn}const Ot=(()=>{const cn=new Vector3;return function(ir,ln){cn.setFromMatrixColumn(ln,0),cn.multiplyScalar(-ir),ct.add(cn)}})(),Ut=(()=>{const cn=new Vector3;return function(ir,ln){tt.screenSpacePanning===!0?cn.setFromMatrixColumn(ln,1):(cn.setFromMatrixColumn(ln,0),cn.crossVectors(tt.object.up,cn)),cn.multiplyScalar(ir),ct.add(cn)}})(),Lt=(()=>{const cn=new Vector3;return function(ir,ln){const On=tt.domElement;if(On&&tt.object instanceof PerspectiveCamera&&tt.object.isPerspectiveCamera){const Dn=tt.object.position;cn.copy(Dn).sub(tt.target);let $n=cn.length();$n*=Math.tan(tt.object.fov/2*Math.PI/180),Ot(2*ir*$n/On.clientHeight,tt.object.matrix),Ut(2*ln*$n/On.clientHeight,tt.object.matrix)}else On&&tt.object instanceof OrthographicCamera$1&&tt.object.isOrthographicCamera?(Ot(ir*(tt.object.right-tt.object.left)/tt.object.zoom/On.clientWidth,tt.object.matrix),Ut(ln*(tt.object.top-tt.object.bottom)/tt.object.zoom/On.clientHeight,tt.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),tt.enablePan=!1)}})();function zt(cn){tt.object instanceof PerspectiveCamera&&tt.object.isPerspectiveCamera||tt.object instanceof OrthographicCamera$1&&tt.object.isOrthographicCamera?it/=cn:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),tt.enableZoom=!1)}function Yt(cn){tt.object instanceof PerspectiveCamera&&tt.object.isPerspectiveCamera||tt.object instanceof OrthographicCamera$1&&tt.object.isOrthographicCamera?it*=cn:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),tt.enableZoom=!1)}function en(cn){if(!tt.zoomToCursor||!tt.domElement)return;St=!0;const Fn=tt.domElement.getBoundingClientRect(),ir=cn.clientX-Fn.left,ln=cn.clientY-Fn.top,On=Fn.width,Dn=Fn.height;At.x=ir/On*2-1,At.y=-(ln/Dn)*2+1,Mt.set(At.x,At.y,1).unproject(tt.object).sub(tt.object.position).normalize()}function bn(cn){return Math.max(tt.minDistance,Math.min(tt.maxDistance,cn))}function Un(cn){ft.set(cn.clientX,cn.clientY)}function mn(cn){en(cn),bt.set(cn.clientX,cn.clientY)}function vn(cn){pt.set(cn.clientX,cn.clientY)}function In(cn){ht.set(cn.clientX,cn.clientY),mt.subVectors(ht,ft).multiplyScalar(tt.rotateSpeed);const Fn=tt.domElement;Fn&&(Nt(2*Math.PI*mt.x/Fn.clientHeight),Bt(2*Math.PI*mt.y/Fn.clientHeight)),ft.copy(ht),tt.update()}function Cn(cn){wt.set(cn.clientX,cn.clientY),xt.subVectors(wt,bt),xt.y>0?zt($t()):xt.y<0&&Yt($t()),bt.copy(wt),tt.update()}function En(cn){_t.set(cn.clientX,cn.clientY),vt.subVectors(_t,pt).multiplyScalar(tt.panSpeed),Lt(vt.x,vt.y),pt.copy(_t),tt.update()}function jt(cn){en(cn),cn.deltaY<0?Yt($t()):cn.deltaY>0&&zt($t()),tt.update()}function Kt(cn){let Fn=!1;switch(cn.code){case tt.keys.UP:Lt(0,tt.keyPanSpeed),Fn=!0;break;case tt.keys.BOTTOM:Lt(0,-tt.keyPanSpeed),Fn=!0;break;case tt.keys.LEFT:Lt(tt.keyPanSpeed,0),Fn=!0;break;case tt.keys.RIGHT:Lt(-tt.keyPanSpeed,0),Fn=!0;break}Fn&&(cn.preventDefault(),tt.update())}function nn(){if(Tt.length==1)ft.set(Tt[0].pageX,Tt[0].pageY);else{const cn=.5*(Tt[0].pageX+Tt[1].pageX),Fn=.5*(Tt[0].pageY+Tt[1].pageY);ft.set(cn,Fn)}}function Vt(){if(Tt.length==1)pt.set(Tt[0].pageX,Tt[0].pageY);else{const cn=.5*(Tt[0].pageX+Tt[1].pageX),Fn=.5*(Tt[0].pageY+Tt[1].pageY);pt.set(cn,Fn)}}function on(){const cn=Tt[0].pageX-Tt[1].pageX,Fn=Tt[0].pageY-Tt[1].pageY,ir=Math.sqrt(cn*cn+Fn*Fn);bt.set(0,ir)}function dn(){tt.enableZoom&&on(),tt.enablePan&&Vt()}function Ln(){tt.enableZoom&&on(),tt.enableRotate&&nn()}function Sn(cn){if(Tt.length==1)ht.set(cn.pageX,cn.pageY);else{const ir=Bn(cn),ln=.5*(cn.pageX+ir.x),On=.5*(cn.pageY+ir.y);ht.set(ln,On)}mt.subVectors(ht,ft).multiplyScalar(tt.rotateSpeed);const Fn=tt.domElement;Fn&&(Nt(2*Math.PI*mt.x/Fn.clientHeight),Bt(2*Math.PI*mt.y/Fn.clientHeight)),ft.copy(ht)}function Xn(cn){if(Tt.length==1)_t.set(cn.pageX,cn.pageY);else{const Fn=Bn(cn),ir=.5*(cn.pageX+Fn.x),ln=.5*(cn.pageY+Fn.y);_t.set(ir,ln)}vt.subVectors(_t,pt).multiplyScalar(tt.panSpeed),Lt(vt.x,vt.y),pt.copy(_t)}function Vn(cn){const Fn=Bn(cn),ir=cn.pageX-Fn.x,ln=cn.pageY-Fn.y,On=Math.sqrt(ir*ir+ln*ln);wt.set(0,On),xt.set(0,Math.pow(wt.y/bt.y,tt.zoomSpeed)),zt(xt.y),bt.copy(wt)}function Hn(cn){tt.enableZoom&&Vn(cn),tt.enablePan&&Xn(cn)}function Zt(cn){tt.enableZoom&&Vn(cn),tt.enableRotate&&Sn(cn)}function Gt(cn){var Fn,ir;tt.enabled!==!1&&(Tt.length===0&&((Fn=tt.domElement)==null||Fn.ownerDocument.addEventListener("pointermove",fn),(ir=tt.domElement)==null||ir.ownerDocument.addEventListener("pointerup",hn)),nr(cn),cn.pointerType==="touch"?or(cn):xn(cn))}function fn(cn){tt.enabled!==!1&&(cn.pointerType==="touch"?fr(cn):Tn(cn))}function hn(cn){var Fn,ir,ln;mr(cn),Tt.length===0&&((Fn=tt.domElement)==null||Fn.releasePointerCapture(cn.pointerId),(ir=tt.domElement)==null||ir.ownerDocument.removeEventListener("pointermove",fn),(ln=tt.domElement)==null||ln.ownerDocument.removeEventListener("pointerup",hn)),tt.dispatchEvent(ot),lt=at.NONE}function xn(cn){let Fn;switch(cn.button){case 0:Fn=tt.mouseButtons.LEFT;break;case 1:Fn=tt.mouseButtons.MIDDLE;break;case 2:Fn=tt.mouseButtons.RIGHT;break;default:Fn=-1}switch(Fn){case MOUSE.DOLLY:if(tt.enableZoom===!1)return;mn(cn),lt=at.DOLLY;break;case MOUSE.ROTATE:if(cn.ctrlKey||cn.metaKey||cn.shiftKey){if(tt.enablePan===!1)return;vn(cn),lt=at.PAN}else{if(tt.enableRotate===!1)return;Un(cn),lt=at.ROTATE}break;case MOUSE.PAN:if(cn.ctrlKey||cn.metaKey||cn.shiftKey){if(tt.enableRotate===!1)return;Un(cn),lt=at.ROTATE}else{if(tt.enablePan===!1)return;vn(cn),lt=at.PAN}break;default:lt=at.NONE}lt!==at.NONE&&tt.dispatchEvent(rt)}function Tn(cn){if(tt.enabled!==!1)switch(lt){case at.ROTATE:if(tt.enableRotate===!1)return;In(cn);break;case at.DOLLY:if(tt.enableZoom===!1)return;Cn(cn);break;case at.PAN:if(tt.enablePan===!1)return;En(cn);break}}function sr(cn){tt.enabled===!1||tt.enableZoom===!1||lt!==at.NONE&&lt!==at.ROTATE||(cn.preventDefault(),tt.dispatchEvent(rt),jt(cn),tt.dispatchEvent(ot))}function Wn(cn){tt.enabled===!1||tt.enablePan===!1||Kt(cn)}function or(cn){switch(hr(cn),Tt.length){case 1:switch(tt.touches.ONE){case TOUCH.ROTATE:if(tt.enableRotate===!1)return;nn(),lt=at.TOUCH_ROTATE;break;case TOUCH.PAN:if(tt.enablePan===!1)return;Vt(),lt=at.TOUCH_PAN;break;default:lt=at.NONE}break;case 2:switch(tt.touches.TWO){case TOUCH.DOLLY_PAN:if(tt.enableZoom===!1&&tt.enablePan===!1)return;dn(),lt=at.TOUCH_DOLLY_PAN;break;case TOUCH.DOLLY_ROTATE:if(tt.enableZoom===!1&&tt.enableRotate===!1)return;Ln(),lt=at.TOUCH_DOLLY_ROTATE;break;default:lt=at.NONE}break;default:lt=at.NONE}lt!==at.NONE&&tt.dispatchEvent(rt)}function fr(cn){switch(hr(cn),lt){case at.TOUCH_ROTATE:if(tt.enableRotate===!1)return;Sn(cn),tt.update();break;case at.TOUCH_PAN:if(tt.enablePan===!1)return;Xn(cn),tt.update();break;case at.TOUCH_DOLLY_PAN:if(tt.enableZoom===!1&&tt.enablePan===!1)return;Hn(cn),tt.update();break;case at.TOUCH_DOLLY_ROTATE:if(tt.enableZoom===!1&&tt.enableRotate===!1)return;Zt(cn),tt.update();break;default:lt=at.NONE}}function Gn(cn){tt.enabled!==!1&&cn.preventDefault()}function nr(cn){Tt.push(cn)}function mr(cn){delete Ct[cn.pointerId];for(let Fn=0;Fn<Tt.length;Fn++)if(Tt[Fn].pointerId==cn.pointerId){Tt.splice(Fn,1);return}}function hr(cn){let Fn=Ct[cn.pointerId];Fn===void 0&&(Fn=new Vector2,Ct[cn.pointerId]=Fn),Fn.set(cn.pageX,cn.pageY)}function Bn(cn){const Fn=cn.pointerId===Tt[0].pointerId?Tt[1]:Tt[0];return Ct[Fn.pointerId]}_e!==void 0&&this.connect(_e),this.update()}};function shallow(et,_){if(Object.is(et,_))return!0;if(typeof et!="object"||et===null||typeof _!="object"||_===null)return!1;const _e=Object.keys(et);if(_e.length!==Object.keys(_).length)return!1;for(let tt=0;tt<_e.length;tt++)if(!Object.prototype.hasOwnProperty.call(_,_e[tt])||!Object.is(et[_e[tt]],_[_e[tt]]))return!1;return!0}function shaderMaterial(et,_,_e,tt){const nt=class extends ShaderMaterial{constructor(ot={}){const at=Object.entries(et);super({uniforms:at.reduce((lt,[ut,dt])=>{const st=UniformsUtils.clone({[ut]:{value:dt}});return{...lt,...st}},{}),vertexShader:_,fragmentShader:_e}),this.key="",at.forEach(([lt])=>Object.defineProperty(this,lt,{get:()=>this.uniforms[lt].value,set:ut=>this.uniforms[lt].value=ut})),Object.assign(this,ot)}};return nt.key=MathUtils.generateUUID(),nt}const IsObject=et=>et===Object(et)&&!Array.isArray(et)&&typeof et!="function";function useTexture(et,_){const _e=useThree(rt=>rt.gl),tt=useLoader(TextureLoader,IsObject(et)?Object.values(et):et);return reactExports.useLayoutEffect(()=>{_==null||_(tt)},[_]),reactExports.useEffect(()=>{if("initTexture"in _e){let rt=[];Array.isArray(tt)?rt=tt:tt instanceof Texture?rt=[tt]:IsObject(tt)&&(rt=Object.values(tt)),rt.forEach(ot=>{ot instanceof Texture&&_e.initTexture(ot)})}},[_e,tt]),reactExports.useMemo(()=>{if(IsObject(et)){const rt={};let ot=0;for(const at in et)rt[at]=tt[ot++];return rt}else return tt},[et,tt])}useTexture.preload=et=>useLoader.preload(TextureLoader,et);useTexture.clear=et=>useLoader.clear(TextureLoader,et);var __defProp=Object.defineProperty,__defNormalProp=(et,_,_e)=>_ in et?__defProp(et,_,{enumerable:!0,configurable:!0,writable:!0,value:_e}):et[_]=_e,__publicField=(et,_,_e)=>(__defNormalProp(et,typeof _!="symbol"?_+"":_,_e),_e);function memcpy(et,_,_e,tt,nt){let rt;if(et=et.subarray||et.slice?et:et.buffer,_e=_e.subarray||_e.slice?_e:_e.buffer,et=_?et.subarray?et.subarray(_,nt&&_+nt):et.slice(_,nt&&_+nt):et,_e.set)_e.set(et,tt);else for(rt=0;rt<et.length;rt++)_e[rt+tt]=et[rt];return _e}function convertPoints(et){return et instanceof Float32Array?et:et instanceof BufferGeometry?et.getAttribute("position").array:et.map(_=>{const _e=Array.isArray(_);return _ instanceof Vector3?[_.x,_.y,_.z]:_ instanceof Vector2?[_.x,_.y,0]:_e&&_.length===3?[_[0],_[1],_[2]]:_e&&_.length===2?[_[0],_[1],0]:_}).flat()}class MeshLineGeometry extends BufferGeometry{constructor(){super(),__publicField(this,"type","MeshLine"),__publicField(this,"isMeshLine",!0),__publicField(this,"positions",[]),__publicField(this,"previous",[]),__publicField(this,"next",[]),__publicField(this,"side",[]),__publicField(this,"width",[]),__publicField(this,"indices_array",[]),__publicField(this,"uvs",[]),__publicField(this,"counters",[]),__publicField(this,"widthCallback",null),__publicField(this,"_attributes"),__publicField(this,"_points",[]),__publicField(this,"points"),__publicField(this,"matrixWorld",new Matrix4),Object.defineProperties(this,{points:{enumerable:!0,get(){return this._points},set(_){this.setPoints(_,this.widthCallback)}}})}setMatrixWorld(_){this.matrixWorld=_}setPoints(_,_e){if(_=convertPoints(_),this._points=_,this.widthCallback=_e??null,this.positions=[],this.counters=[],_.length&&_[0]instanceof Vector3)for(let tt=0;tt<_.length;tt++){const nt=_[tt],rt=tt/(_.length-1);this.positions.push(nt.x,nt.y,nt.z),this.positions.push(nt.x,nt.y,nt.z),this.counters.push(rt),this.counters.push(rt)}else for(let tt=0;tt<_.length;tt+=3){const nt=tt/(_.length-1);this.positions.push(_[tt],_[tt+1],_[tt+2]),this.positions.push(_[tt],_[tt+1],_[tt+2]),this.counters.push(nt),this.counters.push(nt)}this.process()}compareV3(_,_e){const tt=_*6,nt=_e*6;return this.positions[tt]===this.positions[nt]&&this.positions[tt+1]===this.positions[nt+1]&&this.positions[tt+2]===this.positions[nt+2]}copyV3(_){const _e=_*6;return[this.positions[_e],this.positions[_e+1],this.positions[_e+2]]}process(){const _=this.positions.length/6;this.previous=[],this.next=[],this.side=[],this.width=[],this.indices_array=[],this.uvs=[];let _e,tt;this.compareV3(0,_-1)?tt=this.copyV3(_-2):tt=this.copyV3(0),this.previous.push(tt[0],tt[1],tt[2]),this.previous.push(tt[0],tt[1],tt[2]);for(let nt=0;nt<_;nt++){if(this.side.push(1),this.side.push(-1),this.widthCallback?_e=this.widthCallback(nt/(_-1)):_e=1,this.width.push(_e),this.width.push(_e),this.uvs.push(nt/(_-1),0),this.uvs.push(nt/(_-1),1),nt<_-1){tt=this.copyV3(nt),this.previous.push(tt[0],tt[1],tt[2]),this.previous.push(tt[0],tt[1],tt[2]);const rt=nt*2;this.indices_array.push(rt,rt+1,rt+2),this.indices_array.push(rt+2,rt+1,rt+3)}nt>0&&(tt=this.copyV3(nt),this.next.push(tt[0],tt[1],tt[2]),this.next.push(tt[0],tt[1],tt[2]))}this.compareV3(_-1,0)?tt=this.copyV3(1):tt=this.copyV3(_-1),this.next.push(tt[0],tt[1],tt[2]),this.next.push(tt[0],tt[1],tt[2]),!this._attributes||this._attributes.position.count!==this.counters.length?this._attributes={position:new BufferAttribute(new Float32Array(this.positions),3),previous:new BufferAttribute(new Float32Array(this.previous),3),next:new BufferAttribute(new Float32Array(this.next),3),side:new BufferAttribute(new Float32Array(this.side),1),width:new BufferAttribute(new Float32Array(this.width),1),uv:new BufferAttribute(new Float32Array(this.uvs),2),index:new BufferAttribute(new Uint16Array(this.indices_array),1),counters:new BufferAttribute(new Float32Array(this.counters),1)}:(this._attributes.position.copyArray(new Float32Array(this.positions)),this._attributes.position.needsUpdate=!0,this._attributes.previous.copyArray(new Float32Array(this.previous)),this._attributes.previous.needsUpdate=!0,this._attributes.next.copyArray(new Float32Array(this.next)),this._attributes.next.needsUpdate=!0,this._attributes.side.copyArray(new Float32Array(this.side)),this._attributes.side.needsUpdate=!0,this._attributes.width.copyArray(new Float32Array(this.width)),this._attributes.width.needsUpdate=!0,this._attributes.uv.copyArray(new Float32Array(this.uvs)),this._attributes.uv.needsUpdate=!0,this._attributes.index.copyArray(new Uint16Array(this.indices_array)),this._attributes.index.needsUpdate=!0),this.setAttribute("position",this._attributes.position),this.setAttribute("previous",this._attributes.previous),this.setAttribute("next",this._attributes.next),this.setAttribute("side",this._attributes.side),this.setAttribute("width",this._attributes.width),this.setAttribute("uv",this._attributes.uv),this.setAttribute("counters",this._attributes.counters),this.setAttribute("position",this._attributes.position),this.setAttribute("previous",this._attributes.previous),this.setAttribute("next",this._attributes.next),this.setAttribute("side",this._attributes.side),this.setAttribute("width",this._attributes.width),this.setAttribute("uv",this._attributes.uv),this.setAttribute("counters",this._attributes.counters),this.setIndex(this._attributes.index),this.computeBoundingSphere(),this.computeBoundingBox()}advance({x:_,y:_e,z:tt}){const nt=this._attributes.position.array,rt=this._attributes.previous.array,ot=this._attributes.next.array,at=nt.length;memcpy(nt,0,rt,0,at),memcpy(nt,6,nt,0,at-6),nt[at-6]=_,nt[at-5]=_e,nt[at-4]=tt,nt[at-3]=_,nt[at-2]=_e,nt[at-1]=tt,memcpy(nt,6,ot,0,at-6),ot[at-6]=_,ot[at-5]=_e,ot[at-4]=tt,ot[at-3]=_,ot[at-2]=_e,ot[at-1]=tt,this._attributes.position.needsUpdate=!0,this._attributes.previous.needsUpdate=!0,this._attributes.next.needsUpdate=!0}}const vertexShader=`
  #include <common>
  #include <logdepthbuf_pars_vertex>
  #include <fog_pars_vertex>
  #include <clipping_planes_pars_vertex>

  attribute vec3 previous;
  attribute vec3 next;
  attribute float side;
  attribute float width;
  attribute float counters;
  
  uniform vec2 resolution;
  uniform float lineWidth;
  uniform vec3 color;
  uniform float opacity;
  uniform float sizeAttenuation;
  
  varying vec2 vUV;
  varying vec4 vColor;
  varying float vCounters;
  
  vec2 fix(vec4 i, float aspect) {
    vec2 res = i.xy / i.w;
    res.x *= aspect;
    return res;
  }
  
  void main() {
    float aspect = resolution.x / resolution.y;
    vColor = vec4(color, opacity);
    vUV = uv;
    vCounters = counters;
  
    mat4 m = projectionMatrix * modelViewMatrix;
    vec4 finalPosition = m * vec4(position, 1.0) * aspect;
    vec4 prevPos = m * vec4(previous, 1.0);
    vec4 nextPos = m * vec4(next, 1.0);
  
    vec2 currentP = fix(finalPosition, aspect);
    vec2 prevP = fix(prevPos, aspect);
    vec2 nextP = fix(nextPos, aspect);
  
    float w = lineWidth * width;
  
    vec2 dir;
    if (nextP == currentP) dir = normalize(currentP - prevP);
    else if (prevP == currentP) dir = normalize(nextP - currentP);
    else {
      vec2 dir1 = normalize(currentP - prevP);
      vec2 dir2 = normalize(nextP - currentP);
      dir = normalize(dir1 + dir2);
  
      vec2 perp = vec2(-dir1.y, dir1.x);
      vec2 miter = vec2(-dir.y, dir.x);
      //w = clamp(w / dot(miter, perp), 0., 4. * lineWidth * width);
    }
  
    //vec2 normal = (cross(vec3(dir, 0.), vec3(0., 0., 1.))).xy;
    vec4 normal = vec4(-dir.y, dir.x, 0., 1.);
    normal.xy *= .5 * w;
    //normal *= projectionMatrix;
    if (sizeAttenuation == 0.) {
      normal.xy *= finalPosition.w;
      normal.xy /= (vec4(resolution, 0., 1.) * projectionMatrix).xy * aspect;
    }
  
    finalPosition.xy += normal.xy * side;
    gl_Position = finalPosition;
    #include <logdepthbuf_vertex>
    #include <fog_vertex>
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    #include <clipping_planes_vertex>
    #include <fog_vertex>
  }
`,version=parseInt(REVISION.replace(/\D+/g,"")),colorspace_fragment=version>=154?"colorspace_fragment":"encodings_fragment",fragmentShader=`
  #include <fog_pars_fragment>
  #include <logdepthbuf_pars_fragment>
  #include <clipping_planes_pars_fragment>
  
  uniform sampler2D map;
  uniform sampler2D alphaMap;
  uniform float useGradient;
  uniform float useMap;
  uniform float useAlphaMap;
  uniform float useDash;
  uniform float dashArray;
  uniform float dashOffset;
  uniform float dashRatio;
  uniform float visibility;
  uniform float alphaTest;
  uniform vec2 repeat;
  uniform vec3 gradient[2];
  
  varying vec2 vUV;
  varying vec4 vColor;
  varying float vCounters;
  
  void main() {
    #include <logdepthbuf_fragment>
    vec4 diffuseColor = vColor;
    if (useGradient == 1.) diffuseColor = vec4(mix(gradient[0], gradient[1], vCounters), 1.0);
    if (useMap == 1.) diffuseColor *= texture2D(map, vUV * repeat);
    if (useAlphaMap == 1.) diffuseColor.a *= texture2D(alphaMap, vUV * repeat).a;
    if (diffuseColor.a < alphaTest) discard;
    if (useDash == 1.) diffuseColor.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));
    diffuseColor.a *= step(vCounters, visibility);
    #include <clipping_planes_fragment>
    gl_FragColor = diffuseColor;     
    #include <fog_fragment>
    #include <tonemapping_fragment>
    #include <${colorspace_fragment}>
  }
`;class MeshLineMaterial extends ShaderMaterial{constructor(_){super({uniforms:{...UniformsLib.fog,lineWidth:{value:1},map:{value:null},useMap:{value:0},alphaMap:{value:null},useAlphaMap:{value:0},color:{value:new Color$1(16777215)},gradient:{value:[new Color$1(16711680),new Color$1(65280)]},opacity:{value:1},resolution:{value:new Vector2(1,1)},sizeAttenuation:{value:1},dashArray:{value:0},dashOffset:{value:0},dashRatio:{value:.5},useDash:{value:0},useGradient:{value:0},visibility:{value:1},alphaTest:{value:0},repeat:{value:new Vector2(1,1)}},vertexShader,fragmentShader}),__publicField(this,"lineWidth"),__publicField(this,"map"),__publicField(this,"useMap"),__publicField(this,"alphaMap"),__publicField(this,"useAlphaMap"),__publicField(this,"color"),__publicField(this,"gradient"),__publicField(this,"resolution"),__publicField(this,"sizeAttenuation"),__publicField(this,"dashArray"),__publicField(this,"dashOffset"),__publicField(this,"dashRatio"),__publicField(this,"useDash"),__publicField(this,"useGradient"),__publicField(this,"visibility"),__publicField(this,"repeat"),this.type="MeshLineMaterial",Object.defineProperties(this,{lineWidth:{enumerable:!0,get(){return this.uniforms.lineWidth.value},set(_e){this.uniforms.lineWidth.value=_e}},map:{enumerable:!0,get(){return this.uniforms.map.value},set(_e){this.uniforms.map.value=_e}},useMap:{enumerable:!0,get(){return this.uniforms.useMap.value},set(_e){this.uniforms.useMap.value=_e}},alphaMap:{enumerable:!0,get(){return this.uniforms.alphaMap.value},set(_e){this.uniforms.alphaMap.value=_e}},useAlphaMap:{enumerable:!0,get(){return this.uniforms.useAlphaMap.value},set(_e){this.uniforms.useAlphaMap.value=_e}},color:{enumerable:!0,get(){return this.uniforms.color.value},set(_e){this.uniforms.color.value=_e}},gradient:{enumerable:!0,get(){return this.uniforms.gradient.value},set(_e){this.uniforms.gradient.value=_e}},opacity:{enumerable:!0,get(){return this.uniforms.opacity.value},set(_e){this.uniforms.opacity.value=_e}},resolution:{enumerable:!0,get(){return this.uniforms.resolution.value},set(_e){this.uniforms.resolution.value.copy(_e)}},sizeAttenuation:{enumerable:!0,get(){return this.uniforms.sizeAttenuation.value},set(_e){this.uniforms.sizeAttenuation.value=_e}},dashArray:{enumerable:!0,get(){return this.uniforms.dashArray.value},set(_e){this.uniforms.dashArray.value=_e,this.useDash=_e!==0?1:0}},dashOffset:{enumerable:!0,get(){return this.uniforms.dashOffset.value},set(_e){this.uniforms.dashOffset.value=_e}},dashRatio:{enumerable:!0,get(){return this.uniforms.dashRatio.value},set(_e){this.uniforms.dashRatio.value=_e}},useDash:{enumerable:!0,get(){return this.uniforms.useDash.value},set(_e){this.uniforms.useDash.value=_e}},useGradient:{enumerable:!0,get(){return this.uniforms.useGradient.value},set(_e){this.uniforms.useGradient.value=_e}},visibility:{enumerable:!0,get(){return this.uniforms.visibility.value},set(_e){this.uniforms.visibility.value=_e}},alphaTest:{enumerable:!0,get(){return this.uniforms.alphaTest.value},set(_e){this.uniforms.alphaTest.value=_e}},repeat:{enumerable:!0,get(){return this.uniforms.repeat.value},set(_e){this.uniforms.repeat.value.copy(_e)}}}),this.setValues(_)}copy(_){return super.copy(_),this.lineWidth=_.lineWidth,this.map=_.map,this.useMap=_.useMap,this.alphaMap=_.alphaMap,this.useAlphaMap=_.useAlphaMap,this.color.copy(_.color),this.gradient=_.gradient,this.opacity=_.opacity,this.resolution.copy(_.resolution),this.sizeAttenuation=_.sizeAttenuation,this.dashArray=_.dashArray,this.dashOffset=_.dashOffset,this.dashRatio=_.dashRatio,this.useDash=_.useDash,this.useGradient=_.useGradient,this.visibility=_.visibility,this.alphaTest=_.alphaTest,this.repeat.copy(_.repeat),this}}const ComputedAttribute=({compute:et,name:_,..._e})=>{const[tt]=reactExports.useState(()=>new BufferAttribute(new Float32Array(0),1)),nt=reactExports.useRef(null);return reactExports.useLayoutEffect(()=>{if(nt.current){var rt;const ot=(rt=nt.current.parent)!==null&&rt!==void 0?rt:nt.current.__r3f.parent,at=et(ot);nt.current.copy(at)}},[et]),reactExports.createElement("primitive",_extends$1({ref:nt,object:tt,attach:`attributes-${_}`},_e))};function useFBO(et,_,_e){const tt=useThree(it=>it.size),nt=useThree(it=>it.viewport),rt=typeof et=="number"?et:tt.width*nt.dpr,ot=typeof _=="number"?_:tt.height*nt.dpr,at=(typeof et=="number"?_e:et)||{},{samples:lt=0,depth:ut,...dt}=at,st=reactExports.useMemo(()=>{const it=new WebGLRenderTarget(rt,ot,{minFilter:LinearFilter,magFilter:LinearFilter,type:HalfFloatType,...dt});return ut&&(it.depthTexture=new DepthTexture(rt,ot,FloatType)),it.samples=lt,it},[]);return reactExports.useLayoutEffect(()=>{st.setSize(rt,ot),lt&&(st.samples=lt)},[lt,st,rt,ot]),reactExports.useEffect(()=>()=>st.dispose(),[]),st}const isFunction=et=>typeof et=="function",OrthographicCamera=reactExports.forwardRef(({envMap:et,resolution:_=256,frames:_e=1/0,children:tt,makeDefault:nt,...rt},ot)=>{const at=useThree(({set:mt})=>mt),lt=useThree(({camera:mt})=>mt),ut=useThree(({size:mt})=>mt),dt=reactExports.useRef(null);reactExports.useImperativeHandle(ot,()=>dt.current,[]);const st=reactExports.useRef(null),it=useFBO(_);reactExports.useLayoutEffect(()=>{rt.manual||dt.current.updateProjectionMatrix()},[ut,rt]),reactExports.useLayoutEffect(()=>{dt.current.updateProjectionMatrix()}),reactExports.useLayoutEffect(()=>{if(nt){const mt=lt;return at(()=>({camera:dt.current})),()=>at(()=>({camera:mt}))}},[dt,nt,at]);let ct=0,ft=null;const ht=isFunction(tt);return useFrame(mt=>{ht&&(_e===1/0||ct<_e)&&(st.current.visible=!1,mt.gl.setRenderTarget(it),ft=mt.scene.background,et&&(mt.scene.background=et),mt.gl.render(mt.scene,dt.current),mt.scene.background=ft,mt.gl.setRenderTarget(null),st.current.visible=!0,ct++)}),reactExports.createElement(reactExports.Fragment,null,reactExports.createElement("orthographicCamera",_extends$1({left:ut.width/-2,right:ut.width/2,top:ut.height/2,bottom:ut.height/-2,ref:dt},rt),!ht&&tt),reactExports.createElement("group",{ref:st},ht&&tt(it.texture)))}),OrbitControls=reactExports.forwardRef(({makeDefault:et,camera:_,regress:_e,domElement:tt,enableDamping:nt=!0,keyEvents:rt=!1,onChange:ot,onStart:at,onEnd:lt,...ut},dt)=>{const st=useThree(xt=>xt.invalidate),it=useThree(xt=>xt.camera),ct=useThree(xt=>xt.gl),ft=useThree(xt=>xt.events),ht=useThree(xt=>xt.setEvents),mt=useThree(xt=>xt.set),pt=useThree(xt=>xt.get),_t=useThree(xt=>xt.performance),vt=_||it,bt=tt||ft.connected||ct.domElement,wt=reactExports.useMemo(()=>new OrbitControls$1(vt),[vt]);return useFrame(()=>{wt.enabled&&wt.update()},-1),reactExports.useEffect(()=>(rt&&wt.connect(rt===!0?bt:rt),wt.connect(bt),()=>void wt.dispose()),[rt,bt,_e,wt,st]),reactExports.useEffect(()=>{const xt=St=>{st(),_e&&_t.regress(),ot&&ot(St)},Mt=St=>{at&&at(St)},At=St=>{lt&&lt(St)};return wt.addEventListener("change",xt),wt.addEventListener("start",Mt),wt.addEventListener("end",At),()=>{wt.removeEventListener("start",Mt),wt.removeEventListener("end",At),wt.removeEventListener("change",xt)}},[ot,at,lt,wt,st,ht]),reactExports.useEffect(()=>{if(et){const xt=pt().controls;return mt({controls:wt}),()=>mt({controls:xt})}},[et,wt]),reactExports.createElement("primitive",_extends$1({ref:dt,object:wt,enableDamping:nt},ut))});function RenderHud({defaultScene:et,defaultCamera:_,renderPriority:_e=1}){const{gl:tt,scene:nt,camera:rt}=useThree();let ot;return useFrame(()=>{ot=tt.autoClear,_e===1&&(tt.autoClear=!0,tt.render(et,_)),tt.autoClear=!1,tt.clearDepth(),tt.render(nt,rt),tt.autoClear=ot},_e),reactExports.createElement("group",{onPointerOver:()=>null})}function Hud({children:et,renderPriority:_=1}){const{scene:_e,camera:tt}=useThree(),[nt]=reactExports.useState(()=>new Scene$1);return reactExports.createElement(reactExports.Fragment,null,createPortal(reactExports.createElement(reactExports.Fragment,null,et,reactExports.createElement(RenderHud,{defaultScene:_e,defaultCamera:tt,renderPriority:_})),nt,{events:{priority:_+1}}))}var propTypes={exports:{}},ReactPropTypesSecret$1="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",ReactPropTypesSecret_1=ReactPropTypesSecret$1,ReactPropTypesSecret=ReactPropTypesSecret_1;function emptyFunction(){}function emptyFunctionWithReset(){}emptyFunctionWithReset.resetWarningCache=emptyFunction;var factoryWithThrowingShims=function(){function et(tt,nt,rt,ot,at,lt){if(lt!==ReactPropTypesSecret){var ut=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw ut.name="Invariant Violation",ut}}et.isRequired=et;function _(){return et}var _e={array:et,bigint:et,bool:et,func:et,number:et,object:et,string:et,symbol:et,any:et,arrayOf:_,element:et,elementType:et,instanceOf:_,node:et,objectOf:_,oneOf:_,oneOfType:_,shape:_,exact:_,checkPropTypes:emptyFunctionWithReset,resetWarningCache:emptyFunction};return _e.PropTypes=_e,_e};propTypes.exports=factoryWithThrowingShims();var propTypesExports=propTypes.exports;const PropTypes=getDefaultExportFromCjs(propTypesExports),RenderTexture=reactExports.forwardRef(({children:et,compute:_,width:_e,height:tt,samples:nt=8,renderPriority:rt=0,eventPriority:ot=0,frames:at=1/0,stencilBuffer:lt=!1,depthBuffer:ut=!0,generateMipmaps:dt=!1,...st},it)=>{const{size:ct,viewport:ft}=useThree(),ht=useFBO((_e||ct.width)*ft.dpr,(tt||ct.height)*ft.dpr,{samples:nt,stencilBuffer:lt,depthBuffer:ut,generateMipmaps:dt}),[mt]=reactExports.useState(()=>new Scene$1),pt=reactExports.useCallback((_t,vt,bt)=>{var wt,xt;let Mt=(wt=ht.texture)==null?void 0:wt.__r3f.parent;for(;Mt&&!(Mt instanceof Object3D);)Mt=Mt.__r3f.parent;if(!Mt)return!1;bt.raycaster.camera||bt.events.compute(_t,bt,(xt=bt.previousRoot)==null?void 0:xt.getState());const[At]=bt.raycaster.intersectObject(Mt);if(!At)return!1;const St=At.uv;if(!St)return!1;vt.raycaster.setFromCamera(vt.pointer.set(St.x*2-1,St.y*2-1),vt.camera)},[]);return reactExports.useImperativeHandle(it,()=>ht.texture,[ht]),reactExports.createElement(reactExports.Fragment,null,createPortal(reactExports.createElement(Container$3,{renderPriority:rt,frames:at,fbo:ht},et,reactExports.createElement("group",{onPointerOver:()=>null})),mt,{events:{compute:_||pt,priority:ot}}),reactExports.createElement("primitive",_extends$1({object:ht.texture},st)))});function Container$3({frames:et,renderPriority:_,children:_e,fbo:tt}){let nt=0,rt,ot,at,lt;return useFrame(ut=>{(et===1/0||nt<et)&&(rt=ut.gl.autoClear,ot=ut.gl.xr.enabled,at=ut.gl.getRenderTarget(),lt=ut.gl.xr.isPresenting,ut.gl.autoClear=!0,ut.gl.xr.enabled=!1,ut.gl.xr.isPresenting=!1,ut.gl.setRenderTarget(tt),ut.gl.render(ut.scene,ut.camera),ut.gl.setRenderTarget(at),ut.gl.autoClear=rt,ut.gl.xr.enabled=ot,ut.gl.xr.isPresenting=lt,nt++)},_),reactExports.createElement(reactExports.Fragment,null,_e)}const EffectMaterial=shaderMaterial({uBrush:null,uPrev:null,uTime:0,uResolution:new Vector2(1,1)},`
    varying vec2 vUv;

    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

      vUv = uv;
    }
  `,`
    uniform sampler2D uBrush;
    uniform sampler2D uPrev;
    uniform vec2 uResolution;
    uniform float uTime;

    varying vec2 vUv;

    float rand(vec2 n) {
        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
    }
    float noise(vec2 p) {
        vec2 ip = floor(p);
        vec2 u = fract(p);
        u = u*u*(3.0-2.0*u);
        float res = mix(
        mix(rand(ip), rand(ip+vec2(1.0, 0.0)), u.x), mix(rand(ip+vec2(0.0, 1.0)), rand(ip+vec2(1.0, 1.0)), u.x), u.y);
        return res*res;
    }
    float fbm(vec2 x, int numOctaves) {
        float v = 0.0;
        float a = 0.5;
        vec2 shift = vec2(100);
        // Rotate to reduce axial bias

        mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));
        for (int i = 0; i < numOctaves; ++i) {
            v += a * noise(x);
            x = rot * x * 2.0 + shift;
            a *= 0.5;
        }
        return v;
    }

    float blendDarken(float base, float blend) {
    return min(blend, base);
    }
    vec3 blendDarken(vec3 base, vec3 blend) {
        return vec3(blendDarken(base.r, blend.r), blendDarken(base.g, blend.g), blendDarken(base.b, blend.b));
    }
    vec3 blendDarken(vec3 base, vec3 blend, float opacity) {
        return (blendDarken(base, blend) * opacity + base * (1.0 - opacity));
    }

    float hue2rgb(float f1, float f2, float hue) {
        if (hue < 0.0)
        hue += 1.0;
        else if (hue > 1.0)
        hue -= 1.0;
        float res;
        if ((6.0 * hue) < 1.0)
        res = f1 + (f2 - f1) * 6.0 * hue;
        else if ((2.0 * hue) < 1.0)
        res = f2;
        else if ((3.0 * hue) < 2.0)
        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;
        else
        res = f1;
        return res;
    }
    vec3 hsl2rgb(vec3 hsl) {
        vec3 rgb;
        if (hsl.y == 0.0) {
            rgb = vec3(hsl.z); // Luminance
        }
        else {
            float f2;
            if (hsl.z < 0.5)
            f2 = hsl.z * (1.0 + hsl.y);
            else
            f2 = hsl.z + hsl.y - hsl.y * hsl.z;
            float f1 = 2.0 * hsl.z - f2;
            rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));
            rgb.g = hue2rgb(f1, f2, hsl.x);
            rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));
        }
        return rgb;
    }
    vec3 hsl2rgb(float h, float s, float l) {
        return hsl2rgb(vec3(h, s, l));
    }

    void main() {
      float brush = texture(uBrush, vUv).r;
      vec4 prev = texture(uPrev, vUv);

      vec2 aspect = vec2(1.0, uResolution.y / uResolution.x);

      // Increase flood after a set time
      // float floodStart = 0.01;
      // float floodEnd = 0.03;
      // float floodEnd = 0.015;
      // float floodMix = smoothstep(3.0, 4.0, uTime);

      float floodStart = 0.00;
      float floodEnd = 0.025;
      float floodMix = smoothstep(2.5, 4.0, uTime);

      float flood = mix(floodStart, floodEnd, floodMix);

      vec2 disp = fbm(vUv * 22.0, 4) * aspect * flood;

      vec4 texel = texture2D(uPrev, vUv);
      vec4 texel2 = texture2D(uPrev, vec2(vUv.x + disp.x, vUv.y));
      vec4 texel3 = texture2D(uPrev, vec2(vUv.x - disp.x, vUv.y));
      vec4 texel4 = texture2D(uPrev, vec2(vUv.x, vUv.y + disp.y));
      vec4 texel5 = texture2D(uPrev, vec2(vUv.x, vUv.y - disp.y));

      vec3 floodcolor = texel.rgb;
      floodcolor = blendDarken(floodcolor, texel2.rgb);
      floodcolor = blendDarken(floodcolor, texel3.rgb);
      floodcolor = blendDarken(floodcolor, texel4.rgb);
      floodcolor = blendDarken(floodcolor, texel5.rgb);

      // Give color to brush
      // vec3 gradient = hsl2rgb(fract(uTime * 0.1), 0.5, 0.5);
      // vec3 lcolor = mix(vec3(1.0), gradient, brush);
      vec3 lcolor = vec3(1.0 - brush);

      // Gradually fade out
      float fade1 = 0.7;
      vec3 waterColor = blendDarken(prev.rgb, floodcolor * (1.0 + 0.02), fade1);

      vec3 finalColor = blendDarken(waterColor, lcolor, 1.0);

      // More fading out
      float fade2 = 0.001;

      vec4 final = vec4(
        min(vec3(1.0), finalColor * (1.0 + 0.01) + fade2), 1.0
      );

      gl_FragColor = final;
    }
  `),PaintingMaterial=reactExports.forwardRef(function({uniforms:_,map:_e,displacementScale:tt=2,displacementMap:nt},rt){return useFrame(({clock:ot})=>{rt.current.uniforms.uTime.value=ot.getElapsedTime()}),jsxRuntimeExports.jsx(CustomShaderMaterial,{ref:rt,baseMaterial:MeshStandardMaterial,uniforms:_,toneMapped:!1,map:_e,transparent:!0,displacementScale:tt,displacementMap:nt,vertexShader:`
        varying vec2 vUv;

        void main() {
          vUv = uv;
        }
      `,fragmentShader:`
        uniform sampler2D uBrush;
        uniform vec2 uMouse;
        uniform float uTime;

        varying vec2 vUv;

        void main() {
          float brush = texture(uBrush, vUv).r;
          float alpha = 1.0 - brush;

          // Perform color mixing on mouse position
          // float distToMouse = distance(uMouse, vUv);
          // csm_DiffuseColor.a = distToMouse;

          // csm_DiffuseColor.a = step(startTime, uTime) * alpha;
          csm_DiffuseColor.a = alpha;
        }
      `})}),noise3Fn=`
//https://thebookofshaders.com/edit.php#11/iching-03.frag
vec3 random3(vec3 c) {
    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
    vec3 r;
    r.z = fract(512.0*j);
    j *= .125;
    r.x = fract(512.0*j);
    j *= .125;
    r.y = fract(512.0*j);
    return r - 0.5;
}

const float F3 =  0.3333333;
const float G3 =  0.1666667;

float snoise(vec3 p) {

    vec3 s = floor(p + dot(p, vec3(F3)));
    vec3 x = p - s + dot(s, vec3(G3));

    vec3 e = step(vec3(0.0), x - x.yzx);
    vec3 i1 = e*(1.0 - e.zxy);
    vec3 i2 = 1.0 - e.zxy*(1.0 - e);

    vec3 x1 = x - i1 + G3;
    vec3 x2 = x - i2 + 2.0*G3;
    vec3 x3 = x - 1.0 + 3.0*G3;

    vec4 w, d;

    w.x = dot(x, x);
    w.y = dot(x1, x1);
    w.z = dot(x2, x2);
    w.w = dot(x3, x3);

    w = max(0.6 - w, 0.0);

    d.x = dot(random3(s), x);
    d.y = dot(random3(s + i1), x1);
    d.z = dot(random3(s + i2), x2);
    d.w = dot(random3(s + 1.0), x3);

    w *= w;
    w *= w;
    d *= w;

    return dot(d, vec4(52.0));
}

vec2 snoise2(vec3 p) {
  return vec2(snoise(p), snoise(p + vec3(12345.6789)));
}
`;reactExports.forwardRef(function({vertexShader:_=vert,fragmentShader:_e=frag,renderTarget:tt,uniforms:nt},rt){const ot=reactExports.useMemo(()=>new Scene$1,[]),at=reactExports.useMemo(()=>new OrthographicCamera$1(-1,1,1,-1,1/Math.pow(2,53),1),[]);let lt=useFBO(),ut=useFBO();return useFrame(({gl:dt,clock:st})=>{dt.setRenderTarget(lt),dt.render(ot,at),rt.current.uniforms.uPrev.value=lt.texture,rt.current.uniforms;let it=lt;lt=ut,ut=it,dt.setRenderTarget(null)}),jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment,{children:createPortal(jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment,{children:jsxRuntimeExports.jsxs("mesh",{children:[jsxRuntimeExports.jsx("planeGeometry",{args:[2,2]}),jsxRuntimeExports.jsx("shaderMaterial",{ref:rt,uniforms:nt,vertexShader:_,fragmentShader:_e})]})}),ot)})});const vert=`
varying vec2 vUv;

void main() {
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

  vUv = uv;
}
`,frag=`
uniform sampler2D uPrev;
uniform vec2 uMouse;
uniform vec2 uTime;

varying vec2 vUv;

${noise3Fn}

void main() {
  // Perform color mixing on mouse position
  float distToMouse = distance(uMouse, vUv);
  float forceMix = smoothstep(0.05, 0.0, distToMouse);

  vec2 noise = snoise2(vec3(vUv * 5.0, uTime * 0.1)) * 0.01;

  // vec2 noise = snoise2(vUv / 50.0) + snoise2(vUv);
  // vec2 noise = snoise2(vUv * 20.0);
  // noise = noise * 0.5;

  vec2 force = mix(vec2(0.0), noise, forceMix);

  vec4 color = texture(uPrev, vUv + (force * 1.0));

  // FIXME: How to make it return back to normal

  // FIXME: How to create blending and color mixing?

  gl_FragColor = color;
  // gl_FragColor = vec4(vec3(forceMix), 1.0);
}
`,MotionConfigContext=reactExports.createContext({transformPagePoint:et=>et,isStatic:!1,reducedMotion:"never"}),MotionGlobalConfig={skipAnimations:!1,useManualTiming:!1};function createRenderStep(et){let _=new Set,_e=new Set,tt=!1,nt=!1;const rt=new WeakSet;let ot={delta:0,timestamp:0,isProcessing:!1};function at(ut){rt.has(ut)&&(lt.schedule(ut),et()),ut(ot)}const lt={schedule:(ut,dt=!1,st=!1)=>{const ct=st&&tt?_:_e;return dt&&rt.add(ut),ct.has(ut)||ct.add(ut),ut},cancel:ut=>{_e.delete(ut),rt.delete(ut)},process:ut=>{if(ot=ut,tt){nt=!0;return}tt=!0,[_,_e]=[_e,_],_e.clear(),_.forEach(at),tt=!1,nt&&(nt=!1,lt.process(ut))}};return lt}const stepsOrder=["read","resolveKeyframes","update","preRender","render","postRender"],maxElapsed=40;function createRenderBatcher(et,_){let _e=!1,tt=!0;const nt={delta:0,timestamp:0,isProcessing:!1},rt=()=>_e=!0,ot=stepsOrder.reduce((pt,_t)=>(pt[_t]=createRenderStep(rt),pt),{}),{read:at,resolveKeyframes:lt,update:ut,preRender:dt,render:st,postRender:it}=ot,ct=()=>{const pt=performance.now();_e=!1,nt.delta=tt?1e3/60:Math.max(Math.min(pt-nt.timestamp,maxElapsed),1),nt.timestamp=pt,nt.isProcessing=!0,at.process(nt),lt.process(nt),ut.process(nt),dt.process(nt),st.process(nt),it.process(nt),nt.isProcessing=!1,_e&&_&&(tt=!1,et(ct))},ft=()=>{_e=!0,tt=!0,nt.isProcessing||et(ct)};return{schedule:stepsOrder.reduce((pt,_t)=>{const vt=ot[_t];return pt[_t]=(bt,wt=!1,xt=!1)=>(_e||ft(),vt.schedule(bt,wt,xt)),pt},{}),cancel:pt=>{for(let _t=0;_t<stepsOrder.length;_t++)ot[stepsOrder[_t]].cancel(pt)},state:nt,steps:ot}}const noop$1=et=>et;function useConstant(et){const _=reactExports.useRef(null);return _.current===null&&(_.current=et()),_.current}function addUniqueItem(et,_){et.indexOf(_)===-1&&et.push(_)}function removeItem(et,_){const _e=et.indexOf(_);_e>-1&&et.splice(_e,1)}const{schedule:frame,cancel:cancelFrame,state:frameData,steps}=createRenderBatcher(typeof requestAnimationFrame<"u"?requestAnimationFrame:noop$1,!0);let now;function clearTime(){now=void 0}const time={now:()=>(now===void 0&&time.set(frameData.isProcessing||MotionGlobalConfig.useManualTiming?frameData.timestamp:performance.now()),now),set:et=>{now=et,queueMicrotask(clearTime)}};function velocityPerSecond(et,_){return _?et*(1e3/_):0}class SubscriptionManager{constructor(){this.subscriptions=[]}add(_){return addUniqueItem(this.subscriptions,_),()=>removeItem(this.subscriptions,_)}notify(_,_e,tt){const nt=this.subscriptions.length;if(nt)if(nt===1)this.subscriptions[0](_,_e,tt);else for(let rt=0;rt<nt;rt++){const ot=this.subscriptions[rt];ot&&ot(_,_e,tt)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}const MAX_VELOCITY_DELTA=30,isFloat=et=>!isNaN(parseFloat(et));class MotionValue{constructor(_,_e={}){this.version="11.3.18",this.canTrackVelocity=null,this.events={},this.updateAndNotify=(tt,nt=!0)=>{const rt=time.now();this.updatedAt!==rt&&this.setPrevFrameValue(),this.prev=this.current,this.setCurrent(tt),this.current!==this.prev&&this.events.change&&this.events.change.notify(this.current),nt&&this.events.renderRequest&&this.events.renderRequest.notify(this.current)},this.hasAnimated=!1,this.setCurrent(_),this.owner=_e.owner}setCurrent(_){this.current=_,this.updatedAt=time.now(),this.canTrackVelocity===null&&_!==void 0&&(this.canTrackVelocity=isFloat(this.current))}setPrevFrameValue(_=this.current){this.prevFrameValue=_,this.prevUpdatedAt=this.updatedAt}onChange(_){return this.on("change",_)}on(_,_e){this.events[_]||(this.events[_]=new SubscriptionManager);const tt=this.events[_].add(_e);return _==="change"?()=>{tt(),frame.read(()=>{this.events.change.getSize()||this.stop()})}:tt}clearListeners(){for(const _ in this.events)this.events[_].clear()}attach(_,_e){this.passiveEffect=_,this.stopPassiveEffect=_e}set(_,_e=!0){!_e||!this.passiveEffect?this.updateAndNotify(_,_e):this.passiveEffect(_,this.updateAndNotify)}setWithVelocity(_,_e,tt){this.set(_e),this.prev=void 0,this.prevFrameValue=_,this.prevUpdatedAt=this.updatedAt-tt}jump(_,_e=!0){this.updateAndNotify(_),this.prev=_,this.prevUpdatedAt=this.prevFrameValue=void 0,_e&&this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}get(){return this.current}getPrevious(){return this.prev}getVelocity(){const _=time.now();if(!this.canTrackVelocity||this.prevFrameValue===void 0||_-this.updatedAt>MAX_VELOCITY_DELTA)return 0;const _e=Math.min(this.updatedAt-this.prevUpdatedAt,MAX_VELOCITY_DELTA);return velocityPerSecond(parseFloat(this.current)-parseFloat(this.prevFrameValue),_e)}start(_){return this.stop(),new Promise(_e=>{this.hasAnimated=!0,this.animation=_(_e),this.events.animationStart&&this.events.animationStart.notify()}).then(()=>{this.events.animationComplete&&this.events.animationComplete.notify(),this.clearAnimation()})}stop(){this.animation&&(this.animation.stop(),this.events.animationCancel&&this.events.animationCancel.notify()),this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){this.clearListeners(),this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}}function motionValue(et,_){return new MotionValue(et,_)}function useMotionValue(et){const _=useConstant(()=>motionValue(et)),{isStatic:_e}=reactExports.useContext(MotionConfigContext);if(_e){const[,tt]=reactExports.useState(et);reactExports.useEffect(()=>_.on("change",tt),[])}return _}extend$2({MeshLineGeometry,MeshLineMaterial});const BrushParticleMaterial=shaderMaterial({uTexture:null,uBrushTexture:null,uTime:0},`
  attribute float aPointSize;
  attribute float aScaleX;
  attribute float aScaleY;
  attribute float aStartTime;

  varying vec2 vUv;
  varying float vScaleX;
  varying float vScaleY;
  varying float vStartTime;

  float rand(vec2 n) {
    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
  }

  float noise(vec2 p){
    vec2 ip = floor(p);
    vec2 u = fract(p);
    u = u*u*(3.0-2.0*u);

    float res = mix(
      mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),
      mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);
    return res*res;
  }

  void main() {
    vec4 modelPosition = modelMatrix * vec4(position, 1.0);
    vec4 viewPosition = viewMatrix * modelPosition;
    vec4 projectedPosition = projectionMatrix * viewPosition;

    float offset = noise(position.xy * 5.0) * 0.05;

    gl_Position = projectedPosition + offset;

    gl_PointSize = aPointSize * 160.0 * (1.0 / -viewPosition.z);

    vUv = uv;
    vScaleX = aScaleX;
    vScaleY = aScaleY;
    vStartTime = aStartTime;
  }
`,`
  uniform sampler2D uTexture;
  uniform sampler2D uBrushTexture;
  uniform float uTime;

  varying vec2 vUv;
  varying float vScaleX;
  varying float vScaleY;
  varying float vStartTime;

  mat2 rotate2d(float _angle){
    return mat2(cos(_angle),-sin(_angle),
                sin(_angle),cos(_angle));
  }

  float rand(vec2 n) {
    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
  }

  float noise(vec2 p){
    vec2 ip = floor(p);
    vec2 u = fract(p);
    u = u*u*(3.0-2.0*u);

    float res = mix(
      mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),
      mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);
    return res*res;
  }

  void main() {
    vec3 color = texture(uTexture, vUv).rgb;

    float gray = dot(color, vec3(0.299, 0.587, 0.114));

    // float pu = (1.0 - gl_PointCoord.x) * 2.0;
    // float pv = gl_PointCoord.y;
    // float alpha = texture(uBrushTexture, rotate2d(0.5) * vec2(pu, pv)).r;

    vec2 pointCoord = vec2((1.0 - gl_PointCoord.x) * vScaleX, gl_PointCoord.y * vScaleY);
    vec2 centeredCoord = (pointCoord - 0.5) * 2.0;
    // vec2 rotatedCoord = rotate2d(radians(90.0)) * centeredCoord;
    vec2 rotatedCoord = rotate2d(0.0) * centeredCoord;
    vec2 puv = (rotatedCoord / 2.0) + 0.5;
    float alpha = texture(uBrushTexture, puv).r;

    // float vStartTime = (noise(vUv * 50.0) * 0.5 + 0.5) * 2.0;

    float showDuration = 1.0;
    float show = smoothstep(vStartTime + pointCoord.x + pointCoord.y, showDuration + vStartTime + 0.7, uTime + pointCoord.x + pointCoord.y);

    gl_FragColor = vec4(vec3(gray), alpha * show);
  }
`);extend$2({BrushParticleMaterial});const BrushParticles=({planeWidth:et,planeHeight:_,texture:_e,size:tt=96})=>{const nt=reactExports.useRef(),rt=useTexture("/watercolor-painting//brush-texture.png");return useFrame(({clock:ot},at)=>{nt.current.uTime+=at}),jsxRuntimeExports.jsxs("points",{children:[jsxRuntimeExports.jsxs("planeGeometry",{args:[et,_,tt,tt],children:[jsxRuntimeExports.jsx(ComputedAttribute,{name:"aPointSize",compute:ot=>{ot.setIndex(null),ot.deleteAttribute("normal");const at=new Float32Array(ot.attributes.position.count);for(let lt=0;lt<ot.attributes.position.count;lt++)at[lt]=Math.random()*.5+.5;return new BufferAttribute(at,1)}}),jsxRuntimeExports.jsx(ComputedAttribute,{name:"aScaleX",compute:ot=>{const at=new Float32Array(ot.attributes.position.count);for(let lt=0;lt<ot.attributes.position.count;lt++)at[lt]=Math.random()*.2+1;return new BufferAttribute(at,1)}}),jsxRuntimeExports.jsx(ComputedAttribute,{name:"aScaleY",compute:ot=>{const at=new Float32Array(ot.attributes.position.count);for(let lt=0;lt<ot.attributes.position.count;lt++)at[lt]=Math.random()*.2+1;return new BufferAttribute(at,1)}}),jsxRuntimeExports.jsx(ComputedAttribute,{name:"aStartTime",compute:ot=>{const at=new Float32Array(ot.attributes.position.count);for(let lt=0;lt<ot.attributes.position.count;lt++)at[lt]=Math.random()*2;return new BufferAttribute(at,1)}})]}),jsxRuntimeExports.jsx("brushParticleMaterial",{ref:nt,depthWrite:!1,depthTest:!1,transparent:!0,uTexture:_e,uBrushTexture:rt})]})};extend$2({EffectMaterial,MeshLineGeometry,MeshLineMaterial});const Scene=({img:et,depth:_})=>{const{pointer:_e,viewport:tt}=useThree();reactExports.useState(!1);const nt=useMotionValue(0),rt=useMotionValue(0);reactExports.useEffect(()=>{function xt(){const{width:Mt,height:At}=tt.getCurrentViewport();nt.set(_e.x*Mt/2),rt.set(_e.y*At/2)}return window.addEventListener("mousemove",xt),()=>{window.removeEventListener("mousemove",xt)}},[_e,tt,nt,rt]);const ot=reactExports.useRef();reactExports.useRef();const at=reactExports.useRef(),lt=reactExports.useRef(),ut=reactExports.useRef();reactExports.useRef();const dt=reactExports.useMemo(()=>{if(_)return new CanvasTexture(_.toCanvas())},[_]),st=useTexture(et);st.colorSpace=SRGBColorSpace;const{width:it,height:ct}=st.image,[ft,ht]=it>ct?[1,ct/it]:[it/ct,1],mt=ft*5,pt=ht*5,_t=reactExports.useMemo(()=>new Scene$1,[]),vt=reactExports.useMemo(()=>new OrthographicCamera$1(-1,1,1,-1,1/Math.pow(2,53),1),[]);let bt=useFBO(),wt=useFBO();return useFBO(),useFrame(({clock:xt,gl:Mt},At)=>{Mt.setRenderTarget(bt),Mt.render(_t,vt),ut.current.uBrush=lt.current,ut.current.uPrev=bt.texture,ut.current.uTime+=At,Mt.setRenderTarget(null);let St=bt;bt=wt,wt=St}),jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment,{children:[jsxRuntimeExports.jsx(CameraRig,{}),jsxRuntimeExports.jsx(OrbitControls,{}),jsxRuntimeExports.jsx("ambientLight",{args:[16777215,3]}),jsxRuntimeExports.jsx(BrushParticles,{planeWidth:mt,planeHeight:pt,texture:st}),jsxRuntimeExports.jsxs("mesh",{children:[jsxRuntimeExports.jsx("planeGeometry",{args:[mt,pt,64,64]}),jsxRuntimeExports.jsx(PaintingMaterial,{ref:ot,uniforms:{uTime:{value:0},uBrush:{value:bt.texture},uMouse:{value:new Vector2}},map:st,displacementMap:dt})]}),jsxRuntimeExports.jsxs("mesh",{"position-z":.1,onPointerMove:xt=>{if(at.current){const Mt=xt.point.x/(mt/2),At=xt.point.y/(pt/2);at.current.position.x=Mt,at.current.position.y=At}},visible:!1,children:[jsxRuntimeExports.jsx("planeGeometry",{args:[mt,pt]}),jsxRuntimeExports.jsx("meshBasicMaterial",{})]}),jsxRuntimeExports.jsxs(RenderTexture,{ref:lt,children:[jsxRuntimeExports.jsx(OrthographicCamera,{makeDefault:!0,top:1,right:1,bottom:-1,left:-1,near:-.1,far:1}),jsxRuntimeExports.jsxs("mesh",{ref:at,children:[jsxRuntimeExports.jsx("sphereGeometry",{args:[.01,30,30]}),jsxRuntimeExports.jsx("meshBasicMaterial",{color:"white"})]})]}),createPortal(jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment,{children:jsxRuntimeExports.jsxs("mesh",{children:[jsxRuntimeExports.jsx("planeGeometry",{args:[2,2]}),jsxRuntimeExports.jsx("effectMaterial",{ref:ut,children:jsxRuntimeExports.jsx(RenderTexture,{attach:"uPrev",children:jsxRuntimeExports.jsx("color",{attach:"background",args:["white"]})})},EffectMaterial.key)]})}),_t)]})};reactExports.forwardRef(({map:et},_)=>jsxRuntimeExports.jsxs(Hud,{children:[jsxRuntimeExports.jsx(OrthographicCamera,{makeDefault:!0,top:1,right:5,bottom:-5,left:-1,near:0,far:1}),jsxRuntimeExports.jsxs("mesh",{children:[jsxRuntimeExports.jsx("planeGeometry",{args:[2,2]}),jsxRuntimeExports.jsx("meshBasicMaterial",{ref:_,map:et,toneMapped:!1})]})]}));function CameraRig(){useFrame((et,_)=>{easing.damp3(et.camera.position,[-1+et.pointer.x*et.viewport.width/3,(1+et.pointer.y)/2,4.5],.5,_),et.camera.lookAt(0,0,0)})}function dispatchCallback(et,_){et&&et(_)}function reverseDictionary(et){return Object.fromEntries(Object.entries(et).map(([_,_e])=>[_e,_]))}function escapeRegExp(et){return et.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}const Callable=class{constructor(){let et=function(..._){return et._call(..._)};return Object.setPrototypeOf(et,new.target.prototype)}_call(...et){throw Error("Must implement _call method in subclass")}};function isTypedArray(et){var _,_e,tt;return((tt=(_e=(_=et==null?void 0:et.prototype)==null?void 0:_.__proto__)==null?void 0:_e.constructor)==null?void 0:tt.name)==="TypedArray"}function isIntegralNumber(et){return Number.isInteger(et)||typeof et=="bigint"}function exists(et){return et!=null}function calculateDimensions(et){const _=[];let _e=et;for(;Array.isArray(_e);)_.push(_e.length),_e=_e[0];return _}function pop(et,_,_e=void 0){const tt=et[_];if(tt!==void 0)return delete et[_],tt;if(_e===void 0)throw Error(`Key ${_} does not exist in object.`);return _e}function mergeArrays(...et){return Array.prototype.concat.apply([],et)}function product(...et){return et.reduce((_,_e)=>_.flatMap(tt=>_e.map(nt=>[tt,nt])))}function calculateReflectOffset(et,_){return Math.abs((et+_)%(2*_)-_)}const sharp={},ONNX_NODE=Object.freeze(Object.defineProperty({__proto__:null,default:sharp},Symbol.toStringTag,{value:"Module"}));var ortWeb_min$1={exports:{}};const backends={},backendsSortedByPriority=[],registerBackend=(et,_,_e)=>{if(_&&typeof _.init=="function"&&typeof _.createSessionHandler=="function"){const tt=backends[et];if(tt===void 0)backends[et]={backend:_,priority:_e};else{if(tt.priority>_e)return;if(tt.priority===_e&&tt.backend!==_)throw new Error(`cannot register backend "${et}" using priority ${_e}`)}if(_e>=0){const nt=backendsSortedByPriority.indexOf(et);nt!==-1&&backendsSortedByPriority.splice(nt,1);for(let rt=0;rt<backendsSortedByPriority.length;rt++)if(backends[backendsSortedByPriority[rt]].priority<=_e){backendsSortedByPriority.splice(rt,0,et);return}backendsSortedByPriority.push(et)}return}throw new TypeError("not a valid backend")},resolveBackend=async et=>{const _=et.length===0?backendsSortedByPriority:et,_e=[];for(const tt of _){const nt=backends[tt];if(nt){if(nt.initialized)return nt.backend;if(nt.aborted)continue;const rt=!!nt.initPromise;try{return rt||(nt.initPromise=nt.backend.init()),await nt.initPromise,nt.initialized=!0,nt.backend}catch(ot){rt||_e.push({name:tt,err:ot}),nt.aborted=!0}finally{delete nt.initPromise}}}throw new Error(`no available backend found. ERR: ${_e.map(tt=>`[${tt.name}] ${tt.err}`).join(", ")}`)};class EnvImpl{constructor(){this.wasm={},this.webgl={},this.logLevelInternal="warning"}set logLevel(_){if(_!==void 0){if(typeof _!="string"||["verbose","info","warning","error","fatal"].indexOf(_)===-1)throw new Error(`Unsupported logging level: ${_}`);this.logLevelInternal=_}}get logLevel(){return this.logLevelInternal}}const env$2=new EnvImpl,isBigInt64ArrayAvailable=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",isBigUint64ArrayAvailable=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function",NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);isBigInt64ArrayAvailable&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64",BigInt64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array,"int64"));isBigUint64ArrayAvailable&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64",BigUint64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array,"uint64"));const calculateSize=et=>{let _=1;for(let _e=0;_e<et.length;_e++){const tt=et[_e];if(typeof tt!="number"||!Number.isSafeInteger(tt))throw new TypeError(`dims[${_e}] must be an integer, got: ${tt}`);if(tt<0)throw new RangeError(`dims[${_e}] must be a non-negative integer, got: ${tt}`);_*=tt}return _};let Tensor$2=class Ps{constructor(_,_e,tt){let nt,rt,ot;if(typeof _=="string")if(nt=_,ot=tt,_==="string"){if(!Array.isArray(_e))throw new TypeError("A string tensor's data must be a string array.");rt=_e}else{const lt=NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(_);if(lt===void 0)throw new TypeError(`Unsupported tensor type: ${_}.`);if(Array.isArray(_e))rt=lt.from(_e);else if(_e instanceof lt)rt=_e;else throw new TypeError(`A ${nt} tensor's data must be type of ${lt}`)}else if(ot=_e,Array.isArray(_)){if(_.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const lt=typeof _[0];if(lt==="string")nt="string",rt=_;else if(lt==="boolean")nt="bool",rt=Uint8Array.from(_);else throw new TypeError(`Invalid element type of data array: ${lt}.`)}else{const lt=NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(_.constructor);if(lt===void 0)throw new TypeError(`Unsupported type for tensor data: ${_.constructor}.`);nt=lt,rt=_}if(ot===void 0)ot=[rt.length];else if(!Array.isArray(ot))throw new TypeError("A tensor's dims must be a number array");const at=calculateSize(ot);if(at!==rt.length)throw new Error(`Tensor's size(${at}) does not match data length(${rt.length}).`);this.dims=ot,this.type=nt,this.data=rt,this.size=at}static bufferToTensor(_,_e){if(_===void 0)throw new Error("Image buffer must be defined");if(_e.height===void 0||_e.width===void 0)throw new Error("Image height and width must be defined");const{height:tt,width:nt}=_e,rt=_e.norm;let ot,at;rt===void 0||rt.mean===void 0?ot=255:ot=rt.mean,rt===void 0||rt.bias===void 0?at=0:at=rt.bias;const lt=_e.bitmapFormat!==void 0?_e.bitmapFormat:"RGBA",ut=_e.tensorFormat!==void 0&&_e.tensorFormat!==void 0?_e.tensorFormat:"RGB",dt=tt*nt,st=ut==="RGBA"?new Float32Array(dt*4):new Float32Array(dt*3);let it=4,ct=0,ft=1,ht=2,mt=3,pt=0,_t=dt,vt=dt*2,bt=-1;lt==="RGB"&&(it=3,ct=0,ft=1,ht=2,mt=-1),ut==="RGBA"?bt=dt*3:ut==="RBG"?(pt=0,vt=dt,_t=dt*2):ut==="BGR"&&(vt=0,_t=dt,pt=dt*2);for(let xt=0;xt<dt;xt++,ct+=it,ht+=it,ft+=it,mt+=it)st[pt++]=(_[ct]+at)/ot,st[_t++]=(_[ft]+at)/ot,st[vt++]=(_[ht]+at)/ot,bt!==-1&&mt!==-1&&(st[bt++]=(_[mt]+at)/ot);return ut==="RGBA"?new Ps("float32",st,[1,4,tt,nt]):new Ps("float32",st,[1,3,tt,nt])}static async fromImage(_,_e){const tt=typeof HTMLImageElement<"u"&&_ instanceof HTMLImageElement,nt=typeof ImageData<"u"&&_ instanceof ImageData,rt=typeof ImageBitmap<"u"&&_ instanceof ImageBitmap,ot=typeof String<"u"&&(_ instanceof String||typeof _=="string");let at,lt={};if(tt){const ut=document.createElement("canvas"),dt=ut.getContext("2d");if(dt!=null){let st=_.naturalHeight,it=_.naturalWidth;if(_e!==void 0&&_e.resizedHeight!==void 0&&_e.resizedWidth!==void 0&&(st=_e.resizedHeight,it=_e.resizedWidth),_e!==void 0){if(lt=_e,_e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");if(lt.tensorFormat="RGBA",_e.height!==void 0&&_e.height!==st)throw new Error("Image input config height doesn't match HTMLImageElement height");if(lt.height=st,_e.width!==void 0&&_e.width!==it)throw new Error("Image input config width doesn't match HTMLImageElement width");lt.width=it}else lt.tensorFormat="RGBA",lt.height=st,lt.width=it;ut.width=it,ut.height=st,dt.drawImage(_,0,0,it,st),at=dt.getImageData(0,0,it,st).data}else throw new Error("Can not access image data")}else if(nt){const ut="RGBA";let dt,st;if(_e!==void 0&&_e.resizedWidth!==void 0&&_e.resizedHeight!==void 0?(dt=_e.resizedHeight,st=_e.resizedWidth):(dt=_.height,st=_.width),_e!==void 0){if(lt=_e,_e.bitmapFormat!==void 0&&_e.bitmapFormat!==ut)throw new Error("Image input config format must be RGBA for ImageData");lt.bitmapFormat="RGBA"}else lt.bitmapFormat="RGBA";if(lt.height=dt,lt.width=st,_e!==void 0){const it=document.createElement("canvas");it.width=st,it.height=dt;const ct=it.getContext("2d");if(ct!=null)ct.putImageData(_,0,0),at=ct.getImageData(0,0,st,dt).data;else throw new Error("Can not access image data")}else at=_.data}else if(rt){if(_e===void 0)throw new Error("Please provide image config with format for Imagebitmap");if(_e.bitmapFormat!==void 0)throw new Error("Image input config format must be defined for ImageBitmap");const ut=document.createElement("canvas").getContext("2d");if(ut!=null){const dt=_.height,st=_.width;if(ut.drawImage(_,0,0,st,dt),at=ut.getImageData(0,0,st,dt).data,_e!==void 0){if(_e.height!==void 0&&_e.height!==dt)throw new Error("Image input config height doesn't match ImageBitmap height");if(lt.height=dt,_e.width!==void 0&&_e.width!==st)throw new Error("Image input config width doesn't match ImageBitmap width");lt.width=st}else lt.height=dt,lt.width=st;return Ps.bufferToTensor(at,lt)}else throw new Error("Can not access image data")}else{if(ot)return new Promise((ut,dt)=>{const st=document.createElement("canvas"),it=st.getContext("2d");if(!_||!it)return dt();const ct=new Image;ct.crossOrigin="Anonymous",ct.src=_,ct.onload=()=>{st.width=ct.width,st.height=ct.height,it.drawImage(ct,0,0,st.width,st.height);const ft=it.getImageData(0,0,st.width,st.height);if(_e!==void 0){if(_e.height!==void 0&&_e.height!==st.height)throw new Error("Image input config height doesn't match ImageBitmap height");if(lt.height=st.height,_e.width!==void 0&&_e.width!==st.width)throw new Error("Image input config width doesn't match ImageBitmap width");lt.width=st.width}else lt.height=st.height,lt.width=st.width;ut(Ps.bufferToTensor(ft.data,lt))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(at!==void 0)return Ps.bufferToTensor(at,lt);throw new Error("Input data provided is not supported - aborted tensor creation")}toImageData(_){var _e,tt;const nt=document.createElement("canvas").getContext("2d");let rt;if(nt!=null){const ot=this.dims[3],at=this.dims[2],lt=this.dims[1],ut=_!==void 0&&_.format!==void 0?_.format:"RGB",dt=_!==void 0&&((_e=_.norm)===null||_e===void 0?void 0:_e.mean)!==void 0?_.norm.mean:255,st=_!==void 0&&((tt=_.norm)===null||tt===void 0?void 0:tt.bias)!==void 0?_.norm.bias:0,it=at*ot;if(_!==void 0){if(_.height!==void 0&&_.height!==at)throw new Error("Image output config height doesn't match tensor height");if(_.width!==void 0&&_.width!==ot)throw new Error("Image output config width doesn't match tensor width");if(_.format!==void 0&&lt===4&&_.format!=="RGBA"||lt===3&&_.format!=="RGB"&&_.format!=="BGR")throw new Error("Tensor format doesn't match input tensor dims")}const ct=4;let ft=0,ht=1,mt=2,pt=3,_t=0,vt=it,bt=it*2,wt=-1;ut==="RGBA"?(_t=0,vt=it,bt=it*2,wt=it*3):ut==="RGB"?(_t=0,vt=it,bt=it*2):ut==="RBG"&&(_t=0,bt=it,vt=it*2),rt=nt.createImageData(ot,at);for(let xt=0;xt<at*ot;ft+=ct,ht+=ct,mt+=ct,pt+=ct,xt++)rt.data[ft]=(this.data[_t++]-st)*dt,rt.data[ht]=(this.data[vt++]-st)*dt,rt.data[mt]=(this.data[bt++]-st)*dt,rt.data[pt]=wt===-1?255:(this.data[wt++]-st)*dt}else throw new Error("Can not access image data");return rt}reshape(_){return new Ps(this.type,this.data,_)}};const Tensor$1=Tensor$2;let InferenceSession$2=class Um{constructor(_){this.handler=_}async run(_,_e,tt){const nt={};let rt={};if(typeof _!="object"||_===null||_ instanceof Tensor$1||Array.isArray(_))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let ot=!0;if(typeof _e=="object"){if(_e===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(_e instanceof Tensor$1)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(_e)){if(_e.length===0)throw new TypeError("'fetches' cannot be an empty array.");ot=!1;for(const ut of _e){if(typeof ut!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(ut)===-1)throw new RangeError(`'fetches' contains invalid output name: ${ut}.`);nt[ut]=null}if(typeof tt=="object"&&tt!==null)rt=tt;else if(typeof tt<"u")throw new TypeError("'options' must be an object.")}else{let ut=!1;const dt=Object.getOwnPropertyNames(_e);for(const st of this.outputNames)if(dt.indexOf(st)!==-1){const it=_e[st];(it===null||it instanceof Tensor$1)&&(ut=!0,ot=!1,nt[st]=it)}if(ut){if(typeof tt=="object"&&tt!==null)rt=tt;else if(typeof tt<"u")throw new TypeError("'options' must be an object.")}else rt=_e}}else if(typeof _e<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const ut of this.inputNames)if(typeof _[ut]>"u")throw new Error(`input '${ut}' is missing in 'feeds'.`);if(ot)for(const ut of this.outputNames)nt[ut]=null;const at=await this.handler.run(_,nt,rt),lt={};for(const ut in at)Object.hasOwnProperty.call(at,ut)&&(lt[ut]=new Tensor$1(at[ut].type,at[ut].data,at[ut].dims));return lt}static async create(_,_e,tt,nt){let rt,ot={};if(typeof _=="string"){if(rt=_,typeof _e=="object"&&_e!==null)ot=_e;else if(typeof _e<"u")throw new TypeError("'options' must be an object.")}else if(_ instanceof Uint8Array){if(rt=_,typeof _e=="object"&&_e!==null)ot=_e;else if(typeof _e<"u")throw new TypeError("'options' must be an object.")}else if(_ instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&_ instanceof SharedArrayBuffer){const st=_;let it=0,ct=_.byteLength;if(typeof _e=="object"&&_e!==null)ot=_e;else if(typeof _e=="number"){if(it=_e,!Number.isSafeInteger(it))throw new RangeError("'byteOffset' must be an integer.");if(it<0||it>=st.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${st.byteLength}).`);if(ct=_.byteLength-it,typeof tt=="number"){if(ct=tt,!Number.isSafeInteger(ct))throw new RangeError("'byteLength' must be an integer.");if(ct<=0||it+ct>st.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${st.byteLength-it}].`);if(typeof nt=="object"&&nt!==null)ot=nt;else if(typeof nt<"u")throw new TypeError("'options' must be an object.")}else if(typeof tt<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof _e<"u")throw new TypeError("'options' must be an object.");rt=new Uint8Array(st,it,ct)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");const lt=(ot.executionProviders||[]).map(st=>typeof st=="string"?st:st.name),dt=await(await resolveBackend(lt)).createSessionHandler(rt,ot);return new Um(dt)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}};const InferenceSession$1=InferenceSession$2,lib=Object.freeze(Object.defineProperty({__proto__:null,InferenceSession:InferenceSession$1,Tensor:Tensor$1,env:env$2,registerBackend},Symbol.toStringTag,{value:"Module"})),require$$0=getAugmentedNamespace(lib);/*!
* ONNX Runtime Web v1.14.0
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/(function(module,exports){(function(et,_){module.exports=_(require$$0)})(self,__WEBPACK_EXTERNAL_MODULE__1670__=>(()=>{var __webpack_modules__={3474:(et,_,_e)=>{var tt,nt=(tt=(tt=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(rt){function ot(){return zt.buffer!=en&&on(zt.buffer),bn}function at(){return zt.buffer!=en&&on(zt.buffer),Un}function lt(){return zt.buffer!=en&&on(zt.buffer),mn}function ut(){return zt.buffer!=en&&on(zt.buffer),vn}function dt(){return zt.buffer!=en&&on(zt.buffer),In}var st,it,ct;rt=rt||{},st||(st=rt!==void 0?rt:{}),st.ready=new Promise(function(Ft,Ht){it=Ft,ct=Ht});var ft,ht,mt,pt,_t,vt,bt=Object.assign({},st),wt="./this.program",xt=(Ft,Ht)=>{throw Ht},Mt=typeof window=="object",At=typeof importScripts=="function",St=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",Tt=st.ENVIRONMENT_IS_PTHREAD||!1,Ct="";function It(Ft){return st.locateFile?st.locateFile(Ft,Ct):Ct+Ft}if(St){let Ft;Ct=At?_e(908).dirname(Ct)+"/":"//",vt=()=>{_t||(pt=_e(1384),_t=_e(908))},ft=function(Ht,Qt){return vt(),Ht=_t.normalize(Ht),pt.readFileSync(Ht,Qt?void 0:"utf8")},mt=Ht=>((Ht=ft(Ht,!0)).buffer||(Ht=new Uint8Array(Ht)),Ht),ht=(Ht,Qt,un)=>{vt(),Ht=_t.normalize(Ht),pt.readFile(Ht,function(wn,Pn){wn?un(wn):Qt(Pn.buffer)})},1<process.argv.length&&(wt=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",function(Ht){if(!(Ht instanceof fr))throw Ht}),process.on("unhandledRejection",function(Ht){throw Ht}),xt=(Ht,Qt)=>{if(Zt())throw process.exitCode=Ht,Qt;Qt instanceof fr||Ut("exiting due to exception: "+Qt),process.exit(Ht)},st.inspect=function(){return"[Emscripten Module object]"};try{Ft=_e(9925)}catch(Ht){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),Ht}_e.g.Worker=Ft.Worker}else(Mt||At)&&(At?Ct=self.location.href:typeof document<"u"&&document.currentScript&&(Ct=document.currentScript.src),tt&&(Ct=tt),Ct=Ct.indexOf("blob:")!==0?Ct.substr(0,Ct.replace(/[?#].*/,"").lastIndexOf("/")+1):"",St||(ft=Ft=>{var Ht=new XMLHttpRequest;return Ht.open("GET",Ft,!1),Ht.send(null),Ht.responseText},At&&(mt=Ft=>{var Ht=new XMLHttpRequest;return Ht.open("GET",Ft,!1),Ht.responseType="arraybuffer",Ht.send(null),new Uint8Array(Ht.response)}),ht=(Ft,Ht,Qt)=>{var un=new XMLHttpRequest;un.open("GET",Ft,!0),un.responseType="arraybuffer",un.onload=()=>{un.status==200||un.status==0&&un.response?Ht(un.response):Qt()},un.onerror=Qt,un.send(null)}));St&&typeof performance>"u"&&(_e.g.performance=_e(6953).performance);var $t=console.log.bind(console),Nt=console.warn.bind(console);St&&(vt(),$t=Ft=>pt.writeSync(1,Ft+`
`),Nt=Ft=>pt.writeSync(2,Ft+`
`));var Bt,Ot=st.print||$t,Ut=st.printErr||Nt;Object.assign(st,bt),bt=null,st.thisProgram&&(wt=st.thisProgram),st.quit&&(xt=st.quit),st.wasmBinary&&(Bt=st.wasmBinary);var Lt=st.noExitRuntime||!1;typeof WebAssembly!="object"&&Tn("no native wasm support detected");var zt,Yt,en,bn,Un,mn,vn,In,Cn=!1,En=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function jt(Ft,Ht,Qt){var un=(Ht>>>=0)+Qt;for(Qt=Ht;Ft[Qt]&&!(Qt>=un);)++Qt;if(16<Qt-Ht&&Ft.buffer&&En)return En.decode(Ft.buffer instanceof SharedArrayBuffer?Ft.slice(Ht,Qt):Ft.subarray(Ht,Qt));for(un="";Ht<Qt;){var wn=Ft[Ht++];if(128&wn){var Pn=63&Ft[Ht++];if((224&wn)==192)un+=String.fromCharCode((31&wn)<<6|Pn);else{var Yn=63&Ft[Ht++];65536>(wn=(240&wn)==224?(15&wn)<<12|Pn<<6|Yn:(7&wn)<<18|Pn<<12|Yn<<6|63&Ft[Ht++])?un+=String.fromCharCode(wn):(wn-=65536,un+=String.fromCharCode(55296|wn>>10,56320|1023&wn))}}else un+=String.fromCharCode(wn)}return un}function Kt(Ft,Ht){return(Ft>>>=0)?jt(at(),Ft,Ht):""}function nn(Ft,Ht,Qt,un){if(!(0<un))return 0;var wn=Qt>>>=0;un=Qt+un-1;for(var Pn=0;Pn<Ft.length;++Pn){var Yn=Ft.charCodeAt(Pn);if(55296<=Yn&&57343>=Yn&&(Yn=65536+((1023&Yn)<<10)|1023&Ft.charCodeAt(++Pn)),127>=Yn){if(Qt>=un)break;Ht[Qt++>>>0]=Yn}else{if(2047>=Yn){if(Qt+1>=un)break;Ht[Qt++>>>0]=192|Yn>>6}else{if(65535>=Yn){if(Qt+2>=un)break;Ht[Qt++>>>0]=224|Yn>>12}else{if(Qt+3>=un)break;Ht[Qt++>>>0]=240|Yn>>18,Ht[Qt++>>>0]=128|Yn>>12&63}Ht[Qt++>>>0]=128|Yn>>6&63}Ht[Qt++>>>0]=128|63&Yn}}return Ht[Qt>>>0]=0,Qt-wn}function Vt(Ft){for(var Ht=0,Qt=0;Qt<Ft.length;++Qt){var un=Ft.charCodeAt(Qt);127>=un?Ht++:2047>=un?Ht+=2:55296<=un&&57343>=un?(Ht+=4,++Qt):Ht+=3}return Ht}function on(Ft){en=Ft,st.HEAP8=bn=new Int8Array(Ft),st.HEAP16=new Int16Array(Ft),st.HEAP32=mn=new Int32Array(Ft),st.HEAPU8=Un=new Uint8Array(Ft),st.HEAPU16=new Uint16Array(Ft),st.HEAPU32=vn=new Uint32Array(Ft),st.HEAPF32=new Float32Array(Ft),st.HEAPF64=In=new Float64Array(Ft)}Tt&&(en=st.buffer);var dn=st.INITIAL_MEMORY||16777216;if(Tt)zt=st.wasmMemory,en=st.buffer;else if(st.wasmMemory)zt=st.wasmMemory;else if(!((zt=new WebAssembly.Memory({initial:dn/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw Ut("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),St&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");zt&&(en=zt.buffer),dn=en.byteLength,on(en);var Ln,Sn=[],Xn=[],Vn=[],Hn=[];function Zt(){return Lt||!1}function Gt(){var Ft=st.preRun.shift();Sn.unshift(Ft)}var fn,hn=0,xn=null;function Tn(Ft){throw Tt?postMessage({cmd:"onAbort",arg:Ft}):st.onAbort&&st.onAbort(Ft),Ut(Ft="Aborted("+Ft+")"),Cn=!0,Ft=new WebAssembly.RuntimeError(Ft+". Build with -sASSERTIONS for more info."),ct(Ft),Ft}function sr(){return fn.startsWith("data:application/octet-stream;base64,")}function Wn(){var Ft=fn;try{if(Ft==fn&&Bt)return new Uint8Array(Bt);if(mt)return mt(Ft);throw"both async and sync fetching of the wasm failed"}catch(Ht){Tn(Ht)}}fn="ort-wasm-threaded.wasm",sr()||(fn=It(fn));var or={};function fr(Ft){this.name="ExitStatus",this.message="Program terminated with exit("+Ft+")",this.status=Ft}function Gn(Ft){(Ft=Bn.Vb[Ft])||Tn(),Bn.mc(Ft)}function nr(Ft){var Ht=Bn.Cc();if(!Ht)return 6;Bn.ac.push(Ht),Bn.Vb[Ft.Ub]=Ht,Ht.Ub=Ft.Ub;var Qt={cmd:"run",start_routine:Ft.Ic,arg:Ft.zc,pthread_ptr:Ft.Ub};return Ht.$b=()=>{Qt.time=performance.now(),Ht.postMessage(Qt,Ft.Nc)},Ht.loaded&&(Ht.$b(),delete Ht.$b),0}function mr(Ft){if(Tt)return Mn(1,1,Ft);Zt()||(Bn.oc(),st.onExit&&st.onExit(Ft),Cn=!0),xt(Ft,new fr(Ft))}function hr(Ft,Ht){if(!Ht&&Tt)throw ir(Ft),"unwind";Zt()||Tt||(uo(),cn(Vn),Jo(0),jr[1].length&&gr(1,10),jr[2].length&&gr(2,10),Bn.oc()),mr(Ft)}var Bn={Yb:[],ac:[],qc:[],Vb:{},fc:function(){Tt&&Bn.Ec()},Pc:function(){},Ec:function(){Bn.receiveObjectTransfer=Bn.Gc,Bn.threadInitTLS=Bn.pc,Bn.setExitStatus=Bn.nc,Lt=!1},nc:function(){},oc:function(){for(var Ft of Object.values(Bn.Vb))Bn.mc(Ft);for(Ft of Bn.Yb)Ft.terminate();Bn.Yb=[]},mc:function(Ft){var Ht=Ft.Ub;delete Bn.Vb[Ht],Bn.Yb.push(Ft),Bn.ac.splice(Bn.ac.indexOf(Ft),1),Ft.Ub=0,ss(Ht)},Gc:function(){},pc:function(){Bn.qc.forEach(Ft=>Ft())},Fc:function(Ft,Ht){Ft.onmessage=Qt=>{var un=(Qt=Qt.data).cmd;if(Ft.Ub&&(Bn.Bc=Ft.Ub),Qt.targetThread&&Qt.targetThread!=co()){var wn=Bn.Vb[Qt.Qc];wn?wn.postMessage(Qt,Qt.transferList):Ut('Internal error! Worker sent a message "'+un+'" to target pthread '+Qt.targetThread+", but that thread no longer exists!")}else un==="processProxyingQueue"?pn(Qt.queue):un==="spawnThread"?nr(Qt):un==="cleanupThread"?Gn(Qt.thread):un==="killThread"?(Qt=Qt.thread,un=Bn.Vb[Qt],delete Bn.Vb[Qt],un.terminate(),ss(Qt),Bn.ac.splice(Bn.ac.indexOf(un),1),un.Ub=0):un==="cancelThread"?Bn.Vb[Qt.thread].postMessage({cmd:"cancel"}):un==="loaded"?(Ft.loaded=!0,Ht&&Ht(Ft),Ft.$b&&(Ft.$b(),delete Ft.$b)):un==="print"?Ot("Thread "+Qt.threadId+": "+Qt.text):un==="printErr"?Ut("Thread "+Qt.threadId+": "+Qt.text):un==="alert"?alert("Thread "+Qt.threadId+": "+Qt.text):Qt.target==="setimmediate"?Ft.postMessage(Qt):un==="onAbort"?st.onAbort&&st.onAbort(Qt.arg):un&&Ut("worker sent an unknown command "+un);Bn.Bc=void 0},Ft.onerror=Qt=>{throw Ut("worker sent an error! "+Qt.filename+":"+Qt.lineno+": "+Qt.message),Qt},St&&(Ft.on("message",function(Qt){Ft.onmessage({data:Qt})}),Ft.on("error",function(Qt){Ft.onerror(Qt)}),Ft.on("detachedExit",function(){})),Ft.postMessage({cmd:"load",urlOrBlob:st.mainScriptUrlOrBlob||tt,wasmMemory:zt,wasmModule:Yt})},yc:function(){var Ft=It("ort-wasm-threaded.worker.js");Bn.Yb.push(new Worker(Ft))},Cc:function(){return Bn.Yb.length==0&&(Bn.yc(),Bn.Fc(Bn.Yb[0])),Bn.Yb.pop()}};function cn(Ft){for(;0<Ft.length;)Ft.shift()(st)}function Fn(Ft){var Ht=Cr();return Ft=Ft(),Sr(Ht),Ft}function ir(Ft){if(Tt)return Mn(2,0,Ft);try{hr(Ft)}catch(Ht){Ht instanceof fr||Ht=="unwind"||xt(1,Ht)}}st.PThread=Bn,st.establishStackSpace=function(){var Ft=co(),Ht=lt()[Ft+44>>2>>>0];Ft=lt()[Ft+48>>2>>>0],Ml(Ht,Ht-Ft),Sr(Ht)};var ln=[];function On(Ft){var Ht=ln[Ft];return Ht||(Ft>=ln.length&&(ln.length=Ft+1),ln[Ft]=Ht=Ln.get(Ft)),Ht}st.invokeEntryPoint=function(Ft,Ht){Ft=On(Ft)(Ht),Zt()?Bn.nc(Ft):as(Ft)};var Dn,$n,Jn=[],qn=0,Kn=0;function ar(Ft){this.Zb=Ft,this.Sb=Ft-24,this.xc=function(Ht){ut()[this.Sb+4>>2>>>0]=Ht},this.bc=function(){return ut()[this.Sb+4>>2>>>0]},this.wc=function(Ht){ut()[this.Sb+8>>2>>>0]=Ht},this.Dc=function(){return ut()[this.Sb+8>>2>>>0]},this.rc=function(){lt()[this.Sb>>2>>>0]=0},this.hc=function(Ht){Ht=Ht?1:0,ot()[this.Sb+12>>0>>>0]=Ht},this.uc=function(){return ot()[this.Sb+12>>0>>>0]!=0},this.ic=function(Ht){Ht=Ht?1:0,ot()[this.Sb+13>>0>>>0]=Ht},this.kc=function(){return ot()[this.Sb+13>>0>>>0]!=0},this.fc=function(Ht,Qt){this.cc(0),this.xc(Ht),this.wc(Qt),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(lt(),this.Sb>>2,1)},this.Hc=function(){return Atomics.sub(lt(),this.Sb>>2,1)===1},this.cc=function(Ht){ut()[this.Sb+16>>2>>>0]=Ht},this.tc=function(){return ut()[this.Sb+16>>2>>>0]},this.vc=function(){if(Al(this.bc()))return ut()[this.Zb>>2>>>0];var Ht=this.tc();return Ht!==0?Ht:this.Zb}}function Ur(Ft){return to(new ar(Ft).Sb)}function wr(Ft,Ht,Qt,un){return Tt?Mn(3,1,Ft,Ht,Qt,un):Hr(Ft,Ht,Qt,un)}function Hr(Ft,Ht,Qt,un){if(typeof SharedArrayBuffer>"u")return Ut("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var wn=[];return Tt&&wn.length===0?wr(Ft,Ht,Qt,un):(Ft={Ic:Qt,Ub:Ft,zc:un,Nc:wn},Tt?(Ft.Oc="spawnThread",postMessage(Ft,wn),0):nr(Ft))}function Wr(Ft,Ht,Qt){return Tt?Mn(4,1,Ft,Ht,Qt):0}function jo(Ft,Ht){if(Tt)return Mn(5,1,Ft,Ht)}function go(Ft,Ht){if(Tt)return Mn(6,1,Ft,Ht)}function Uo(Ft,Ht,Qt){if(Tt)return Mn(7,1,Ft,Ht,Qt)}function zo(Ft,Ht,Qt){return Tt?Mn(8,1,Ft,Ht,Qt):0}function Co(Ft,Ht){if(Tt)return Mn(9,1,Ft,Ht)}function Ro(Ft,Ht,Qt){if(Tt)return Mn(10,1,Ft,Ht,Qt)}function vo(Ft,Ht,Qt,un){if(Tt)return Mn(11,1,Ft,Ht,Qt,un)}function Oo(Ft,Ht,Qt,un){if(Tt)return Mn(12,1,Ft,Ht,Qt,un)}function Ho(Ft,Ht,Qt,un){if(Tt)return Mn(13,1,Ft,Ht,Qt,un)}function Wo(Ft){if(Tt)return Mn(14,1,Ft)}function Wt(Ft,Ht){if(Tt)return Mn(15,1,Ft,Ht)}function rn(Ft,Ht,Qt){if(Tt)return Mn(16,1,Ft,Ht,Qt)}function pn(Ft){Atomics.store(lt(),Ft>>2,1),co()&&_s(Ft),Atomics.compareExchange(lt(),Ft>>2,1,0)}function Dt(Ft){return ut()[Ft>>>2]+4294967296*lt()[Ft+4>>>2]}function Xt(Ft,Ht,Qt,un,wn,Pn){return Tt?Mn(17,1,Ft,Ht,Qt,un,wn,Pn):-52}function Jt(Ft,Ht,Qt,un,wn,Pn){if(Tt)return Mn(18,1,Ft,Ht,Qt,un,wn,Pn)}function sn(Ft){var Ht=Vt(Ft)+1,Qt=qo(Ht);return Qt&&nn(Ft,ot(),Qt,Ht),Qt}function an(Ft,Ht,Qt){function un(Rr){return(Rr=Rr.toTimeString().match(/\(([A-Za-z ]+)\)$/))?Rr[1]:"GMT"}if(Tt)return Mn(19,1,Ft,Ht,Qt);var wn=new Date().getFullYear(),Pn=new Date(wn,0,1),Yn=new Date(wn,6,1);wn=Pn.getTimezoneOffset();var pr=Yn.getTimezoneOffset(),Ar=Math.max(wn,pr);lt()[Ft>>2>>>0]=60*Ar,lt()[Ht>>2>>>0]=+(wn!=pr),Ft=un(Pn),Ht=un(Yn),Ft=sn(Ft),Ht=sn(Ht),pr<wn?(ut()[Qt>>2>>>0]=Ft,ut()[Qt+4>>2>>>0]=Ht):(ut()[Qt>>2>>>0]=Ht,ut()[Qt+4>>2>>>0]=Ft)}function Mn(Ft,Ht){var Qt=arguments.length-2,un=arguments;return Fn(()=>{for(var wn=ys(8*Qt),Pn=wn>>3,Yn=0;Yn<Qt;Yn++){var pr=un[2+Yn];dt()[Pn+Yn>>>0]=pr}return El(Ft,Qt,wn,Ht)})}st.executeNotifiedProxyingQueue=pn,$n=St?()=>{var Ft=process.hrtime();return 1e3*Ft[0]+Ft[1]/1e6}:Tt?()=>performance.now()-st.__performance_now_clock_drift:()=>performance.now();var zn,Qn=[],rr={};function cr(){if(!zn){var Ft,Ht={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:wt||"./this.program"};for(Ft in rr)rr[Ft]===void 0?delete Ht[Ft]:Ht[Ft]=rr[Ft];var Qt=[];for(Ft in Ht)Qt.push(Ft+"="+Ht[Ft]);zn=Qt}return zn}function _n(Ft,Ht){if(Tt)return Mn(20,1,Ft,Ht);var Qt=0;return cr().forEach(function(un,wn){var Pn=Ht+Qt;for(wn=ut()[Ft+4*wn>>2>>>0]=Pn,Pn=0;Pn<un.length;++Pn)ot()[wn++>>0>>>0]=un.charCodeAt(Pn);ot()[wn>>0>>>0]=0,Qt+=un.length+1}),0}function Zn(Ft,Ht){if(Tt)return Mn(21,1,Ft,Ht);var Qt=cr();ut()[Ft>>2>>>0]=Qt.length;var un=0;return Qt.forEach(function(wn){un+=wn.length+1}),ut()[Ht>>2>>>0]=un,0}function _r(Ft){return Tt?Mn(22,1,Ft):52}function Ir(Ft,Ht,Qt,un){return Tt?Mn(23,1,Ft,Ht,Qt,un):52}function Lr(Ft,Ht,Qt,un,wn){return Tt?Mn(24,1,Ft,Ht,Qt,un,wn):70}var jr=[null,[],[]];function gr(Ft,Ht){var Qt=jr[Ft];Ht===0||Ht===10?((Ft===1?Ot:Ut)(jt(Qt,0)),Qt.length=0):Qt.push(Ht)}function tr(Ft,Ht,Qt,un){if(Tt)return Mn(25,1,Ft,Ht,Qt,un);for(var wn=0,Pn=0;Pn<Qt;Pn++){var Yn=ut()[Ht>>2>>>0],pr=ut()[Ht+4>>2>>>0];Ht+=8;for(var Ar=0;Ar<pr;Ar++)gr(Ft,at()[Yn+Ar>>>0]);wn+=pr}return ut()[un>>2>>>0]=wn,0}var Pr=0;function br(Ft){return Ft%4==0&&(Ft%100!=0||Ft%400==0)}var zr=[31,29,31,30,31,30,31,31,30,31,30,31],ao=[31,28,31,30,31,30,31,31,30,31,30,31];function Yr(Ft,Ht,Qt,un){function wn(Rn,Dr,Fr){for(Rn=typeof Rn=="number"?Rn.toString():Rn||"";Rn.length<Dr;)Rn=Fr[0]+Rn;return Rn}function Pn(Rn,Dr){return wn(Rn,Dr,"0")}function Yn(Rn,Dr){function Fr(Vo){return 0>Vo?-1:0<Vo?1:0}var xo;return(xo=Fr(Rn.getFullYear()-Dr.getFullYear()))===0&&(xo=Fr(Rn.getMonth()-Dr.getMonth()))===0&&(xo=Fr(Rn.getDate()-Dr.getDate())),xo}function pr(Rn){switch(Rn.getDay()){case 0:return new Date(Rn.getFullYear()-1,11,29);case 1:return Rn;case 2:return new Date(Rn.getFullYear(),0,3);case 3:return new Date(Rn.getFullYear(),0,2);case 4:return new Date(Rn.getFullYear(),0,1);case 5:return new Date(Rn.getFullYear()-1,11,31);case 6:return new Date(Rn.getFullYear()-1,11,30)}}function Ar(Rn){var Dr=Rn.Wb;for(Rn=new Date(new Date(Rn.Xb+1900,0,1).getTime());0<Dr;){var Fr=Rn.getMonth(),xo=(br(Rn.getFullYear())?zr:ao)[Fr];if(!(Dr>xo-Rn.getDate())){Rn.setDate(Rn.getDate()+Dr);break}Dr-=xo-Rn.getDate()+1,Rn.setDate(1),11>Fr?Rn.setMonth(Fr+1):(Rn.setMonth(0),Rn.setFullYear(Rn.getFullYear()+1))}return Fr=new Date(Rn.getFullYear()+1,0,4),Dr=pr(new Date(Rn.getFullYear(),0,4)),Fr=pr(Fr),0>=Yn(Dr,Rn)?0>=Yn(Fr,Rn)?Rn.getFullYear()+1:Rn.getFullYear():Rn.getFullYear()-1}var Rr=lt()[un+40>>2>>>0];for(var qr in un={Lc:lt()[un>>2>>>0],Kc:lt()[un+4>>2>>>0],dc:lt()[un+8>>2>>>0],jc:lt()[un+12>>2>>>0],ec:lt()[un+16>>2>>>0],Xb:lt()[un+20>>2>>>0],Tb:lt()[un+24>>2>>>0],Wb:lt()[un+28>>2>>>0],Rc:lt()[un+32>>2>>>0],Jc:lt()[un+36>>2>>>0],Mc:Rr?Kt(Rr):""},Qt=Kt(Qt),Rr={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})Qt=Qt.replace(new RegExp(qr,"g"),Rr[qr]);var Jr="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),bo="January February March April May June July August September October November December".split(" ");for(qr in Rr={"%a":function(Rn){return Jr[Rn.Tb].substring(0,3)},"%A":function(Rn){return Jr[Rn.Tb]},"%b":function(Rn){return bo[Rn.ec].substring(0,3)},"%B":function(Rn){return bo[Rn.ec]},"%C":function(Rn){return Pn((Rn.Xb+1900)/100|0,2)},"%d":function(Rn){return Pn(Rn.jc,2)},"%e":function(Rn){return wn(Rn.jc,2," ")},"%g":function(Rn){return Ar(Rn).toString().substring(2)},"%G":function(Rn){return Ar(Rn)},"%H":function(Rn){return Pn(Rn.dc,2)},"%I":function(Rn){return(Rn=Rn.dc)==0?Rn=12:12<Rn&&(Rn-=12),Pn(Rn,2)},"%j":function(Rn){for(var Dr=0,Fr=0;Fr<=Rn.ec-1;Dr+=(br(Rn.Xb+1900)?zr:ao)[Fr++]);return Pn(Rn.jc+Dr,3)},"%m":function(Rn){return Pn(Rn.ec+1,2)},"%M":function(Rn){return Pn(Rn.Kc,2)},"%n":function(){return`
`},"%p":function(Rn){return 0<=Rn.dc&&12>Rn.dc?"AM":"PM"},"%S":function(Rn){return Pn(Rn.Lc,2)},"%t":function(){return"	"},"%u":function(Rn){return Rn.Tb||7},"%U":function(Rn){return Pn(Math.floor((Rn.Wb+7-Rn.Tb)/7),2)},"%V":function(Rn){var Dr=Math.floor((Rn.Wb+7-(Rn.Tb+6)%7)/7);if(2>=(Rn.Tb+371-Rn.Wb-2)%7&&Dr++,Dr)Dr==53&&((Fr=(Rn.Tb+371-Rn.Wb)%7)==4||Fr==3&&br(Rn.Xb)||(Dr=1));else{Dr=52;var Fr=(Rn.Tb+7-Rn.Wb-1)%7;(Fr==4||Fr==5&&br(Rn.Xb%400-1))&&Dr++}return Pn(Dr,2)},"%w":function(Rn){return Rn.Tb},"%W":function(Rn){return Pn(Math.floor((Rn.Wb+7-(Rn.Tb+6)%7)/7),2)},"%y":function(Rn){return(Rn.Xb+1900).toString().substring(2)},"%Y":function(Rn){return Rn.Xb+1900},"%z":function(Rn){var Dr=0<=(Rn=Rn.Jc);return Rn=Math.abs(Rn)/60,(Dr?"+":"-")+("0000"+(Rn/60*100+Rn%60)).slice(-4)},"%Z":function(Rn){return Rn.Mc},"%%":function(){return"%"}},Qt=Qt.replace(/%%/g,"\0\0"),Rr)Qt.includes(qr)&&(Qt=Qt.replace(new RegExp(qr,"g"),Rr[qr](un)));return qr=function(Rn){var Dr=Array(Vt(Rn)+1);return nn(Rn,Dr,0,Dr.length),Dr}(Qt=Qt.replace(/\0\0/g,"%")),qr.length>Ht?0:(function(Rn,Dr){ot().set(Rn,Dr>>>0)}(qr,Ft),qr.length-1)}Bn.fc();var eo=[null,mr,ir,wr,Wr,jo,go,Uo,zo,Co,Ro,vo,Oo,Ho,Wo,Wt,rn,Xt,Jt,an,_n,Zn,_r,Ir,Lr,tr],Vr={b:function(Ft){return qo(Ft+24)+24},n:function(Ft){return(Ft=new ar(Ft)).uc()||(Ft.hc(!0),qn--),Ft.ic(!1),Jn.push(Ft),Ft.sc(),Ft.vc()},ma:function(Ft){throw Ut("Unexpected exception thrown, this is not properly supported - aborting"),Cn=!0,Ft},x:function(){Tr(0);var Ft=Jn.pop();if(Ft.Hc()&&!Ft.kc()){var Ht=Ft.Dc();Ht&&On(Ht)(Ft.Zb),Ur(Ft.Zb)}Kn=0},e:function(){var Ft=Kn;if(!Ft)return Pr=0;var Ht=new ar(Ft);Ht.cc(Ft);var Qt=Ht.bc();if(!Qt)return Pr=0,Ft;for(var un=Array.prototype.slice.call(arguments),wn=0;wn<un.length;wn++){var Pn=un[wn];if(Pn===0||Pn===Qt)break;if(Xo(Pn,Qt,Ht.Sb+16))return Pr=Pn,Ft}return Pr=Qt,Ft},l:function(){var Ft=Kn;if(!Ft)return Pr=0;var Ht=new ar(Ft);Ht.cc(Ft);var Qt=Ht.bc();if(!Qt)return Pr=0,Ft;for(var un=Array.prototype.slice.call(arguments),wn=0;wn<un.length;wn++){var Pn=un[wn];if(Pn===0||Pn===Qt)break;if(Xo(Pn,Qt,Ht.Sb+16))return Pr=Pn,Ft}return Pr=Qt,Ft},h:function(){var Ft=Kn;if(!Ft)return Pr=0;var Ht=new ar(Ft);Ht.cc(Ft);var Qt=Ht.bc();if(!Qt)return Pr=0,Ft;for(var un=Array.prototype.slice.call(arguments),wn=0;wn<un.length;wn++){var Pn=un[wn];if(Pn===0||Pn===Qt)break;if(Xo(Pn,Qt,Ht.Sb+16))return Pr=Pn,Ft}return Pr=Qt,Ft},t:Ur,M:function(){var Ft=Jn.pop();Ft||Tn("no exception to throw");var Ht=Ft.Zb;throw Ft.kc()||(Jn.push(Ft),Ft.ic(!0),Ft.hc(!1),qn++),Kn=Ht,Ht},c:function(Ft,Ht,Qt){throw new ar(Ft).fc(Ht,Qt),Kn=Ft,qn++,Ft},pa:function(){return qn},Fa:function(Ft){gs(Ft,!At,1,!Mt),Bn.pc()},T:function(Ft){Tt?postMessage({cmd:"cleanupThread",thread:Ft}):Gn(Ft)},xa:Hr,j:function(Ft){throw Kn||(Kn=Ft),Ft},H:Wr,Ma:jo,ua:go,wa:Uo,oa:zo,Ka:Co,Ca:Ro,Ja:vo,V:Oo,va:Ho,sa:Wo,La:Wt,ta:rn,Ta:function(){},X:function(){Tn("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){Tn("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(Ft,Ht,Qt,un){if(Ft==Ht)setTimeout(()=>pn(un));else if(Tt)postMessage({targetThread:Ft,cmd:"processProxyingQueue",queue:un});else{if(!(Ft=Bn.Vb[Ft]))return;Ft.postMessage({cmd:"processProxyingQueue",queue:un})}return 1},Ea:function(){return-1},Pa:function(Ft,Ht){Ft=new Date(1e3*Dt(Ft)),lt()[Ht>>2>>>0]=Ft.getUTCSeconds(),lt()[Ht+4>>2>>>0]=Ft.getUTCMinutes(),lt()[Ht+8>>2>>>0]=Ft.getUTCHours(),lt()[Ht+12>>2>>>0]=Ft.getUTCDate(),lt()[Ht+16>>2>>>0]=Ft.getUTCMonth(),lt()[Ht+20>>2>>>0]=Ft.getUTCFullYear()-1900,lt()[Ht+24>>2>>>0]=Ft.getUTCDay(),Ft=(Ft.getTime()-Date.UTC(Ft.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,lt()[Ht+28>>2>>>0]=Ft},Qa:function(Ft,Ht){Ft=new Date(1e3*Dt(Ft)),lt()[Ht>>2>>>0]=Ft.getSeconds(),lt()[Ht+4>>2>>>0]=Ft.getMinutes(),lt()[Ht+8>>2>>>0]=Ft.getHours(),lt()[Ht+12>>2>>>0]=Ft.getDate(),lt()[Ht+16>>2>>>0]=Ft.getMonth(),lt()[Ht+20>>2>>>0]=Ft.getFullYear()-1900,lt()[Ht+24>>2>>>0]=Ft.getDay();var Qt=new Date(Ft.getFullYear(),0,1),un=(Ft.getTime()-Qt.getTime())/864e5|0;lt()[Ht+28>>2>>>0]=un,lt()[Ht+36>>2>>>0]=-60*Ft.getTimezoneOffset(),un=new Date(Ft.getFullYear(),6,1).getTimezoneOffset(),Ft=0|(un!=(Qt=Qt.getTimezoneOffset())&&Ft.getTimezoneOffset()==Math.min(Qt,un)),lt()[Ht+32>>2>>>0]=Ft},Ra:function(Ft){var Ht=new Date(lt()[Ft+20>>2>>>0]+1900,lt()[Ft+16>>2>>>0],lt()[Ft+12>>2>>>0],lt()[Ft+8>>2>>>0],lt()[Ft+4>>2>>>0],lt()[Ft>>2>>>0],0),Qt=lt()[Ft+32>>2>>>0],un=Ht.getTimezoneOffset(),wn=new Date(Ht.getFullYear(),0,1),Pn=new Date(Ht.getFullYear(),6,1).getTimezoneOffset(),Yn=wn.getTimezoneOffset(),pr=Math.min(Yn,Pn);return 0>Qt?lt()[Ft+32>>2>>>0]=+(Pn!=Yn&&pr==un):0<Qt!=(pr==un)&&(Pn=Math.max(Yn,Pn),Ht.setTime(Ht.getTime()+6e4*((0<Qt?pr:Pn)-un))),lt()[Ft+24>>2>>>0]=Ht.getDay(),Qt=(Ht.getTime()-wn.getTime())/864e5|0,lt()[Ft+28>>2>>>0]=Qt,lt()[Ft>>2>>>0]=Ht.getSeconds(),lt()[Ft+4>>2>>>0]=Ht.getMinutes(),lt()[Ft+8>>2>>>0]=Ht.getHours(),lt()[Ft+12>>2>>>0]=Ht.getDate(),lt()[Ft+16>>2>>>0]=Ht.getMonth(),Ht.getTime()/1e3|0},Aa:Xt,Ba:Jt,Sa:function Ft(Ht,Qt,un){Ft.Ac||(Ft.Ac=!0,an(Ht,Qt,un))},y:function(){Tn("")},U:function(){if(!St&&!At){var Ft="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";Dn||(Dn={}),Dn[Ft]||(Dn[Ft]=1,St&&(Ft="warning: "+Ft),Ut(Ft))}},ra:function(){return 4294901760},B:$n,Ia:function(Ft,Ht,Qt){at().copyWithin(Ft>>>0,Ht>>>0,Ht+Qt>>>0)},F:function(){return St?_e(3993).cpus().length:navigator.hardwareConcurrency},Da:function(Ft,Ht,Qt){Qn.length=Ht,Qt>>=3;for(var un=0;un<Ht;un++)Qn[un]=dt()[Qt+un>>>0];return(0>Ft?or[-Ft-1]:eo[Ft]).apply(null,Qn)},qa:function(Ft){var Ht=at().length;if((Ft>>>=0)<=Ht||4294901760<Ft)return!1;for(var Qt=1;4>=Qt;Qt*=2){var un=Ht*(1+.2/Qt);un=Math.min(un,Ft+100663296);var wn=Math;un=Math.max(Ft,un),wn=wn.min.call(wn,4294901760,un+(65536-un%65536)%65536);e:{try{zt.grow(wn-en.byteLength+65535>>>16),on(zt.buffer);var Pn=1;break e}catch{}Pn=void 0}if(Pn)return!0}return!1},Na:function(){throw"unwind"},Ga:_n,Ha:Zn,J:hr,I:_r,S:Ir,ga:Lr,R:tr,d:function(){return Pr},na:function Ft(Ht,Qt){Ft.lc||(Ft.lc=function(){if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function"){var wn=new Uint8Array(1);return()=>(crypto.getRandomValues(wn),wn[0])}if(St)try{var Pn=_e(Object(function(){var Yn=new Error("Cannot find module 'crypto'");throw Yn.code="MODULE_NOT_FOUND",Yn}()));return()=>Pn.randomBytes(1)[0]}catch{}return()=>Tn("randomDevice")}());for(var un=0;un<Qt;un++)ot()[Ht+un>>0>>>0]=Ft.lc();return 0},ia:function(Ft,Ht,Qt){var un=Cr();try{return On(Ft)(Ht,Qt)}catch(wn){if(Sr(un),wn!==wn+0)throw wn;Tr(1,0)}},ja:function(Ft,Ht,Qt){var un=Cr();try{return On(Ft)(Ht,Qt)}catch(wn){if(Sr(un),wn!==wn+0)throw wn;Tr(1,0)}},K:function(Ft){var Ht=Cr();try{return On(Ft)()}catch(Qt){if(Sr(Ht),Qt!==Qt+0)throw Qt;Tr(1,0)}},f:function(Ft,Ht){var Qt=Cr();try{return On(Ft)(Ht)}catch(un){if(Sr(Qt),un!==un+0)throw un;Tr(1,0)}},P:function(Ft,Ht,Qt){var un=Cr();try{return On(Ft)(Ht,Qt)}catch(wn){if(Sr(un),wn!==wn+0)throw wn;Tr(1,0)}},Q:function(Ft,Ht,Qt){var un=Cr();try{return On(Ft)(Ht,Qt)}catch(wn){if(Sr(un),wn!==wn+0)throw wn;Tr(1,0)}},k:function(Ft,Ht,Qt){var un=Cr();try{return On(Ft)(Ht,Qt)}catch(wn){if(Sr(un),wn!==wn+0)throw wn;Tr(1,0)}},p:function(Ft,Ht,Qt,un){var wn=Cr();try{return On(Ft)(Ht,Qt,un)}catch(Pn){if(Sr(wn),Pn!==Pn+0)throw Pn;Tr(1,0)}},q:function(Ft,Ht,Qt,un,wn){var Pn=Cr();try{return On(Ft)(Ht,Qt,un,wn)}catch(Yn){if(Sr(Pn),Yn!==Yn+0)throw Yn;Tr(1,0)}},N:function(Ft,Ht,Qt,un,wn,Pn){var Yn=Cr();try{return On(Ft)(Ht,Qt,un,wn,Pn)}catch(pr){if(Sr(Yn),pr!==pr+0)throw pr;Tr(1,0)}},s:function(Ft,Ht,Qt,un,wn,Pn){var Yn=Cr();try{return On(Ft)(Ht,Qt,un,wn,Pn)}catch(pr){if(Sr(Yn),pr!==pr+0)throw pr;Tr(1,0)}},w:function(Ft,Ht,Qt,un,wn,Pn,Yn){var pr=Cr();try{return On(Ft)(Ht,Qt,un,wn,Pn,Yn)}catch(Ar){if(Sr(pr),Ar!==Ar+0)throw Ar;Tr(1,0)}},L:function(Ft,Ht,Qt,un,wn,Pn,Yn,pr){var Ar=Cr();try{return On(Ft)(Ht,Qt,un,wn,Pn,Yn,pr)}catch(Rr){if(Sr(Ar),Rr!==Rr+0)throw Rr;Tr(1,0)}},E:function(Ft,Ht,Qt,un,wn,Pn,Yn,pr,Ar,Rr,qr,Jr){var bo=Cr();try{return On(Ft)(Ht,Qt,un,wn,Pn,Yn,pr,Ar,Rr,qr,Jr)}catch(Rn){if(Sr(bo),Rn!==Rn+0)throw Rn;Tr(1,0)}},aa:function(Ft,Ht,Qt,un,wn,Pn,Yn,pr){var Ar=Cr();try{return Is(Ft,Ht,Qt,un,wn,Pn,Yn,pr)}catch(Rr){if(Sr(Ar),Rr!==Rr+0)throw Rr;Tr(1,0)}},_:function(Ft,Ht,Qt,un,wn,Pn,Yn){var pr=Cr();try{return Nr(Ft,Ht,Qt,un,wn,Pn,Yn)}catch(Ar){if(Sr(pr),Ar!==Ar+0)throw Ar;Tr(1,0)}},Z:function(Ft,Ht,Qt,un,wn){var Pn=Cr();try{return Rl(Ft,Ht,Qt,un,wn)}catch(Yn){if(Sr(Pn),Yn!==Yn+0)throw Yn;Tr(1,0)}},ca:function(Ft,Ht,Qt,un){var wn=Cr();try{return Cl(Ft,Ht,Qt,un)}catch(Pn){if(Sr(wn),Pn!==Pn+0)throw Pn;Tr(1,0)}},$:function(Ft){var Ht=Cr();try{return Rs(Ft)}catch(Qt){if(Sr(Ht),Qt!==Qt+0)throw Qt;Tr(1,0)}},ba:function(Ft,Ht){var Qt=Cr();try{return Zr(Ft,Ht)}catch(un){if(Sr(Qt),un!==un+0)throw un;Tr(1,0)}},Y:function(Ft,Ht,Qt){var un=Cr();try{return Ws(Ft,Ht,Qt)}catch(wn){if(Sr(un),wn!==wn+0)throw wn;Tr(1,0)}},g:function(Ft){var Ht=Cr();try{On(Ft)()}catch(Qt){if(Sr(Ht),Qt!==Qt+0)throw Qt;Tr(1,0)}},r:function(Ft,Ht){var Qt=Cr();try{On(Ft)(Ht)}catch(un){if(Sr(Qt),un!==un+0)throw un;Tr(1,0)}},i:function(Ft,Ht,Qt){var un=Cr();try{On(Ft)(Ht,Qt)}catch(wn){if(Sr(un),wn!==wn+0)throw wn;Tr(1,0)}},ha:function(Ft,Ht,Qt,un){var wn=Cr();try{On(Ft)(Ht,Qt,un)}catch(Pn){if(Sr(wn),Pn!==Pn+0)throw Pn;Tr(1,0)}},m:function(Ft,Ht,Qt,un){var wn=Cr();try{On(Ft)(Ht,Qt,un)}catch(Pn){if(Sr(wn),Pn!==Pn+0)throw Pn;Tr(1,0)}},v:function(Ft,Ht,Qt,un,wn){var Pn=Cr();try{On(Ft)(Ht,Qt,un,wn)}catch(Yn){if(Sr(Pn),Yn!==Yn+0)throw Yn;Tr(1,0)}},u:function(Ft,Ht,Qt,un,wn,Pn){var Yn=Cr();try{On(Ft)(Ht,Qt,un,wn,Pn)}catch(pr){if(Sr(Yn),pr!==pr+0)throw pr;Tr(1,0)}},O:function(Ft,Ht,Qt,un,wn,Pn,Yn){var pr=Cr();try{On(Ft)(Ht,Qt,un,wn,Pn,Yn)}catch(Ar){if(Sr(pr),Ar!==Ar+0)throw Ar;Tr(1,0)}},A:function(Ft,Ht,Qt,un,wn,Pn,Yn,pr){var Ar=Cr();try{On(Ft)(Ht,Qt,un,wn,Pn,Yn,pr)}catch(Rr){if(Sr(Ar),Rr!==Rr+0)throw Rr;Tr(1,0)}},ka:function(Ft,Ht,Qt,un,wn,Pn,Yn,pr,Ar){var Rr=Cr();try{On(Ft)(Ht,Qt,un,wn,Pn,Yn,pr,Ar)}catch(qr){if(Sr(Rr),qr!==qr+0)throw qr;Tr(1,0)}},C:function(Ft,Ht,Qt,un,wn,Pn,Yn,pr,Ar,Rr,qr){var Jr=Cr();try{On(Ft)(Ht,Qt,un,wn,Pn,Yn,pr,Ar,Rr,qr)}catch(bo){if(Sr(Jr),bo!==bo+0)throw bo;Tr(1,0)}},D:function(Ft,Ht,Qt,un,wn,Pn,Yn,pr,Ar,Rr,qr,Jr,bo,Rn,Dr,Fr){var xo=Cr();try{On(Ft)(Ht,Qt,un,wn,Pn,Yn,pr,Ar,Rr,qr,Jr,bo,Rn,Dr,Fr)}catch(Vo){if(Sr(xo),Vo!==Vo+0)throw Vo;Tr(1,0)}},fa:function(Ft,Ht,Qt,un,wn,Pn,Yn,pr){var Ar=Cr();try{Os(Ft,Ht,Qt,un,wn,Pn,Yn,pr)}catch(Rr){if(Sr(Ar),Rr!==Rr+0)throw Rr;Tr(1,0)}},da:function(Ft,Ht,Qt,un,wn,Pn,Yn,pr,Ar,Rr,qr,Jr){var bo=Cr();try{Pl(Ft,Ht,Qt,un,wn,Pn,Yn,pr,Ar,Rr,qr,Jr)}catch(Rn){if(Sr(bo),Rn!==Rn+0)throw Rn;Tr(1,0)}},ea:function(Ft,Ht,Qt,un,wn,Pn){var Yn=Cr();try{qs(Ft,Ht,Qt,un,wn,Pn)}catch(pr){if(Sr(Yn),pr!==pr+0)throw pr;Tr(1,0)}},o:function(Ft){return Ft},a:zt||st.wasmMemory,G:function(Ft){Pr=Ft},la:Yr,z:function(Ft,Ht,Qt,un){return Yr(Ft,Ht,Qt,un)}};(function(){function Ft(wn,Pn){st.asm=wn.exports,Bn.qc.push(st.asm.sb),Ln=st.asm.ub,Xn.unshift(st.asm.Va),Yt=Pn,Tt||(hn--,st.monitorRunDependencies&&st.monitorRunDependencies(hn),hn==0&&xn&&(wn=xn,xn=null,wn()))}function Ht(wn){Ft(wn.instance,wn.module)}function Qt(wn){return function(){if(!Bt&&(Mt||At)){if(typeof fetch=="function"&&!fn.startsWith("file://"))return fetch(fn,{credentials:"same-origin"}).then(function(Pn){if(!Pn.ok)throw"failed to load wasm binary file at '"+fn+"'";return Pn.arrayBuffer()}).catch(function(){return Wn()});if(ht)return new Promise(function(Pn,Yn){ht(fn,function(pr){Pn(new Uint8Array(pr))},Yn)})}return Promise.resolve().then(function(){return Wn()})}().then(function(Pn){return WebAssembly.instantiate(Pn,un)}).then(function(Pn){return Pn}).then(wn,function(Pn){Ut("failed to asynchronously prepare wasm: "+Pn),Tn(Pn)})}var un={a:Vr};if(Tt||(hn++,st.monitorRunDependencies&&st.monitorRunDependencies(hn)),st.instantiateWasm)try{return st.instantiateWasm(un,Ft)}catch(wn){return Ut("Module.instantiateWasm callback failed with error: "+wn),!1}(Bt||typeof WebAssembly.instantiateStreaming!="function"||sr()||fn.startsWith("file://")||St||typeof fetch!="function"?Qt(Ht):fetch(fn,{credentials:"same-origin"}).then(function(wn){return WebAssembly.instantiateStreaming(wn,un).then(Ht,function(Pn){return Ut("wasm streaming compile failed: "+Pn),Ut("falling back to ArrayBuffer instantiation"),Qt(Ht)})})).catch(ct)})(),st.___wasm_call_ctors=function(){return(st.___wasm_call_ctors=st.asm.Va).apply(null,arguments)},st._OrtInit=function(){return(st._OrtInit=st.asm.Wa).apply(null,arguments)},st._OrtCreateSessionOptions=function(){return(st._OrtCreateSessionOptions=st.asm.Xa).apply(null,arguments)},st._OrtAppendExecutionProvider=function(){return(st._OrtAppendExecutionProvider=st.asm.Ya).apply(null,arguments)},st._OrtAddSessionConfigEntry=function(){return(st._OrtAddSessionConfigEntry=st.asm.Za).apply(null,arguments)},st._OrtReleaseSessionOptions=function(){return(st._OrtReleaseSessionOptions=st.asm._a).apply(null,arguments)},st._OrtCreateSession=function(){return(st._OrtCreateSession=st.asm.$a).apply(null,arguments)},st._OrtReleaseSession=function(){return(st._OrtReleaseSession=st.asm.ab).apply(null,arguments)},st._OrtGetInputCount=function(){return(st._OrtGetInputCount=st.asm.bb).apply(null,arguments)},st._OrtGetOutputCount=function(){return(st._OrtGetOutputCount=st.asm.cb).apply(null,arguments)},st._OrtGetInputName=function(){return(st._OrtGetInputName=st.asm.db).apply(null,arguments)},st._OrtGetOutputName=function(){return(st._OrtGetOutputName=st.asm.eb).apply(null,arguments)},st._OrtFree=function(){return(st._OrtFree=st.asm.fb).apply(null,arguments)},st._OrtCreateTensor=function(){return(st._OrtCreateTensor=st.asm.gb).apply(null,arguments)},st._OrtGetTensorData=function(){return(st._OrtGetTensorData=st.asm.hb).apply(null,arguments)},st._OrtReleaseTensor=function(){return(st._OrtReleaseTensor=st.asm.ib).apply(null,arguments)},st._OrtCreateRunOptions=function(){return(st._OrtCreateRunOptions=st.asm.jb).apply(null,arguments)},st._OrtAddRunConfigEntry=function(){return(st._OrtAddRunConfigEntry=st.asm.kb).apply(null,arguments)},st._OrtReleaseRunOptions=function(){return(st._OrtReleaseRunOptions=st.asm.lb).apply(null,arguments)},st._OrtRun=function(){return(st._OrtRun=st.asm.mb).apply(null,arguments)},st._OrtEndProfiling=function(){return(st._OrtEndProfiling=st.asm.nb).apply(null,arguments)};var co=st._pthread_self=function(){return(co=st._pthread_self=st.asm.ob).apply(null,arguments)},qo=st._malloc=function(){return(qo=st._malloc=st.asm.pb).apply(null,arguments)},to=st._free=function(){return(to=st._free=st.asm.qb).apply(null,arguments)},Jo=st._fflush=function(){return(Jo=st._fflush=st.asm.rb).apply(null,arguments)};st.__emscripten_tls_init=function(){return(st.__emscripten_tls_init=st.asm.sb).apply(null,arguments)};var uo=st.___funcs_on_exit=function(){return(uo=st.___funcs_on_exit=st.asm.tb).apply(null,arguments)},gs=st.__emscripten_thread_init=function(){return(gs=st.__emscripten_thread_init=st.asm.vb).apply(null,arguments)};st.__emscripten_thread_crashed=function(){return(st.__emscripten_thread_crashed=st.asm.wb).apply(null,arguments)};var Cs,El=st._emscripten_run_in_main_runtime_thread_js=function(){return(El=st._emscripten_run_in_main_runtime_thread_js=st.asm.xb).apply(null,arguments)},_s=st.__emscripten_proxy_execute_task_queue=function(){return(_s=st.__emscripten_proxy_execute_task_queue=st.asm.yb).apply(null,arguments)},ss=st.__emscripten_thread_free_data=function(){return(ss=st.__emscripten_thread_free_data=st.asm.zb).apply(null,arguments)},as=st.__emscripten_thread_exit=function(){return(as=st.__emscripten_thread_exit=st.asm.Ab).apply(null,arguments)},Tr=st._setThrew=function(){return(Tr=st._setThrew=st.asm.Bb).apply(null,arguments)},Ml=st._emscripten_stack_set_limits=function(){return(Ml=st._emscripten_stack_set_limits=st.asm.Cb).apply(null,arguments)},Cr=st.stackSave=function(){return(Cr=st.stackSave=st.asm.Db).apply(null,arguments)},Sr=st.stackRestore=function(){return(Sr=st.stackRestore=st.asm.Eb).apply(null,arguments)},ys=st.stackAlloc=function(){return(ys=st.stackAlloc=st.asm.Fb).apply(null,arguments)},Xo=st.___cxa_can_catch=function(){return(Xo=st.___cxa_can_catch=st.asm.Gb).apply(null,arguments)},Al=st.___cxa_is_pointer_type=function(){return(Al=st.___cxa_is_pointer_type=st.asm.Hb).apply(null,arguments)},Rs=st.dynCall_j=function(){return(Rs=st.dynCall_j=st.asm.Ib).apply(null,arguments)},Nr=st.dynCall_iiiiij=function(){return(Nr=st.dynCall_iiiiij=st.asm.Jb).apply(null,arguments)},Ws=st.dynCall_jii=function(){return(Ws=st.dynCall_jii=st.asm.Kb).apply(null,arguments)},Os=st.dynCall_viiiiij=function(){return(Os=st.dynCall_viiiiij=st.asm.Lb).apply(null,arguments)},qs=st.dynCall_vjji=function(){return(qs=st.dynCall_vjji=st.asm.Mb).apply(null,arguments)},Pl=st.dynCall_viiijjjii=function(){return(Pl=st.dynCall_viiijjjii=st.asm.Nb).apply(null,arguments)},Cl=st.dynCall_iij=function(){return(Cl=st.dynCall_iij=st.asm.Ob).apply(null,arguments)},Zr=st.dynCall_ji=function(){return(Zr=st.dynCall_ji=st.asm.Pb).apply(null,arguments)},Is=st.dynCall_iiiiiij=function(){return(Is=st.dynCall_iiiiiij=st.asm.Qb).apply(null,arguments)},Rl=st.dynCall_iiij=function(){return(Rl=st.dynCall_iiij=st.asm.Rb).apply(null,arguments)};function Ls(){function Ft(){if(!Cs&&(Cs=!0,st.calledRun=!0,!Cn)&&(Tt||cn(Xn),it(st),st.onRuntimeInitialized&&st.onRuntimeInitialized(),!Tt)){if(st.postRun)for(typeof st.postRun=="function"&&(st.postRun=[st.postRun]);st.postRun.length;){var Ht=st.postRun.shift();Hn.unshift(Ht)}cn(Hn)}}if(!(0<hn))if(Tt)it(st),Tt||cn(Xn),postMessage({cmd:"loaded"});else{if(st.preRun)for(typeof st.preRun=="function"&&(st.preRun=[st.preRun]);st.preRun.length;)Gt();cn(Sn),0<hn||(st.setStatus?(st.setStatus("Running..."),setTimeout(function(){setTimeout(function(){st.setStatus("")},1),Ft()},1)):Ft())}}if(st.UTF8ToString=Kt,st.stringToUTF8=function(Ft,Ht,Qt){return nn(Ft,at(),Ht,Qt)},st.lengthBytesUTF8=Vt,st.keepRuntimeAlive=Zt,st.wasmMemory=zt,st.stackSave=Cr,st.stackRestore=Sr,st.stackAlloc=ys,st.ExitStatus=fr,st.PThread=Bn,xn=function Ft(){Cs||Ls(),Cs||(xn=Ft)},st.preInit)for(typeof st.preInit=="function"&&(st.preInit=[st.preInit]);0<st.preInit.length;)st.preInit.pop()();return Ls(),rt.ready});et.exports=nt},932:(et,_,_e)=>{var tt,nt=(tt=(tt=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(rt){var ot,at,lt;rt=rt||{},ot||(ot=rt!==void 0?rt:{}),ot.ready=new Promise(function(Wt,rn){at=Wt,lt=rn});var ut,dt,st,it,ct,ft,ht=Object.assign({},ot),mt="./this.program",pt=(Wt,rn)=>{throw rn},_t=typeof window=="object",vt=typeof importScripts=="function",bt=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",wt="";bt?(wt=vt?_e(908).dirname(wt)+"/":"//",ft=()=>{ct||(it=_e(1384),ct=_e(908))},ut=function(Wt,rn){return ft(),Wt=ct.normalize(Wt),it.readFileSync(Wt,rn?void 0:"utf8")},st=Wt=>((Wt=ut(Wt,!0)).buffer||(Wt=new Uint8Array(Wt)),Wt),dt=(Wt,rn,pn)=>{ft(),Wt=ct.normalize(Wt),it.readFile(Wt,function(Dt,Xt){Dt?pn(Dt):rn(Xt.buffer)})},1<process.argv.length&&(mt=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",function(Wt){if(!(Wt instanceof Xn))throw Wt}),process.on("unhandledRejection",function(Wt){throw Wt}),pt=(Wt,rn)=>{if(St||0<En)throw process.exitCode=Wt,rn;rn instanceof Xn||At("exiting due to exception: "+rn),process.exit(Wt)},ot.inspect=function(){return"[Emscripten Module object]"}):(_t||vt)&&(vt?wt=self.location.href:typeof document<"u"&&document.currentScript&&(wt=document.currentScript.src),tt&&(wt=tt),wt=wt.indexOf("blob:")!==0?wt.substr(0,wt.replace(/[?#].*/,"").lastIndexOf("/")+1):"",ut=Wt=>{var rn=new XMLHttpRequest;return rn.open("GET",Wt,!1),rn.send(null),rn.responseText},vt&&(st=Wt=>{var rn=new XMLHttpRequest;return rn.open("GET",Wt,!1),rn.responseType="arraybuffer",rn.send(null),new Uint8Array(rn.response)}),dt=(Wt,rn,pn)=>{var Dt=new XMLHttpRequest;Dt.open("GET",Wt,!0),Dt.responseType="arraybuffer",Dt.onload=()=>{Dt.status==200||Dt.status==0&&Dt.response?rn(Dt.response):pn()},Dt.onerror=pn,Dt.send(null)});var xt,Mt=ot.print||console.log.bind(console),At=ot.printErr||console.warn.bind(console);Object.assign(ot,ht),ht=null,ot.thisProgram&&(mt=ot.thisProgram),ot.quit&&(pt=ot.quit),ot.wasmBinary&&(xt=ot.wasmBinary);var St=ot.noExitRuntime||!1;typeof WebAssembly!="object"&&on("no native wasm support detected");var Tt,Ct,It,$t,Nt,Bt,Ot=!1,Ut=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function Lt(Wt,rn,pn){var Dt=(rn>>>=0)+pn;for(pn=rn;Wt[pn]&&!(pn>=Dt);)++pn;if(16<pn-rn&&Wt.buffer&&Ut)return Ut.decode(Wt.subarray(rn,pn));for(Dt="";rn<pn;){var Xt=Wt[rn++];if(128&Xt){var Jt=63&Wt[rn++];if((224&Xt)==192)Dt+=String.fromCharCode((31&Xt)<<6|Jt);else{var sn=63&Wt[rn++];65536>(Xt=(240&Xt)==224?(15&Xt)<<12|Jt<<6|sn:(7&Xt)<<18|Jt<<12|sn<<6|63&Wt[rn++])?Dt+=String.fromCharCode(Xt):(Xt-=65536,Dt+=String.fromCharCode(55296|Xt>>10,56320|1023&Xt))}}else Dt+=String.fromCharCode(Xt)}return Dt}function zt(Wt,rn){return(Wt>>>=0)?Lt($t,Wt,rn):""}function Yt(Wt,rn,pn,Dt){if(!(0<Dt))return 0;var Xt=pn>>>=0;Dt=pn+Dt-1;for(var Jt=0;Jt<Wt.length;++Jt){var sn=Wt.charCodeAt(Jt);if(55296<=sn&&57343>=sn&&(sn=65536+((1023&sn)<<10)|1023&Wt.charCodeAt(++Jt)),127>=sn){if(pn>=Dt)break;rn[pn++>>>0]=sn}else{if(2047>=sn){if(pn+1>=Dt)break;rn[pn++>>>0]=192|sn>>6}else{if(65535>=sn){if(pn+2>=Dt)break;rn[pn++>>>0]=224|sn>>12}else{if(pn+3>=Dt)break;rn[pn++>>>0]=240|sn>>18,rn[pn++>>>0]=128|sn>>12&63}rn[pn++>>>0]=128|sn>>6&63}rn[pn++>>>0]=128|63&sn}}return rn[pn>>>0]=0,pn-Xt}function en(Wt){for(var rn=0,pn=0;pn<Wt.length;++pn){var Dt=Wt.charCodeAt(pn);127>=Dt?rn++:2047>=Dt?rn+=2:55296<=Dt&&57343>=Dt?(rn+=4,++pn):rn+=3}return rn}function bn(){var Wt=Tt.buffer;Ct=Wt,ot.HEAP8=It=new Int8Array(Wt),ot.HEAP16=new Int16Array(Wt),ot.HEAP32=Nt=new Int32Array(Wt),ot.HEAPU8=$t=new Uint8Array(Wt),ot.HEAPU16=new Uint16Array(Wt),ot.HEAPU32=Bt=new Uint32Array(Wt),ot.HEAPF32=new Float32Array(Wt),ot.HEAPF64=new Float64Array(Wt)}var Un,mn=[],vn=[],In=[],Cn=[],En=0;function jt(){var Wt=ot.preRun.shift();mn.unshift(Wt)}var Kt,nn=0,Vt=null;function on(Wt){throw ot.onAbort&&ot.onAbort(Wt),At(Wt="Aborted("+Wt+")"),Ot=!0,Wt=new WebAssembly.RuntimeError(Wt+". Build with -sASSERTIONS for more info."),lt(Wt),Wt}function dn(){return Kt.startsWith("data:application/octet-stream;base64,")}if(Kt="ort-wasm.wasm",!dn()){var Ln=Kt;Kt=ot.locateFile?ot.locateFile(Ln,wt):wt+Ln}function Sn(){var Wt=Kt;try{if(Wt==Kt&&xt)return new Uint8Array(xt);if(st)return st(Wt);throw"both async and sync fetching of the wasm failed"}catch(rn){on(rn)}}function Xn(Wt){this.name="ExitStatus",this.message="Program terminated with exit("+Wt+")",this.status=Wt}function Vn(Wt){for(;0<Wt.length;)Wt.shift()(ot)}var Hn=[],Zt=0,Gt=0;function fn(Wt){this.Db=Wt,this.zb=Wt-24,this.Ub=function(rn){Bt[this.zb+4>>2>>>0]=rn},this.Eb=function(){return Bt[this.zb+4>>2>>>0]},this.Sb=function(rn){Bt[this.zb+8>>2>>>0]=rn},this.Wb=function(){return Bt[this.zb+8>>2>>>0]},this.Tb=function(){Nt[this.zb>>2>>>0]=0},this.Ib=function(rn){It[this.zb+12>>0>>>0]=rn?1:0},this.Pb=function(){return It[this.zb+12>>0>>>0]!=0},this.Jb=function(rn){It[this.zb+13>>0>>>0]=rn?1:0},this.Lb=function(){return It[this.zb+13>>0>>>0]!=0},this.Rb=function(rn,pn){this.Fb(0),this.Ub(rn),this.Sb(pn),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){Nt[this.zb>>2>>>0]+=1},this.Xb=function(){var rn=Nt[this.zb>>2>>>0];return Nt[this.zb>>2>>>0]=rn-1,rn===1},this.Fb=function(rn){Bt[this.zb+16>>2>>>0]=rn},this.Ob=function(){return Bt[this.zb+16>>2>>>0]},this.Qb=function(){if(Hr(this.Eb()))return Bt[this.Db>>2>>>0];var rn=this.Ob();return rn!==0?rn:this.Db}}function hn(Wt){return Dn(new fn(Wt).zb)}var xn=[];function Tn(Wt){var rn=xn[Wt];return rn||(Wt>=xn.length&&(xn.length=Wt+1),xn[Wt]=rn=Un.get(Wt)),rn}function sr(Wt){var rn=en(Wt)+1,pn=On(rn);return pn&&Yt(Wt,It,pn,rn),pn}var Wn={};function or(){if(!fr){var Wt,rn={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:mt||"./this.program"};for(Wt in Wn)Wn[Wt]===void 0?delete rn[Wt]:rn[Wt]=Wn[Wt];var pn=[];for(Wt in rn)pn.push(Wt+"="+rn[Wt]);fr=pn}return fr}var fr,Gn=[null,[],[]];function nr(Wt,rn){var pn=Gn[Wt];rn===0||rn===10?((Wt===1?Mt:At)(Lt(pn,0)),pn.length=0):pn.push(rn)}var mr=0;function hr(Wt){return Wt%4==0&&(Wt%100!=0||Wt%400==0)}var Bn=[31,29,31,30,31,30,31,31,30,31,30,31],cn=[31,28,31,30,31,30,31,31,30,31,30,31];function Fn(Wt,rn,pn,Dt){function Xt(_n,Zn,_r){for(_n=typeof _n=="number"?_n.toString():_n||"";_n.length<Zn;)_n=_r[0]+_n;return _n}function Jt(_n,Zn){return Xt(_n,Zn,"0")}function sn(_n,Zn){function _r(Lr){return 0>Lr?-1:0<Lr?1:0}var Ir;return(Ir=_r(_n.getFullYear()-Zn.getFullYear()))===0&&(Ir=_r(_n.getMonth()-Zn.getMonth()))===0&&(Ir=_r(_n.getDate()-Zn.getDate())),Ir}function an(_n){switch(_n.getDay()){case 0:return new Date(_n.getFullYear()-1,11,29);case 1:return _n;case 2:return new Date(_n.getFullYear(),0,3);case 3:return new Date(_n.getFullYear(),0,2);case 4:return new Date(_n.getFullYear(),0,1);case 5:return new Date(_n.getFullYear()-1,11,31);case 6:return new Date(_n.getFullYear()-1,11,30)}}function Mn(_n){var Zn=_n.Bb;for(_n=new Date(new Date(_n.Cb+1900,0,1).getTime());0<Zn;){var _r=_n.getMonth(),Ir=(hr(_n.getFullYear())?Bn:cn)[_r];if(!(Zn>Ir-_n.getDate())){_n.setDate(_n.getDate()+Zn);break}Zn-=Ir-_n.getDate()+1,_n.setDate(1),11>_r?_n.setMonth(_r+1):(_n.setMonth(0),_n.setFullYear(_n.getFullYear()+1))}return _r=new Date(_n.getFullYear()+1,0,4),Zn=an(new Date(_n.getFullYear(),0,4)),_r=an(_r),0>=sn(Zn,_n)?0>=sn(_r,_n)?_n.getFullYear()+1:_n.getFullYear():_n.getFullYear()-1}var zn=Nt[Dt+40>>2>>>0];for(var Qn in Dt={$b:Nt[Dt>>2>>>0],Zb:Nt[Dt+4>>2>>>0],Gb:Nt[Dt+8>>2>>>0],Kb:Nt[Dt+12>>2>>>0],Hb:Nt[Dt+16>>2>>>0],Cb:Nt[Dt+20>>2>>>0],Ab:Nt[Dt+24>>2>>>0],Bb:Nt[Dt+28>>2>>>0],bc:Nt[Dt+32>>2>>>0],Yb:Nt[Dt+36>>2>>>0],ac:zn?zt(zn):""},pn=zt(pn),zn={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})pn=pn.replace(new RegExp(Qn,"g"),zn[Qn]);var rr="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),cr="January February March April May June July August September October November December".split(" ");for(Qn in zn={"%a":function(_n){return rr[_n.Ab].substring(0,3)},"%A":function(_n){return rr[_n.Ab]},"%b":function(_n){return cr[_n.Hb].substring(0,3)},"%B":function(_n){return cr[_n.Hb]},"%C":function(_n){return Jt((_n.Cb+1900)/100|0,2)},"%d":function(_n){return Jt(_n.Kb,2)},"%e":function(_n){return Xt(_n.Kb,2," ")},"%g":function(_n){return Mn(_n).toString().substring(2)},"%G":function(_n){return Mn(_n)},"%H":function(_n){return Jt(_n.Gb,2)},"%I":function(_n){return(_n=_n.Gb)==0?_n=12:12<_n&&(_n-=12),Jt(_n,2)},"%j":function(_n){for(var Zn=0,_r=0;_r<=_n.Hb-1;Zn+=(hr(_n.Cb+1900)?Bn:cn)[_r++]);return Jt(_n.Kb+Zn,3)},"%m":function(_n){return Jt(_n.Hb+1,2)},"%M":function(_n){return Jt(_n.Zb,2)},"%n":function(){return`
`},"%p":function(_n){return 0<=_n.Gb&&12>_n.Gb?"AM":"PM"},"%S":function(_n){return Jt(_n.$b,2)},"%t":function(){return"	"},"%u":function(_n){return _n.Ab||7},"%U":function(_n){return Jt(Math.floor((_n.Bb+7-_n.Ab)/7),2)},"%V":function(_n){var Zn=Math.floor((_n.Bb+7-(_n.Ab+6)%7)/7);if(2>=(_n.Ab+371-_n.Bb-2)%7&&Zn++,Zn)Zn==53&&((_r=(_n.Ab+371-_n.Bb)%7)==4||_r==3&&hr(_n.Cb)||(Zn=1));else{Zn=52;var _r=(_n.Ab+7-_n.Bb-1)%7;(_r==4||_r==5&&hr(_n.Cb%400-1))&&Zn++}return Jt(Zn,2)},"%w":function(_n){return _n.Ab},"%W":function(_n){return Jt(Math.floor((_n.Bb+7-(_n.Ab+6)%7)/7),2)},"%y":function(_n){return(_n.Cb+1900).toString().substring(2)},"%Y":function(_n){return _n.Cb+1900},"%z":function(_n){var Zn=0<=(_n=_n.Yb);return _n=Math.abs(_n)/60,(Zn?"+":"-")+("0000"+(_n/60*100+_n%60)).slice(-4)},"%Z":function(_n){return _n.ac},"%%":function(){return"%"}},pn=pn.replace(/%%/g,"\0\0"),zn)pn.includes(Qn)&&(pn=pn.replace(new RegExp(Qn,"g"),zn[Qn](Dt)));return Qn=function(_n){var Zn=Array(en(_n)+1);return Yt(_n,Zn,0,Zn.length),Zn}(pn=pn.replace(/\0\0/g,"%")),Qn.length>rn?0:(It.set(Qn,Wt>>>0),Qn.length-1)}var ir={a:function(Wt){return On(Wt+24)+24},m:function(Wt){return(Wt=new fn(Wt)).Pb()||(Wt.Ib(!0),Zt--),Wt.Jb(!1),Hn.push(Wt),Wt.Nb(),Wt.Qb()},ia:function(Wt){throw At("Unexpected exception thrown, this is not properly supported - aborting"),Ot=!0,Wt},w:function(){qn(0);var Wt=Hn.pop();if(Wt.Xb()&&!Wt.Lb()){var rn=Wt.Wb();rn&&Tn(rn)(Wt.Db),hn(Wt.Db)}Gt=0},d:function(){var Wt=Gt;if(!Wt)return mr=0;var rn=new fn(Wt);rn.Fb(Wt);var pn=rn.Eb();if(!pn)return mr=0,Wt;for(var Dt=Array.prototype.slice.call(arguments),Xt=0;Xt<Dt.length;Xt++){var Jt=Dt[Xt];if(Jt===0||Jt===pn)break;if(wr(Jt,pn,rn.zb+16))return mr=Jt,Wt}return mr=pn,Wt},k:function(){var Wt=Gt;if(!Wt)return mr=0;var rn=new fn(Wt);rn.Fb(Wt);var pn=rn.Eb();if(!pn)return mr=0,Wt;for(var Dt=Array.prototype.slice.call(arguments),Xt=0;Xt<Dt.length;Xt++){var Jt=Dt[Xt];if(Jt===0||Jt===pn)break;if(wr(Jt,pn,rn.zb+16))return mr=Jt,Wt}return mr=pn,Wt},g:function(){var Wt=Gt;if(!Wt)return mr=0;var rn=new fn(Wt);rn.Fb(Wt);var pn=rn.Eb();if(!pn)return mr=0,Wt;for(var Dt=Array.prototype.slice.call(arguments),Xt=0;Xt<Dt.length;Xt++){var Jt=Dt[Xt];if(Jt===0||Jt===pn)break;if(wr(Jt,pn,rn.zb+16))return mr=Jt,Wt}return mr=pn,Wt},s:hn,L:function(){var Wt=Hn.pop();Wt||on("no exception to throw");var rn=Wt.Db;throw Wt.Lb()||(Hn.push(Wt),Wt.Jb(!0),Wt.Ib(!1),Zt++),Gt=rn,rn},b:function(Wt,rn,pn){throw new fn(Wt).Rb(rn,pn),Gt=Wt,Zt++,Wt},la:function(){return Zt},i:function(Wt){throw Gt||(Gt=Wt),Wt},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){on("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){on("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(Wt,rn){Wt=new Date(1e3*(Bt[Wt>>>2]+4294967296*Nt[Wt+4>>>2])),Nt[rn>>2>>>0]=Wt.getUTCSeconds(),Nt[rn+4>>2>>>0]=Wt.getUTCMinutes(),Nt[rn+8>>2>>>0]=Wt.getUTCHours(),Nt[rn+12>>2>>>0]=Wt.getUTCDate(),Nt[rn+16>>2>>>0]=Wt.getUTCMonth(),Nt[rn+20>>2>>>0]=Wt.getUTCFullYear()-1900,Nt[rn+24>>2>>>0]=Wt.getUTCDay(),Nt[rn+28>>2>>>0]=(Wt.getTime()-Date.UTC(Wt.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(Wt,rn){Wt=new Date(1e3*(Bt[Wt>>>2]+4294967296*Nt[Wt+4>>>2])),Nt[rn>>2>>>0]=Wt.getSeconds(),Nt[rn+4>>2>>>0]=Wt.getMinutes(),Nt[rn+8>>2>>>0]=Wt.getHours(),Nt[rn+12>>2>>>0]=Wt.getDate(),Nt[rn+16>>2>>>0]=Wt.getMonth(),Nt[rn+20>>2>>>0]=Wt.getFullYear()-1900,Nt[rn+24>>2>>>0]=Wt.getDay();var pn=new Date(Wt.getFullYear(),0,1);Nt[rn+28>>2>>>0]=(Wt.getTime()-pn.getTime())/864e5|0,Nt[rn+36>>2>>>0]=-60*Wt.getTimezoneOffset();var Dt=new Date(Wt.getFullYear(),6,1).getTimezoneOffset();pn=pn.getTimezoneOffset(),Nt[rn+32>>2>>>0]=0|(Dt!=pn&&Wt.getTimezoneOffset()==Math.min(pn,Dt))},Fa:function(Wt){var rn=new Date(Nt[Wt+20>>2>>>0]+1900,Nt[Wt+16>>2>>>0],Nt[Wt+12>>2>>>0],Nt[Wt+8>>2>>>0],Nt[Wt+4>>2>>>0],Nt[Wt>>2>>>0],0),pn=Nt[Wt+32>>2>>>0],Dt=rn.getTimezoneOffset(),Xt=new Date(rn.getFullYear(),0,1),Jt=new Date(rn.getFullYear(),6,1).getTimezoneOffset(),sn=Xt.getTimezoneOffset(),an=Math.min(sn,Jt);return 0>pn?Nt[Wt+32>>2>>>0]=+(Jt!=sn&&an==Dt):0<pn!=(an==Dt)&&(Jt=Math.max(sn,Jt),rn.setTime(rn.getTime()+6e4*((0<pn?an:Jt)-Dt))),Nt[Wt+24>>2>>>0]=rn.getDay(),Nt[Wt+28>>2>>>0]=(rn.getTime()-Xt.getTime())/864e5|0,Nt[Wt>>2>>>0]=rn.getSeconds(),Nt[Wt+4>>2>>>0]=rn.getMinutes(),Nt[Wt+8>>2>>>0]=rn.getHours(),Nt[Wt+12>>2>>>0]=rn.getDate(),Nt[Wt+16>>2>>>0]=rn.getMonth(),rn.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function Wt(rn,pn,Dt){Wt.Vb||(Wt.Vb=!0,function(Xt,Jt,sn){function an(cr){return(cr=cr.toTimeString().match(/\(([A-Za-z ]+)\)$/))?cr[1]:"GMT"}var Mn=new Date().getFullYear(),zn=new Date(Mn,0,1),Qn=new Date(Mn,6,1);Mn=zn.getTimezoneOffset();var rr=Qn.getTimezoneOffset();Nt[Xt>>2>>>0]=60*Math.max(Mn,rr),Nt[Jt>>2>>>0]=+(Mn!=rr),Xt=an(zn),Jt=an(Qn),Xt=sr(Xt),Jt=sr(Jt),rr<Mn?(Bt[sn>>2>>>0]=Xt,Bt[sn+4>>2>>>0]=Jt):(Bt[sn>>2>>>0]=Jt,Bt[sn+4>>2>>>0]=Xt)}(rn,pn,Dt))},B:function(){on("")},ma:function(){return 4294901760},I:bt?()=>{var Wt=process.hrtime();return 1e3*Wt[0]+Wt[1]/1e6}:()=>performance.now(),xa:function(Wt,rn,pn){$t.copyWithin(Wt>>>0,rn>>>0,rn+pn>>>0)},G:function(Wt){var rn=$t.length;if(4294901760<(Wt>>>=0))return!1;for(var pn=1;4>=pn;pn*=2){var Dt=rn*(1+.2/pn);Dt=Math.min(Dt,Wt+100663296);var Xt=Math;Dt=Math.max(Wt,Dt),Xt=Xt.min.call(Xt,4294901760,Dt+(65536-Dt%65536)%65536);e:{try{Tt.grow(Xt-Ct.byteLength+65535>>>16),bn();var Jt=1;break e}catch{}Jt=void 0}if(Jt)return!0}return!1},va:function(Wt,rn){var pn=0;return or().forEach(function(Dt,Xt){var Jt=rn+pn;for(Xt=Bt[Wt+4*Xt>>2>>>0]=Jt,Jt=0;Jt<Dt.length;++Jt)It[Xt++>>0>>>0]=Dt.charCodeAt(Jt);It[Xt>>0>>>0]=0,pn+=Dt.length+1}),0},wa:function(Wt,rn){var pn=or();Bt[Wt>>2>>>0]=pn.length;var Dt=0;return pn.forEach(function(Xt){Dt+=Xt.length+1}),Bt[rn>>2>>>0]=Dt,0},ba:function(Wt){St||0<En||(Jn(),Vn(In),$n(0),Gn[1].length&&nr(1,10),Gn[2].length&&nr(2,10)),St||0<En||(ot.onExit&&ot.onExit(Wt),Ot=!0),pt(Wt,new Xn(Wt))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(Wt,rn,pn,Dt){for(var Xt=0,Jt=0;Jt<pn;Jt++){var sn=Bt[rn>>2>>>0],an=Bt[rn+4>>2>>>0];rn+=8;for(var Mn=0;Mn<an;Mn++)nr(Wt,$t[sn+Mn>>>0]);Xt+=an}return Bt[Dt>>2>>>0]=Xt,0},c:function(){return mr},ja:function Wt(rn,pn){Wt.Mb||(Wt.Mb=function(){if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function"){var Xt=new Uint8Array(1);return()=>(crypto.getRandomValues(Xt),Xt[0])}if(bt)try{var Jt=_e(Object(function(){var sn=new Error("Cannot find module 'crypto'");throw sn.code="MODULE_NOT_FOUND",sn}()));return()=>Jt.randomBytes(1)[0]}catch{}return()=>on("randomDevice")}());for(var Dt=0;Dt<pn;Dt++)It[rn+Dt>>0>>>0]=Wt.Mb();return 0},ea:function(Wt,rn,pn){var Dt=Kn();try{return Tn(Wt)(rn,pn)}catch(Xt){if(ar(Dt),Xt!==Xt+0)throw Xt;qn(1,0)}},fa:function(Wt,rn,pn){var Dt=Kn();try{return Tn(Wt)(rn,pn)}catch(Xt){if(ar(Dt),Xt!==Xt+0)throw Xt;qn(1,0)}},J:function(Wt){var rn=Kn();try{return Tn(Wt)()}catch(pn){if(ar(rn),pn!==pn+0)throw pn;qn(1,0)}},e:function(Wt,rn){var pn=Kn();try{return Tn(Wt)(rn)}catch(Dt){if(ar(pn),Dt!==Dt+0)throw Dt;qn(1,0)}},N:function(Wt,rn,pn){var Dt=Kn();try{return Tn(Wt)(rn,pn)}catch(Xt){if(ar(Dt),Xt!==Xt+0)throw Xt;qn(1,0)}},O:function(Wt,rn,pn){var Dt=Kn();try{return Tn(Wt)(rn,pn)}catch(Xt){if(ar(Dt),Xt!==Xt+0)throw Xt;qn(1,0)}},j:function(Wt,rn,pn){var Dt=Kn();try{return Tn(Wt)(rn,pn)}catch(Xt){if(ar(Dt),Xt!==Xt+0)throw Xt;qn(1,0)}},o:function(Wt,rn,pn,Dt){var Xt=Kn();try{return Tn(Wt)(rn,pn,Dt)}catch(Jt){if(ar(Xt),Jt!==Jt+0)throw Jt;qn(1,0)}},p:function(Wt,rn,pn,Dt,Xt){var Jt=Kn();try{return Tn(Wt)(rn,pn,Dt,Xt)}catch(sn){if(ar(Jt),sn!==sn+0)throw sn;qn(1,0)}},M:function(Wt,rn,pn,Dt,Xt,Jt){var sn=Kn();try{return Tn(Wt)(rn,pn,Dt,Xt,Jt)}catch(an){if(ar(sn),an!==an+0)throw an;qn(1,0)}},r:function(Wt,rn,pn,Dt,Xt,Jt){var sn=Kn();try{return Tn(Wt)(rn,pn,Dt,Xt,Jt)}catch(an){if(ar(sn),an!==an+0)throw an;qn(1,0)}},v:function(Wt,rn,pn,Dt,Xt,Jt,sn){var an=Kn();try{return Tn(Wt)(rn,pn,Dt,Xt,Jt,sn)}catch(Mn){if(ar(an),Mn!==Mn+0)throw Mn;qn(1,0)}},K:function(Wt,rn,pn,Dt,Xt,Jt,sn,an){var Mn=Kn();try{return Tn(Wt)(rn,pn,Dt,Xt,Jt,sn,an)}catch(zn){if(ar(Mn),zn!==zn+0)throw zn;qn(1,0)}},D:function(Wt,rn,pn,Dt,Xt,Jt,sn,an,Mn,zn,Qn,rr){var cr=Kn();try{return Tn(Wt)(rn,pn,Dt,Xt,Jt,sn,an,Mn,zn,Qn,rr)}catch(_n){if(ar(cr),_n!==_n+0)throw _n;qn(1,0)}},X:function(Wt,rn,pn,Dt,Xt,Jt,sn,an){var Mn=Kn();try{return Oo(Wt,rn,pn,Dt,Xt,Jt,sn,an)}catch(zn){if(ar(Mn),zn!==zn+0)throw zn;qn(1,0)}},V:function(Wt,rn,pn,Dt,Xt,Jt,sn){var an=Kn();try{return jo(Wt,rn,pn,Dt,Xt,Jt,sn)}catch(Mn){if(ar(an),Mn!==Mn+0)throw Mn;qn(1,0)}},U:function(Wt,rn,pn,Dt,Xt){var Jt=Kn();try{return Ho(Wt,rn,pn,Dt,Xt)}catch(sn){if(ar(Jt),sn!==sn+0)throw sn;qn(1,0)}},Z:function(Wt,rn,pn,Dt){var Xt=Kn();try{return Ro(Wt,rn,pn,Dt)}catch(Jt){if(ar(Xt),Jt!==Jt+0)throw Jt;qn(1,0)}},W:function(Wt){var rn=Kn();try{return Wr(Wt)}catch(pn){if(ar(rn),pn!==pn+0)throw pn;qn(1,0)}},Y:function(Wt,rn){var pn=Kn();try{return vo(Wt,rn)}catch(Dt){if(ar(pn),Dt!==Dt+0)throw Dt;qn(1,0)}},T:function(Wt,rn,pn){var Dt=Kn();try{return go(Wt,rn,pn)}catch(Xt){if(ar(Dt),Xt!==Xt+0)throw Xt;qn(1,0)}},f:function(Wt){var rn=Kn();try{Tn(Wt)()}catch(pn){if(ar(rn),pn!==pn+0)throw pn;qn(1,0)}},q:function(Wt,rn){var pn=Kn();try{Tn(Wt)(rn)}catch(Dt){if(ar(pn),Dt!==Dt+0)throw Dt;qn(1,0)}},h:function(Wt,rn,pn){var Dt=Kn();try{Tn(Wt)(rn,pn)}catch(Xt){if(ar(Dt),Xt!==Xt+0)throw Xt;qn(1,0)}},da:function(Wt,rn,pn,Dt){var Xt=Kn();try{Tn(Wt)(rn,pn,Dt)}catch(Jt){if(ar(Xt),Jt!==Jt+0)throw Jt;qn(1,0)}},l:function(Wt,rn,pn,Dt){var Xt=Kn();try{Tn(Wt)(rn,pn,Dt)}catch(Jt){if(ar(Xt),Jt!==Jt+0)throw Jt;qn(1,0)}},t:function(Wt,rn,pn,Dt,Xt){var Jt=Kn();try{Tn(Wt)(rn,pn,Dt,Xt)}catch(sn){if(ar(Jt),sn!==sn+0)throw sn;qn(1,0)}},u:function(Wt,rn,pn,Dt,Xt,Jt){var sn=Kn();try{Tn(Wt)(rn,pn,Dt,Xt,Jt)}catch(an){if(ar(sn),an!==an+0)throw an;qn(1,0)}},x:function(Wt,rn,pn,Dt,Xt,Jt,sn){var an=Kn();try{Tn(Wt)(rn,pn,Dt,Xt,Jt,sn)}catch(Mn){if(ar(an),Mn!==Mn+0)throw Mn;qn(1,0)}},z:function(Wt,rn,pn,Dt,Xt,Jt,sn,an){var Mn=Kn();try{Tn(Wt)(rn,pn,Dt,Xt,Jt,sn,an)}catch(zn){if(ar(Mn),zn!==zn+0)throw zn;qn(1,0)}},ga:function(Wt,rn,pn,Dt,Xt,Jt,sn,an,Mn){var zn=Kn();try{Tn(Wt)(rn,pn,Dt,Xt,Jt,sn,an,Mn)}catch(Qn){if(ar(zn),Qn!==Qn+0)throw Qn;qn(1,0)}},A:function(Wt,rn,pn,Dt,Xt,Jt,sn,an,Mn,zn,Qn){var rr=Kn();try{Tn(Wt)(rn,pn,Dt,Xt,Jt,sn,an,Mn,zn,Qn)}catch(cr){if(ar(rr),cr!==cr+0)throw cr;qn(1,0)}},C:function(Wt,rn,pn,Dt,Xt,Jt,sn,an,Mn,zn,Qn,rr,cr,_n,Zn,_r){var Ir=Kn();try{Tn(Wt)(rn,pn,Dt,Xt,Jt,sn,an,Mn,zn,Qn,rr,cr,_n,Zn,_r)}catch(Lr){if(ar(Ir),Lr!==Lr+0)throw Lr;qn(1,0)}},aa:function(Wt,rn,pn,Dt,Xt,Jt,sn,an){var Mn=Kn();try{Uo(Wt,rn,pn,Dt,Xt,Jt,sn,an)}catch(zn){if(ar(Mn),zn!==zn+0)throw zn;qn(1,0)}},_:function(Wt,rn,pn,Dt,Xt,Jt,sn,an,Mn,zn,Qn,rr){var cr=Kn();try{Co(Wt,rn,pn,Dt,Xt,Jt,sn,an,Mn,zn,Qn,rr)}catch(_n){if(ar(cr),_n!==_n+0)throw _n;qn(1,0)}},$:function(Wt,rn,pn,Dt,Xt,Jt){var sn=Kn();try{zo(Wt,rn,pn,Dt,Xt,Jt)}catch(an){if(ar(sn),an!==an+0)throw an;qn(1,0)}},n:function(Wt){return Wt},F:function(Wt){mr=Wt},ha:Fn,y:function(Wt,rn,pn,Dt){return Fn(Wt,rn,pn,Dt)}};(function(){function Wt(Xt){ot.asm=Xt.exports,Tt=ot.asm.Ka,bn(),Un=ot.asm.ib,vn.unshift(ot.asm.La),nn--,ot.monitorRunDependencies&&ot.monitorRunDependencies(nn),nn==0&&Vt&&(Xt=Vt,Vt=null,Xt())}function rn(Xt){Wt(Xt.instance)}function pn(Xt){return function(){if(!xt&&(_t||vt)){if(typeof fetch=="function"&&!Kt.startsWith("file://"))return fetch(Kt,{credentials:"same-origin"}).then(function(Jt){if(!Jt.ok)throw"failed to load wasm binary file at '"+Kt+"'";return Jt.arrayBuffer()}).catch(function(){return Sn()});if(dt)return new Promise(function(Jt,sn){dt(Kt,function(an){Jt(new Uint8Array(an))},sn)})}return Promise.resolve().then(function(){return Sn()})}().then(function(Jt){return WebAssembly.instantiate(Jt,Dt)}).then(function(Jt){return Jt}).then(Xt,function(Jt){At("failed to asynchronously prepare wasm: "+Jt),on(Jt)})}var Dt={a:ir};if(nn++,ot.monitorRunDependencies&&ot.monitorRunDependencies(nn),ot.instantiateWasm)try{return ot.instantiateWasm(Dt,Wt)}catch(Xt){return At("Module.instantiateWasm callback failed with error: "+Xt),!1}(xt||typeof WebAssembly.instantiateStreaming!="function"||dn()||Kt.startsWith("file://")||bt||typeof fetch!="function"?pn(rn):fetch(Kt,{credentials:"same-origin"}).then(function(Xt){return WebAssembly.instantiateStreaming(Xt,Dt).then(rn,function(Jt){return At("wasm streaming compile failed: "+Jt),At("falling back to ArrayBuffer instantiation"),pn(rn)})})).catch(lt)})(),ot.___wasm_call_ctors=function(){return(ot.___wasm_call_ctors=ot.asm.La).apply(null,arguments)},ot._OrtInit=function(){return(ot._OrtInit=ot.asm.Ma).apply(null,arguments)},ot._OrtCreateSessionOptions=function(){return(ot._OrtCreateSessionOptions=ot.asm.Na).apply(null,arguments)},ot._OrtAppendExecutionProvider=function(){return(ot._OrtAppendExecutionProvider=ot.asm.Oa).apply(null,arguments)},ot._OrtAddSessionConfigEntry=function(){return(ot._OrtAddSessionConfigEntry=ot.asm.Pa).apply(null,arguments)},ot._OrtReleaseSessionOptions=function(){return(ot._OrtReleaseSessionOptions=ot.asm.Qa).apply(null,arguments)},ot._OrtCreateSession=function(){return(ot._OrtCreateSession=ot.asm.Ra).apply(null,arguments)},ot._OrtReleaseSession=function(){return(ot._OrtReleaseSession=ot.asm.Sa).apply(null,arguments)},ot._OrtGetInputCount=function(){return(ot._OrtGetInputCount=ot.asm.Ta).apply(null,arguments)},ot._OrtGetOutputCount=function(){return(ot._OrtGetOutputCount=ot.asm.Ua).apply(null,arguments)},ot._OrtGetInputName=function(){return(ot._OrtGetInputName=ot.asm.Va).apply(null,arguments)},ot._OrtGetOutputName=function(){return(ot._OrtGetOutputName=ot.asm.Wa).apply(null,arguments)},ot._OrtFree=function(){return(ot._OrtFree=ot.asm.Xa).apply(null,arguments)},ot._OrtCreateTensor=function(){return(ot._OrtCreateTensor=ot.asm.Ya).apply(null,arguments)},ot._OrtGetTensorData=function(){return(ot._OrtGetTensorData=ot.asm.Za).apply(null,arguments)},ot._OrtReleaseTensor=function(){return(ot._OrtReleaseTensor=ot.asm._a).apply(null,arguments)},ot._OrtCreateRunOptions=function(){return(ot._OrtCreateRunOptions=ot.asm.$a).apply(null,arguments)},ot._OrtAddRunConfigEntry=function(){return(ot._OrtAddRunConfigEntry=ot.asm.ab).apply(null,arguments)},ot._OrtReleaseRunOptions=function(){return(ot._OrtReleaseRunOptions=ot.asm.bb).apply(null,arguments)},ot._OrtRun=function(){return(ot._OrtRun=ot.asm.cb).apply(null,arguments)},ot._OrtEndProfiling=function(){return(ot._OrtEndProfiling=ot.asm.db).apply(null,arguments)};var ln,On=ot._malloc=function(){return(On=ot._malloc=ot.asm.eb).apply(null,arguments)},Dn=ot._free=function(){return(Dn=ot._free=ot.asm.fb).apply(null,arguments)},$n=ot._fflush=function(){return($n=ot._fflush=ot.asm.gb).apply(null,arguments)},Jn=ot.___funcs_on_exit=function(){return(Jn=ot.___funcs_on_exit=ot.asm.hb).apply(null,arguments)},qn=ot._setThrew=function(){return(qn=ot._setThrew=ot.asm.jb).apply(null,arguments)},Kn=ot.stackSave=function(){return(Kn=ot.stackSave=ot.asm.kb).apply(null,arguments)},ar=ot.stackRestore=function(){return(ar=ot.stackRestore=ot.asm.lb).apply(null,arguments)},Ur=ot.stackAlloc=function(){return(Ur=ot.stackAlloc=ot.asm.mb).apply(null,arguments)},wr=ot.___cxa_can_catch=function(){return(wr=ot.___cxa_can_catch=ot.asm.nb).apply(null,arguments)},Hr=ot.___cxa_is_pointer_type=function(){return(Hr=ot.___cxa_is_pointer_type=ot.asm.ob).apply(null,arguments)},Wr=ot.dynCall_j=function(){return(Wr=ot.dynCall_j=ot.asm.pb).apply(null,arguments)},jo=ot.dynCall_iiiiij=function(){return(jo=ot.dynCall_iiiiij=ot.asm.qb).apply(null,arguments)},go=ot.dynCall_jii=function(){return(go=ot.dynCall_jii=ot.asm.rb).apply(null,arguments)},Uo=ot.dynCall_viiiiij=function(){return(Uo=ot.dynCall_viiiiij=ot.asm.sb).apply(null,arguments)},zo=ot.dynCall_vjji=function(){return(zo=ot.dynCall_vjji=ot.asm.tb).apply(null,arguments)},Co=ot.dynCall_viiijjjii=function(){return(Co=ot.dynCall_viiijjjii=ot.asm.ub).apply(null,arguments)},Ro=ot.dynCall_iij=function(){return(Ro=ot.dynCall_iij=ot.asm.vb).apply(null,arguments)},vo=ot.dynCall_ji=function(){return(vo=ot.dynCall_ji=ot.asm.wb).apply(null,arguments)},Oo=ot.dynCall_iiiiiij=function(){return(Oo=ot.dynCall_iiiiiij=ot.asm.xb).apply(null,arguments)},Ho=ot.dynCall_iiij=function(){return(Ho=ot.dynCall_iiij=ot.asm.yb).apply(null,arguments)};function Wo(){function Wt(){if(!ln&&(ln=!0,ot.calledRun=!0,!Ot)){if(Vn(vn),at(ot),ot.onRuntimeInitialized&&ot.onRuntimeInitialized(),ot.postRun)for(typeof ot.postRun=="function"&&(ot.postRun=[ot.postRun]);ot.postRun.length;){var rn=ot.postRun.shift();Cn.unshift(rn)}Vn(Cn)}}if(!(0<nn)){if(ot.preRun)for(typeof ot.preRun=="function"&&(ot.preRun=[ot.preRun]);ot.preRun.length;)jt();Vn(mn),0<nn||(ot.setStatus?(ot.setStatus("Running..."),setTimeout(function(){setTimeout(function(){ot.setStatus("")},1),Wt()},1)):Wt())}}if(ot.UTF8ToString=zt,ot.stringToUTF8=function(Wt,rn,pn){return Yt(Wt,$t,rn,pn)},ot.lengthBytesUTF8=en,ot.stackSave=Kn,ot.stackRestore=ar,ot.stackAlloc=Ur,Vt=function Wt(){ln||Wo(),ln||(Vt=Wt)},ot.preInit)for(typeof ot.preInit=="function"&&(ot.preInit=[ot.preInit]);0<ot.preInit.length;)ot.preInit.pop()();return Wo(),rt.ready});et.exports=nt},4537:et=>{et.exports=function(_,_e){for(var tt=new Array(arguments.length-1),nt=0,rt=2,ot=!0;rt<arguments.length;)tt[nt++]=arguments[rt++];return new Promise(function(at,lt){tt[nt]=function(ut){if(ot)if(ot=!1,ut)lt(ut);else{for(var dt=new Array(arguments.length-1),st=0;st<dt.length;)dt[st++]=arguments[st];at.apply(null,dt)}};try{_.apply(_e||null,tt)}catch(ut){ot&&(ot=!1,lt(ut))}})}},7419:(et,_)=>{var _e=_;_e.length=function(at){var lt=at.length;if(!lt)return 0;for(var ut=0;--lt%4>1&&at.charAt(lt)==="=";)++ut;return Math.ceil(3*at.length)/4-ut};for(var tt=new Array(64),nt=new Array(123),rt=0;rt<64;)nt[tt[rt]=rt<26?rt+65:rt<52?rt+71:rt<62?rt-4:rt-59|43]=rt++;_e.encode=function(at,lt,ut){for(var dt,st=null,it=[],ct=0,ft=0;lt<ut;){var ht=at[lt++];switch(ft){case 0:it[ct++]=tt[ht>>2],dt=(3&ht)<<4,ft=1;break;case 1:it[ct++]=tt[dt|ht>>4],dt=(15&ht)<<2,ft=2;break;case 2:it[ct++]=tt[dt|ht>>6],it[ct++]=tt[63&ht],ft=0}ct>8191&&((st||(st=[])).push(String.fromCharCode.apply(String,it)),ct=0)}return ft&&(it[ct++]=tt[dt],it[ct++]=61,ft===1&&(it[ct++]=61)),st?(ct&&st.push(String.fromCharCode.apply(String,it.slice(0,ct))),st.join("")):String.fromCharCode.apply(String,it.slice(0,ct))};var ot="invalid encoding";_e.decode=function(at,lt,ut){for(var dt,st=ut,it=0,ct=0;ct<at.length;){var ft=at.charCodeAt(ct++);if(ft===61&&it>1)break;if((ft=nt[ft])===void 0)throw Error(ot);switch(it){case 0:dt=ft,it=1;break;case 1:lt[ut++]=dt<<2|(48&ft)>>4,dt=ft,it=2;break;case 2:lt[ut++]=(15&dt)<<4|(60&ft)>>2,dt=ft,it=3;break;case 3:lt[ut++]=(3&dt)<<6|ft,it=0}}if(it===1)throw Error(ot);return ut-st},_e.test=function(at){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(at)}},9211:et=>{function _(){this._listeners={}}et.exports=_,_.prototype.on=function(_e,tt,nt){return(this._listeners[_e]||(this._listeners[_e]=[])).push({fn:tt,ctx:nt||this}),this},_.prototype.off=function(_e,tt){if(_e===void 0)this._listeners={};else if(tt===void 0)this._listeners[_e]=[];else for(var nt=this._listeners[_e],rt=0;rt<nt.length;)nt[rt].fn===tt?nt.splice(rt,1):++rt;return this},_.prototype.emit=function(_e){var tt=this._listeners[_e];if(tt){for(var nt=[],rt=1;rt<arguments.length;)nt.push(arguments[rt++]);for(rt=0;rt<tt.length;)tt[rt].fn.apply(tt[rt++].ctx,nt)}return this}},945:et=>{function _(ot){return typeof Float32Array<"u"?function(){var at=new Float32Array([-0]),lt=new Uint8Array(at.buffer),ut=lt[3]===128;function dt(ft,ht,mt){at[0]=ft,ht[mt]=lt[0],ht[mt+1]=lt[1],ht[mt+2]=lt[2],ht[mt+3]=lt[3]}function st(ft,ht,mt){at[0]=ft,ht[mt]=lt[3],ht[mt+1]=lt[2],ht[mt+2]=lt[1],ht[mt+3]=lt[0]}function it(ft,ht){return lt[0]=ft[ht],lt[1]=ft[ht+1],lt[2]=ft[ht+2],lt[3]=ft[ht+3],at[0]}function ct(ft,ht){return lt[3]=ft[ht],lt[2]=ft[ht+1],lt[1]=ft[ht+2],lt[0]=ft[ht+3],at[0]}ot.writeFloatLE=ut?dt:st,ot.writeFloatBE=ut?st:dt,ot.readFloatLE=ut?it:ct,ot.readFloatBE=ut?ct:it}():function(){function at(ut,dt,st,it){var ct=dt<0?1:0;if(ct&&(dt=-dt),dt===0)ut(1/dt>0?0:2147483648,st,it);else if(isNaN(dt))ut(2143289344,st,it);else if(dt>34028234663852886e22)ut((ct<<31|2139095040)>>>0,st,it);else if(dt<11754943508222875e-54)ut((ct<<31|Math.round(dt/1401298464324817e-60))>>>0,st,it);else{var ft=Math.floor(Math.log(dt)/Math.LN2);ut((ct<<31|ft+127<<23|8388607&Math.round(dt*Math.pow(2,-ft)*8388608))>>>0,st,it)}}function lt(ut,dt,st){var it=ut(dt,st),ct=2*(it>>31)+1,ft=it>>>23&255,ht=8388607&it;return ft===255?ht?NaN:ct*(1/0):ft===0?1401298464324817e-60*ct*ht:ct*Math.pow(2,ft-150)*(ht+8388608)}ot.writeFloatLE=at.bind(null,_e),ot.writeFloatBE=at.bind(null,tt),ot.readFloatLE=lt.bind(null,nt),ot.readFloatBE=lt.bind(null,rt)}(),typeof Float64Array<"u"?function(){var at=new Float64Array([-0]),lt=new Uint8Array(at.buffer),ut=lt[7]===128;function dt(ft,ht,mt){at[0]=ft,ht[mt]=lt[0],ht[mt+1]=lt[1],ht[mt+2]=lt[2],ht[mt+3]=lt[3],ht[mt+4]=lt[4],ht[mt+5]=lt[5],ht[mt+6]=lt[6],ht[mt+7]=lt[7]}function st(ft,ht,mt){at[0]=ft,ht[mt]=lt[7],ht[mt+1]=lt[6],ht[mt+2]=lt[5],ht[mt+3]=lt[4],ht[mt+4]=lt[3],ht[mt+5]=lt[2],ht[mt+6]=lt[1],ht[mt+7]=lt[0]}function it(ft,ht){return lt[0]=ft[ht],lt[1]=ft[ht+1],lt[2]=ft[ht+2],lt[3]=ft[ht+3],lt[4]=ft[ht+4],lt[5]=ft[ht+5],lt[6]=ft[ht+6],lt[7]=ft[ht+7],at[0]}function ct(ft,ht){return lt[7]=ft[ht],lt[6]=ft[ht+1],lt[5]=ft[ht+2],lt[4]=ft[ht+3],lt[3]=ft[ht+4],lt[2]=ft[ht+5],lt[1]=ft[ht+6],lt[0]=ft[ht+7],at[0]}ot.writeDoubleLE=ut?dt:st,ot.writeDoubleBE=ut?st:dt,ot.readDoubleLE=ut?it:ct,ot.readDoubleBE=ut?ct:it}():function(){function at(ut,dt,st,it,ct,ft){var ht=it<0?1:0;if(ht&&(it=-it),it===0)ut(0,ct,ft+dt),ut(1/it>0?0:2147483648,ct,ft+st);else if(isNaN(it))ut(0,ct,ft+dt),ut(2146959360,ct,ft+st);else if(it>17976931348623157e292)ut(0,ct,ft+dt),ut((ht<<31|2146435072)>>>0,ct,ft+st);else{var mt;if(it<22250738585072014e-324)ut((mt=it/5e-324)>>>0,ct,ft+dt),ut((ht<<31|mt/4294967296)>>>0,ct,ft+st);else{var pt=Math.floor(Math.log(it)/Math.LN2);pt===1024&&(pt=1023),ut(4503599627370496*(mt=it*Math.pow(2,-pt))>>>0,ct,ft+dt),ut((ht<<31|pt+1023<<20|1048576*mt&1048575)>>>0,ct,ft+st)}}}function lt(ut,dt,st,it,ct){var ft=ut(it,ct+dt),ht=ut(it,ct+st),mt=2*(ht>>31)+1,pt=ht>>>20&2047,_t=4294967296*(1048575&ht)+ft;return pt===2047?_t?NaN:mt*(1/0):pt===0?5e-324*mt*_t:mt*Math.pow(2,pt-1075)*(_t+4503599627370496)}ot.writeDoubleLE=at.bind(null,_e,0,4),ot.writeDoubleBE=at.bind(null,tt,4,0),ot.readDoubleLE=lt.bind(null,nt,0,4),ot.readDoubleBE=lt.bind(null,rt,4,0)}(),ot}function _e(ot,at,lt){at[lt]=255&ot,at[lt+1]=ot>>>8&255,at[lt+2]=ot>>>16&255,at[lt+3]=ot>>>24}function tt(ot,at,lt){at[lt]=ot>>>24,at[lt+1]=ot>>>16&255,at[lt+2]=ot>>>8&255,at[lt+3]=255&ot}function nt(ot,at){return(ot[at]|ot[at+1]<<8|ot[at+2]<<16|ot[at+3]<<24)>>>0}function rt(ot,at){return(ot[at]<<24|ot[at+1]<<16|ot[at+2]<<8|ot[at+3])>>>0}et.exports=_(_)},7199:module=>{function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(et){}return null}module.exports=inquire},6662:et=>{et.exports=function(_,_e,tt){var nt=tt||8192,rt=nt>>>1,ot=null,at=nt;return function(lt){if(lt<1||lt>rt)return _(lt);at+lt>nt&&(ot=_(nt),at=0);var ut=_e.call(ot,at,at+=lt);return 7&at&&(at=1+(7|at)),ut}}},4997:(et,_)=>{var _e=_;_e.length=function(tt){for(var nt=0,rt=0,ot=0;ot<tt.length;++ot)(rt=tt.charCodeAt(ot))<128?nt+=1:rt<2048?nt+=2:(64512&rt)==55296&&(64512&tt.charCodeAt(ot+1))==56320?(++ot,nt+=4):nt+=3;return nt},_e.read=function(tt,nt,rt){if(rt-nt<1)return"";for(var ot,at=null,lt=[],ut=0;nt<rt;)(ot=tt[nt++])<128?lt[ut++]=ot:ot>191&&ot<224?lt[ut++]=(31&ot)<<6|63&tt[nt++]:ot>239&&ot<365?(ot=((7&ot)<<18|(63&tt[nt++])<<12|(63&tt[nt++])<<6|63&tt[nt++])-65536,lt[ut++]=55296+(ot>>10),lt[ut++]=56320+(1023&ot)):lt[ut++]=(15&ot)<<12|(63&tt[nt++])<<6|63&tt[nt++],ut>8191&&((at||(at=[])).push(String.fromCharCode.apply(String,lt)),ut=0);return at?(ut&&at.push(String.fromCharCode.apply(String,lt.slice(0,ut))),at.join("")):String.fromCharCode.apply(String,lt.slice(0,ut))},_e.write=function(tt,nt,rt){for(var ot,at,lt=rt,ut=0;ut<tt.length;++ut)(ot=tt.charCodeAt(ut))<128?nt[rt++]=ot:ot<2048?(nt[rt++]=ot>>6|192,nt[rt++]=63&ot|128):(64512&ot)==55296&&(64512&(at=tt.charCodeAt(ut+1)))==56320?(ot=65536+((1023&ot)<<10)+(1023&at),++ut,nt[rt++]=ot>>18|240,nt[rt++]=ot>>12&63|128,nt[rt++]=ot>>6&63|128,nt[rt++]=63&ot|128):(nt[rt++]=ot>>12|224,nt[rt++]=ot>>6&63|128,nt[rt++]=63&ot|128);return rt-lt}},3442:(et,_)=>{_.__esModule=!0;var _e=function(){function tt(nt){if(!nt)throw new TypeError("Invalid argument; `value` has no value.");this.value=tt.EMPTY,nt&&tt.isGuid(nt)&&(this.value=nt)}return tt.isGuid=function(nt){var rt=nt.toString();return nt&&(nt instanceof tt||tt.validator.test(rt))},tt.create=function(){return new tt([tt.gen(2),tt.gen(1),tt.gen(1),tt.gen(1),tt.gen(3)].join("-"))},tt.createEmpty=function(){return new tt("emptyguid")},tt.parse=function(nt){return new tt(nt)},tt.raw=function(){return[tt.gen(2),tt.gen(1),tt.gen(1),tt.gen(1),tt.gen(3)].join("-")},tt.gen=function(nt){for(var rt="",ot=0;ot<nt;ot++)rt+=(65536*(1+Math.random())|0).toString(16).substring(1);return rt},tt.prototype.equals=function(nt){return tt.isGuid(nt)&&this.value===nt.toString()},tt.prototype.isEmpty=function(){return this.value===tt.EMPTY},tt.prototype.toString=function(){return this.value},tt.prototype.toJSON=function(){return{value:this.value}},tt.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),tt.EMPTY="00000000-0000-0000-0000-000000000000",tt}();_.Guid=_e},3720:et=>{et.exports=_e;var _=null;try{_=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function _e(St,Tt,Ct){this.low=0|St,this.high=0|Tt,this.unsigned=!!Ct}function tt(St){return(St&&St.__isLong__)===!0}_e.prototype.__isLong__,Object.defineProperty(_e.prototype,"__isLong__",{value:!0}),_e.isLong=tt;var nt={},rt={};function ot(St,Tt){var Ct,It,$t;return Tt?($t=0<=(St>>>=0)&&St<256)&&(It=rt[St])?It:(Ct=lt(St,(0|St)<0?-1:0,!0),$t&&(rt[St]=Ct),Ct):($t=-128<=(St|=0)&&St<128)&&(It=nt[St])?It:(Ct=lt(St,St<0?-1:0,!1),$t&&(nt[St]=Ct),Ct)}function at(St,Tt){if(isNaN(St))return Tt?pt:mt;if(Tt){if(St<0)return pt;if(St>=ct)return xt}else{if(St<=-ft)return Mt;if(St+1>=ft)return wt}return St<0?at(-St,Tt).neg():lt(St%it|0,St/it|0,Tt)}function lt(St,Tt,Ct){return new _e(St,Tt,Ct)}_e.fromInt=ot,_e.fromNumber=at,_e.fromBits=lt;var ut=Math.pow;function dt(St,Tt,Ct){if(St.length===0)throw Error("empty string");if(St==="NaN"||St==="Infinity"||St==="+Infinity"||St==="-Infinity")return mt;if(typeof Tt=="number"?(Ct=Tt,Tt=!1):Tt=!!Tt,(Ct=Ct||10)<2||36<Ct)throw RangeError("radix");var It;if((It=St.indexOf("-"))>0)throw Error("interior hyphen");if(It===0)return dt(St.substring(1),Tt,Ct).neg();for(var $t=at(ut(Ct,8)),Nt=mt,Bt=0;Bt<St.length;Bt+=8){var Ot=Math.min(8,St.length-Bt),Ut=parseInt(St.substring(Bt,Bt+Ot),Ct);if(Ot<8){var Lt=at(ut(Ct,Ot));Nt=Nt.mul(Lt).add(at(Ut))}else Nt=(Nt=Nt.mul($t)).add(at(Ut))}return Nt.unsigned=Tt,Nt}function st(St,Tt){return typeof St=="number"?at(St,Tt):typeof St=="string"?dt(St,Tt):lt(St.low,St.high,typeof Tt=="boolean"?Tt:St.unsigned)}_e.fromString=dt,_e.fromValue=st;var it=4294967296,ct=it*it,ft=ct/2,ht=ot(1<<24),mt=ot(0);_e.ZERO=mt;var pt=ot(0,!0);_e.UZERO=pt;var _t=ot(1);_e.ONE=_t;var vt=ot(1,!0);_e.UONE=vt;var bt=ot(-1);_e.NEG_ONE=bt;var wt=lt(-1,2147483647,!1);_e.MAX_VALUE=wt;var xt=lt(-1,-1,!0);_e.MAX_UNSIGNED_VALUE=xt;var Mt=lt(0,-2147483648,!1);_e.MIN_VALUE=Mt;var At=_e.prototype;At.toInt=function(){return this.unsigned?this.low>>>0:this.low},At.toNumber=function(){return this.unsigned?(this.high>>>0)*it+(this.low>>>0):this.high*it+(this.low>>>0)},At.toString=function(St){if((St=St||10)<2||36<St)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(Mt)){var Tt=at(St),Ct=this.div(Tt),It=Ct.mul(Tt).sub(this);return Ct.toString(St)+It.toInt().toString(St)}return"-"+this.neg().toString(St)}for(var $t=at(ut(St,6),this.unsigned),Nt=this,Bt="";;){var Ot=Nt.div($t),Ut=(Nt.sub(Ot.mul($t)).toInt()>>>0).toString(St);if((Nt=Ot).isZero())return Ut+Bt;for(;Ut.length<6;)Ut="0"+Ut;Bt=""+Ut+Bt}},At.getHighBits=function(){return this.high},At.getHighBitsUnsigned=function(){return this.high>>>0},At.getLowBits=function(){return this.low},At.getLowBitsUnsigned=function(){return this.low>>>0},At.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Mt)?64:this.neg().getNumBitsAbs();for(var St=this.high!=0?this.high:this.low,Tt=31;Tt>0&&!(St&1<<Tt);Tt--);return this.high!=0?Tt+33:Tt+1},At.isZero=function(){return this.high===0&&this.low===0},At.eqz=At.isZero,At.isNegative=function(){return!this.unsigned&&this.high<0},At.isPositive=function(){return this.unsigned||this.high>=0},At.isOdd=function(){return(1&this.low)==1},At.isEven=function(){return(1&this.low)==0},At.equals=function(St){return tt(St)||(St=st(St)),(this.unsigned===St.unsigned||this.high>>>31!=1||St.high>>>31!=1)&&this.high===St.high&&this.low===St.low},At.eq=At.equals,At.notEquals=function(St){return!this.eq(St)},At.neq=At.notEquals,At.ne=At.notEquals,At.lessThan=function(St){return this.comp(St)<0},At.lt=At.lessThan,At.lessThanOrEqual=function(St){return this.comp(St)<=0},At.lte=At.lessThanOrEqual,At.le=At.lessThanOrEqual,At.greaterThan=function(St){return this.comp(St)>0},At.gt=At.greaterThan,At.greaterThanOrEqual=function(St){return this.comp(St)>=0},At.gte=At.greaterThanOrEqual,At.ge=At.greaterThanOrEqual,At.compare=function(St){if(tt(St)||(St=st(St)),this.eq(St))return 0;var Tt=this.isNegative(),Ct=St.isNegative();return Tt&&!Ct?-1:!Tt&&Ct?1:this.unsigned?St.high>>>0>this.high>>>0||St.high===this.high&&St.low>>>0>this.low>>>0?-1:1:this.sub(St).isNegative()?-1:1},At.comp=At.compare,At.negate=function(){return!this.unsigned&&this.eq(Mt)?Mt:this.not().add(_t)},At.neg=At.negate,At.add=function(St){tt(St)||(St=st(St));var Tt=this.high>>>16,Ct=65535&this.high,It=this.low>>>16,$t=65535&this.low,Nt=St.high>>>16,Bt=65535&St.high,Ot=St.low>>>16,Ut=0,Lt=0,zt=0,Yt=0;return zt+=(Yt+=$t+(65535&St.low))>>>16,Lt+=(zt+=It+Ot)>>>16,Ut+=(Lt+=Ct+Bt)>>>16,Ut+=Tt+Nt,lt((zt&=65535)<<16|(Yt&=65535),(Ut&=65535)<<16|(Lt&=65535),this.unsigned)},At.subtract=function(St){return tt(St)||(St=st(St)),this.add(St.neg())},At.sub=At.subtract,At.multiply=function(St){if(this.isZero())return mt;if(tt(St)||(St=st(St)),_)return lt(_.mul(this.low,this.high,St.low,St.high),_.get_high(),this.unsigned);if(St.isZero())return mt;if(this.eq(Mt))return St.isOdd()?Mt:mt;if(St.eq(Mt))return this.isOdd()?Mt:mt;if(this.isNegative())return St.isNegative()?this.neg().mul(St.neg()):this.neg().mul(St).neg();if(St.isNegative())return this.mul(St.neg()).neg();if(this.lt(ht)&&St.lt(ht))return at(this.toNumber()*St.toNumber(),this.unsigned);var Tt=this.high>>>16,Ct=65535&this.high,It=this.low>>>16,$t=65535&this.low,Nt=St.high>>>16,Bt=65535&St.high,Ot=St.low>>>16,Ut=65535&St.low,Lt=0,zt=0,Yt=0,en=0;return Yt+=(en+=$t*Ut)>>>16,zt+=(Yt+=It*Ut)>>>16,Yt&=65535,zt+=(Yt+=$t*Ot)>>>16,Lt+=(zt+=Ct*Ut)>>>16,zt&=65535,Lt+=(zt+=It*Ot)>>>16,zt&=65535,Lt+=(zt+=$t*Bt)>>>16,Lt+=Tt*Ut+Ct*Ot+It*Bt+$t*Nt,lt((Yt&=65535)<<16|(en&=65535),(Lt&=65535)<<16|(zt&=65535),this.unsigned)},At.mul=At.multiply,At.divide=function(St){if(tt(St)||(St=st(St)),St.isZero())throw Error("division by zero");var Tt,Ct,It;if(_)return this.unsigned||this.high!==-2147483648||St.low!==-1||St.high!==-1?lt((this.unsigned?_.div_u:_.div_s)(this.low,this.high,St.low,St.high),_.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?pt:mt;if(this.unsigned){if(St.unsigned||(St=St.toUnsigned()),St.gt(this))return pt;if(St.gt(this.shru(1)))return vt;It=pt}else{if(this.eq(Mt))return St.eq(_t)||St.eq(bt)?Mt:St.eq(Mt)?_t:(Tt=this.shr(1).div(St).shl(1)).eq(mt)?St.isNegative()?_t:bt:(Ct=this.sub(St.mul(Tt)),It=Tt.add(Ct.div(St)));if(St.eq(Mt))return this.unsigned?pt:mt;if(this.isNegative())return St.isNegative()?this.neg().div(St.neg()):this.neg().div(St).neg();if(St.isNegative())return this.div(St.neg()).neg();It=mt}for(Ct=this;Ct.gte(St);){Tt=Math.max(1,Math.floor(Ct.toNumber()/St.toNumber()));for(var $t=Math.ceil(Math.log(Tt)/Math.LN2),Nt=$t<=48?1:ut(2,$t-48),Bt=at(Tt),Ot=Bt.mul(St);Ot.isNegative()||Ot.gt(Ct);)Ot=(Bt=at(Tt-=Nt,this.unsigned)).mul(St);Bt.isZero()&&(Bt=_t),It=It.add(Bt),Ct=Ct.sub(Ot)}return It},At.div=At.divide,At.modulo=function(St){return tt(St)||(St=st(St)),_?lt((this.unsigned?_.rem_u:_.rem_s)(this.low,this.high,St.low,St.high),_.get_high(),this.unsigned):this.sub(this.div(St).mul(St))},At.mod=At.modulo,At.rem=At.modulo,At.not=function(){return lt(~this.low,~this.high,this.unsigned)},At.and=function(St){return tt(St)||(St=st(St)),lt(this.low&St.low,this.high&St.high,this.unsigned)},At.or=function(St){return tt(St)||(St=st(St)),lt(this.low|St.low,this.high|St.high,this.unsigned)},At.xor=function(St){return tt(St)||(St=st(St)),lt(this.low^St.low,this.high^St.high,this.unsigned)},At.shiftLeft=function(St){return tt(St)&&(St=St.toInt()),(St&=63)==0?this:St<32?lt(this.low<<St,this.high<<St|this.low>>>32-St,this.unsigned):lt(0,this.low<<St-32,this.unsigned)},At.shl=At.shiftLeft,At.shiftRight=function(St){return tt(St)&&(St=St.toInt()),(St&=63)==0?this:St<32?lt(this.low>>>St|this.high<<32-St,this.high>>St,this.unsigned):lt(this.high>>St-32,this.high>=0?0:-1,this.unsigned)},At.shr=At.shiftRight,At.shiftRightUnsigned=function(St){if(tt(St)&&(St=St.toInt()),(St&=63)==0)return this;var Tt=this.high;return St<32?lt(this.low>>>St|Tt<<32-St,Tt>>>St,this.unsigned):lt(St===32?Tt:Tt>>>St-32,0,this.unsigned)},At.shru=At.shiftRightUnsigned,At.shr_u=At.shiftRightUnsigned,At.toSigned=function(){return this.unsigned?lt(this.low,this.high,!1):this},At.toUnsigned=function(){return this.unsigned?this:lt(this.low,this.high,!0)},At.toBytes=function(St){return St?this.toBytesLE():this.toBytesBE()},At.toBytesLE=function(){var St=this.high,Tt=this.low;return[255&Tt,Tt>>>8&255,Tt>>>16&255,Tt>>>24,255&St,St>>>8&255,St>>>16&255,St>>>24]},At.toBytesBE=function(){var St=this.high,Tt=this.low;return[St>>>24,St>>>16&255,St>>>8&255,255&St,Tt>>>24,Tt>>>16&255,Tt>>>8&255,255&Tt]},_e.fromBytes=function(St,Tt,Ct){return Ct?_e.fromBytesLE(St,Tt):_e.fromBytesBE(St,Tt)},_e.fromBytesLE=function(St,Tt){return new _e(St[0]|St[1]<<8|St[2]<<16|St[3]<<24,St[4]|St[5]<<8|St[6]<<16|St[7]<<24,Tt)},_e.fromBytesBE=function(St,Tt){return new _e(St[4]<<24|St[5]<<16|St[6]<<8|St[7],St[0]<<24|St[1]<<16|St[2]<<8|St[3],Tt)}},1446:(et,_,_e)=>{var tt,nt,rt,ot=_e(2100),at=ot.Reader,lt=ot.Writer,ut=ot.util,dt=ot.roots.default||(ot.roots.default={});dt.onnx=((rt={}).Version=(tt={},(nt=Object.create(tt))[tt[0]="_START_VERSION"]=0,nt[tt[1]="IR_VERSION_2017_10_10"]=1,nt[tt[2]="IR_VERSION_2017_10_30"]=2,nt[tt[3]="IR_VERSION_2017_11_3"]=3,nt[tt[4]="IR_VERSION_2019_1_22"]=4,nt[tt[5]="IR_VERSION"]=5,nt),rt.AttributeProto=function(){function st(it){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],it)for(var ct=Object.keys(it),ft=0;ft<ct.length;++ft)it[ct[ft]]!=null&&(this[ct[ft]]=it[ct[ft]])}return st.prototype.name="",st.prototype.refAttrName="",st.prototype.docString="",st.prototype.type=0,st.prototype.f=0,st.prototype.i=ut.Long?ut.Long.fromBits(0,0,!1):0,st.prototype.s=ut.newBuffer([]),st.prototype.t=null,st.prototype.g=null,st.prototype.floats=ut.emptyArray,st.prototype.ints=ut.emptyArray,st.prototype.strings=ut.emptyArray,st.prototype.tensors=ut.emptyArray,st.prototype.graphs=ut.emptyArray,st.create=function(it){return new st(it)},st.encode=function(it,ct){if(ct||(ct=lt.create()),it.name!=null&&it.hasOwnProperty("name")&&ct.uint32(10).string(it.name),it.f!=null&&it.hasOwnProperty("f")&&ct.uint32(21).float(it.f),it.i!=null&&it.hasOwnProperty("i")&&ct.uint32(24).int64(it.i),it.s!=null&&it.hasOwnProperty("s")&&ct.uint32(34).bytes(it.s),it.t!=null&&it.hasOwnProperty("t")&&dt.onnx.TensorProto.encode(it.t,ct.uint32(42).fork()).ldelim(),it.g!=null&&it.hasOwnProperty("g")&&dt.onnx.GraphProto.encode(it.g,ct.uint32(50).fork()).ldelim(),it.floats!=null&&it.floats.length){ct.uint32(58).fork();for(var ft=0;ft<it.floats.length;++ft)ct.float(it.floats[ft]);ct.ldelim()}if(it.ints!=null&&it.ints.length){for(ct.uint32(66).fork(),ft=0;ft<it.ints.length;++ft)ct.int64(it.ints[ft]);ct.ldelim()}if(it.strings!=null&&it.strings.length)for(ft=0;ft<it.strings.length;++ft)ct.uint32(74).bytes(it.strings[ft]);if(it.tensors!=null&&it.tensors.length)for(ft=0;ft<it.tensors.length;++ft)dt.onnx.TensorProto.encode(it.tensors[ft],ct.uint32(82).fork()).ldelim();if(it.graphs!=null&&it.graphs.length)for(ft=0;ft<it.graphs.length;++ft)dt.onnx.GraphProto.encode(it.graphs[ft],ct.uint32(90).fork()).ldelim();return it.docString!=null&&it.hasOwnProperty("docString")&&ct.uint32(106).string(it.docString),it.type!=null&&it.hasOwnProperty("type")&&ct.uint32(160).int32(it.type),it.refAttrName!=null&&it.hasOwnProperty("refAttrName")&&ct.uint32(170).string(it.refAttrName),ct},st.encodeDelimited=function(it,ct){return this.encode(it,ct).ldelim()},st.decode=function(it,ct){it instanceof at||(it=at.create(it));for(var ft=ct===void 0?it.len:it.pos+ct,ht=new dt.onnx.AttributeProto;it.pos<ft;){var mt=it.uint32();switch(mt>>>3){case 1:ht.name=it.string();break;case 21:ht.refAttrName=it.string();break;case 13:ht.docString=it.string();break;case 20:ht.type=it.int32();break;case 2:ht.f=it.float();break;case 3:ht.i=it.int64();break;case 4:ht.s=it.bytes();break;case 5:ht.t=dt.onnx.TensorProto.decode(it,it.uint32());break;case 6:ht.g=dt.onnx.GraphProto.decode(it,it.uint32());break;case 7:if(ht.floats&&ht.floats.length||(ht.floats=[]),(7&mt)==2)for(var pt=it.uint32()+it.pos;it.pos<pt;)ht.floats.push(it.float());else ht.floats.push(it.float());break;case 8:if(ht.ints&&ht.ints.length||(ht.ints=[]),(7&mt)==2)for(pt=it.uint32()+it.pos;it.pos<pt;)ht.ints.push(it.int64());else ht.ints.push(it.int64());break;case 9:ht.strings&&ht.strings.length||(ht.strings=[]),ht.strings.push(it.bytes());break;case 10:ht.tensors&&ht.tensors.length||(ht.tensors=[]),ht.tensors.push(dt.onnx.TensorProto.decode(it,it.uint32()));break;case 11:ht.graphs&&ht.graphs.length||(ht.graphs=[]),ht.graphs.push(dt.onnx.GraphProto.decode(it,it.uint32()));break;default:it.skipType(7&mt)}}return ht},st.decodeDelimited=function(it){return it instanceof at||(it=new at(it)),this.decode(it,it.uint32())},st.verify=function(it){if(typeof it!="object"||it===null)return"object expected";if(it.name!=null&&it.hasOwnProperty("name")&&!ut.isString(it.name))return"name: string expected";if(it.refAttrName!=null&&it.hasOwnProperty("refAttrName")&&!ut.isString(it.refAttrName))return"refAttrName: string expected";if(it.docString!=null&&it.hasOwnProperty("docString")&&!ut.isString(it.docString))return"docString: string expected";if(it.type!=null&&it.hasOwnProperty("type"))switch(it.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:}if(it.f!=null&&it.hasOwnProperty("f")&&typeof it.f!="number")return"f: number expected";if(it.i!=null&&it.hasOwnProperty("i")&&!(ut.isInteger(it.i)||it.i&&ut.isInteger(it.i.low)&&ut.isInteger(it.i.high)))return"i: integer|Long expected";if(it.s!=null&&it.hasOwnProperty("s")&&!(it.s&&typeof it.s.length=="number"||ut.isString(it.s)))return"s: buffer expected";if(it.t!=null&&it.hasOwnProperty("t")&&(ft=dt.onnx.TensorProto.verify(it.t)))return"t."+ft;if(it.g!=null&&it.hasOwnProperty("g")&&(ft=dt.onnx.GraphProto.verify(it.g)))return"g."+ft;if(it.floats!=null&&it.hasOwnProperty("floats")){if(!Array.isArray(it.floats))return"floats: array expected";for(var ct=0;ct<it.floats.length;++ct)if(typeof it.floats[ct]!="number")return"floats: number[] expected"}if(it.ints!=null&&it.hasOwnProperty("ints")){if(!Array.isArray(it.ints))return"ints: array expected";for(ct=0;ct<it.ints.length;++ct)if(!(ut.isInteger(it.ints[ct])||it.ints[ct]&&ut.isInteger(it.ints[ct].low)&&ut.isInteger(it.ints[ct].high)))return"ints: integer|Long[] expected"}if(it.strings!=null&&it.hasOwnProperty("strings")){if(!Array.isArray(it.strings))return"strings: array expected";for(ct=0;ct<it.strings.length;++ct)if(!(it.strings[ct]&&typeof it.strings[ct].length=="number"||ut.isString(it.strings[ct])))return"strings: buffer[] expected"}if(it.tensors!=null&&it.hasOwnProperty("tensors")){if(!Array.isArray(it.tensors))return"tensors: array expected";for(ct=0;ct<it.tensors.length;++ct)if(ft=dt.onnx.TensorProto.verify(it.tensors[ct]))return"tensors."+ft}if(it.graphs!=null&&it.hasOwnProperty("graphs")){if(!Array.isArray(it.graphs))return"graphs: array expected";for(ct=0;ct<it.graphs.length;++ct){var ft;if(ft=dt.onnx.GraphProto.verify(it.graphs[ct]))return"graphs."+ft}}return null},st.fromObject=function(it){if(it instanceof dt.onnx.AttributeProto)return it;var ct=new dt.onnx.AttributeProto;switch(it.name!=null&&(ct.name=String(it.name)),it.refAttrName!=null&&(ct.refAttrName=String(it.refAttrName)),it.docString!=null&&(ct.docString=String(it.docString)),it.type){case"UNDEFINED":case 0:ct.type=0;break;case"FLOAT":case 1:ct.type=1;break;case"INT":case 2:ct.type=2;break;case"STRING":case 3:ct.type=3;break;case"TENSOR":case 4:ct.type=4;break;case"GRAPH":case 5:ct.type=5;break;case"FLOATS":case 6:ct.type=6;break;case"INTS":case 7:ct.type=7;break;case"STRINGS":case 8:ct.type=8;break;case"TENSORS":case 9:ct.type=9;break;case"GRAPHS":case 10:ct.type=10}if(it.f!=null&&(ct.f=Number(it.f)),it.i!=null&&(ut.Long?(ct.i=ut.Long.fromValue(it.i)).unsigned=!1:typeof it.i=="string"?ct.i=parseInt(it.i,10):typeof it.i=="number"?ct.i=it.i:typeof it.i=="object"&&(ct.i=new ut.LongBits(it.i.low>>>0,it.i.high>>>0).toNumber())),it.s!=null&&(typeof it.s=="string"?ut.base64.decode(it.s,ct.s=ut.newBuffer(ut.base64.length(it.s)),0):it.s.length&&(ct.s=it.s)),it.t!=null){if(typeof it.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");ct.t=dt.onnx.TensorProto.fromObject(it.t)}if(it.g!=null){if(typeof it.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");ct.g=dt.onnx.GraphProto.fromObject(it.g)}if(it.floats){if(!Array.isArray(it.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");ct.floats=[];for(var ft=0;ft<it.floats.length;++ft)ct.floats[ft]=Number(it.floats[ft])}if(it.ints){if(!Array.isArray(it.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(ct.ints=[],ft=0;ft<it.ints.length;++ft)ut.Long?(ct.ints[ft]=ut.Long.fromValue(it.ints[ft])).unsigned=!1:typeof it.ints[ft]=="string"?ct.ints[ft]=parseInt(it.ints[ft],10):typeof it.ints[ft]=="number"?ct.ints[ft]=it.ints[ft]:typeof it.ints[ft]=="object"&&(ct.ints[ft]=new ut.LongBits(it.ints[ft].low>>>0,it.ints[ft].high>>>0).toNumber())}if(it.strings){if(!Array.isArray(it.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(ct.strings=[],ft=0;ft<it.strings.length;++ft)typeof it.strings[ft]=="string"?ut.base64.decode(it.strings[ft],ct.strings[ft]=ut.newBuffer(ut.base64.length(it.strings[ft])),0):it.strings[ft].length&&(ct.strings[ft]=it.strings[ft])}if(it.tensors){if(!Array.isArray(it.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(ct.tensors=[],ft=0;ft<it.tensors.length;++ft){if(typeof it.tensors[ft]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");ct.tensors[ft]=dt.onnx.TensorProto.fromObject(it.tensors[ft])}}if(it.graphs){if(!Array.isArray(it.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(ct.graphs=[],ft=0;ft<it.graphs.length;++ft){if(typeof it.graphs[ft]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");ct.graphs[ft]=dt.onnx.GraphProto.fromObject(it.graphs[ft])}}return ct},st.toObject=function(it,ct){ct||(ct={});var ft={};if((ct.arrays||ct.defaults)&&(ft.floats=[],ft.ints=[],ft.strings=[],ft.tensors=[],ft.graphs=[]),ct.defaults){if(ft.name="",ft.f=0,ut.Long){var ht=new ut.Long(0,0,!1);ft.i=ct.longs===String?ht.toString():ct.longs===Number?ht.toNumber():ht}else ft.i=ct.longs===String?"0":0;ct.bytes===String?ft.s="":(ft.s=[],ct.bytes!==Array&&(ft.s=ut.newBuffer(ft.s))),ft.t=null,ft.g=null,ft.docString="",ft.type=ct.enums===String?"UNDEFINED":0,ft.refAttrName=""}if(it.name!=null&&it.hasOwnProperty("name")&&(ft.name=it.name),it.f!=null&&it.hasOwnProperty("f")&&(ft.f=ct.json&&!isFinite(it.f)?String(it.f):it.f),it.i!=null&&it.hasOwnProperty("i")&&(typeof it.i=="number"?ft.i=ct.longs===String?String(it.i):it.i:ft.i=ct.longs===String?ut.Long.prototype.toString.call(it.i):ct.longs===Number?new ut.LongBits(it.i.low>>>0,it.i.high>>>0).toNumber():it.i),it.s!=null&&it.hasOwnProperty("s")&&(ft.s=ct.bytes===String?ut.base64.encode(it.s,0,it.s.length):ct.bytes===Array?Array.prototype.slice.call(it.s):it.s),it.t!=null&&it.hasOwnProperty("t")&&(ft.t=dt.onnx.TensorProto.toObject(it.t,ct)),it.g!=null&&it.hasOwnProperty("g")&&(ft.g=dt.onnx.GraphProto.toObject(it.g,ct)),it.floats&&it.floats.length){ft.floats=[];for(var mt=0;mt<it.floats.length;++mt)ft.floats[mt]=ct.json&&!isFinite(it.floats[mt])?String(it.floats[mt]):it.floats[mt]}if(it.ints&&it.ints.length)for(ft.ints=[],mt=0;mt<it.ints.length;++mt)typeof it.ints[mt]=="number"?ft.ints[mt]=ct.longs===String?String(it.ints[mt]):it.ints[mt]:ft.ints[mt]=ct.longs===String?ut.Long.prototype.toString.call(it.ints[mt]):ct.longs===Number?new ut.LongBits(it.ints[mt].low>>>0,it.ints[mt].high>>>0).toNumber():it.ints[mt];if(it.strings&&it.strings.length)for(ft.strings=[],mt=0;mt<it.strings.length;++mt)ft.strings[mt]=ct.bytes===String?ut.base64.encode(it.strings[mt],0,it.strings[mt].length):ct.bytes===Array?Array.prototype.slice.call(it.strings[mt]):it.strings[mt];if(it.tensors&&it.tensors.length)for(ft.tensors=[],mt=0;mt<it.tensors.length;++mt)ft.tensors[mt]=dt.onnx.TensorProto.toObject(it.tensors[mt],ct);if(it.graphs&&it.graphs.length)for(ft.graphs=[],mt=0;mt<it.graphs.length;++mt)ft.graphs[mt]=dt.onnx.GraphProto.toObject(it.graphs[mt],ct);return it.docString!=null&&it.hasOwnProperty("docString")&&(ft.docString=it.docString),it.type!=null&&it.hasOwnProperty("type")&&(ft.type=ct.enums===String?dt.onnx.AttributeProto.AttributeType[it.type]:it.type),it.refAttrName!=null&&it.hasOwnProperty("refAttrName")&&(ft.refAttrName=it.refAttrName),ft},st.prototype.toJSON=function(){return this.constructor.toObject(this,ot.util.toJSONOptions)},st.AttributeType=function(){var it={},ct=Object.create(it);return ct[it[0]="UNDEFINED"]=0,ct[it[1]="FLOAT"]=1,ct[it[2]="INT"]=2,ct[it[3]="STRING"]=3,ct[it[4]="TENSOR"]=4,ct[it[5]="GRAPH"]=5,ct[it[6]="FLOATS"]=6,ct[it[7]="INTS"]=7,ct[it[8]="STRINGS"]=8,ct[it[9]="TENSORS"]=9,ct[it[10]="GRAPHS"]=10,ct}(),st}(),rt.ValueInfoProto=function(){function st(it){if(it)for(var ct=Object.keys(it),ft=0;ft<ct.length;++ft)it[ct[ft]]!=null&&(this[ct[ft]]=it[ct[ft]])}return st.prototype.name="",st.prototype.type=null,st.prototype.docString="",st.create=function(it){return new st(it)},st.encode=function(it,ct){return ct||(ct=lt.create()),it.name!=null&&it.hasOwnProperty("name")&&ct.uint32(10).string(it.name),it.type!=null&&it.hasOwnProperty("type")&&dt.onnx.TypeProto.encode(it.type,ct.uint32(18).fork()).ldelim(),it.docString!=null&&it.hasOwnProperty("docString")&&ct.uint32(26).string(it.docString),ct},st.encodeDelimited=function(it,ct){return this.encode(it,ct).ldelim()},st.decode=function(it,ct){it instanceof at||(it=at.create(it));for(var ft=ct===void 0?it.len:it.pos+ct,ht=new dt.onnx.ValueInfoProto;it.pos<ft;){var mt=it.uint32();switch(mt>>>3){case 1:ht.name=it.string();break;case 2:ht.type=dt.onnx.TypeProto.decode(it,it.uint32());break;case 3:ht.docString=it.string();break;default:it.skipType(7&mt)}}return ht},st.decodeDelimited=function(it){return it instanceof at||(it=new at(it)),this.decode(it,it.uint32())},st.verify=function(it){if(typeof it!="object"||it===null)return"object expected";if(it.name!=null&&it.hasOwnProperty("name")&&!ut.isString(it.name))return"name: string expected";if(it.type!=null&&it.hasOwnProperty("type")){var ct=dt.onnx.TypeProto.verify(it.type);if(ct)return"type."+ct}return it.docString!=null&&it.hasOwnProperty("docString")&&!ut.isString(it.docString)?"docString: string expected":null},st.fromObject=function(it){if(it instanceof dt.onnx.ValueInfoProto)return it;var ct=new dt.onnx.ValueInfoProto;if(it.name!=null&&(ct.name=String(it.name)),it.type!=null){if(typeof it.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");ct.type=dt.onnx.TypeProto.fromObject(it.type)}return it.docString!=null&&(ct.docString=String(it.docString)),ct},st.toObject=function(it,ct){ct||(ct={});var ft={};return ct.defaults&&(ft.name="",ft.type=null,ft.docString=""),it.name!=null&&it.hasOwnProperty("name")&&(ft.name=it.name),it.type!=null&&it.hasOwnProperty("type")&&(ft.type=dt.onnx.TypeProto.toObject(it.type,ct)),it.docString!=null&&it.hasOwnProperty("docString")&&(ft.docString=it.docString),ft},st.prototype.toJSON=function(){return this.constructor.toObject(this,ot.util.toJSONOptions)},st}(),rt.NodeProto=function(){function st(it){if(this.input=[],this.output=[],this.attribute=[],it)for(var ct=Object.keys(it),ft=0;ft<ct.length;++ft)it[ct[ft]]!=null&&(this[ct[ft]]=it[ct[ft]])}return st.prototype.input=ut.emptyArray,st.prototype.output=ut.emptyArray,st.prototype.name="",st.prototype.opType="",st.prototype.domain="",st.prototype.attribute=ut.emptyArray,st.prototype.docString="",st.create=function(it){return new st(it)},st.encode=function(it,ct){if(ct||(ct=lt.create()),it.input!=null&&it.input.length)for(var ft=0;ft<it.input.length;++ft)ct.uint32(10).string(it.input[ft]);if(it.output!=null&&it.output.length)for(ft=0;ft<it.output.length;++ft)ct.uint32(18).string(it.output[ft]);if(it.name!=null&&it.hasOwnProperty("name")&&ct.uint32(26).string(it.name),it.opType!=null&&it.hasOwnProperty("opType")&&ct.uint32(34).string(it.opType),it.attribute!=null&&it.attribute.length)for(ft=0;ft<it.attribute.length;++ft)dt.onnx.AttributeProto.encode(it.attribute[ft],ct.uint32(42).fork()).ldelim();return it.docString!=null&&it.hasOwnProperty("docString")&&ct.uint32(50).string(it.docString),it.domain!=null&&it.hasOwnProperty("domain")&&ct.uint32(58).string(it.domain),ct},st.encodeDelimited=function(it,ct){return this.encode(it,ct).ldelim()},st.decode=function(it,ct){it instanceof at||(it=at.create(it));for(var ft=ct===void 0?it.len:it.pos+ct,ht=new dt.onnx.NodeProto;it.pos<ft;){var mt=it.uint32();switch(mt>>>3){case 1:ht.input&&ht.input.length||(ht.input=[]),ht.input.push(it.string());break;case 2:ht.output&&ht.output.length||(ht.output=[]),ht.output.push(it.string());break;case 3:ht.name=it.string();break;case 4:ht.opType=it.string();break;case 7:ht.domain=it.string();break;case 5:ht.attribute&&ht.attribute.length||(ht.attribute=[]),ht.attribute.push(dt.onnx.AttributeProto.decode(it,it.uint32()));break;case 6:ht.docString=it.string();break;default:it.skipType(7&mt)}}return ht},st.decodeDelimited=function(it){return it instanceof at||(it=new at(it)),this.decode(it,it.uint32())},st.verify=function(it){if(typeof it!="object"||it===null)return"object expected";if(it.input!=null&&it.hasOwnProperty("input")){if(!Array.isArray(it.input))return"input: array expected";for(var ct=0;ct<it.input.length;++ct)if(!ut.isString(it.input[ct]))return"input: string[] expected"}if(it.output!=null&&it.hasOwnProperty("output")){if(!Array.isArray(it.output))return"output: array expected";for(ct=0;ct<it.output.length;++ct)if(!ut.isString(it.output[ct]))return"output: string[] expected"}if(it.name!=null&&it.hasOwnProperty("name")&&!ut.isString(it.name))return"name: string expected";if(it.opType!=null&&it.hasOwnProperty("opType")&&!ut.isString(it.opType))return"opType: string expected";if(it.domain!=null&&it.hasOwnProperty("domain")&&!ut.isString(it.domain))return"domain: string expected";if(it.attribute!=null&&it.hasOwnProperty("attribute")){if(!Array.isArray(it.attribute))return"attribute: array expected";for(ct=0;ct<it.attribute.length;++ct){var ft=dt.onnx.AttributeProto.verify(it.attribute[ct]);if(ft)return"attribute."+ft}}return it.docString!=null&&it.hasOwnProperty("docString")&&!ut.isString(it.docString)?"docString: string expected":null},st.fromObject=function(it){if(it instanceof dt.onnx.NodeProto)return it;var ct=new dt.onnx.NodeProto;if(it.input){if(!Array.isArray(it.input))throw TypeError(".onnx.NodeProto.input: array expected");ct.input=[];for(var ft=0;ft<it.input.length;++ft)ct.input[ft]=String(it.input[ft])}if(it.output){if(!Array.isArray(it.output))throw TypeError(".onnx.NodeProto.output: array expected");for(ct.output=[],ft=0;ft<it.output.length;++ft)ct.output[ft]=String(it.output[ft])}if(it.name!=null&&(ct.name=String(it.name)),it.opType!=null&&(ct.opType=String(it.opType)),it.domain!=null&&(ct.domain=String(it.domain)),it.attribute){if(!Array.isArray(it.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(ct.attribute=[],ft=0;ft<it.attribute.length;++ft){if(typeof it.attribute[ft]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");ct.attribute[ft]=dt.onnx.AttributeProto.fromObject(it.attribute[ft])}}return it.docString!=null&&(ct.docString=String(it.docString)),ct},st.toObject=function(it,ct){ct||(ct={});var ft={};if((ct.arrays||ct.defaults)&&(ft.input=[],ft.output=[],ft.attribute=[]),ct.defaults&&(ft.name="",ft.opType="",ft.docString="",ft.domain=""),it.input&&it.input.length){ft.input=[];for(var ht=0;ht<it.input.length;++ht)ft.input[ht]=it.input[ht]}if(it.output&&it.output.length)for(ft.output=[],ht=0;ht<it.output.length;++ht)ft.output[ht]=it.output[ht];if(it.name!=null&&it.hasOwnProperty("name")&&(ft.name=it.name),it.opType!=null&&it.hasOwnProperty("opType")&&(ft.opType=it.opType),it.attribute&&it.attribute.length)for(ft.attribute=[],ht=0;ht<it.attribute.length;++ht)ft.attribute[ht]=dt.onnx.AttributeProto.toObject(it.attribute[ht],ct);return it.docString!=null&&it.hasOwnProperty("docString")&&(ft.docString=it.docString),it.domain!=null&&it.hasOwnProperty("domain")&&(ft.domain=it.domain),ft},st.prototype.toJSON=function(){return this.constructor.toObject(this,ot.util.toJSONOptions)},st}(),rt.ModelProto=function(){function st(it){if(this.opsetImport=[],this.metadataProps=[],it)for(var ct=Object.keys(it),ft=0;ft<ct.length;++ft)it[ct[ft]]!=null&&(this[ct[ft]]=it[ct[ft]])}return st.prototype.irVersion=ut.Long?ut.Long.fromBits(0,0,!1):0,st.prototype.opsetImport=ut.emptyArray,st.prototype.producerName="",st.prototype.producerVersion="",st.prototype.domain="",st.prototype.modelVersion=ut.Long?ut.Long.fromBits(0,0,!1):0,st.prototype.docString="",st.prototype.graph=null,st.prototype.metadataProps=ut.emptyArray,st.create=function(it){return new st(it)},st.encode=function(it,ct){if(ct||(ct=lt.create()),it.irVersion!=null&&it.hasOwnProperty("irVersion")&&ct.uint32(8).int64(it.irVersion),it.producerName!=null&&it.hasOwnProperty("producerName")&&ct.uint32(18).string(it.producerName),it.producerVersion!=null&&it.hasOwnProperty("producerVersion")&&ct.uint32(26).string(it.producerVersion),it.domain!=null&&it.hasOwnProperty("domain")&&ct.uint32(34).string(it.domain),it.modelVersion!=null&&it.hasOwnProperty("modelVersion")&&ct.uint32(40).int64(it.modelVersion),it.docString!=null&&it.hasOwnProperty("docString")&&ct.uint32(50).string(it.docString),it.graph!=null&&it.hasOwnProperty("graph")&&dt.onnx.GraphProto.encode(it.graph,ct.uint32(58).fork()).ldelim(),it.opsetImport!=null&&it.opsetImport.length)for(var ft=0;ft<it.opsetImport.length;++ft)dt.onnx.OperatorSetIdProto.encode(it.opsetImport[ft],ct.uint32(66).fork()).ldelim();if(it.metadataProps!=null&&it.metadataProps.length)for(ft=0;ft<it.metadataProps.length;++ft)dt.onnx.StringStringEntryProto.encode(it.metadataProps[ft],ct.uint32(114).fork()).ldelim();return ct},st.encodeDelimited=function(it,ct){return this.encode(it,ct).ldelim()},st.decode=function(it,ct){it instanceof at||(it=at.create(it));for(var ft=ct===void 0?it.len:it.pos+ct,ht=new dt.onnx.ModelProto;it.pos<ft;){var mt=it.uint32();switch(mt>>>3){case 1:ht.irVersion=it.int64();break;case 8:ht.opsetImport&&ht.opsetImport.length||(ht.opsetImport=[]),ht.opsetImport.push(dt.onnx.OperatorSetIdProto.decode(it,it.uint32()));break;case 2:ht.producerName=it.string();break;case 3:ht.producerVersion=it.string();break;case 4:ht.domain=it.string();break;case 5:ht.modelVersion=it.int64();break;case 6:ht.docString=it.string();break;case 7:ht.graph=dt.onnx.GraphProto.decode(it,it.uint32());break;case 14:ht.metadataProps&&ht.metadataProps.length||(ht.metadataProps=[]),ht.metadataProps.push(dt.onnx.StringStringEntryProto.decode(it,it.uint32()));break;default:it.skipType(7&mt)}}return ht},st.decodeDelimited=function(it){return it instanceof at||(it=new at(it)),this.decode(it,it.uint32())},st.verify=function(it){if(typeof it!="object"||it===null)return"object expected";if(it.irVersion!=null&&it.hasOwnProperty("irVersion")&&!(ut.isInteger(it.irVersion)||it.irVersion&&ut.isInteger(it.irVersion.low)&&ut.isInteger(it.irVersion.high)))return"irVersion: integer|Long expected";if(it.opsetImport!=null&&it.hasOwnProperty("opsetImport")){if(!Array.isArray(it.opsetImport))return"opsetImport: array expected";for(var ct=0;ct<it.opsetImport.length;++ct)if(ft=dt.onnx.OperatorSetIdProto.verify(it.opsetImport[ct]))return"opsetImport."+ft}if(it.producerName!=null&&it.hasOwnProperty("producerName")&&!ut.isString(it.producerName))return"producerName: string expected";if(it.producerVersion!=null&&it.hasOwnProperty("producerVersion")&&!ut.isString(it.producerVersion))return"producerVersion: string expected";if(it.domain!=null&&it.hasOwnProperty("domain")&&!ut.isString(it.domain))return"domain: string expected";if(it.modelVersion!=null&&it.hasOwnProperty("modelVersion")&&!(ut.isInteger(it.modelVersion)||it.modelVersion&&ut.isInteger(it.modelVersion.low)&&ut.isInteger(it.modelVersion.high)))return"modelVersion: integer|Long expected";if(it.docString!=null&&it.hasOwnProperty("docString")&&!ut.isString(it.docString))return"docString: string expected";if(it.graph!=null&&it.hasOwnProperty("graph")&&(ft=dt.onnx.GraphProto.verify(it.graph)))return"graph."+ft;if(it.metadataProps!=null&&it.hasOwnProperty("metadataProps")){if(!Array.isArray(it.metadataProps))return"metadataProps: array expected";for(ct=0;ct<it.metadataProps.length;++ct){var ft;if(ft=dt.onnx.StringStringEntryProto.verify(it.metadataProps[ct]))return"metadataProps."+ft}}return null},st.fromObject=function(it){if(it instanceof dt.onnx.ModelProto)return it;var ct=new dt.onnx.ModelProto;if(it.irVersion!=null&&(ut.Long?(ct.irVersion=ut.Long.fromValue(it.irVersion)).unsigned=!1:typeof it.irVersion=="string"?ct.irVersion=parseInt(it.irVersion,10):typeof it.irVersion=="number"?ct.irVersion=it.irVersion:typeof it.irVersion=="object"&&(ct.irVersion=new ut.LongBits(it.irVersion.low>>>0,it.irVersion.high>>>0).toNumber())),it.opsetImport){if(!Array.isArray(it.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");ct.opsetImport=[];for(var ft=0;ft<it.opsetImport.length;++ft){if(typeof it.opsetImport[ft]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");ct.opsetImport[ft]=dt.onnx.OperatorSetIdProto.fromObject(it.opsetImport[ft])}}if(it.producerName!=null&&(ct.producerName=String(it.producerName)),it.producerVersion!=null&&(ct.producerVersion=String(it.producerVersion)),it.domain!=null&&(ct.domain=String(it.domain)),it.modelVersion!=null&&(ut.Long?(ct.modelVersion=ut.Long.fromValue(it.modelVersion)).unsigned=!1:typeof it.modelVersion=="string"?ct.modelVersion=parseInt(it.modelVersion,10):typeof it.modelVersion=="number"?ct.modelVersion=it.modelVersion:typeof it.modelVersion=="object"&&(ct.modelVersion=new ut.LongBits(it.modelVersion.low>>>0,it.modelVersion.high>>>0).toNumber())),it.docString!=null&&(ct.docString=String(it.docString)),it.graph!=null){if(typeof it.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");ct.graph=dt.onnx.GraphProto.fromObject(it.graph)}if(it.metadataProps){if(!Array.isArray(it.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(ct.metadataProps=[],ft=0;ft<it.metadataProps.length;++ft){if(typeof it.metadataProps[ft]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");ct.metadataProps[ft]=dt.onnx.StringStringEntryProto.fromObject(it.metadataProps[ft])}}return ct},st.toObject=function(it,ct){ct||(ct={});var ft={};if((ct.arrays||ct.defaults)&&(ft.opsetImport=[],ft.metadataProps=[]),ct.defaults){if(ut.Long){var ht=new ut.Long(0,0,!1);ft.irVersion=ct.longs===String?ht.toString():ct.longs===Number?ht.toNumber():ht}else ft.irVersion=ct.longs===String?"0":0;ft.producerName="",ft.producerVersion="",ft.domain="",ut.Long?(ht=new ut.Long(0,0,!1),ft.modelVersion=ct.longs===String?ht.toString():ct.longs===Number?ht.toNumber():ht):ft.modelVersion=ct.longs===String?"0":0,ft.docString="",ft.graph=null}if(it.irVersion!=null&&it.hasOwnProperty("irVersion")&&(typeof it.irVersion=="number"?ft.irVersion=ct.longs===String?String(it.irVersion):it.irVersion:ft.irVersion=ct.longs===String?ut.Long.prototype.toString.call(it.irVersion):ct.longs===Number?new ut.LongBits(it.irVersion.low>>>0,it.irVersion.high>>>0).toNumber():it.irVersion),it.producerName!=null&&it.hasOwnProperty("producerName")&&(ft.producerName=it.producerName),it.producerVersion!=null&&it.hasOwnProperty("producerVersion")&&(ft.producerVersion=it.producerVersion),it.domain!=null&&it.hasOwnProperty("domain")&&(ft.domain=it.domain),it.modelVersion!=null&&it.hasOwnProperty("modelVersion")&&(typeof it.modelVersion=="number"?ft.modelVersion=ct.longs===String?String(it.modelVersion):it.modelVersion:ft.modelVersion=ct.longs===String?ut.Long.prototype.toString.call(it.modelVersion):ct.longs===Number?new ut.LongBits(it.modelVersion.low>>>0,it.modelVersion.high>>>0).toNumber():it.modelVersion),it.docString!=null&&it.hasOwnProperty("docString")&&(ft.docString=it.docString),it.graph!=null&&it.hasOwnProperty("graph")&&(ft.graph=dt.onnx.GraphProto.toObject(it.graph,ct)),it.opsetImport&&it.opsetImport.length){ft.opsetImport=[];for(var mt=0;mt<it.opsetImport.length;++mt)ft.opsetImport[mt]=dt.onnx.OperatorSetIdProto.toObject(it.opsetImport[mt],ct)}if(it.metadataProps&&it.metadataProps.length)for(ft.metadataProps=[],mt=0;mt<it.metadataProps.length;++mt)ft.metadataProps[mt]=dt.onnx.StringStringEntryProto.toObject(it.metadataProps[mt],ct);return ft},st.prototype.toJSON=function(){return this.constructor.toObject(this,ot.util.toJSONOptions)},st}(),rt.StringStringEntryProto=function(){function st(it){if(it)for(var ct=Object.keys(it),ft=0;ft<ct.length;++ft)it[ct[ft]]!=null&&(this[ct[ft]]=it[ct[ft]])}return st.prototype.key="",st.prototype.value="",st.create=function(it){return new st(it)},st.encode=function(it,ct){return ct||(ct=lt.create()),it.key!=null&&it.hasOwnProperty("key")&&ct.uint32(10).string(it.key),it.value!=null&&it.hasOwnProperty("value")&&ct.uint32(18).string(it.value),ct},st.encodeDelimited=function(it,ct){return this.encode(it,ct).ldelim()},st.decode=function(it,ct){it instanceof at||(it=at.create(it));for(var ft=ct===void 0?it.len:it.pos+ct,ht=new dt.onnx.StringStringEntryProto;it.pos<ft;){var mt=it.uint32();switch(mt>>>3){case 1:ht.key=it.string();break;case 2:ht.value=it.string();break;default:it.skipType(7&mt)}}return ht},st.decodeDelimited=function(it){return it instanceof at||(it=new at(it)),this.decode(it,it.uint32())},st.verify=function(it){return typeof it!="object"||it===null?"object expected":it.key!=null&&it.hasOwnProperty("key")&&!ut.isString(it.key)?"key: string expected":it.value!=null&&it.hasOwnProperty("value")&&!ut.isString(it.value)?"value: string expected":null},st.fromObject=function(it){if(it instanceof dt.onnx.StringStringEntryProto)return it;var ct=new dt.onnx.StringStringEntryProto;return it.key!=null&&(ct.key=String(it.key)),it.value!=null&&(ct.value=String(it.value)),ct},st.toObject=function(it,ct){ct||(ct={});var ft={};return ct.defaults&&(ft.key="",ft.value=""),it.key!=null&&it.hasOwnProperty("key")&&(ft.key=it.key),it.value!=null&&it.hasOwnProperty("value")&&(ft.value=it.value),ft},st.prototype.toJSON=function(){return this.constructor.toObject(this,ot.util.toJSONOptions)},st}(),rt.TensorAnnotation=function(){function st(it){if(this.quantParameterTensorNames=[],it)for(var ct=Object.keys(it),ft=0;ft<ct.length;++ft)it[ct[ft]]!=null&&(this[ct[ft]]=it[ct[ft]])}return st.prototype.tensorName="",st.prototype.quantParameterTensorNames=ut.emptyArray,st.create=function(it){return new st(it)},st.encode=function(it,ct){if(ct||(ct=lt.create()),it.tensorName!=null&&it.hasOwnProperty("tensorName")&&ct.uint32(10).string(it.tensorName),it.quantParameterTensorNames!=null&&it.quantParameterTensorNames.length)for(var ft=0;ft<it.quantParameterTensorNames.length;++ft)dt.onnx.StringStringEntryProto.encode(it.quantParameterTensorNames[ft],ct.uint32(18).fork()).ldelim();return ct},st.encodeDelimited=function(it,ct){return this.encode(it,ct).ldelim()},st.decode=function(it,ct){it instanceof at||(it=at.create(it));for(var ft=ct===void 0?it.len:it.pos+ct,ht=new dt.onnx.TensorAnnotation;it.pos<ft;){var mt=it.uint32();switch(mt>>>3){case 1:ht.tensorName=it.string();break;case 2:ht.quantParameterTensorNames&&ht.quantParameterTensorNames.length||(ht.quantParameterTensorNames=[]),ht.quantParameterTensorNames.push(dt.onnx.StringStringEntryProto.decode(it,it.uint32()));break;default:it.skipType(7&mt)}}return ht},st.decodeDelimited=function(it){return it instanceof at||(it=new at(it)),this.decode(it,it.uint32())},st.verify=function(it){if(typeof it!="object"||it===null)return"object expected";if(it.tensorName!=null&&it.hasOwnProperty("tensorName")&&!ut.isString(it.tensorName))return"tensorName: string expected";if(it.quantParameterTensorNames!=null&&it.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(it.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var ct=0;ct<it.quantParameterTensorNames.length;++ct){var ft=dt.onnx.StringStringEntryProto.verify(it.quantParameterTensorNames[ct]);if(ft)return"quantParameterTensorNames."+ft}}return null},st.fromObject=function(it){if(it instanceof dt.onnx.TensorAnnotation)return it;var ct=new dt.onnx.TensorAnnotation;if(it.tensorName!=null&&(ct.tensorName=String(it.tensorName)),it.quantParameterTensorNames){if(!Array.isArray(it.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");ct.quantParameterTensorNames=[];for(var ft=0;ft<it.quantParameterTensorNames.length;++ft){if(typeof it.quantParameterTensorNames[ft]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");ct.quantParameterTensorNames[ft]=dt.onnx.StringStringEntryProto.fromObject(it.quantParameterTensorNames[ft])}}return ct},st.toObject=function(it,ct){ct||(ct={});var ft={};if((ct.arrays||ct.defaults)&&(ft.quantParameterTensorNames=[]),ct.defaults&&(ft.tensorName=""),it.tensorName!=null&&it.hasOwnProperty("tensorName")&&(ft.tensorName=it.tensorName),it.quantParameterTensorNames&&it.quantParameterTensorNames.length){ft.quantParameterTensorNames=[];for(var ht=0;ht<it.quantParameterTensorNames.length;++ht)ft.quantParameterTensorNames[ht]=dt.onnx.StringStringEntryProto.toObject(it.quantParameterTensorNames[ht],ct)}return ft},st.prototype.toJSON=function(){return this.constructor.toObject(this,ot.util.toJSONOptions)},st}(),rt.GraphProto=function(){function st(it){if(this.node=[],this.initializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],it)for(var ct=Object.keys(it),ft=0;ft<ct.length;++ft)it[ct[ft]]!=null&&(this[ct[ft]]=it[ct[ft]])}return st.prototype.node=ut.emptyArray,st.prototype.name="",st.prototype.initializer=ut.emptyArray,st.prototype.docString="",st.prototype.input=ut.emptyArray,st.prototype.output=ut.emptyArray,st.prototype.valueInfo=ut.emptyArray,st.prototype.quantizationAnnotation=ut.emptyArray,st.create=function(it){return new st(it)},st.encode=function(it,ct){if(ct||(ct=lt.create()),it.node!=null&&it.node.length)for(var ft=0;ft<it.node.length;++ft)dt.onnx.NodeProto.encode(it.node[ft],ct.uint32(10).fork()).ldelim();if(it.name!=null&&it.hasOwnProperty("name")&&ct.uint32(18).string(it.name),it.initializer!=null&&it.initializer.length)for(ft=0;ft<it.initializer.length;++ft)dt.onnx.TensorProto.encode(it.initializer[ft],ct.uint32(42).fork()).ldelim();if(it.docString!=null&&it.hasOwnProperty("docString")&&ct.uint32(82).string(it.docString),it.input!=null&&it.input.length)for(ft=0;ft<it.input.length;++ft)dt.onnx.ValueInfoProto.encode(it.input[ft],ct.uint32(90).fork()).ldelim();if(it.output!=null&&it.output.length)for(ft=0;ft<it.output.length;++ft)dt.onnx.ValueInfoProto.encode(it.output[ft],ct.uint32(98).fork()).ldelim();if(it.valueInfo!=null&&it.valueInfo.length)for(ft=0;ft<it.valueInfo.length;++ft)dt.onnx.ValueInfoProto.encode(it.valueInfo[ft],ct.uint32(106).fork()).ldelim();if(it.quantizationAnnotation!=null&&it.quantizationAnnotation.length)for(ft=0;ft<it.quantizationAnnotation.length;++ft)dt.onnx.TensorAnnotation.encode(it.quantizationAnnotation[ft],ct.uint32(114).fork()).ldelim();return ct},st.encodeDelimited=function(it,ct){return this.encode(it,ct).ldelim()},st.decode=function(it,ct){it instanceof at||(it=at.create(it));for(var ft=ct===void 0?it.len:it.pos+ct,ht=new dt.onnx.GraphProto;it.pos<ft;){var mt=it.uint32();switch(mt>>>3){case 1:ht.node&&ht.node.length||(ht.node=[]),ht.node.push(dt.onnx.NodeProto.decode(it,it.uint32()));break;case 2:ht.name=it.string();break;case 5:ht.initializer&&ht.initializer.length||(ht.initializer=[]),ht.initializer.push(dt.onnx.TensorProto.decode(it,it.uint32()));break;case 10:ht.docString=it.string();break;case 11:ht.input&&ht.input.length||(ht.input=[]),ht.input.push(dt.onnx.ValueInfoProto.decode(it,it.uint32()));break;case 12:ht.output&&ht.output.length||(ht.output=[]),ht.output.push(dt.onnx.ValueInfoProto.decode(it,it.uint32()));break;case 13:ht.valueInfo&&ht.valueInfo.length||(ht.valueInfo=[]),ht.valueInfo.push(dt.onnx.ValueInfoProto.decode(it,it.uint32()));break;case 14:ht.quantizationAnnotation&&ht.quantizationAnnotation.length||(ht.quantizationAnnotation=[]),ht.quantizationAnnotation.push(dt.onnx.TensorAnnotation.decode(it,it.uint32()));break;default:it.skipType(7&mt)}}return ht},st.decodeDelimited=function(it){return it instanceof at||(it=new at(it)),this.decode(it,it.uint32())},st.verify=function(it){if(typeof it!="object"||it===null)return"object expected";if(it.node!=null&&it.hasOwnProperty("node")){if(!Array.isArray(it.node))return"node: array expected";for(var ct=0;ct<it.node.length;++ct)if(ft=dt.onnx.NodeProto.verify(it.node[ct]))return"node."+ft}if(it.name!=null&&it.hasOwnProperty("name")&&!ut.isString(it.name))return"name: string expected";if(it.initializer!=null&&it.hasOwnProperty("initializer")){if(!Array.isArray(it.initializer))return"initializer: array expected";for(ct=0;ct<it.initializer.length;++ct)if(ft=dt.onnx.TensorProto.verify(it.initializer[ct]))return"initializer."+ft}if(it.docString!=null&&it.hasOwnProperty("docString")&&!ut.isString(it.docString))return"docString: string expected";if(it.input!=null&&it.hasOwnProperty("input")){if(!Array.isArray(it.input))return"input: array expected";for(ct=0;ct<it.input.length;++ct)if(ft=dt.onnx.ValueInfoProto.verify(it.input[ct]))return"input."+ft}if(it.output!=null&&it.hasOwnProperty("output")){if(!Array.isArray(it.output))return"output: array expected";for(ct=0;ct<it.output.length;++ct)if(ft=dt.onnx.ValueInfoProto.verify(it.output[ct]))return"output."+ft}if(it.valueInfo!=null&&it.hasOwnProperty("valueInfo")){if(!Array.isArray(it.valueInfo))return"valueInfo: array expected";for(ct=0;ct<it.valueInfo.length;++ct)if(ft=dt.onnx.ValueInfoProto.verify(it.valueInfo[ct]))return"valueInfo."+ft}if(it.quantizationAnnotation!=null&&it.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(it.quantizationAnnotation))return"quantizationAnnotation: array expected";for(ct=0;ct<it.quantizationAnnotation.length;++ct){var ft;if(ft=dt.onnx.TensorAnnotation.verify(it.quantizationAnnotation[ct]))return"quantizationAnnotation."+ft}}return null},st.fromObject=function(it){if(it instanceof dt.onnx.GraphProto)return it;var ct=new dt.onnx.GraphProto;if(it.node){if(!Array.isArray(it.node))throw TypeError(".onnx.GraphProto.node: array expected");ct.node=[];for(var ft=0;ft<it.node.length;++ft){if(typeof it.node[ft]!="object")throw TypeError(".onnx.GraphProto.node: object expected");ct.node[ft]=dt.onnx.NodeProto.fromObject(it.node[ft])}}if(it.name!=null&&(ct.name=String(it.name)),it.initializer){if(!Array.isArray(it.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(ct.initializer=[],ft=0;ft<it.initializer.length;++ft){if(typeof it.initializer[ft]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");ct.initializer[ft]=dt.onnx.TensorProto.fromObject(it.initializer[ft])}}if(it.docString!=null&&(ct.docString=String(it.docString)),it.input){if(!Array.isArray(it.input))throw TypeError(".onnx.GraphProto.input: array expected");for(ct.input=[],ft=0;ft<it.input.length;++ft){if(typeof it.input[ft]!="object")throw TypeError(".onnx.GraphProto.input: object expected");ct.input[ft]=dt.onnx.ValueInfoProto.fromObject(it.input[ft])}}if(it.output){if(!Array.isArray(it.output))throw TypeError(".onnx.GraphProto.output: array expected");for(ct.output=[],ft=0;ft<it.output.length;++ft){if(typeof it.output[ft]!="object")throw TypeError(".onnx.GraphProto.output: object expected");ct.output[ft]=dt.onnx.ValueInfoProto.fromObject(it.output[ft])}}if(it.valueInfo){if(!Array.isArray(it.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(ct.valueInfo=[],ft=0;ft<it.valueInfo.length;++ft){if(typeof it.valueInfo[ft]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");ct.valueInfo[ft]=dt.onnx.ValueInfoProto.fromObject(it.valueInfo[ft])}}if(it.quantizationAnnotation){if(!Array.isArray(it.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(ct.quantizationAnnotation=[],ft=0;ft<it.quantizationAnnotation.length;++ft){if(typeof it.quantizationAnnotation[ft]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");ct.quantizationAnnotation[ft]=dt.onnx.TensorAnnotation.fromObject(it.quantizationAnnotation[ft])}}return ct},st.toObject=function(it,ct){ct||(ct={});var ft={};if((ct.arrays||ct.defaults)&&(ft.node=[],ft.initializer=[],ft.input=[],ft.output=[],ft.valueInfo=[],ft.quantizationAnnotation=[]),ct.defaults&&(ft.name="",ft.docString=""),it.node&&it.node.length){ft.node=[];for(var ht=0;ht<it.node.length;++ht)ft.node[ht]=dt.onnx.NodeProto.toObject(it.node[ht],ct)}if(it.name!=null&&it.hasOwnProperty("name")&&(ft.name=it.name),it.initializer&&it.initializer.length)for(ft.initializer=[],ht=0;ht<it.initializer.length;++ht)ft.initializer[ht]=dt.onnx.TensorProto.toObject(it.initializer[ht],ct);if(it.docString!=null&&it.hasOwnProperty("docString")&&(ft.docString=it.docString),it.input&&it.input.length)for(ft.input=[],ht=0;ht<it.input.length;++ht)ft.input[ht]=dt.onnx.ValueInfoProto.toObject(it.input[ht],ct);if(it.output&&it.output.length)for(ft.output=[],ht=0;ht<it.output.length;++ht)ft.output[ht]=dt.onnx.ValueInfoProto.toObject(it.output[ht],ct);if(it.valueInfo&&it.valueInfo.length)for(ft.valueInfo=[],ht=0;ht<it.valueInfo.length;++ht)ft.valueInfo[ht]=dt.onnx.ValueInfoProto.toObject(it.valueInfo[ht],ct);if(it.quantizationAnnotation&&it.quantizationAnnotation.length)for(ft.quantizationAnnotation=[],ht=0;ht<it.quantizationAnnotation.length;++ht)ft.quantizationAnnotation[ht]=dt.onnx.TensorAnnotation.toObject(it.quantizationAnnotation[ht],ct);return ft},st.prototype.toJSON=function(){return this.constructor.toObject(this,ot.util.toJSONOptions)},st}(),rt.TensorProto=function(){function st(it){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],it)for(var ct=Object.keys(it),ft=0;ft<ct.length;++ft)it[ct[ft]]!=null&&(this[ct[ft]]=it[ct[ft]])}return st.prototype.dims=ut.emptyArray,st.prototype.dataType=0,st.prototype.segment=null,st.prototype.floatData=ut.emptyArray,st.prototype.int32Data=ut.emptyArray,st.prototype.stringData=ut.emptyArray,st.prototype.int64Data=ut.emptyArray,st.prototype.name="",st.prototype.docString="",st.prototype.rawData=ut.newBuffer([]),st.prototype.externalData=ut.emptyArray,st.prototype.dataLocation=0,st.prototype.doubleData=ut.emptyArray,st.prototype.uint64Data=ut.emptyArray,st.create=function(it){return new st(it)},st.encode=function(it,ct){if(ct||(ct=lt.create()),it.dims!=null&&it.dims.length){ct.uint32(10).fork();for(var ft=0;ft<it.dims.length;++ft)ct.int64(it.dims[ft]);ct.ldelim()}if(it.dataType!=null&&it.hasOwnProperty("dataType")&&ct.uint32(16).int32(it.dataType),it.segment!=null&&it.hasOwnProperty("segment")&&dt.onnx.TensorProto.Segment.encode(it.segment,ct.uint32(26).fork()).ldelim(),it.floatData!=null&&it.floatData.length){for(ct.uint32(34).fork(),ft=0;ft<it.floatData.length;++ft)ct.float(it.floatData[ft]);ct.ldelim()}if(it.int32Data!=null&&it.int32Data.length){for(ct.uint32(42).fork(),ft=0;ft<it.int32Data.length;++ft)ct.int32(it.int32Data[ft]);ct.ldelim()}if(it.stringData!=null&&it.stringData.length)for(ft=0;ft<it.stringData.length;++ft)ct.uint32(50).bytes(it.stringData[ft]);if(it.int64Data!=null&&it.int64Data.length){for(ct.uint32(58).fork(),ft=0;ft<it.int64Data.length;++ft)ct.int64(it.int64Data[ft]);ct.ldelim()}if(it.name!=null&&it.hasOwnProperty("name")&&ct.uint32(66).string(it.name),it.rawData!=null&&it.hasOwnProperty("rawData")&&ct.uint32(74).bytes(it.rawData),it.doubleData!=null&&it.doubleData.length){for(ct.uint32(82).fork(),ft=0;ft<it.doubleData.length;++ft)ct.double(it.doubleData[ft]);ct.ldelim()}if(it.uint64Data!=null&&it.uint64Data.length){for(ct.uint32(90).fork(),ft=0;ft<it.uint64Data.length;++ft)ct.uint64(it.uint64Data[ft]);ct.ldelim()}if(it.docString!=null&&it.hasOwnProperty("docString")&&ct.uint32(98).string(it.docString),it.externalData!=null&&it.externalData.length)for(ft=0;ft<it.externalData.length;++ft)dt.onnx.StringStringEntryProto.encode(it.externalData[ft],ct.uint32(106).fork()).ldelim();return it.dataLocation!=null&&it.hasOwnProperty("dataLocation")&&ct.uint32(112).int32(it.dataLocation),ct},st.encodeDelimited=function(it,ct){return this.encode(it,ct).ldelim()},st.decode=function(it,ct){it instanceof at||(it=at.create(it));for(var ft=ct===void 0?it.len:it.pos+ct,ht=new dt.onnx.TensorProto;it.pos<ft;){var mt=it.uint32();switch(mt>>>3){case 1:if(ht.dims&&ht.dims.length||(ht.dims=[]),(7&mt)==2)for(var pt=it.uint32()+it.pos;it.pos<pt;)ht.dims.push(it.int64());else ht.dims.push(it.int64());break;case 2:ht.dataType=it.int32();break;case 3:ht.segment=dt.onnx.TensorProto.Segment.decode(it,it.uint32());break;case 4:if(ht.floatData&&ht.floatData.length||(ht.floatData=[]),(7&mt)==2)for(pt=it.uint32()+it.pos;it.pos<pt;)ht.floatData.push(it.float());else ht.floatData.push(it.float());break;case 5:if(ht.int32Data&&ht.int32Data.length||(ht.int32Data=[]),(7&mt)==2)for(pt=it.uint32()+it.pos;it.pos<pt;)ht.int32Data.push(it.int32());else ht.int32Data.push(it.int32());break;case 6:ht.stringData&&ht.stringData.length||(ht.stringData=[]),ht.stringData.push(it.bytes());break;case 7:if(ht.int64Data&&ht.int64Data.length||(ht.int64Data=[]),(7&mt)==2)for(pt=it.uint32()+it.pos;it.pos<pt;)ht.int64Data.push(it.int64());else ht.int64Data.push(it.int64());break;case 8:ht.name=it.string();break;case 12:ht.docString=it.string();break;case 9:ht.rawData=it.bytes();break;case 13:ht.externalData&&ht.externalData.length||(ht.externalData=[]),ht.externalData.push(dt.onnx.StringStringEntryProto.decode(it,it.uint32()));break;case 14:ht.dataLocation=it.int32();break;case 10:if(ht.doubleData&&ht.doubleData.length||(ht.doubleData=[]),(7&mt)==2)for(pt=it.uint32()+it.pos;it.pos<pt;)ht.doubleData.push(it.double());else ht.doubleData.push(it.double());break;case 11:if(ht.uint64Data&&ht.uint64Data.length||(ht.uint64Data=[]),(7&mt)==2)for(pt=it.uint32()+it.pos;it.pos<pt;)ht.uint64Data.push(it.uint64());else ht.uint64Data.push(it.uint64());break;default:it.skipType(7&mt)}}return ht},st.decodeDelimited=function(it){return it instanceof at||(it=new at(it)),this.decode(it,it.uint32())},st.verify=function(it){if(typeof it!="object"||it===null)return"object expected";if(it.dims!=null&&it.hasOwnProperty("dims")){if(!Array.isArray(it.dims))return"dims: array expected";for(var ct=0;ct<it.dims.length;++ct)if(!(ut.isInteger(it.dims[ct])||it.dims[ct]&&ut.isInteger(it.dims[ct].low)&&ut.isInteger(it.dims[ct].high)))return"dims: integer|Long[] expected"}if(it.dataType!=null&&it.hasOwnProperty("dataType")&&!ut.isInteger(it.dataType))return"dataType: integer expected";if(it.segment!=null&&it.hasOwnProperty("segment")&&(ft=dt.onnx.TensorProto.Segment.verify(it.segment)))return"segment."+ft;if(it.floatData!=null&&it.hasOwnProperty("floatData")){if(!Array.isArray(it.floatData))return"floatData: array expected";for(ct=0;ct<it.floatData.length;++ct)if(typeof it.floatData[ct]!="number")return"floatData: number[] expected"}if(it.int32Data!=null&&it.hasOwnProperty("int32Data")){if(!Array.isArray(it.int32Data))return"int32Data: array expected";for(ct=0;ct<it.int32Data.length;++ct)if(!ut.isInteger(it.int32Data[ct]))return"int32Data: integer[] expected"}if(it.stringData!=null&&it.hasOwnProperty("stringData")){if(!Array.isArray(it.stringData))return"stringData: array expected";for(ct=0;ct<it.stringData.length;++ct)if(!(it.stringData[ct]&&typeof it.stringData[ct].length=="number"||ut.isString(it.stringData[ct])))return"stringData: buffer[] expected"}if(it.int64Data!=null&&it.hasOwnProperty("int64Data")){if(!Array.isArray(it.int64Data))return"int64Data: array expected";for(ct=0;ct<it.int64Data.length;++ct)if(!(ut.isInteger(it.int64Data[ct])||it.int64Data[ct]&&ut.isInteger(it.int64Data[ct].low)&&ut.isInteger(it.int64Data[ct].high)))return"int64Data: integer|Long[] expected"}if(it.name!=null&&it.hasOwnProperty("name")&&!ut.isString(it.name))return"name: string expected";if(it.docString!=null&&it.hasOwnProperty("docString")&&!ut.isString(it.docString))return"docString: string expected";if(it.rawData!=null&&it.hasOwnProperty("rawData")&&!(it.rawData&&typeof it.rawData.length=="number"||ut.isString(it.rawData)))return"rawData: buffer expected";if(it.externalData!=null&&it.hasOwnProperty("externalData")){if(!Array.isArray(it.externalData))return"externalData: array expected";for(ct=0;ct<it.externalData.length;++ct){var ft;if(ft=dt.onnx.StringStringEntryProto.verify(it.externalData[ct]))return"externalData."+ft}}if(it.dataLocation!=null&&it.hasOwnProperty("dataLocation"))switch(it.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(it.doubleData!=null&&it.hasOwnProperty("doubleData")){if(!Array.isArray(it.doubleData))return"doubleData: array expected";for(ct=0;ct<it.doubleData.length;++ct)if(typeof it.doubleData[ct]!="number")return"doubleData: number[] expected"}if(it.uint64Data!=null&&it.hasOwnProperty("uint64Data")){if(!Array.isArray(it.uint64Data))return"uint64Data: array expected";for(ct=0;ct<it.uint64Data.length;++ct)if(!(ut.isInteger(it.uint64Data[ct])||it.uint64Data[ct]&&ut.isInteger(it.uint64Data[ct].low)&&ut.isInteger(it.uint64Data[ct].high)))return"uint64Data: integer|Long[] expected"}return null},st.fromObject=function(it){if(it instanceof dt.onnx.TensorProto)return it;var ct=new dt.onnx.TensorProto;if(it.dims){if(!Array.isArray(it.dims))throw TypeError(".onnx.TensorProto.dims: array expected");ct.dims=[];for(var ft=0;ft<it.dims.length;++ft)ut.Long?(ct.dims[ft]=ut.Long.fromValue(it.dims[ft])).unsigned=!1:typeof it.dims[ft]=="string"?ct.dims[ft]=parseInt(it.dims[ft],10):typeof it.dims[ft]=="number"?ct.dims[ft]=it.dims[ft]:typeof it.dims[ft]=="object"&&(ct.dims[ft]=new ut.LongBits(it.dims[ft].low>>>0,it.dims[ft].high>>>0).toNumber())}if(it.dataType!=null&&(ct.dataType=0|it.dataType),it.segment!=null){if(typeof it.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");ct.segment=dt.onnx.TensorProto.Segment.fromObject(it.segment)}if(it.floatData){if(!Array.isArray(it.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(ct.floatData=[],ft=0;ft<it.floatData.length;++ft)ct.floatData[ft]=Number(it.floatData[ft])}if(it.int32Data){if(!Array.isArray(it.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(ct.int32Data=[],ft=0;ft<it.int32Data.length;++ft)ct.int32Data[ft]=0|it.int32Data[ft]}if(it.stringData){if(!Array.isArray(it.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(ct.stringData=[],ft=0;ft<it.stringData.length;++ft)typeof it.stringData[ft]=="string"?ut.base64.decode(it.stringData[ft],ct.stringData[ft]=ut.newBuffer(ut.base64.length(it.stringData[ft])),0):it.stringData[ft].length&&(ct.stringData[ft]=it.stringData[ft])}if(it.int64Data){if(!Array.isArray(it.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(ct.int64Data=[],ft=0;ft<it.int64Data.length;++ft)ut.Long?(ct.int64Data[ft]=ut.Long.fromValue(it.int64Data[ft])).unsigned=!1:typeof it.int64Data[ft]=="string"?ct.int64Data[ft]=parseInt(it.int64Data[ft],10):typeof it.int64Data[ft]=="number"?ct.int64Data[ft]=it.int64Data[ft]:typeof it.int64Data[ft]=="object"&&(ct.int64Data[ft]=new ut.LongBits(it.int64Data[ft].low>>>0,it.int64Data[ft].high>>>0).toNumber())}if(it.name!=null&&(ct.name=String(it.name)),it.docString!=null&&(ct.docString=String(it.docString)),it.rawData!=null&&(typeof it.rawData=="string"?ut.base64.decode(it.rawData,ct.rawData=ut.newBuffer(ut.base64.length(it.rawData)),0):it.rawData.length&&(ct.rawData=it.rawData)),it.externalData){if(!Array.isArray(it.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(ct.externalData=[],ft=0;ft<it.externalData.length;++ft){if(typeof it.externalData[ft]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");ct.externalData[ft]=dt.onnx.StringStringEntryProto.fromObject(it.externalData[ft])}}switch(it.dataLocation){case"DEFAULT":case 0:ct.dataLocation=0;break;case"EXTERNAL":case 1:ct.dataLocation=1}if(it.doubleData){if(!Array.isArray(it.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(ct.doubleData=[],ft=0;ft<it.doubleData.length;++ft)ct.doubleData[ft]=Number(it.doubleData[ft])}if(it.uint64Data){if(!Array.isArray(it.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(ct.uint64Data=[],ft=0;ft<it.uint64Data.length;++ft)ut.Long?(ct.uint64Data[ft]=ut.Long.fromValue(it.uint64Data[ft])).unsigned=!0:typeof it.uint64Data[ft]=="string"?ct.uint64Data[ft]=parseInt(it.uint64Data[ft],10):typeof it.uint64Data[ft]=="number"?ct.uint64Data[ft]=it.uint64Data[ft]:typeof it.uint64Data[ft]=="object"&&(ct.uint64Data[ft]=new ut.LongBits(it.uint64Data[ft].low>>>0,it.uint64Data[ft].high>>>0).toNumber(!0))}return ct},st.toObject=function(it,ct){ct||(ct={});var ft={};if((ct.arrays||ct.defaults)&&(ft.dims=[],ft.floatData=[],ft.int32Data=[],ft.stringData=[],ft.int64Data=[],ft.doubleData=[],ft.uint64Data=[],ft.externalData=[]),ct.defaults&&(ft.dataType=0,ft.segment=null,ft.name="",ct.bytes===String?ft.rawData="":(ft.rawData=[],ct.bytes!==Array&&(ft.rawData=ut.newBuffer(ft.rawData))),ft.docString="",ft.dataLocation=ct.enums===String?"DEFAULT":0),it.dims&&it.dims.length){ft.dims=[];for(var ht=0;ht<it.dims.length;++ht)typeof it.dims[ht]=="number"?ft.dims[ht]=ct.longs===String?String(it.dims[ht]):it.dims[ht]:ft.dims[ht]=ct.longs===String?ut.Long.prototype.toString.call(it.dims[ht]):ct.longs===Number?new ut.LongBits(it.dims[ht].low>>>0,it.dims[ht].high>>>0).toNumber():it.dims[ht]}if(it.dataType!=null&&it.hasOwnProperty("dataType")&&(ft.dataType=it.dataType),it.segment!=null&&it.hasOwnProperty("segment")&&(ft.segment=dt.onnx.TensorProto.Segment.toObject(it.segment,ct)),it.floatData&&it.floatData.length)for(ft.floatData=[],ht=0;ht<it.floatData.length;++ht)ft.floatData[ht]=ct.json&&!isFinite(it.floatData[ht])?String(it.floatData[ht]):it.floatData[ht];if(it.int32Data&&it.int32Data.length)for(ft.int32Data=[],ht=0;ht<it.int32Data.length;++ht)ft.int32Data[ht]=it.int32Data[ht];if(it.stringData&&it.stringData.length)for(ft.stringData=[],ht=0;ht<it.stringData.length;++ht)ft.stringData[ht]=ct.bytes===String?ut.base64.encode(it.stringData[ht],0,it.stringData[ht].length):ct.bytes===Array?Array.prototype.slice.call(it.stringData[ht]):it.stringData[ht];if(it.int64Data&&it.int64Data.length)for(ft.int64Data=[],ht=0;ht<it.int64Data.length;++ht)typeof it.int64Data[ht]=="number"?ft.int64Data[ht]=ct.longs===String?String(it.int64Data[ht]):it.int64Data[ht]:ft.int64Data[ht]=ct.longs===String?ut.Long.prototype.toString.call(it.int64Data[ht]):ct.longs===Number?new ut.LongBits(it.int64Data[ht].low>>>0,it.int64Data[ht].high>>>0).toNumber():it.int64Data[ht];if(it.name!=null&&it.hasOwnProperty("name")&&(ft.name=it.name),it.rawData!=null&&it.hasOwnProperty("rawData")&&(ft.rawData=ct.bytes===String?ut.base64.encode(it.rawData,0,it.rawData.length):ct.bytes===Array?Array.prototype.slice.call(it.rawData):it.rawData),it.doubleData&&it.doubleData.length)for(ft.doubleData=[],ht=0;ht<it.doubleData.length;++ht)ft.doubleData[ht]=ct.json&&!isFinite(it.doubleData[ht])?String(it.doubleData[ht]):it.doubleData[ht];if(it.uint64Data&&it.uint64Data.length)for(ft.uint64Data=[],ht=0;ht<it.uint64Data.length;++ht)typeof it.uint64Data[ht]=="number"?ft.uint64Data[ht]=ct.longs===String?String(it.uint64Data[ht]):it.uint64Data[ht]:ft.uint64Data[ht]=ct.longs===String?ut.Long.prototype.toString.call(it.uint64Data[ht]):ct.longs===Number?new ut.LongBits(it.uint64Data[ht].low>>>0,it.uint64Data[ht].high>>>0).toNumber(!0):it.uint64Data[ht];if(it.docString!=null&&it.hasOwnProperty("docString")&&(ft.docString=it.docString),it.externalData&&it.externalData.length)for(ft.externalData=[],ht=0;ht<it.externalData.length;++ht)ft.externalData[ht]=dt.onnx.StringStringEntryProto.toObject(it.externalData[ht],ct);return it.dataLocation!=null&&it.hasOwnProperty("dataLocation")&&(ft.dataLocation=ct.enums===String?dt.onnx.TensorProto.DataLocation[it.dataLocation]:it.dataLocation),ft},st.prototype.toJSON=function(){return this.constructor.toObject(this,ot.util.toJSONOptions)},st.DataType=function(){var it={},ct=Object.create(it);return ct[it[0]="UNDEFINED"]=0,ct[it[1]="FLOAT"]=1,ct[it[2]="UINT8"]=2,ct[it[3]="INT8"]=3,ct[it[4]="UINT16"]=4,ct[it[5]="INT16"]=5,ct[it[6]="INT32"]=6,ct[it[7]="INT64"]=7,ct[it[8]="STRING"]=8,ct[it[9]="BOOL"]=9,ct[it[10]="FLOAT16"]=10,ct[it[11]="DOUBLE"]=11,ct[it[12]="UINT32"]=12,ct[it[13]="UINT64"]=13,ct[it[14]="COMPLEX64"]=14,ct[it[15]="COMPLEX128"]=15,ct[it[16]="BFLOAT16"]=16,ct}(),st.Segment=function(){function it(ct){if(ct)for(var ft=Object.keys(ct),ht=0;ht<ft.length;++ht)ct[ft[ht]]!=null&&(this[ft[ht]]=ct[ft[ht]])}return it.prototype.begin=ut.Long?ut.Long.fromBits(0,0,!1):0,it.prototype.end=ut.Long?ut.Long.fromBits(0,0,!1):0,it.create=function(ct){return new it(ct)},it.encode=function(ct,ft){return ft||(ft=lt.create()),ct.begin!=null&&ct.hasOwnProperty("begin")&&ft.uint32(8).int64(ct.begin),ct.end!=null&&ct.hasOwnProperty("end")&&ft.uint32(16).int64(ct.end),ft},it.encodeDelimited=function(ct,ft){return this.encode(ct,ft).ldelim()},it.decode=function(ct,ft){ct instanceof at||(ct=at.create(ct));for(var ht=ft===void 0?ct.len:ct.pos+ft,mt=new dt.onnx.TensorProto.Segment;ct.pos<ht;){var pt=ct.uint32();switch(pt>>>3){case 1:mt.begin=ct.int64();break;case 2:mt.end=ct.int64();break;default:ct.skipType(7&pt)}}return mt},it.decodeDelimited=function(ct){return ct instanceof at||(ct=new at(ct)),this.decode(ct,ct.uint32())},it.verify=function(ct){return typeof ct!="object"||ct===null?"object expected":ct.begin!=null&&ct.hasOwnProperty("begin")&&!(ut.isInteger(ct.begin)||ct.begin&&ut.isInteger(ct.begin.low)&&ut.isInteger(ct.begin.high))?"begin: integer|Long expected":ct.end!=null&&ct.hasOwnProperty("end")&&!(ut.isInteger(ct.end)||ct.end&&ut.isInteger(ct.end.low)&&ut.isInteger(ct.end.high))?"end: integer|Long expected":null},it.fromObject=function(ct){if(ct instanceof dt.onnx.TensorProto.Segment)return ct;var ft=new dt.onnx.TensorProto.Segment;return ct.begin!=null&&(ut.Long?(ft.begin=ut.Long.fromValue(ct.begin)).unsigned=!1:typeof ct.begin=="string"?ft.begin=parseInt(ct.begin,10):typeof ct.begin=="number"?ft.begin=ct.begin:typeof ct.begin=="object"&&(ft.begin=new ut.LongBits(ct.begin.low>>>0,ct.begin.high>>>0).toNumber())),ct.end!=null&&(ut.Long?(ft.end=ut.Long.fromValue(ct.end)).unsigned=!1:typeof ct.end=="string"?ft.end=parseInt(ct.end,10):typeof ct.end=="number"?ft.end=ct.end:typeof ct.end=="object"&&(ft.end=new ut.LongBits(ct.end.low>>>0,ct.end.high>>>0).toNumber())),ft},it.toObject=function(ct,ft){ft||(ft={});var ht={};if(ft.defaults){if(ut.Long){var mt=new ut.Long(0,0,!1);ht.begin=ft.longs===String?mt.toString():ft.longs===Number?mt.toNumber():mt}else ht.begin=ft.longs===String?"0":0;ut.Long?(mt=new ut.Long(0,0,!1),ht.end=ft.longs===String?mt.toString():ft.longs===Number?mt.toNumber():mt):ht.end=ft.longs===String?"0":0}return ct.begin!=null&&ct.hasOwnProperty("begin")&&(typeof ct.begin=="number"?ht.begin=ft.longs===String?String(ct.begin):ct.begin:ht.begin=ft.longs===String?ut.Long.prototype.toString.call(ct.begin):ft.longs===Number?new ut.LongBits(ct.begin.low>>>0,ct.begin.high>>>0).toNumber():ct.begin),ct.end!=null&&ct.hasOwnProperty("end")&&(typeof ct.end=="number"?ht.end=ft.longs===String?String(ct.end):ct.end:ht.end=ft.longs===String?ut.Long.prototype.toString.call(ct.end):ft.longs===Number?new ut.LongBits(ct.end.low>>>0,ct.end.high>>>0).toNumber():ct.end),ht},it.prototype.toJSON=function(){return this.constructor.toObject(this,ot.util.toJSONOptions)},it}(),st.DataLocation=function(){var it={},ct=Object.create(it);return ct[it[0]="DEFAULT"]=0,ct[it[1]="EXTERNAL"]=1,ct}(),st}(),rt.TensorShapeProto=function(){function st(it){if(this.dim=[],it)for(var ct=Object.keys(it),ft=0;ft<ct.length;++ft)it[ct[ft]]!=null&&(this[ct[ft]]=it[ct[ft]])}return st.prototype.dim=ut.emptyArray,st.create=function(it){return new st(it)},st.encode=function(it,ct){if(ct||(ct=lt.create()),it.dim!=null&&it.dim.length)for(var ft=0;ft<it.dim.length;++ft)dt.onnx.TensorShapeProto.Dimension.encode(it.dim[ft],ct.uint32(10).fork()).ldelim();return ct},st.encodeDelimited=function(it,ct){return this.encode(it,ct).ldelim()},st.decode=function(it,ct){it instanceof at||(it=at.create(it));for(var ft=ct===void 0?it.len:it.pos+ct,ht=new dt.onnx.TensorShapeProto;it.pos<ft;){var mt=it.uint32();mt>>>3==1?(ht.dim&&ht.dim.length||(ht.dim=[]),ht.dim.push(dt.onnx.TensorShapeProto.Dimension.decode(it,it.uint32()))):it.skipType(7&mt)}return ht},st.decodeDelimited=function(it){return it instanceof at||(it=new at(it)),this.decode(it,it.uint32())},st.verify=function(it){if(typeof it!="object"||it===null)return"object expected";if(it.dim!=null&&it.hasOwnProperty("dim")){if(!Array.isArray(it.dim))return"dim: array expected";for(var ct=0;ct<it.dim.length;++ct){var ft=dt.onnx.TensorShapeProto.Dimension.verify(it.dim[ct]);if(ft)return"dim."+ft}}return null},st.fromObject=function(it){if(it instanceof dt.onnx.TensorShapeProto)return it;var ct=new dt.onnx.TensorShapeProto;if(it.dim){if(!Array.isArray(it.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");ct.dim=[];for(var ft=0;ft<it.dim.length;++ft){if(typeof it.dim[ft]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");ct.dim[ft]=dt.onnx.TensorShapeProto.Dimension.fromObject(it.dim[ft])}}return ct},st.toObject=function(it,ct){ct||(ct={});var ft={};if((ct.arrays||ct.defaults)&&(ft.dim=[]),it.dim&&it.dim.length){ft.dim=[];for(var ht=0;ht<it.dim.length;++ht)ft.dim[ht]=dt.onnx.TensorShapeProto.Dimension.toObject(it.dim[ht],ct)}return ft},st.prototype.toJSON=function(){return this.constructor.toObject(this,ot.util.toJSONOptions)},st.Dimension=function(){function it(ft){if(ft)for(var ht=Object.keys(ft),mt=0;mt<ht.length;++mt)ft[ht[mt]]!=null&&(this[ht[mt]]=ft[ht[mt]])}var ct;return it.prototype.dimValue=ut.Long?ut.Long.fromBits(0,0,!1):0,it.prototype.dimParam="",it.prototype.denotation="",Object.defineProperty(it.prototype,"value",{get:ut.oneOfGetter(ct=["dimValue","dimParam"]),set:ut.oneOfSetter(ct)}),it.create=function(ft){return new it(ft)},it.encode=function(ft,ht){return ht||(ht=lt.create()),ft.dimValue!=null&&ft.hasOwnProperty("dimValue")&&ht.uint32(8).int64(ft.dimValue),ft.dimParam!=null&&ft.hasOwnProperty("dimParam")&&ht.uint32(18).string(ft.dimParam),ft.denotation!=null&&ft.hasOwnProperty("denotation")&&ht.uint32(26).string(ft.denotation),ht},it.encodeDelimited=function(ft,ht){return this.encode(ft,ht).ldelim()},it.decode=function(ft,ht){ft instanceof at||(ft=at.create(ft));for(var mt=ht===void 0?ft.len:ft.pos+ht,pt=new dt.onnx.TensorShapeProto.Dimension;ft.pos<mt;){var _t=ft.uint32();switch(_t>>>3){case 1:pt.dimValue=ft.int64();break;case 2:pt.dimParam=ft.string();break;case 3:pt.denotation=ft.string();break;default:ft.skipType(7&_t)}}return pt},it.decodeDelimited=function(ft){return ft instanceof at||(ft=new at(ft)),this.decode(ft,ft.uint32())},it.verify=function(ft){if(typeof ft!="object"||ft===null)return"object expected";var ht={};if(ft.dimValue!=null&&ft.hasOwnProperty("dimValue")&&(ht.value=1,!(ut.isInteger(ft.dimValue)||ft.dimValue&&ut.isInteger(ft.dimValue.low)&&ut.isInteger(ft.dimValue.high))))return"dimValue: integer|Long expected";if(ft.dimParam!=null&&ft.hasOwnProperty("dimParam")){if(ht.value===1)return"value: multiple values";if(ht.value=1,!ut.isString(ft.dimParam))return"dimParam: string expected"}return ft.denotation!=null&&ft.hasOwnProperty("denotation")&&!ut.isString(ft.denotation)?"denotation: string expected":null},it.fromObject=function(ft){if(ft instanceof dt.onnx.TensorShapeProto.Dimension)return ft;var ht=new dt.onnx.TensorShapeProto.Dimension;return ft.dimValue!=null&&(ut.Long?(ht.dimValue=ut.Long.fromValue(ft.dimValue)).unsigned=!1:typeof ft.dimValue=="string"?ht.dimValue=parseInt(ft.dimValue,10):typeof ft.dimValue=="number"?ht.dimValue=ft.dimValue:typeof ft.dimValue=="object"&&(ht.dimValue=new ut.LongBits(ft.dimValue.low>>>0,ft.dimValue.high>>>0).toNumber())),ft.dimParam!=null&&(ht.dimParam=String(ft.dimParam)),ft.denotation!=null&&(ht.denotation=String(ft.denotation)),ht},it.toObject=function(ft,ht){ht||(ht={});var mt={};return ht.defaults&&(mt.denotation=""),ft.dimValue!=null&&ft.hasOwnProperty("dimValue")&&(typeof ft.dimValue=="number"?mt.dimValue=ht.longs===String?String(ft.dimValue):ft.dimValue:mt.dimValue=ht.longs===String?ut.Long.prototype.toString.call(ft.dimValue):ht.longs===Number?new ut.LongBits(ft.dimValue.low>>>0,ft.dimValue.high>>>0).toNumber():ft.dimValue,ht.oneofs&&(mt.value="dimValue")),ft.dimParam!=null&&ft.hasOwnProperty("dimParam")&&(mt.dimParam=ft.dimParam,ht.oneofs&&(mt.value="dimParam")),ft.denotation!=null&&ft.hasOwnProperty("denotation")&&(mt.denotation=ft.denotation),mt},it.prototype.toJSON=function(){return this.constructor.toObject(this,ot.util.toJSONOptions)},it}(),st}(),rt.TypeProto=function(){function st(ct){if(ct)for(var ft=Object.keys(ct),ht=0;ht<ft.length;++ht)ct[ft[ht]]!=null&&(this[ft[ht]]=ct[ft[ht]])}var it;return st.prototype.tensorType=null,st.prototype.denotation="",Object.defineProperty(st.prototype,"value",{get:ut.oneOfGetter(it=["tensorType"]),set:ut.oneOfSetter(it)}),st.create=function(ct){return new st(ct)},st.encode=function(ct,ft){return ft||(ft=lt.create()),ct.tensorType!=null&&ct.hasOwnProperty("tensorType")&&dt.onnx.TypeProto.Tensor.encode(ct.tensorType,ft.uint32(10).fork()).ldelim(),ct.denotation!=null&&ct.hasOwnProperty("denotation")&&ft.uint32(50).string(ct.denotation),ft},st.encodeDelimited=function(ct,ft){return this.encode(ct,ft).ldelim()},st.decode=function(ct,ft){ct instanceof at||(ct=at.create(ct));for(var ht=ft===void 0?ct.len:ct.pos+ft,mt=new dt.onnx.TypeProto;ct.pos<ht;){var pt=ct.uint32();switch(pt>>>3){case 1:mt.tensorType=dt.onnx.TypeProto.Tensor.decode(ct,ct.uint32());break;case 6:mt.denotation=ct.string();break;default:ct.skipType(7&pt)}}return mt},st.decodeDelimited=function(ct){return ct instanceof at||(ct=new at(ct)),this.decode(ct,ct.uint32())},st.verify=function(ct){if(typeof ct!="object"||ct===null)return"object expected";if(ct.tensorType!=null&&ct.hasOwnProperty("tensorType")){var ft=dt.onnx.TypeProto.Tensor.verify(ct.tensorType);if(ft)return"tensorType."+ft}return ct.denotation!=null&&ct.hasOwnProperty("denotation")&&!ut.isString(ct.denotation)?"denotation: string expected":null},st.fromObject=function(ct){if(ct instanceof dt.onnx.TypeProto)return ct;var ft=new dt.onnx.TypeProto;if(ct.tensorType!=null){if(typeof ct.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");ft.tensorType=dt.onnx.TypeProto.Tensor.fromObject(ct.tensorType)}return ct.denotation!=null&&(ft.denotation=String(ct.denotation)),ft},st.toObject=function(ct,ft){ft||(ft={});var ht={};return ft.defaults&&(ht.denotation=""),ct.tensorType!=null&&ct.hasOwnProperty("tensorType")&&(ht.tensorType=dt.onnx.TypeProto.Tensor.toObject(ct.tensorType,ft),ft.oneofs&&(ht.value="tensorType")),ct.denotation!=null&&ct.hasOwnProperty("denotation")&&(ht.denotation=ct.denotation),ht},st.prototype.toJSON=function(){return this.constructor.toObject(this,ot.util.toJSONOptions)},st.Tensor=function(){function ct(ft){if(ft)for(var ht=Object.keys(ft),mt=0;mt<ht.length;++mt)ft[ht[mt]]!=null&&(this[ht[mt]]=ft[ht[mt]])}return ct.prototype.elemType=0,ct.prototype.shape=null,ct.create=function(ft){return new ct(ft)},ct.encode=function(ft,ht){return ht||(ht=lt.create()),ft.elemType!=null&&ft.hasOwnProperty("elemType")&&ht.uint32(8).int32(ft.elemType),ft.shape!=null&&ft.hasOwnProperty("shape")&&dt.onnx.TensorShapeProto.encode(ft.shape,ht.uint32(18).fork()).ldelim(),ht},ct.encodeDelimited=function(ft,ht){return this.encode(ft,ht).ldelim()},ct.decode=function(ft,ht){ft instanceof at||(ft=at.create(ft));for(var mt=ht===void 0?ft.len:ft.pos+ht,pt=new dt.onnx.TypeProto.Tensor;ft.pos<mt;){var _t=ft.uint32();switch(_t>>>3){case 1:pt.elemType=ft.int32();break;case 2:pt.shape=dt.onnx.TensorShapeProto.decode(ft,ft.uint32());break;default:ft.skipType(7&_t)}}return pt},ct.decodeDelimited=function(ft){return ft instanceof at||(ft=new at(ft)),this.decode(ft,ft.uint32())},ct.verify=function(ft){if(typeof ft!="object"||ft===null)return"object expected";if(ft.elemType!=null&&ft.hasOwnProperty("elemType")&&!ut.isInteger(ft.elemType))return"elemType: integer expected";if(ft.shape!=null&&ft.hasOwnProperty("shape")){var ht=dt.onnx.TensorShapeProto.verify(ft.shape);if(ht)return"shape."+ht}return null},ct.fromObject=function(ft){if(ft instanceof dt.onnx.TypeProto.Tensor)return ft;var ht=new dt.onnx.TypeProto.Tensor;if(ft.elemType!=null&&(ht.elemType=0|ft.elemType),ft.shape!=null){if(typeof ft.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");ht.shape=dt.onnx.TensorShapeProto.fromObject(ft.shape)}return ht},ct.toObject=function(ft,ht){ht||(ht={});var mt={};return ht.defaults&&(mt.elemType=0,mt.shape=null),ft.elemType!=null&&ft.hasOwnProperty("elemType")&&(mt.elemType=ft.elemType),ft.shape!=null&&ft.hasOwnProperty("shape")&&(mt.shape=dt.onnx.TensorShapeProto.toObject(ft.shape,ht)),mt},ct.prototype.toJSON=function(){return this.constructor.toObject(this,ot.util.toJSONOptions)},ct}(),st}(),rt.OperatorSetIdProto=function(){function st(it){if(it)for(var ct=Object.keys(it),ft=0;ft<ct.length;++ft)it[ct[ft]]!=null&&(this[ct[ft]]=it[ct[ft]])}return st.prototype.domain="",st.prototype.version=ut.Long?ut.Long.fromBits(0,0,!1):0,st.create=function(it){return new st(it)},st.encode=function(it,ct){return ct||(ct=lt.create()),it.domain!=null&&it.hasOwnProperty("domain")&&ct.uint32(10).string(it.domain),it.version!=null&&it.hasOwnProperty("version")&&ct.uint32(16).int64(it.version),ct},st.encodeDelimited=function(it,ct){return this.encode(it,ct).ldelim()},st.decode=function(it,ct){it instanceof at||(it=at.create(it));for(var ft=ct===void 0?it.len:it.pos+ct,ht=new dt.onnx.OperatorSetIdProto;it.pos<ft;){var mt=it.uint32();switch(mt>>>3){case 1:ht.domain=it.string();break;case 2:ht.version=it.int64();break;default:it.skipType(7&mt)}}return ht},st.decodeDelimited=function(it){return it instanceof at||(it=new at(it)),this.decode(it,it.uint32())},st.verify=function(it){return typeof it!="object"||it===null?"object expected":it.domain!=null&&it.hasOwnProperty("domain")&&!ut.isString(it.domain)?"domain: string expected":it.version!=null&&it.hasOwnProperty("version")&&!(ut.isInteger(it.version)||it.version&&ut.isInteger(it.version.low)&&ut.isInteger(it.version.high))?"version: integer|Long expected":null},st.fromObject=function(it){if(it instanceof dt.onnx.OperatorSetIdProto)return it;var ct=new dt.onnx.OperatorSetIdProto;return it.domain!=null&&(ct.domain=String(it.domain)),it.version!=null&&(ut.Long?(ct.version=ut.Long.fromValue(it.version)).unsigned=!1:typeof it.version=="string"?ct.version=parseInt(it.version,10):typeof it.version=="number"?ct.version=it.version:typeof it.version=="object"&&(ct.version=new ut.LongBits(it.version.low>>>0,it.version.high>>>0).toNumber())),ct},st.toObject=function(it,ct){ct||(ct={});var ft={};if(ct.defaults)if(ft.domain="",ut.Long){var ht=new ut.Long(0,0,!1);ft.version=ct.longs===String?ht.toString():ct.longs===Number?ht.toNumber():ht}else ft.version=ct.longs===String?"0":0;return it.domain!=null&&it.hasOwnProperty("domain")&&(ft.domain=it.domain),it.version!=null&&it.hasOwnProperty("version")&&(typeof it.version=="number"?ft.version=ct.longs===String?String(it.version):it.version:ft.version=ct.longs===String?ut.Long.prototype.toString.call(it.version):ct.longs===Number?new ut.LongBits(it.version.low>>>0,it.version.high>>>0).toNumber():it.version),ft},st.prototype.toJSON=function(){return this.constructor.toObject(this,ot.util.toJSONOptions)},st}(),rt),et.exports=dt},2100:(et,_,_e)=>{et.exports=_e(9482)},9482:(et,_,_e)=>{var tt=_;function nt(){tt.util._configure(),tt.Writer._configure(tt.BufferWriter),tt.Reader._configure(tt.BufferReader)}tt.build="minimal",tt.Writer=_e(1173),tt.BufferWriter=_e(3155),tt.Reader=_e(1408),tt.BufferReader=_e(593),tt.util=_e(9693),tt.rpc=_e(5994),tt.roots=_e(5054),tt.configure=nt,nt()},1408:(et,_,_e)=>{et.exports=lt;var tt,nt=_e(9693),rt=nt.LongBits,ot=nt.utf8;function at(ht,mt){return RangeError("index out of range: "+ht.pos+" + "+(mt||1)+" > "+ht.len)}function lt(ht){this.buf=ht,this.pos=0,this.len=ht.length}var ut,dt=typeof Uint8Array<"u"?function(ht){if(ht instanceof Uint8Array||Array.isArray(ht))return new lt(ht);throw Error("illegal buffer")}:function(ht){if(Array.isArray(ht))return new lt(ht);throw Error("illegal buffer")},st=function(){return nt.Buffer?function(ht){return(lt.create=function(mt){return nt.Buffer.isBuffer(mt)?new tt(mt):dt(mt)})(ht)}:dt};function it(){var ht=new rt(0,0),mt=0;if(!(this.len-this.pos>4)){for(;mt<3;++mt){if(this.pos>=this.len)throw at(this);if(ht.lo=(ht.lo|(127&this.buf[this.pos])<<7*mt)>>>0,this.buf[this.pos++]<128)return ht}return ht.lo=(ht.lo|(127&this.buf[this.pos++])<<7*mt)>>>0,ht}for(;mt<4;++mt)if(ht.lo=(ht.lo|(127&this.buf[this.pos])<<7*mt)>>>0,this.buf[this.pos++]<128)return ht;if(ht.lo=(ht.lo|(127&this.buf[this.pos])<<28)>>>0,ht.hi=(ht.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return ht;if(mt=0,this.len-this.pos>4){for(;mt<5;++mt)if(ht.hi=(ht.hi|(127&this.buf[this.pos])<<7*mt+3)>>>0,this.buf[this.pos++]<128)return ht}else for(;mt<5;++mt){if(this.pos>=this.len)throw at(this);if(ht.hi=(ht.hi|(127&this.buf[this.pos])<<7*mt+3)>>>0,this.buf[this.pos++]<128)return ht}throw Error("invalid varint encoding")}function ct(ht,mt){return(ht[mt-4]|ht[mt-3]<<8|ht[mt-2]<<16|ht[mt-1]<<24)>>>0}function ft(){if(this.pos+8>this.len)throw at(this,8);return new rt(ct(this.buf,this.pos+=4),ct(this.buf,this.pos+=4))}lt.create=st(),lt.prototype._slice=nt.Array.prototype.subarray||nt.Array.prototype.slice,lt.prototype.uint32=(ut=4294967295,function(){if(ut=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128||(ut=(ut|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)||(ut=(ut|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)||(ut=(ut|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)||(ut=(ut|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128))return ut;if((this.pos+=5)>this.len)throw this.pos=this.len,at(this,10);return ut}),lt.prototype.int32=function(){return 0|this.uint32()},lt.prototype.sint32=function(){var ht=this.uint32();return ht>>>1^-(1&ht)|0},lt.prototype.bool=function(){return this.uint32()!==0},lt.prototype.fixed32=function(){if(this.pos+4>this.len)throw at(this,4);return ct(this.buf,this.pos+=4)},lt.prototype.sfixed32=function(){if(this.pos+4>this.len)throw at(this,4);return 0|ct(this.buf,this.pos+=4)},lt.prototype.float=function(){if(this.pos+4>this.len)throw at(this,4);var ht=nt.float.readFloatLE(this.buf,this.pos);return this.pos+=4,ht},lt.prototype.double=function(){if(this.pos+8>this.len)throw at(this,4);var ht=nt.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,ht},lt.prototype.bytes=function(){var ht=this.uint32(),mt=this.pos,pt=this.pos+ht;if(pt>this.len)throw at(this,ht);return this.pos+=ht,Array.isArray(this.buf)?this.buf.slice(mt,pt):mt===pt?new this.buf.constructor(0):this._slice.call(this.buf,mt,pt)},lt.prototype.string=function(){var ht=this.bytes();return ot.read(ht,0,ht.length)},lt.prototype.skip=function(ht){if(typeof ht=="number"){if(this.pos+ht>this.len)throw at(this,ht);this.pos+=ht}else do if(this.pos>=this.len)throw at(this);while(128&this.buf[this.pos++]);return this},lt.prototype.skipType=function(ht){switch(ht){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(ht=7&this.uint32())!=4;)this.skipType(ht);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+ht+" at offset "+this.pos)}return this},lt._configure=function(ht){tt=ht,lt.create=st(),tt._configure();var mt=nt.Long?"toLong":"toNumber";nt.merge(lt.prototype,{int64:function(){return it.call(this)[mt](!1)},uint64:function(){return it.call(this)[mt](!0)},sint64:function(){return it.call(this).zzDecode()[mt](!1)},fixed64:function(){return ft.call(this)[mt](!0)},sfixed64:function(){return ft.call(this)[mt](!1)}})}},593:(et,_,_e)=>{et.exports=rt;var tt=_e(1408);(rt.prototype=Object.create(tt.prototype)).constructor=rt;var nt=_e(9693);function rt(ot){tt.call(this,ot)}rt._configure=function(){nt.Buffer&&(rt.prototype._slice=nt.Buffer.prototype.slice)},rt.prototype.string=function(){var ot=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+ot,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+ot,this.len))},rt._configure()},5054:et=>{et.exports={}},5994:(et,_,_e)=>{_.Service=_e(7948)},7948:(et,_,_e)=>{et.exports=nt;var tt=_e(9693);function nt(rt,ot,at){if(typeof rt!="function")throw TypeError("rpcImpl must be a function");tt.EventEmitter.call(this),this.rpcImpl=rt,this.requestDelimited=!!ot,this.responseDelimited=!!at}(nt.prototype=Object.create(tt.EventEmitter.prototype)).constructor=nt,nt.prototype.rpcCall=function rt(ot,at,lt,ut,dt){if(!ut)throw TypeError("request must be specified");var st=this;if(!dt)return tt.asPromise(rt,st,ot,at,lt,ut);if(st.rpcImpl)try{return st.rpcImpl(ot,at[st.requestDelimited?"encodeDelimited":"encode"](ut).finish(),function(it,ct){if(it)return st.emit("error",it,ot),dt(it);if(ct!==null){if(!(ct instanceof lt))try{ct=lt[st.responseDelimited?"decodeDelimited":"decode"](ct)}catch(ft){return st.emit("error",ft,ot),dt(ft)}return st.emit("data",ct,ot),dt(null,ct)}st.end(!0)})}catch(it){return st.emit("error",it,ot),void setTimeout(function(){dt(it)},0)}else setTimeout(function(){dt(Error("already ended"))},0)},nt.prototype.end=function(rt){return this.rpcImpl&&(rt||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(et,_,_e)=>{et.exports=nt;var tt=_e(9693);function nt(lt,ut){this.lo=lt>>>0,this.hi=ut>>>0}var rt=nt.zero=new nt(0,0);rt.toNumber=function(){return 0},rt.zzEncode=rt.zzDecode=function(){return this},rt.length=function(){return 1};var ot=nt.zeroHash="\0\0\0\0\0\0\0\0";nt.fromNumber=function(lt){if(lt===0)return rt;var ut=lt<0;ut&&(lt=-lt);var dt=lt>>>0,st=(lt-dt)/4294967296>>>0;return ut&&(st=~st>>>0,dt=~dt>>>0,++dt>4294967295&&(dt=0,++st>4294967295&&(st=0))),new nt(dt,st)},nt.from=function(lt){if(typeof lt=="number")return nt.fromNumber(lt);if(tt.isString(lt)){if(!tt.Long)return nt.fromNumber(parseInt(lt,10));lt=tt.Long.fromString(lt)}return lt.low||lt.high?new nt(lt.low>>>0,lt.high>>>0):rt},nt.prototype.toNumber=function(lt){if(!lt&&this.hi>>>31){var ut=1+~this.lo>>>0,dt=~this.hi>>>0;return ut||(dt=dt+1>>>0),-(ut+4294967296*dt)}return this.lo+4294967296*this.hi},nt.prototype.toLong=function(lt){return tt.Long?new tt.Long(0|this.lo,0|this.hi,!!lt):{low:0|this.lo,high:0|this.hi,unsigned:!!lt}};var at=String.prototype.charCodeAt;nt.fromHash=function(lt){return lt===ot?rt:new nt((at.call(lt,0)|at.call(lt,1)<<8|at.call(lt,2)<<16|at.call(lt,3)<<24)>>>0,(at.call(lt,4)|at.call(lt,5)<<8|at.call(lt,6)<<16|at.call(lt,7)<<24)>>>0)},nt.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},nt.prototype.zzEncode=function(){var lt=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^lt)>>>0,this.lo=(this.lo<<1^lt)>>>0,this},nt.prototype.zzDecode=function(){var lt=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^lt)>>>0,this.hi=(this.hi>>>1^lt)>>>0,this},nt.prototype.length=function(){var lt=this.lo,ut=(this.lo>>>28|this.hi<<4)>>>0,dt=this.hi>>>24;return dt===0?ut===0?lt<16384?lt<128?1:2:lt<2097152?3:4:ut<16384?ut<128?5:6:ut<2097152?7:8:dt<128?9:10}},9693:function(et,_,_e){var tt=_;function nt(ot,at,lt){for(var ut=Object.keys(at),dt=0;dt<ut.length;++dt)ot[ut[dt]]!==void 0&&lt||(ot[ut[dt]]=at[ut[dt]]);return ot}function rt(ot){function at(lt,ut){if(!(this instanceof at))return new at(lt,ut);Object.defineProperty(this,"message",{get:function(){return lt}}),Error.captureStackTrace?Error.captureStackTrace(this,at):Object.defineProperty(this,"stack",{value:new Error().stack||""}),ut&&nt(this,ut)}return(at.prototype=Object.create(Error.prototype)).constructor=at,Object.defineProperty(at.prototype,"name",{get:function(){return ot}}),at.prototype.toString=function(){return this.name+": "+this.message},at}tt.asPromise=_e(4537),tt.base64=_e(7419),tt.EventEmitter=_e(9211),tt.float=_e(945),tt.inquire=_e(7199),tt.utf8=_e(4997),tt.pool=_e(6662),tt.LongBits=_e(1945),tt.isNode=!!(_e.g!==void 0&&_e.g&&_e.g.process&&_e.g.process.versions&&_e.g.process.versions.node),tt.global=tt.isNode&&_e.g||typeof window<"u"&&window||typeof self<"u"&&self||this,tt.emptyArray=Object.freeze?Object.freeze([]):[],tt.emptyObject=Object.freeze?Object.freeze({}):{},tt.isInteger=Number.isInteger||function(ot){return typeof ot=="number"&&isFinite(ot)&&Math.floor(ot)===ot},tt.isString=function(ot){return typeof ot=="string"||ot instanceof String},tt.isObject=function(ot){return ot&&typeof ot=="object"},tt.isset=tt.isSet=function(ot,at){var lt=ot[at];return!(lt==null||!ot.hasOwnProperty(at))&&(typeof lt!="object"||(Array.isArray(lt)?lt.length:Object.keys(lt).length)>0)},tt.Buffer=function(){try{var ot=tt.inquire("buffer").Buffer;return ot.prototype.utf8Write?ot:null}catch{return null}}(),tt._Buffer_from=null,tt._Buffer_allocUnsafe=null,tt.newBuffer=function(ot){return typeof ot=="number"?tt.Buffer?tt._Buffer_allocUnsafe(ot):new tt.Array(ot):tt.Buffer?tt._Buffer_from(ot):typeof Uint8Array>"u"?ot:new Uint8Array(ot)},tt.Array=typeof Uint8Array<"u"?Uint8Array:Array,tt.Long=tt.global.dcodeIO&&tt.global.dcodeIO.Long||tt.global.Long||tt.inquire("long"),tt.key2Re=/^true|false|0|1$/,tt.key32Re=/^-?(?:0|[1-9][0-9]*)$/,tt.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,tt.longToHash=function(ot){return ot?tt.LongBits.from(ot).toHash():tt.LongBits.zeroHash},tt.longFromHash=function(ot,at){var lt=tt.LongBits.fromHash(ot);return tt.Long?tt.Long.fromBits(lt.lo,lt.hi,at):lt.toNumber(!!at)},tt.merge=nt,tt.lcFirst=function(ot){return ot.charAt(0).toLowerCase()+ot.substring(1)},tt.newError=rt,tt.ProtocolError=rt("ProtocolError"),tt.oneOfGetter=function(ot){for(var at={},lt=0;lt<ot.length;++lt)at[ot[lt]]=1;return function(){for(var ut=Object.keys(this),dt=ut.length-1;dt>-1;--dt)if(at[ut[dt]]===1&&this[ut[dt]]!==void 0&&this[ut[dt]]!==null)return ut[dt]}},tt.oneOfSetter=function(ot){return function(at){for(var lt=0;lt<ot.length;++lt)ot[lt]!==at&&delete this[ot[lt]]}},tt.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},tt._configure=function(){var ot=tt.Buffer;ot?(tt._Buffer_from=ot.from!==Uint8Array.from&&ot.from||function(at,lt){return new ot(at,lt)},tt._Buffer_allocUnsafe=ot.allocUnsafe||function(at){return new ot(at)}):tt._Buffer_from=tt._Buffer_allocUnsafe=null}},1173:(et,_,_e)=>{et.exports=st;var tt,nt=_e(9693),rt=nt.LongBits,ot=nt.base64,at=nt.utf8;function lt(_t,vt,bt){this.fn=_t,this.len=vt,this.next=void 0,this.val=bt}function ut(){}function dt(_t){this.head=_t.head,this.tail=_t.tail,this.len=_t.len,this.next=_t.states}function st(){this.len=0,this.head=new lt(ut,0,0),this.tail=this.head,this.states=null}var it=function(){return nt.Buffer?function(){return(st.create=function(){return new tt})()}:function(){return new st}};function ct(_t,vt,bt){vt[bt]=255&_t}function ft(_t,vt){this.len=_t,this.next=void 0,this.val=vt}function ht(_t,vt,bt){for(;_t.hi;)vt[bt++]=127&_t.lo|128,_t.lo=(_t.lo>>>7|_t.hi<<25)>>>0,_t.hi>>>=7;for(;_t.lo>127;)vt[bt++]=127&_t.lo|128,_t.lo=_t.lo>>>7;vt[bt++]=_t.lo}function mt(_t,vt,bt){vt[bt]=255&_t,vt[bt+1]=_t>>>8&255,vt[bt+2]=_t>>>16&255,vt[bt+3]=_t>>>24}st.create=it(),st.alloc=function(_t){return new nt.Array(_t)},nt.Array!==Array&&(st.alloc=nt.pool(st.alloc,nt.Array.prototype.subarray)),st.prototype._push=function(_t,vt,bt){return this.tail=this.tail.next=new lt(_t,vt,bt),this.len+=vt,this},ft.prototype=Object.create(lt.prototype),ft.prototype.fn=function(_t,vt,bt){for(;_t>127;)vt[bt++]=127&_t|128,_t>>>=7;vt[bt]=_t},st.prototype.uint32=function(_t){return this.len+=(this.tail=this.tail.next=new ft((_t>>>=0)<128?1:_t<16384?2:_t<2097152?3:_t<268435456?4:5,_t)).len,this},st.prototype.int32=function(_t){return _t<0?this._push(ht,10,rt.fromNumber(_t)):this.uint32(_t)},st.prototype.sint32=function(_t){return this.uint32((_t<<1^_t>>31)>>>0)},st.prototype.uint64=function(_t){var vt=rt.from(_t);return this._push(ht,vt.length(),vt)},st.prototype.int64=st.prototype.uint64,st.prototype.sint64=function(_t){var vt=rt.from(_t).zzEncode();return this._push(ht,vt.length(),vt)},st.prototype.bool=function(_t){return this._push(ct,1,_t?1:0)},st.prototype.fixed32=function(_t){return this._push(mt,4,_t>>>0)},st.prototype.sfixed32=st.prototype.fixed32,st.prototype.fixed64=function(_t){var vt=rt.from(_t);return this._push(mt,4,vt.lo)._push(mt,4,vt.hi)},st.prototype.sfixed64=st.prototype.fixed64,st.prototype.float=function(_t){return this._push(nt.float.writeFloatLE,4,_t)},st.prototype.double=function(_t){return this._push(nt.float.writeDoubleLE,8,_t)};var pt=nt.Array.prototype.set?function(_t,vt,bt){vt.set(_t,bt)}:function(_t,vt,bt){for(var wt=0;wt<_t.length;++wt)vt[bt+wt]=_t[wt]};st.prototype.bytes=function(_t){var vt=_t.length>>>0;if(!vt)return this._push(ct,1,0);if(nt.isString(_t)){var bt=st.alloc(vt=ot.length(_t));ot.decode(_t,bt,0),_t=bt}return this.uint32(vt)._push(pt,vt,_t)},st.prototype.string=function(_t){var vt=at.length(_t);return vt?this.uint32(vt)._push(at.write,vt,_t):this._push(ct,1,0)},st.prototype.fork=function(){return this.states=new dt(this),this.head=this.tail=new lt(ut,0,0),this.len=0,this},st.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new lt(ut,0,0),this.len=0),this},st.prototype.ldelim=function(){var _t=this.head,vt=this.tail,bt=this.len;return this.reset().uint32(bt),bt&&(this.tail.next=_t.next,this.tail=vt,this.len+=bt),this},st.prototype.finish=function(){for(var _t=this.head.next,vt=this.constructor.alloc(this.len),bt=0;_t;)_t.fn(_t.val,vt,bt),bt+=_t.len,_t=_t.next;return vt},st._configure=function(_t){tt=_t,st.create=it(),tt._configure()}},3155:(et,_,_e)=>{et.exports=rt;var tt=_e(1173);(rt.prototype=Object.create(tt.prototype)).constructor=rt;var nt=_e(9693);function rt(){tt.call(this)}function ot(at,lt,ut){at.length<40?nt.utf8.write(at,lt,ut):lt.utf8Write?lt.utf8Write(at,ut):lt.write(at,ut)}rt._configure=function(){rt.alloc=nt._Buffer_allocUnsafe,rt.writeBytesBuffer=nt.Buffer&&nt.Buffer.prototype instanceof Uint8Array&&nt.Buffer.prototype.set.name==="set"?function(at,lt,ut){lt.set(at,ut)}:function(at,lt,ut){if(at.copy)at.copy(lt,ut,0,at.length);else for(var dt=0;dt<at.length;)lt[ut++]=at[dt++]}},rt.prototype.bytes=function(at){nt.isString(at)&&(at=nt._Buffer_from(at,"base64"));var lt=at.length>>>0;return this.uint32(lt),lt&&this._push(rt.writeBytesBuffer,lt,at),this},rt.prototype.string=function(at){var lt=nt.Buffer.byteLength(at);return this.uint32(lt),lt&&this._push(ot,lt,at),this},rt._configure()},7714:(et,_,_e)=>{_.R=void 0;const tt=_e(6919),nt=_e(7448);_.R=new class{async init(){}async createSessionHandler(rt,ot){const at=new tt.Session(ot);return await at.loadModel(rt),new nt.OnnxjsSessionHandler(at)}}},4200:(et,_,_e)=>{_.c8=_.rX=void 0;const tt=_e(1670),nt=_e(5381),rt=_e(2157),ot=_e(2306);_.rX=()=>{if((typeof tt.env.wasm.initTimeout!="number"||tt.env.wasm.initTimeout<0)&&(tt.env.wasm.initTimeout=0),typeof tt.env.wasm.simd!="boolean"&&(tt.env.wasm.simd=!0),typeof tt.env.wasm.proxy!="boolean"&&(tt.env.wasm.proxy=!1),typeof tt.env.wasm.numThreads!="number"||!Number.isInteger(tt.env.wasm.numThreads)||tt.env.wasm.numThreads<=0){const at=typeof navigator>"u"?(0,nt.cpus)().length:navigator.hardwareConcurrency;tt.env.wasm.numThreads=Math.min(4,Math.ceil((at||1)/2))}},_.c8=new class{async init(){(0,_.rX)(),await(0,rt.initWasm)()}async createSessionHandler(at,lt){const ut=new ot.OnnxruntimeWebAssemblySessionHandler;return await ut.loadModel(at,lt),Promise.resolve(ut)}}},6018:function(et,_,_e){var tt=this&&this.__createBinding||(Object.create?function(ot,at,lt,ut){ut===void 0&&(ut=lt);var dt=Object.getOwnPropertyDescriptor(at,lt);dt&&!("get"in dt?!at.__esModule:dt.writable||dt.configurable)||(dt={enumerable:!0,get:function(){return at[lt]}}),Object.defineProperty(ot,ut,dt)}:function(ot,at,lt,ut){ut===void 0&&(ut=lt),ot[ut]=at[lt]}),nt=this&&this.__exportStar||function(ot,at){for(var lt in ot)lt==="default"||Object.prototype.hasOwnProperty.call(at,lt)||tt(at,ot,lt)};Object.defineProperty(_,"__esModule",{value:!0}),nt(_e(1670),_);const rt=_e(1670);{const ot=_e(7714).R;(0,rt.registerBackend)("webgl",ot,-10)}{const ot=_e(4200).c8;(0,rt.registerBackend)("cpu",ot,10),(0,rt.registerBackend)("wasm",ot,10),(0,rt.registerBackend)("xnnpack",ot,9)}},246:(et,_)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.createAttributeWithCacheKey=void 0;class _e{constructor(nt){Object.assign(this,nt)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(nt=>`${this[nt]}`).join(";")),this._cacheKey}}_.createAttributeWithCacheKey=tt=>new _e(tt)},7778:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.Attribute=void 0;const tt=_e(1446),nt=_e(9395),rt=_e(9162),ot=_e(2517);var at=nt.onnxruntime.experimental.fbs;class lt{constructor(dt){if(this._attributes=new Map,dt!=null){for(const st of dt)st instanceof tt.onnx.AttributeProto?this._attributes.set(st.name,[lt.getValue(st),lt.getType(st)]):st instanceof at.Attribute&&this._attributes.set(st.name(),[lt.getValue(st),lt.getType(st)]);if(this._attributes.size<dt.length)throw new Error("duplicated attribute names")}}set(dt,st,it){this._attributes.set(dt,[it,st])}delete(dt){this._attributes.delete(dt)}getFloat(dt,st){return this.get(dt,"float",st)}getInt(dt,st){return this.get(dt,"int",st)}getString(dt,st){return this.get(dt,"string",st)}getTensor(dt,st){return this.get(dt,"tensor",st)}getFloats(dt,st){return this.get(dt,"floats",st)}getInts(dt,st){return this.get(dt,"ints",st)}getStrings(dt,st){return this.get(dt,"strings",st)}getTensors(dt,st){return this.get(dt,"tensors",st)}get(dt,st,it){const ct=this._attributes.get(dt);if(ct===void 0){if(it!==void 0)return it;throw new Error(`required attribute not found: ${dt}`)}if(ct[1]!==st)throw new Error(`type mismatch: expected ${st} but got ${ct[1]}`);return ct[0]}static getType(dt){const st=dt instanceof tt.onnx.AttributeProto?dt.type:dt.type();switch(st){case tt.onnx.AttributeProto.AttributeType.FLOAT:return"float";case tt.onnx.AttributeProto.AttributeType.INT:return"int";case tt.onnx.AttributeProto.AttributeType.STRING:return"string";case tt.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case tt.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case tt.onnx.AttributeProto.AttributeType.INTS:return"ints";case tt.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case tt.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${tt.onnx.AttributeProto.AttributeType[st]}`)}}static getValue(dt){const st=dt instanceof tt.onnx.AttributeProto?dt.type:dt.type();if(st===tt.onnx.AttributeProto.AttributeType.GRAPH||st===tt.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const it=this.getValueNoCheck(dt);if(st===tt.onnx.AttributeProto.AttributeType.INT&&ot.LongUtil.isLong(it))return ot.LongUtil.longToNumber(it);if(st===tt.onnx.AttributeProto.AttributeType.INTS){const ct=it,ft=new Array(ct.length);for(let ht=0;ht<ct.length;ht++){const mt=ct[ht];ft[ht]=ot.LongUtil.longToNumber(mt)}return ft}if(st===tt.onnx.AttributeProto.AttributeType.TENSOR)return dt instanceof tt.onnx.AttributeProto?rt.Tensor.fromProto(it):rt.Tensor.fromOrtTensor(it);if(st===tt.onnx.AttributeProto.AttributeType.TENSORS){if(dt instanceof tt.onnx.AttributeProto)return it.map(ct=>rt.Tensor.fromProto(ct));if(dt instanceof at.Attribute)return it.map(ct=>rt.Tensor.fromOrtTensor(ct))}if(st===tt.onnx.AttributeProto.AttributeType.STRING&&dt instanceof tt.onnx.AttributeProto){const ct=it;return(0,ot.decodeUtf8String)(ct)}return st===tt.onnx.AttributeProto.AttributeType.STRINGS&&dt instanceof tt.onnx.AttributeProto?it.map(ot.decodeUtf8String):it}static getValueNoCheck(dt){return dt instanceof tt.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(dt):this.getValueNoCheckFromOrtFormat(dt)}static getValueNoCheckFromOnnxFormat(dt){switch(dt.type){case tt.onnx.AttributeProto.AttributeType.FLOAT:return dt.f;case tt.onnx.AttributeProto.AttributeType.INT:return dt.i;case tt.onnx.AttributeProto.AttributeType.STRING:return dt.s;case tt.onnx.AttributeProto.AttributeType.TENSOR:return dt.t;case tt.onnx.AttributeProto.AttributeType.GRAPH:return dt.g;case tt.onnx.AttributeProto.AttributeType.FLOATS:return dt.floats;case tt.onnx.AttributeProto.AttributeType.INTS:return dt.ints;case tt.onnx.AttributeProto.AttributeType.STRINGS:return dt.strings;case tt.onnx.AttributeProto.AttributeType.TENSORS:return dt.tensors;case tt.onnx.AttributeProto.AttributeType.GRAPHS:return dt.graphs;default:throw new Error(`unsupported attribute type: ${tt.onnx.AttributeProto.AttributeType[dt.type]}`)}}static getValueNoCheckFromOrtFormat(dt){switch(dt.type()){case at.AttributeType.FLOAT:return dt.f();case at.AttributeType.INT:return dt.i();case at.AttributeType.STRING:return dt.s();case at.AttributeType.TENSOR:return dt.t();case at.AttributeType.GRAPH:return dt.g();case at.AttributeType.FLOATS:return dt.floatsArray();case at.AttributeType.INTS:{const st=[];for(let it=0;it<dt.intsLength();it++)st.push(dt.ints(it));return st}case at.AttributeType.STRINGS:{const st=[];for(let it=0;it<dt.stringsLength();it++)st.push(dt.strings(it));return st}case at.AttributeType.TENSORS:{const st=[];for(let it=0;it<dt.tensorsLength();it++)st.push(dt.tensors(it));return st}default:throw new Error(`unsupported attribute type: ${at.AttributeType[dt.type()]}`)}}}_.Attribute=lt},7091:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.resolveBackend=_.backend=void 0;const tt=_e(5038),nt=new Map;async function rt(ot){const at=_.backend;if(at[ot]!==void 0&&function(lt){const ut=lt;return"initialize"in ut&&typeof ut.initialize=="function"&&"createSessionHandler"in ut&&typeof ut.createSessionHandler=="function"&&"dispose"in ut&&typeof ut.dispose=="function"}(at[ot])){const lt=at[ot];let ut=lt.initialize();if(typeof ut=="object"&&"then"in ut&&(ut=await ut),ut)return nt.set(ot,lt),lt}}_.backend={webgl:new tt.WebGLBackend},_.resolveBackend=async function ot(at){if(!at)return ot(["webgl"]);{const lt=typeof at=="string"?[at]:at;for(const ut of lt){const dt=nt.get(ut);if(dt)return dt;const st=await rt(ut);if(st)return st}}throw new Error("no available backend to use")}},5038:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.WebGLBackend=void 0;const tt=_e(1670),nt=_e(6231),rt=_e(6416),ot=_e(7305);_.WebGLBackend=class{get contextId(){return tt.env.webgl.contextId}set contextId(at){tt.env.webgl.contextId=at}get matmulMaxBatchSize(){return tt.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(at){tt.env.webgl.matmulMaxBatchSize=at}get textureCacheMode(){return tt.env.webgl.textureCacheMode}set textureCacheMode(at){tt.env.webgl.textureCacheMode=at}get pack(){return tt.env.webgl.pack}set pack(at){tt.env.webgl.pack=at}get async(){return tt.env.webgl.async}set async(at){tt.env.webgl.async=at}initialize(){try{return this.glContext=(0,ot.createWebGLContext)(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),nt.Logger.setWithEnv(tt.env),nt.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(at){return nt.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${at}`),!1}}createSessionHandler(at){return new rt.WebGLSessionHandler(this,at)}dispose(){this.glContext.dispose()}}},5107:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.CoordsGlslLib=void 0;const tt=_e(2517),nt=_e(8520),rt=_e(5060),ot=_e(7859),at=_e(9390);class lt extends nt.GlslLib{constructor(dt){super(dt)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new nt.GlslLibRoutine(`
      vec2 offsetToCoords(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){return{coordsToOffset:new nt.GlslLibRoutine(`
      int coordsToOffset(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){const dt=this.context.outputTextureLayout;return dt.isPacked?this.getPackedOutputSamplingSnippet(dt):this.getUnpackedOutputSamplingSnippet(dt)}getPackedOutputSamplingSnippet(dt){const st=dt.unpackedShape,it=[dt.width,dt.height],ct={},ft="getOutputCoords";switch(st.length){case 0:ct[ft]=this.getOutputScalarCoords();break;case 1:ct[ft]=this.getOutputPacked1DCoords(st,it);break;case 2:ct[ft]=this.getOutputPacked2DCoords(st,it);break;case 3:ct[ft]=this.getOutputPacked3DCoords(st,it);break;default:ct[ft]=this.getOutputPackedNDCoords(st,it)}const ht=`
      void setOutput(vec4 val) {
        ${(0,rt.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;return ct.floatTextureSetRGBA=new nt.GlslLibRoutine(ht),ct}getUnpackedOutputSamplingSnippet(dt){const st=dt.unpackedShape,it=[dt.width,dt.height],ct={},ft="getOutputCoords";switch(st.length){case 0:ct[ft]=this.getOutputScalarCoords();break;case 1:ct[ft]=this.getOutputUnpacked1DCoords(st,it);break;case 2:ct[ft]=this.getOutputUnpacked2DCoords(st,it);break;case 3:ct[ft]=this.getOutputUnpacked3DCoords(st,it);break;case 4:ct[ft]=this.getOutputUnpacked4DCoords(st,it);break;case 5:ct[ft]=this.getOutputUnpacked5DCoords(st,it);break;case 6:ct[ft]=this.getOutputUnpacked6DCoords(st,it);break;default:throw new Error(`Unsupported output dimensionality: ${st.length}`)}const ht=`
        void setOutput(float val) {
          ${(0,rt.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;return ct.floatTextureSetR=new nt.GlslLibRoutine(ht),ct}getOutputScalarCoords(){return new nt.GlslLibRoutine(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(dt,st){const it=st;let ct="";return it[0]===1?(ct=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${it[1]}.0);
          }
        `,new nt.GlslLibRoutine(ct)):it[1]===1?(ct=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${it[0]}.0);
          }
        `,new nt.GlslLibRoutine(ct)):(ct=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${it[0]}, ${it[1]}));
          return 2 * (resTexRC.y * ${it[0]} + resTexRC.x);
        }
      `,new nt.GlslLibRoutine(ct))}getOutputPacked2DCoords(dt,st){let it="";if(tt.ArrayUtil.arraysEqual(dt,st))return it=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${st[0]}, ${st[1]}));
        }
      `,new nt.GlslLibRoutine(it);const ct=st,ft=Math.ceil(dt[1]/2);return it=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${ct[0]}, ${ct[1]}));

          int index = resTexRC.y * ${ct[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${ft}) * 2;
          int c = 2 * (index / ${ft});

          return ivec2(r, c);
        }
      `,new nt.GlslLibRoutine(it)}getOutputPacked3DCoords(dt,st){const it=[st[0],st[1]],ct=Math.ceil(dt[2]/2),ft=ct*Math.ceil(dt[1]/2),ht=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${it[0]}, ${it[1]}));
          int index = resTexRC.y * ${it[0]} + resTexRC.x;

          int b = index / ${ft};
          index -= b * ${ft};

          // reverse r and c order for packed texture
          int r = imod(index, ${ct}) * 2;
          int c = 2 * (index / ${ct});

          return ivec3(b, r, c);
        }
      `;return new nt.GlslLibRoutine(ht)}getOutputPackedNDCoords(dt,st){const it=[st[0],st[1]],ct=Math.ceil(dt[dt.length-1]/2),ft=ct*Math.ceil(dt[dt.length-2]/2);let ht=ft,mt="",pt="b, r, c";for(let vt=2;vt<dt.length-1;vt++)ht*=dt[dt.length-vt-1],mt=`
      int b${vt} = index / ${ht};
      index -= b${vt} * ${ht};
    `+mt,pt=`b${vt}, `+pt;const _t=`
      ivec${dt.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${it[0]}, ${it[1]}));
        int index = resTexRC.y * ${it[0]} + resTexRC.x;

        ${mt}

        int b = index / ${ft};
        index -= b * ${ft};

        // reverse r and c order for packed texture
        int r = imod(index, ${ct}) * 2;
        int c = 2 * (index / ${ct});

        return ivec${dt.length}(${pt});
      }
    `;return new nt.GlslLibRoutine(_t)}getOutputUnpacked1DCoords(dt,st){const it=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${st[0]}, ${st[1]}));
          return resTexRC.y * ${st[0]} + resTexRC.x;
        }
      `;return new nt.GlslLibRoutine(it)}getOutputUnpacked2DCoords(dt,st){const it=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${st[0]}, ${st[1]}));
          int index = resTexRC.y * ${st[0]} + resTexRC.x;
          int r = index / ${dt[1]};
          int c = index - r * ${dt[1]};
          return ivec2(r, c);
        }
      `;return new nt.GlslLibRoutine(it)}getOutputUnpacked3DCoords(dt,st){let it="";const ct=dt.length;let ft=null;ct<2&&(ft=[]),ft=new Array(ct-1),ft[ct-2]=dt[ct-1];for(let pt=ct-3;pt>=0;--pt)ft[pt]=ft[pt+1]*dt[pt+1];const ht=["r","c","d"],mt=ft.map((pt,_t)=>`int ${ht[_t]} = index / ${pt}; ${_t===ft.length-1?`int ${ht[_t+1]} = index - ${ht[_t]} * ${pt}`:`index -= ${ht[_t]} * ${pt}`};`).join("");return it=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${st[0]}, ${st[1]}));
          int index = resTexRC.y * ${st[0]} + resTexRC.x;
          ${mt}
          return ivec3(r, c, d);
        }
      `,new nt.GlslLibRoutine(it)}getOutputUnpacked4DCoords(dt,st){let it="";const ct=dt.length;let ft=null;ct<2&&(ft=[]),ft=new Array(ct-1),ft[ct-2]=dt[ct-1];for(let pt=ct-3;pt>=0;--pt)ft[pt]=ft[pt+1]*dt[pt+1];const ht=["r","c","d","d2"],mt=ft.map((pt,_t)=>`int ${ht[_t]} = index / ${pt}; ${_t===ft.length-1?`int ${ht[_t+1]} = index - ${ht[_t]} * ${pt}`:`index -= ${ht[_t]} * ${pt}`};`).join("");return it=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${st[0]}, ${st[1]}));
          int index = resTexRC.y * ${st[0]} + resTexRC.x;
          ${mt}
          return ivec4(r, c, d, d2);
        }
      `,new nt.GlslLibRoutine(it)}getOutputUnpacked5DCoords(dt,st){let it="";const ct=dt.length;let ft=null;ct<2&&(ft=[]),ft=new Array(ct-1),ft[ct-2]=dt[ct-1];for(let pt=ct-3;pt>=0;--pt)ft[pt]=ft[pt+1]*dt[pt+1];const ht=["r","c","d","d2","d3"],mt=ft.map((pt,_t)=>`int ${ht[_t]} = index / ${pt}; ${_t===ft.length-1?`int ${ht[_t+1]} = index - ${ht[_t]} * ${pt}`:`index -= ${ht[_t]} * ${pt}`};`).join("");return it=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${st[0]}, ${st[1]}));
          int index = resTexRC.y * ${st[0]} + resTexRC.x;
          ${mt}
          return ivec5(r, c, d, d2, d3);
        }
      `,new nt.GlslLibRoutine(it)}getOutputUnpacked6DCoords(dt,st){let it="";const ct=dt.length;let ft=null;ct<2&&(ft=[]),ft=new Array(ct-1),ft[ct-2]=dt[ct-1];for(let pt=ct-3;pt>=0;--pt)ft[pt]=ft[pt+1]*dt[pt+1];const ht=["r","c","d","d2","d3","d4"],mt=ft.map((pt,_t)=>`int ${ht[_t]} = index / ${pt}; ${_t===ft.length-1?`int ${ht[_t+1]} = index - ${ht[_t]} * ${pt}`:`index -= ${ht[_t]} * ${pt}`};`).join("");return it=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${st[0]}, ${st[1]}));
         int index = resTexRC.y * ${st[0]} + resTexRC.x;
         ${mt}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new nt.GlslLibRoutine(it)}getCommonUtilFuncs(){const dt={};let st="uvFromFlat";dt[st]=new nt.GlslLibRoutine(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),st="packedUVfrom1D",dt[st]=new nt.GlslLibRoutine(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),st="packedUVfrom2D",dt[st]=new nt.GlslLibRoutine(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),st="packedUVfrom3D",dt[st]=new nt.GlslLibRoutine(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),st="sampleTexture";const it=(0,rt.getGlsl)(this.context.glContext.version);return dt[st]=new nt.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${it.texture2D}(textureSampler, uv).r;
        }`),dt}getInputsSamplingSnippets(){const dt={},st=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((it,ct)=>{const ft=this.context.inputTextureLayouts[ct],ht=(0,at.generateShaderFuncNameFromInputSamplerName)(it);ft.isPacked?dt[ht]=this.getPackedSamplerFromInput(ht,it,ft):dt[ht]=this.getUnpackedSamplerFromInput(ht,it,ft);const mt=(0,at.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(it);ft.unpackedShape.length<=st.unpackedShape.length&&(ft.isPacked?dt[mt]=this.getPackedSamplerAtOutputCoords(mt,ft,st,it):dt[mt]=this.getUnpackedSamplerAtOutputCoords(mt,ft,st,it))}),dt}getPackedSamplerAtOutputCoords(dt,st,it,ct){const ft=st.unpackedShape,ht=it.unpackedShape,mt=ct,pt=(0,at.generateShaderFuncNameFromInputSamplerName)(mt),_t=ft.length,vt=ht.length,bt=tt.BroadcastUtil.getBroadcastDims(ft,ht),wt=(0,at.getCoordsDataType)(vt),xt=vt-_t;let Mt;const At=(0,at.getGlChannels)();Mt=_t===0?"":vt<2&&bt.length>=1?"coords = 0;":bt.map(Nt=>`coords.${At[Nt+xt]} = 0;`).join(`
`);let St="";St=vt<2&&_t>0?"coords":ft.map((Nt,Bt)=>`coords.${At[Bt+xt]}`).join(", ");let Tt="return outputValue;";const Ct=tt.ShapeUtil.size(ft)===1,It=tt.ShapeUtil.size(ht)===1;if(_t!==1||Ct||It){if(Ct&&!It)Tt=vt===1?`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:`
          return vec4(outputValue.x);
        `;else if(bt.length){const Nt=_t-2,Bt=_t-1;bt.indexOf(Nt)>-1&&bt.indexOf(Bt)>-1?Tt="return vec4(outputValue.x);":bt.indexOf(Nt)>-1?Tt="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":bt.indexOf(Bt)>-1&&(Tt="return vec4(outputValue.xx, outputValue.zz);")}}else Tt=`
        return vec4(outputValue.xy, outputValue.xy);
      `;const $t=`
      vec4 ${dt}() {
        ${wt} coords = getOutputCoords();
        
        int lastDim = coords.${At[vt-1]};
        coords.${At[vt-1]} = coords.${At[vt-2]};
        coords.${At[vt-2]} = lastDim;
      
        ${Mt}
        vec4 outputValue = ${pt}(${St});
        ${Tt}
      }
    `;return new nt.GlslLibRoutine($t,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(dt,st,it,ct){const ft=[it.width,it.height],ht=[st.width,st.height],mt=st.unpackedShape.length,pt=it.unpackedShape.length,_t=st.unpackedShape,vt=it.unpackedShape,bt=(0,at.generateShaderFuncNameFromInputSamplerName)(ct);if(mt===pt&&tt.ArrayUtil.arraysEqual(ht,ft)){const It=`
          float ${dt}() {
            return sampleTexture(${ct}, TexCoords);
          }
        `;return new nt.GlslLibRoutine(It,["coordinates.sampleTexture"])}const wt=(0,at.getCoordsDataType)(pt),xt=tt.BroadcastUtil.getBroadcastDims(_t,vt),Mt=pt-mt;let At;const St=(0,at.getGlChannels)();At=mt===0?"":pt<2&&xt.length>=1?"coords = 0;":xt.map(It=>`coords.${St[It+Mt]} = 0;`).join(`
`);let Tt="";Tt=pt<2&&mt>0?"coords":st.unpackedShape.map((It,$t)=>`coords.${St[$t+Mt]}`).join(", ");const Ct=`
        float ${dt}() {
          ${wt} coords = getOutputCoords();
          ${At}
          return ${bt}(${Tt});
        }
      `;return new nt.GlslLibRoutine(Ct,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(dt,st,it){switch(it.unpackedShape.length){case 0:return this.getPackedSamplerScalar(dt,st);case 1:return this.getPackedSampler1D(dt,st,it);case 2:return this.getPackedSampler2D(dt,st,it);case 3:return this.getPackedSampler3D(dt,st,it);default:return this.getPackedSamplerND(dt,st,it)}}getUnpackedSamplerFromInput(dt,st,it){const ct=it.unpackedShape;switch(ct.length){case 0:return this.getUnpackedSamplerScalar(dt,st,it);case 1:return this.getUnpackedSampler1D(dt,st,it);case 2:return this.getUnpackedSampler2D(dt,st,it);case 3:return this.getUnpackedSampler3D(dt,st,it);case 4:return this.getUnpackedSampler4D(dt,st,it);case 5:return this.getUnpackedSampler5D(dt,st,it);case 6:return this.getUnpackedSampler6D(dt,st,it);default:throw new Error(`Unsupported dimension ${ct.length}-D`)}}getPackedSamplerScalar(dt,st){const it=`
          vec4 ${dt}() {
            return ${(0,rt.getGlsl)(this.context.glContext.version).texture2D}(${st}, halfCR);
          }
        `;return new nt.GlslLibRoutine(it)}getPackedSampler1D(dt,st,it){const ct=[it.width,it.height],ft=[ct[1],ct[0]],ht=(0,rt.getGlsl)(this.context.glContext.version),mt=`vec4 ${dt}(int index) {
      vec2 uv = packedUVfrom1D(
      ${ft[0]}, ${ft[1]}, index);
      return ${ht.texture2D}(${st}, uv);
    }`;return new nt.GlslLibRoutine(mt,["coordinates.packedUVfrom1D"])}getPackedSampler2D(dt,st,it){const ct=it.unpackedShape,ft=[it.width,it.height],ht=(0,rt.getGlsl)(this.context.glContext.version),mt=ft[0],pt=ft[1];if(ft!=null&&tt.ArrayUtil.arraysEqual(ct,ft)){const wt=`vec4 ${dt}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${pt}.0, ${mt}.0);
        return ${ht.texture2D}(${st}, uv);
      }`;return new nt.GlslLibRoutine(wt)}const _t=ft,vt=Math.ceil(ct[1]/2),bt=`vec4 ${dt}(int row, int col) {
      vec2 uv = packedUVfrom2D(${_t[1]}, ${_t[0]}, ${vt}, row, col);
      return ${ht.texture2D}(${st}, uv);
    }`;return new nt.GlslLibRoutine(bt,["coordinates.packedUVfrom2D"])}getPackedSampler3D(dt,st,it){const ct=it.unpackedShape,ft=[it.width,it.height],ht=[ft[0],ft[1]],mt=(0,rt.getGlsl)(this.context.glContext.version);if(ct[0]===1){const wt=ct.slice(1),xt=[1,2],Mt=(0,at.squeezeInputShape)(ct,wt),At=["b","row","col"],St=JSON.parse(JSON.stringify(it));St.unpackedShape=Mt;const Tt=this.getPackedSamplerFromInput(dt,st,St),Ct=`${Tt.routineBody}
      vec4 ${dt}(int b, int row, int col) {
        return ${dt}(${(0,at.getSqueezedParams)(At,xt)});
      } `;return new nt.GlslLibRoutine(Ct,Tt.dependencies)}const pt=ht[0],_t=ht[1],vt=Math.ceil(ct[2]/2),bt=`vec4 ${dt}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${_t}, ${pt}, ${vt*Math.ceil(ct[1]/2)}, ${vt}, b, row, col);
      return ${mt.texture2D}(${st}, uv);}`;return new nt.GlslLibRoutine(bt,["coordinates.packedUVfrom3D"])}getPackedSamplerND(dt,st,it){const ct=it.unpackedShape,ft=ct.length,ht=[it.width,it.height],mt=(0,rt.getGlsl)(this.context.glContext.version),pt=[ht[0],ht[1]],_t=pt[1],vt=pt[0],bt=Math.ceil(ct[ft-1]/2);let wt=bt*Math.ceil(ct[ft-2]/2),xt="int b, int row, int col",Mt=`b * ${wt} + (row / 2) * ${bt} + (col / 2)`;for(let St=2;St<ft-1;St++)xt=`int b${St}, `+xt,wt*=ct[ft-St-1],Mt=`b${St} * ${wt} + `+Mt;const At=`vec4 ${dt}(${xt}) {
      int index = ${Mt};
      int texR = index / ${vt};
      int texC = index - texR * ${vt};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${vt}, ${_t});
      return ${mt.texture2D}(${st}, uv);
    }`;return new nt.GlslLibRoutine(At)}getUnpackedSamplerScalar(dt,st,it){const[ct,ft]=[it.width,it.height];if(ct===1&&ft===1){const mt=`
          float ${dt}() {
            return sampleTexture(${st}, halfCR);
          }
        `;return new nt.GlslLibRoutine(mt,["coordinates.sampleTexture"])}const ht=`
        float ${dt}() {
          int offset_${st} = coordsToOffset(TexCoords, ${ct}, ${ft});
          vec2 uv = uvFromFlat(${ct}, ${ft}, offset_${st});
          return sampleTexture(${st}, uv);
        }
      `;return new nt.GlslLibRoutine(ht,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(dt,st,it){const ct=it.width,ft=it.height;if(ft===1&&ct===1){const mt=`
        float ${dt}(int index) {
          return sampleTexture(${st}, halfCR);
        }
      `;return new nt.GlslLibRoutine(mt,["coordinates.sampleTexture"])}if(ft===1){const mt=`
          float ${dt}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${ct}.0, 0.5);
            return sampleTexture(${st}, uv);
          }
        `;return new nt.GlslLibRoutine(mt,["coordinates.sampleTexture"])}if(ct===1){const mt=`
          float ${dt}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${ft}.0);
            return sampleTexture(${st}, uv);
          }
        `;return new nt.GlslLibRoutine(mt,["coordinates.sampleTexture"])}const ht=`
        float ${dt}(int index) {
          vec2 uv = uvFromFlat(${ct}, ${ft}, index);
          return sampleTexture(${st}, uv);
        }
      `;return new nt.GlslLibRoutine(ht,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(dt,st,it){const ct=it.unpackedShape,ft=[it.height,it.width];if(ft!=null&&tt.ArrayUtil.arraysEqual(ct,ft)){const wt=`
          float ${dt}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${ft[1]}.0, ${ft[0]}.0);
            return sampleTexture(${st}, uv);
          }
        `;return new nt.GlslLibRoutine(wt,["coordinates.sampleTexture"])}const{newShape:ht,keptDims:mt}=(0,ot.squeezeShape)(ct),pt=ht;if(pt.length<ct.length){const wt=(0,at.squeezeInputShape)(ct,pt),xt=JSON.parse(JSON.stringify(it));xt.unpackedShape=wt;const Mt=["col","row"],At=`
          ${this.getUnpackedSamplerFromInput(dt,st,xt).routineBody}
          float ${dt}(int row, int col) {
            return ${dt}(${(0,at.getSqueezedParams)(Mt,mt)});
          }
        `;return new nt.GlslLibRoutine(At,["coordinates.sampleTexture"])}const _t=ft[1],vt=ft[0];if(vt===1){const wt=`
          float ${dt}(int row, int col) {
            int offset_${st} = coordsToOffset(TexCoords, ${_t}, ${vt});
            float index = dot(vec3(row, col, offset_${st}), vec3(${ct[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${_t}.0);
            return sampleTexture(${st}, uv);
          }
        `;return new nt.GlslLibRoutine(wt,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(_t===1){const wt=`
          float ${dt}(int row, int col) {
            int offset_${st} = coordsToOffset(TexCoords, ${_t}, ${vt});
            float index = dot(vec3(row, col, offset_${st}), vec3(${ct[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${vt}.0, 0.5);
            return sampleTexture(${st}, uv);
          }
        `;return new nt.GlslLibRoutine(wt,["coordinates.sampleTexture","coordinates.coordsToOffset"])}const bt=`
        float ${dt}(int row, int col) {
          int index = col * ${ct[1]} + row;
          vec2 uv = uvFromFlat(${_t}, ${vt}, index);
          return sampleTexture(${st}, uv);
        }
      `;return new nt.GlslLibRoutine(bt,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(dt,st,it){const ct=it.unpackedShape,ft=ct[1]*ct[2],ht=ct[2],{newShape:mt,keptDims:pt}=(0,ot.squeezeShape)(ct),_t=mt;if(_t.length<ct.length){const bt=(0,at.squeezeInputShape)(ct,_t),wt=["batch","col","row"],xt=JSON.parse(JSON.stringify(it));xt.unpackedShape=bt;const Mt=this.getUnpackedSamplerFromInput(dt,st,xt),At=pt.reverse(),St=`
          ${Mt.routineBody}
          float ${dt}(int batch, int row, int col) {
            return ${dt}(${(0,at.getSqueezedParams)(wt,At)});
          }
        `;return new nt.GlslLibRoutine(St,Mt.dependencies)}const vt=`
          float ${dt}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${ft} + col * ${ht} + row;
            vec2 uv = uvFromFlat(${it.width}, ${it.height}, index);
            return sampleTexture(${st}, uv);
          }
      `;return new nt.GlslLibRoutine(vt,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(dt,st,it){const ct=it.unpackedShape,ft=ct[3],ht=ct[2]*ft,mt=`
        float ${dt}(int row, int col, int depth, int depth2) {
          int index = row * ${ct[1]*ht} + col * ${ht} +
              depth2 * ${ft} + depth;
          vec2 uv = uvFromFlat(${it.width}, ${it.height}, index);
          return sampleTexture(${st}, uv);
        }
      `;return new nt.GlslLibRoutine(mt,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(dt,st,it){const ct=it.unpackedShape,ft=ct[4],ht=ct[3]*ft,mt=ct[2]*ht,pt=ct[1]*mt,{newShape:_t,keptDims:vt}=(0,ot.squeezeShape)(ct);if(_t.length<ct.length){const wt=(0,at.squeezeInputShape)(ct,_t),xt=["row","col","depth","depth2","depth3"],Mt=JSON.parse(JSON.stringify(it));Mt.unpackedShape=wt;const At=`
          ${this.getUnpackedSamplerFromInput(dt,st,Mt).routineBody}
          float ${dt}(int row, int col, int depth, int depth2, int depth3) {
            return ${dt}(${(0,at.getSqueezedParams)(xt,vt)});
          }
        `;return new nt.GlslLibRoutine(At,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const bt=`
        float ${dt}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${pt} + col * ${mt} + depth * ${ht} +
          depth3 * ${ft} + depth2;
          vec2 uv = uvFromFlat(${it.width}, ${it.height}, index);
          return sampleTexture(${st}, uv);
        }
      `;return new nt.GlslLibRoutine(bt,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(dt,st,it){const ct=it.unpackedShape,ft=ct[5],ht=ct[4]*ft,mt=ct[3]*ht,pt=ct[2]*mt,_t=ct[1]*pt,{newShape:vt,keptDims:bt}=(0,ot.squeezeShape)(ct);if(vt.length<ct.length){const xt=(0,at.squeezeInputShape)(ct,vt),Mt=["row","col","depth","depth2","depth3","depth4"],At=JSON.parse(JSON.stringify(it));At.unpackedShape=xt;const St=`
            ${this.getUnpackedSamplerFromInput(dt,st,At).routineBody}
            float ${dt}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${dt}(${(0,at.getSqueezedParams)(Mt,bt)});
            }
          `;return new nt.GlslLibRoutine(St,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const wt=`
          float ${dt}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${_t} + col * ${pt} + depth * ${mt} +
            depth2 * ${ht} + depth3 * ${ft} + depth4;
            vec2 uv = uvFromFlat(${it.width}, ${it.height}, index);
            return sampleTexture(${st}, uv);
          }
        `;return new nt.GlslLibRoutine(wt,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const dt=this.context.outputTextureLayout,st=dt.shape.length,it=dt.strides,ct=dt.width,ft=dt.height,ht=[];for(let pt=0;pt<st-1;++pt)ht.push(`
        c[${pt}] = offset / ${it[pt]};`),ht.push(`
        offset -= c[${pt}] * ${it[pt]};`);ht.push(`
        c[${st-1}] = offset;`);const mt=`
      void toVec(vec2 texCoords, out int c[${st}]) {
        int offset = coordsToOffset(texCoords, ${ct}, ${ft});
        ${ht.join("")}
      }
      void toVec(int offset, out int c[${st}]) {
        ${ht.join("")}
      }
    `;return{toVec:new nt.GlslLibRoutine(mt,["coordinates.coordsToOffset"])}}valueFrom(){const dt={};return this.context.programInfo.inputNames.forEach((st,it)=>{const ct=this.context.inputTextureLayouts[it],ft=(ct.unpackedShape.length>0?ct.unpackedShape:ct.shape).length;let ht=`_${st}`;dt[ht]=new nt.GlslLibRoutine(this.getValueFromSingle(st,ft,ct.width,ct.height,!1),[`shapeUtils.indicesToOffset${ht}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),ht+="_T",dt[ht]=new nt.GlslLibRoutine(this.getValueFromSingle(st,ft,ct.width,ct.height,!0),[`shapeUtils.indicesToOffset${ht}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),dt}getValueFromSingle(dt,st,it,ct,ft){let ht=`_${dt}`;return ft&&(ht+="_T"),`
        float ${ht}(int m[${st}]) {
          int offset = indicesToOffset${ht}(m);
          vec2 coords = offsetToCoords(offset, ${it}, ${ct});
          float value = getColorAsFloat(${(0,rt.getGlsl)(this.context.glContext.version).texture2D}(${dt}, coords));
          return value;
        }
        `}getPackedValueFrom(dt,st,it,ct,ft){let ht=`_${dt}_Pack`;return ft&&(ht+="_T"),`
        vec4 ${ht}(int m[${st}]) {
          int offset = indicesToOffset_${dt}(m);
          vec2 coords = offsetToCoords(offset, ${it}, ${ct});
          return ${(0,rt.getGlsl)(this.context.glContext.version).texture2D}(${dt}, coords);
        }
        `}}_.CoordsGlslLib=lt},8520:(et,_)=>{var _e;Object.defineProperty(_,"__esModule",{value:!0}),_.TopologicalSortGlslRoutines=_.GlslLibRoutineNode=_.GlslLibRoutine=_.GlslLib=_.GlslContext=_.FunctionType=void 0,(_e=_.FunctionType||(_.FunctionType={}))[_e.ValueBased=0]="ValueBased",_e[_e.Positional=1]="Positional",_.GlslContext=class{constructor(tt,nt,rt,ot){this.glContext=tt,this.programInfo=nt,this.inputTextureLayouts=rt,this.outputTextureLayout=ot}},_.GlslLib=class{constructor(tt){this.context=tt}},_.GlslLibRoutine=class{constructor(tt,nt){this.routineBody=tt,this.dependencies=nt}},_.GlslLibRoutineNode=class{constructor(tt,nt,rt){this.name=tt,this.dependencies=rt||[],nt&&(this.routineBody=nt)}addDependency(tt){tt&&this.dependencies.push(tt)}},_.TopologicalSortGlslRoutines=class{static returnOrderedNodes(tt){if(!tt||tt.length===0)return[];if(tt.length===1)return tt;const nt=new Set,rt=new Set,ot=new Array;return this.createOrderedNodes(tt,nt,rt,ot),ot}static createOrderedNodes(tt,nt,rt,ot){for(let at=0;at<tt.length;++at)this.dfsTraverse(tt[at],nt,rt,ot)}static dfsTraverse(tt,nt,rt,ot){if(!tt||rt.has(tt.name))return;if(nt.has(tt.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");nt.add(tt.name);const at=tt.dependencies;if(at&&at.length>0)for(let lt=0;lt<at.length;++lt)this.dfsTraverse(at[lt],nt,rt,ot);ot.push(tt),rt.add(tt.name),nt.delete(tt.name)}}},7341:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.EncodingGlslLib=void 0;const tt=_e(8520);class nt extends tt.GlslLib{constructor(ot){super(ot)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new tt.GlslLibRoutine(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new tt.GlslLibRoutine(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){const ot=nt.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new tt.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${ot}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){const ot=nt.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new tt.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${ot}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){const ot=new ArrayBuffer(4),at=new Uint32Array(ot),lt=new Uint8Array(ot);if(at[0]=3735928559,lt[0]===239)return!0;if(lt[0]===222)return!1;throw new Error("unknown endianness")}}_.EncodingGlslLib=nt},9894:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.FragColorGlslLib=void 0;const tt=_e(8520),nt=_e(5060);class rt extends tt.GlslLib{constructor(at){super(at)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const at=(0,nt.getGlsl)(this.context.glContext.version);return{setFragColor:new tt.GlslLibRoutine(`
        void setFragColor(float value) {
            ${at.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new tt.GlslLibRoutine(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}_.FragColorGlslLib=rt},2848:(et,_)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.replaceInlines=void 0;const _e=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;_.replaceInlines=function(tt){const nt={};let rt;for(;(rt=_e.exec(tt))!==null;){const ot=rt[3].split(",").map(at=>{const lt=at.trim().split(" ");return lt&&lt.length===2?{type:lt[0],name:lt[1]}:null}).filter(at=>at!==null);nt[rt[2]]={params:ot,body:rt[4]}}for(const ot in nt){const at="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",ot),lt=new RegExp(at,"gm");for(;(rt=lt.exec(tt))!==null;){const ut=rt[1],dt=rt[2],st=rt[3].split(","),it=ut?`${ut} ${dt};`:"";let ct=nt[ot].body,ft="";nt[ot].params.forEach((mt,pt)=>{mt&&(ft+=`${mt.type} ${mt.name} = ${st[pt]};
`)}),ct=`${ft}
 ${ct}`,ct=ct.replace("return",`${dt} = `);const ht=`
      ${it}
      {
        ${ct}
      }
      `;tt=tt.replace(rt[0],ht)}}return tt.replace(_e,"")}},8879:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.GlslPreprocessor=void 0;const tt=_e(8520),nt=_e(2848),rt=_e(5483),ot=_e(5060);_.GlslPreprocessor=class{constructor(at,lt,ut,dt){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new tt.GlslContext(at,lt,ut,dt),Object.keys(rt.glslRegistry).forEach(it=>{const ct=new rt.glslRegistry[it](this.context);this.libs[it]=ct});const st=this.glslLibRoutineDependencyGraph;for(const it in this.libs){const ct=this.libs[it].getFunctions();for(const ft in ct){const ht=it+"."+ft;let mt;st[ht]?(mt=st[ht],mt.routineBody=ct[ft].routineBody):(mt=new tt.GlslLibRoutineNode(ht,ct[ft].routineBody),st[ht]=mt);const pt=ct[ft].dependencies;if(pt)for(let _t=0;_t<pt.length;++_t)if(st[pt[_t]])mt.addDependency(st[pt[_t]]);else{const vt=new tt.GlslLibRoutineNode(pt[_t]);st[pt[_t]]=vt,mt.addDependency(vt)}}}}preprocess(){const at=this.context.programInfo;let lt=at.shaderSource;return this.context.programInfo.hasMain||(lt=`${lt}
      ${(0,ot.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),lt=(0,nt.replaceInlines)(lt),`${(0,ot.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(at.inputNames,at.variables)}
    ${this.getImports(lt)}
    ${lt}`}getImports(at){const lt=this.selectGlslLibRoutinesToBeIncluded(at);if(lt.length===0)return"";let ut="";for(let dt=0;dt<lt.length;++dt){if(!lt[dt].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${lt[dt].name}`);ut+=lt[dt].routineBody+`
`}return ut}selectGlslLibRoutinesToBeIncluded(at){const lt=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(ut=>{const dt=ut.split(".")[1];at.indexOf(dt)!==-1&&lt.push(this.glslLibRoutineDependencyGraph[ut])}),tt.TopologicalSortGlslRoutines.returnOrderedNodes(lt)}getUniforms(at,lt){const ut=[];if(at)for(const dt of at)ut.push(`uniform sampler2D ${dt};`);if(lt)for(const dt of lt)ut.push(`uniform ${dt.type} ${dt.name}${dt.arrayLength?`[${dt.arrayLength}]`:""};`);return ut.join(`
`)}}},5483:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.glslRegistry=void 0;const tt=_e(5107),nt=_e(7341),rt=_e(9894),ot=_e(2655),at=_e(3891);_.glslRegistry={encoding:nt.EncodingGlslLib,fragcolor:rt.FragColorGlslLib,vec:at.VecGlslLib,shapeUtils:ot.ShapeUtilsGlslLib,coordinates:tt.CoordsGlslLib}},2655:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.ShapeUtilsGlslLib=void 0;const tt=_e(8520);class nt extends tt.GlslLib{constructor(ot){super(ot)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const ot=this.context.outputTextureLayout.shape.length,at={};return this.context.programInfo.inputNames.forEach((lt,ut)=>{const dt=this.context.inputTextureLayouts[ut].unpackedShape;if(dt.length<=ot){const st=dt.length,it=ot-st,ct=`bcastIndices_${lt}`;let ft="";for(let mt=0;mt<st;++mt)ft+=`
          realIndices[${mt}] = int( mod(float(bcastedIndices[${it+mt}]), ${dt[mt]}.0) );
          `;const ht=`
        void ${ct} (int bcastedIndices[${ot}], out int realIndices[${st}]) {
          ${ft}
        }
        `;at[ct]=new tt.GlslLibRoutine(ht)}}),at}bcastMatmulIndex(){const ot=this.context.outputTextureLayout.shape.length,at={};return this.context.programInfo.inputNames.forEach((lt,ut)=>{const dt=this.context.inputTextureLayouts[ut].shape;if(!(dt.length<2||dt.length>ot)){const st=dt.length,it=ot-st,ct=`bcastMatmulIndices_${lt}`;let ft="";for(let mt=0;mt<st-2;++mt)ft+=`
          realIndices[${mt}] = int( mod(float(bcastedIndices[${it+mt}]), ${dt[mt]}.0) );
          `;const ht=`
        void ${ct}(int bcastedIndices[${ot}], out int realIndices[${st}]) {
          ${ft}
          realIndices[${st-1}] = bcastedIndices[${ot-1}];
          realIndices[${st-2}] = bcastedIndices[${ot-2}];
        }
        `;at[ct]=new tt.GlslLibRoutine(ht)}}),at}indicesToOffset(){const ot={};return this.context.programInfo.inputNames.forEach((at,lt)=>{const ut=this.context.inputTextureLayouts[lt].shape,dt=this.context.inputTextureLayouts[lt].strides,st=ut.length;let it=`indicesToOffset_${at}`;ot[it]=new tt.GlslLibRoutine(nt.indexToOffsetSingle(it,st,dt)),it=`indicesToOffset_${at}_T`,ot[it]=new tt.GlslLibRoutine(nt.indexToOffsetSingle(it,st,dt.slice().reverse()))}),ot}static indexToOffsetSingle(ot,at,lt){let ut="";for(let dt=at-1;dt>=0;--dt)ut+=`
        offset += indices[${dt}] * ${lt[dt]};
        `;return`
      int ${ot}(int indices[${at}]) {
        int offset = 0;
        ${ut}
        return offset;
      }
      `}offsetToIndices(){const ot={};return this.context.programInfo.inputNames.forEach((at,lt)=>{const ut=this.context.inputTextureLayouts[lt].shape,dt=this.context.inputTextureLayouts[lt].strides,st=ut.length;let it=`offsetToIndices_${at}`;ot[it]=new tt.GlslLibRoutine(nt.offsetToIndicesSingle(it,st,dt)),it=`offsetToIndices_${at}_T`,ot[it]=new tt.GlslLibRoutine(nt.offsetToIndicesSingle(it,st,dt.slice().reverse()))}),ot}static offsetToIndicesSingle(ot,at,lt){const ut=[];for(let dt=0;dt<at-1;++dt)ut.push(`
      indices[${dt}] = offset / ${lt[dt]};`),ut.push(`
        offset -= indices[${dt}] * ${lt[dt]};`);return ut.push(`
      indices[${at-1}] = offset;`),`
      void ${ot}(int offset, out int indices[${at}]) {
        ${ut.join("")}
      }
      `}incrementIndices(){const ot={};return this.context.programInfo.inputNames.forEach((at,lt)=>{const ut=this.context.inputTextureLayouts[lt].shape,dt=ut.length,st=`incrementIndices_${at}`;let it="";for(let ft=0;ft<dt;++ft)it+=`
        shape[${ft}] = ${ut[ft]};`;const ct=`
        void ${st}(int axis, out int indices[${dt}]) {
          int shape[${dt}];
          ${it};
          for(int i = ${dt} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;ot[st]=new tt.GlslLibRoutine(ct)}),ot}}_.ShapeUtilsGlslLib=nt},5060:(et,_)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.getDefaultFragShaderMain=_.getFragShaderPreamble=_.getVertexShaderSource=_.getGlsl=void 0;const _e={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},tt={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function nt(rt){return rt===1?_e:tt}_.getGlsl=nt,_.getVertexShaderSource=function(rt){const ot=nt(rt);return`${ot.version}
      precision highp float;
      ${ot.attribute} vec3 position;
      ${ot.attribute} vec2 textureCoord;

      ${ot.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`},_.getFragShaderPreamble=function(rt){const ot=nt(rt);return`${ot.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${ot.varyingFrag} vec2 TexCoords;
    ${ot.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `},_.getDefaultFragShaderMain=function(rt,ot){return`
  void main() {
    int indices[${ot}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${nt(rt).output} = result;
  }
  `}},3891:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.VecGlslLib=void 0;const tt=_e(8520);class nt extends tt.GlslLib{constructor(ot){super(ot)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const ot=this.context.outputTextureLayout.shape.length,at={add:"+=",sub:"-=",mul:"*=",div:"/="},lt={};for(const ut in at){const dt=`${ut}Vec`;let st="";for(let ct=0;ct<ot;++ct)st+=`
          dest[${ct}] ${at[ut]} src[${ct}];
          `;const it=`
        void ${dt}(int src[${ot}], out int dest[${ot}]) {
          ${st}
        }
        `;lt[dt]=new tt.GlslLibRoutine(it)}return lt}copyVec(){const ot=this.context.outputTextureLayout.shape.length;let at="";for(let ut=0;ut<ot;++ut)at+=`
        dest[${ut}] = src[${ut}];
        `;const lt=`
      void copyVec(int src[${ot}], out int dest[${ot}]) {
        ${at}
      }
      `;return{copyVec:new tt.GlslLibRoutine(lt)}}setVecItem(){const ot=this.context.outputTextureLayout.shape.length;let at=`
        if(index < 0)
            index =${ot} + index;
        if (index == 0)
            m[0] = value;
        `;for(let ut=1;ut<ot-1;++ut)at+=`
        else if (index == ${ut})
            m[${ut}] = value;
            `;at+=`
        else
            m[${ot-1}] = value;
        `;const lt=`
      void setVecItem(out int m[${ot}], int index, int value) {
        ${at}
      }
        `;return{setVecItem:new tt.GlslLibRoutine(lt)}}getVecItem(){const ot=this.context.outputTextureLayout.shape.length;let at=`
        if(index < 0)
            index = ${ot} + index;
        if (index == 0)
            return m[0];
      `;for(let ut=1;ut<ot-1;++ut)at+=`
        else if (index == ${ut})
            return m[${ut}];
      `;at+=`
        else
            return m[${ot-1}];
        `;const lt=`
      int getVecItem(int m[${ot}], int index) {
        ${at}
      }
    `;return{getVecItem:new tt.GlslLibRoutine(lt)}}}_.VecGlslLib=nt},8316:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.WebGLInferenceHandler=void 0;const tt=_e(6231),nt=_e(9162),rt=_e(2517),ot=_e(2403),at=_e(7019),lt=_e(8710),ut=_e(5611),dt=_e(4057),st=_e(2039);_.WebGLInferenceHandler=class{constructor(it){this.session=it,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(it,ct){return(0,dt.calculateTextureWidthAndHeight)(this.session.layoutStrategy,it,ct)}executeProgram(it,ct){if(ct.length<it.inputNames.length)throw new Error(`Input size mustn't be less than ${it.inputNames.length}.`);if(it.inputNames.length!==it.inputTypes.length)throw new Error("input names size does not match input types");const ft=[];for(let bt=0;bt<it.inputNames.length;++bt)ft[bt]=this.getOrCreateTextureData(ct[bt],it.inputTypes[bt]);const ht=((bt,wt)=>{const xt=wt.map(At=>`${At.unpackedShape.join(",")};${At.width}x${At.height}`).join("_");let Mt=bt.name;return bt.cacheHint&&(Mt+="["+bt.cacheHint+"]"),Mt+=":"+xt,Mt})(it,ft);let mt=this.session.programManager.getArtifact(ht);const pt=mt?mt.programInfo:typeof it.get=="function"?it.get():it,_t=(0,dt.createTextureLayoutFromTextureType)(this.session.layoutStrategy,pt.output.dims,pt.output.textureType),vt=this.createTextureData(_t,pt.output.type);return mt||(mt=this.session.programManager.build(pt,ft,vt),this.session.programManager.setArtifact(ht,mt)),this.runProgram(mt,ft,vt),vt}run(it,ct){return this.executeProgram(it,ct).tensor}runProgram(it,ct,ft){for(let ht=0;ht<ct.length;++ht)if(!!ct[ht].isPacked!=(it.programInfo.inputTypes[ht]===st.TextureType.packed))throw new Error(`input[${ht}] property packed inconsistent`);if(!!ft.isPacked!=(it.programInfo.output.textureType===st.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(it,ct,ft)}getOrCreateTextureData(it,ct){let ft=this.getTextureData(it.dataId,ct===st.TextureType.packed);if(!ft&&(ft=this.getTextureData(it.dataId,ct!==st.TextureType.packed),ft))return ct===st.TextureType.packed?this.pack(ft):this.unpack(ft);if(!ft){const ht=(0,dt.createTextureLayoutFromTextureType)(this.session.layoutStrategy,it.dims,ct);if(ct===st.TextureType.packedLastDimension){const _t=it.dims;if(_t.length===4){const vt=[_t[0],Math.ceil(_t[1]*_t[2]*_t[3]/4)],bt=(0,dt.createTextureLayoutFromTextureType)(this.session.layoutStrategy,vt,ct);let wt=it.numberData;if(_t[1]*_t[2]*_t[3]%4!=0){const xt=_t[0],Mt=_t[1]*_t[2]*_t[3],At=Math.ceil(Mt*1/4)*4;wt=new Float32Array(xt*At);for(let St=0;St<xt;++St){const Tt=St*Mt,Ct=St*At+St%1*Mt;wt.set(it.numberData.subarray(Tt,Tt+Mt),Ct)}}return this.createTextureData(bt,it.type,wt,it,1)}}if(ct===st.TextureType.packed){const mt=(0,dt.createTextureLayoutFromShape)(this.session.layoutStrategy,it.dims,1,[],{reverseWH:!0}),pt=this.createTextureData(mt,it.type,it.numberData,it,1);ft=this.pack(pt)}else ft=this.createTextureData(ht,it.type,it.numberData,it,1)}return ft}createTextureDataFromLayoutBindTensor(it,ct,ft,ht){return this.createTextureData(it,ct,ft,ht,1)}createTextureData(it,ct,ft,ht,mt){tt.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(it)}]`);const pt=this.session.textureManager.createTextureFromLayout(ct,it,ft,mt);return this.createTextureDataFromTexture(it,ct,pt,ht)}reshapeUnpacked(it,ct){const ft=this.getOrCreateTextureData(it,st.TextureType.unpacked),ht={channels:ft.channels,height:ft.height,width:ft.width,shape:ct.length!==0?ct:[1],strides:rt.ShapeUtil.computeStrides(ct),unpackedShape:ct};return this.createTextureDataFromTexture(ht,it.type,ft.texture).tensor}reshapePacked(it,ct){const ft=this.getOrCreateTextureData(it,st.TextureType.packed);if((0,at.isReshapeCheap)(it.dims,ct)){const vt={channels:ft.channels,height:ft.height,width:ft.width,shape:ct.length!==0?ct:[1],strides:rt.ShapeUtil.computeStrides(ct),unpackedShape:ct,isPacked:!0};return this.createTextureDataFromTexture(vt,it.type,ft.texture).tensor}const ht=(0,at.processDims3D)(it.dims),mt=(0,at.processDims3D)(ct),pt=this.reshapePacked(it,ht),_t=this.run((0,at.createPackedReshape3DProgramInfoLoader)(this,pt,mt),[pt]);return this.reshapePacked(_t,ct)}cast(it,ct){const ft=this.getOrCreateTextureData(it,st.TextureType.unpacked);return this.createTextureDataFromTexture(ft,ct,ft.texture).tensor}createTextureDataFromTexture(it,ct,ft,ht,mt){const pt=Object.assign(Object.assign({},it),{tensor:ht||new nt.Tensor(it.unpackedShape,ct,_t=>this.readTexture(pt),async _t=>this.readTextureAsync(pt),void 0,mt),texture:ft});return this.setTextureData(pt.tensor.dataId,pt,it.isPacked),pt}getTextureData(it,ct=!1){return this.session.isInitializer(it)?this.session.getTextureData(it,ct):ct?this.packedTextureDataCache.get(it):this.unpackedTextureDataCache.get(it)}setTextureData(it,ct,ft=!1){this.session.isInitializer(it)?this.session.setTextureData(it,ct,ft):(ft?this.packedTextureDataCache:this.unpackedTextureDataCache).set(it,ct)}isTextureLayoutCached(it,ct=!1){return!!this.getTextureData(it.dataId,ct)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(it=>this.session.textureManager.releaseTexture(it)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(it=>this.session.textureManager.releaseTexture(it)),this.unpackedTextureDataCache=new Map}readTexture(it){return it.isPacked?this.readTexture(this.unpack(it)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(it,it.tensor.type,it.channels):this.session.textureManager.readUint8TextureAsFloat((0,lt.encodeAsUint8)(this,it))}async readTextureAsync(it){return it.isPacked?this.readTextureAsync(this.unpack(it)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(it,it.tensor.type,it.channels):this.session.textureManager.readUint8TextureAsFloat((0,lt.encodeAsUint8)(this,it))}pack(it){return this.executeProgram((0,ot.createPackProgramInfoLoader)(this,it.tensor),[it.tensor])}unpack(it){return this.executeProgram((0,ut.createUnpackProgramInfoLoader)(this,it.tensor),[it.tensor])}}},1640:function(et,_,_e){var tt=this&&this.__createBinding||(Object.create?function(zt,Yt,en,bn){bn===void 0&&(bn=en);var Un=Object.getOwnPropertyDescriptor(Yt,en);Un&&!("get"in Un?!Yt.__esModule:Un.writable||Un.configurable)||(Un={enumerable:!0,get:function(){return Yt[en]}}),Object.defineProperty(zt,bn,Un)}:function(zt,Yt,en,bn){bn===void 0&&(bn=en),zt[bn]=Yt[en]}),nt=this&&this.__setModuleDefault||(Object.create?function(zt,Yt){Object.defineProperty(zt,"default",{enumerable:!0,value:Yt})}:function(zt,Yt){zt.default=Yt}),rt=this&&this.__importStar||function(zt){if(zt&&zt.__esModule)return zt;var Yt={};if(zt!=null)for(var en in zt)en!=="default"&&Object.prototype.hasOwnProperty.call(zt,en)&&tt(Yt,zt,en);return nt(Yt,zt),Yt};Object.defineProperty(_,"__esModule",{value:!0}),_.WEBGL_OP_RESOLVE_RULES=void 0;const ot=_e(2898),at=rt(_e(7839)),lt=_e(4196),ut=_e(2069),dt=_e(8138),st=_e(9663),it=_e(5193),ct=_e(7992),ft=_e(1253),ht=_e(4776),mt=_e(6572),pt=_e(3346),_t=_e(5623),vt=_e(2870),bt=_e(2143),wt=_e(4939),xt=_e(718),Mt=_e(2268),At=_e(8117),St=_e(2278),Tt=_e(5524),Ct=_e(5975),It=_e(3933),$t=_e(6558),Nt=_e(5723),Bt=_e(3738),Ot=rt(_e(4909)),Ut=_e(8428),Lt=_e(9793);_.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",Ot.abs],["Acos","","7+",Ot.acos],["Add","","7+",at.add],["And","","7+",at.and],["Asin","","7+",Ot.asin],["Atan","","7+",Ot.atan],["AveragePool","","7+",bt.averagePool,bt.parseAveragePoolAttributes],["BatchNormalization","","7+",ot.batchNormalization,ot.parseBatchNormalizationAttributes],["Cast","","6+",lt.cast,lt.parseCastAttributes],["Ceil","","6+",Ot.ceil],["Clip","","6-10",Ot.clip,Ot.parseClipAttributes],["Clip","","11+",Ot.clipV11],["Concat","","4+",ut.concat,ut.parseConcatAttributes],["Conv","","1+",dt.conv,dt.parseConvAttributes],["ConvTranspose","","1+",st.convTranspose,st.parseConvTransposeAttributes],["Cos","","7+",Ot.cos],["Div","","7+",at.div],["Dropout","","7+",Ot.identity],["DepthToSpace","","1+",it.depthToSpace,it.parseDepthToSpaceAttributes],["Equal","","7+",at.equal],["Elu","","6+",Ot.elu,Ot.parseEluAttributes],["Exp","","6+",Ot.exp],["Flatten","","1+",ct.flatten,ct.parseFlattenAttributes],["Floor","","6+",Ot.floor],["FusedConv","com.microsoft","1+",dt.conv,dt.parseConvAttributes],["Gather","","1+",ft.gather,ft.parseGatherAttributes],["Gemm","","7-10",ht.gemm,ht.parseGemmAttributesV7],["Gemm","","11+",ht.gemm,ht.parseGemmAttributesV11],["GlobalAveragePool","","1+",bt.globalAveragePool,bt.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",bt.globalMaxPool],["Greater","","7+",at.greater],["Identity","","1+",Ot.identity],["ImageScaler","","1+",mt.imageScaler,mt.parseImageScalerAttributes],["InstanceNormalization","","6+",pt.instanceNormalization,pt.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",Ot.leakyRelu,Ot.parseLeakyReluAttributes],["Less","","7+",at.less],["Log","","6+",Ot.log],["MatMul","","1+",_t.matMul,_t.parseMatMulAttributes],["MaxPool","","1+",bt.maxPool,bt.parseMaxPoolAttributes],["Mul","","7+",at.mul],["Neg","","6+",Ot.neg],["Not","","1+",Ot.not],["Or","","7+",at.or],["Pad","","2-10",vt.padV2,vt.parsePadAttributesV2],["Pad","","11+",vt.padV11,vt.parsePadAttributesV11],["Pow","","7+",at.pow],["PRelu","","7+",at.pRelu],["ReduceLogSum","","1+",wt.reduceLogSum,wt.parseReduceAttributes],["ReduceMax","","1+",wt.reduceMax,wt.parseReduceAttributes],["ReduceMean","","1+",wt.reduceMean,wt.parseReduceAttributes],["ReduceMin","","1+",wt.reduceMin,wt.parseReduceAttributes],["ReduceProd","","1+",wt.reduceProd,wt.parseReduceAttributes],["ReduceSum","","1-12",wt.reduceSum,wt.parseReduceAttributes],["ReduceSumSquare","","1+",wt.reduceLogSumSquare,wt.parseReduceAttributes],["Relu","","6+",Ot.relu],["Reshape","","5+",xt.reshape],["Resize","","10",Mt.resize,Mt.parseResizeAttributesV10],["Resize","","11+",Mt.resize,Mt.parseResizeAttributesV11],["Shape","","1+",At.shape],["Sigmoid","","6+",Ot.sigmoid],["Sin","","7+",Ot.sin],["Slice","","10+",St.sliceV10],["Slice","","1-9",St.slice,St.parseSliceAttributes],["Softmax","","1-12",Tt.softmax,Tt.parseSoftmaxAttributes],["Softmax","","13+",Tt.softmaxV13,Tt.parseSoftmaxAttributesV13],["Split","","2-12",Ct.split,Ct.parseSplitAttributes],["Sqrt","","6+",Ot.sqrt],["Squeeze","","1-12",It.squeeze,It.parseSqueezeAttributes],["Squeeze","","13+",It.squeezeV13],["Sub","","7+",at.sub],["Sum","","6+",$t.sum],["Tan","","7+",Ot.tan],["Tanh","","6+",Ot.tanh],["Tile","","6+",Nt.tile],["Transpose","","1+",Bt.transpose,Bt.parseTransposeAttributes],["Upsample","","7-8",Lt.upsample,Lt.parseUpsampleAttributesV7],["Upsample","","9",Lt.upsample,Lt.parseUpsampleAttributesV9],["Unsqueeze","","1-12",Ut.unsqueeze,Ut.parseUnsqueezeAttributes],["Unsqueeze","","13+",Ut.unsqueezeV13],["Xor","","7+",at.xor]]},2898:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.parseBatchNormalizationAttributes=_.batchNormalization=void 0;const tt=_e(246),nt=_e(5060),rt=_e(2039),ot={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[rt.TextureType.unpacked,rt.TextureType.unpacked,rt.TextureType.unpacked,rt.TextureType.unpacked,rt.TextureType.unpacked]};_.batchNormalization=(ut,dt,st)=>(lt(dt),[ut.run(Object.assign(Object.assign({},ot),{cacheHint:st.cacheKey,get:()=>at(ut,dt,st)}),dt)]),_.parseBatchNormalizationAttributes=ut=>{const dt=ut.attributes.getFloat("epsilon",1e-5),st=ut.attributes.getFloat("momentum",.9),it=ut.attributes.getInt("spatial",1);return(0,tt.createAttributeWithCacheKey)({epsilon:dt,momentum:st,spatial:it})};const at=(ut,dt,st)=>{const it=(0,nt.getGlsl)(ut.session.backend.glContext.version),ct=dt[0].dims.length,[ft,ht]=ut.calculateTextureWidthAndHeight(dt[1].dims,rt.TextureType.unpacked),mt=`
  float process(int[${ct}] indices) {
    vec2 position = offsetToCoords(indices[1], ${ft}, ${ht});
    float scale = getColorAsFloat(${it.texture2D}(Scale, position));
    float mean = getColorAsFloat(${it.texture2D}(Mean, position));
    float variance = getColorAsFloat(${it.texture2D}(Variance, position));
    float b = getColorAsFloat(${it.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${st.epsilon})) ) + b;
  }`;return Object.assign(Object.assign({},ot),{output:{dims:dt[0].dims,type:dt[0].type,textureType:rt.TextureType.unpacked},shaderSource:mt})},lt=ut=>{if(!ut||ut.length!==5)throw new Error("BatchNormalization requires 5 inputs.");const dt=ut[0],st=ut[1],it=ut[2],ct=ut[3],ft=ut[4];if(dt.dims.length<3||st.dims.length!==1||it.dims.length!==1||ct.dims.length!==1||ft.dims.length!==1)throw new Error("invalid input shape.");if(st.dims[0]!==dt.dims[1]||it.dims[0]!==dt.dims[1]||ct.dims[0]!==dt.dims[1]||ft.dims[0]!==dt.dims[1])throw new Error("invalid input shape.");if(dt.type!=="float32"&&dt.type!=="float64"||st.type!=="float32"&&st.type!=="float64"||it.type!=="float32"&&it.type!=="float64"||ct.type!=="float32"&&ct.type!=="float64"||ft.type!=="float32"&&ft.type!=="float64")throw new Error("invalid input tensor types.")}},7839:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.xor=_.sub=_.pRelu=_.pow=_.or=_.mul=_.less=_.greater=_.equal=_.div=_.and=_.add=_.glslPRelu=_.glslPow=_.glslXor=_.glslOr=_.glslAnd=_.glslLess=_.glslGreater=_.glslEqual=_.glslSub=_.glslMul=_.glslDiv=_.glslAdd=void 0;const tt=_e(2517),nt=_e(8520),rt=_e(5060),ot=_e(2039);function at(){const wt="add_";return{body:`
  float ${wt}(float a, float b) {
    return a + b;
  }
  vec4 ${wt}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:wt,type:nt.FunctionType.ValueBased}}function lt(){const wt="div_";return{body:`
  float ${wt}(float a, float b) {
    return a / b;
  }
  vec4 ${wt}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:wt,type:nt.FunctionType.ValueBased}}function ut(){const wt="mul_";return{body:`
  float ${wt}(float a, float b) {
    return a * b;
  }
  vec4 ${wt}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:wt,type:nt.FunctionType.ValueBased}}function dt(){const wt="sub_";return{body:`
  float ${wt}(float a, float b) {
    return a - b;
  }
  vec4 ${wt}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:wt,type:nt.FunctionType.ValueBased}}function st(){const wt="equal_";return{body:`
  float ${wt}(float a, float b) {
    return float(a == b);
  }
  vec4 ${wt}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:wt,type:nt.FunctionType.ValueBased}}function it(){const wt="greater_";return{body:`
  float ${wt}(float a, float b) {
    return float(a > b);
  }
  vec4 ${wt}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:wt,type:nt.FunctionType.ValueBased}}function ct(){const wt="less_";return{body:`
  float ${wt}(float a, float b) {
    return float(a < b);
  }
  vec4 ${wt}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:wt,type:nt.FunctionType.ValueBased}}function ft(){const wt="and_";return{body:`
  float ${wt}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${wt}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:wt,type:nt.FunctionType.ValueBased}}function ht(){const wt="or_";return{body:`
  float ${wt}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${wt}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:wt,type:nt.FunctionType.ValueBased}}function mt(){const wt="xor_";return{body:`
  float ${wt}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${wt}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:wt,type:nt.FunctionType.ValueBased}}function pt(){return function(wt){const xt=`${wt}_`;return{body:`
  float ${xt}(float a, float b) {
    return ${wt}(a, b);
  }
  vec4 ${xt}(vec4 v1, vec4 v2) {
    return ${wt}(v1, v2);
  }
  `,name:xt,type:nt.FunctionType.ValueBased}}("pow")}function _t(){const wt="prelu_";return{body:`
  float ${wt}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${wt}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:wt,type:nt.FunctionType.ValueBased}}_.glslAdd=at,_.glslDiv=lt,_.glslMul=ut,_.glslSub=dt,_.glslEqual=st,_.glslGreater=it,_.glslLess=ct,_.glslAnd=ft,_.glslOr=ht,_.glslXor=mt,_.glslPow=pt,_.glslPRelu=_t;const vt=(wt,xt,Mt,At=xt[0].type,St)=>{const Tt=wt.session.pack?ot.TextureType.packed:ot.TextureType.unpacked;return{name:Mt.name,inputNames:["A","B"],inputTypes:[Tt,Tt],cacheHint:St,get:()=>bt(wt,xt,Mt,At)}},bt=(wt,xt,Mt,At=xt[0].type)=>{const St=wt.session.pack?ot.TextureType.packed:ot.TextureType.unpacked,Tt=!tt.ShapeUtil.areEqual(xt[0].dims,xt[1].dims);let Ct=xt[0].dims;const It=wt.session.pack;if(Tt){const Bt=tt.BroadcastUtil.calcShape(xt[0].dims,xt[1].dims,!1);if(!Bt)throw new Error("Can't perform binary op on the given tensors");Ct=Bt;const Ot=Ct.length,Ut=xt[0].dims.length!==0?xt[0].dims.length:1,Lt=xt[1].dims.length!==0?xt[1].dims.length:1,zt=xt[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",Yt=xt[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",en=(0,rt.getGlsl)(wt.session.backend.glContext.version),bn=It?`
      ${Mt.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${Mt.name}(a, b);
        ${en.output} = result;
      }`:`
      ${Mt.body}
      float process(int indices[${Ot}]) {
        int aindices[${Ut}];
        int bindices[${Lt}];
        ${zt}
        ${Yt}
        return ${Mt.name}(_A(aindices), _B(bindices));
      }`;return{name:Mt.name,inputNames:["A","B"],inputTypes:[St,St],output:{dims:Ct,type:At,textureType:St},shaderSource:bn,hasMain:It}}const $t=(0,rt.getGlsl)(wt.session.backend.glContext.version),Nt=`
    ${Mt.body}
    void main() {
      vec4 v1 = ${$t.texture2D}(A, TexCoords);
      vec4 v2 = ${$t.texture2D}(B, TexCoords);
      vec4 result = ${Mt.name}(v1, v2);
      ${$t.output} = result;
    }
    `;return{name:Mt.name,inputNames:["A","B"],inputTypes:[St,St],output:{dims:xt[0].dims,type:At,textureType:St},shaderSource:Nt,hasMain:!0}};_.add=(wt,xt)=>[wt.run(vt(wt,xt,at()),xt)],_.and=(wt,xt)=>[wt.run(vt(wt,xt,ft(),"bool"),xt)],_.div=(wt,xt)=>[wt.run(vt(wt,xt,lt()),xt)],_.equal=(wt,xt)=>[wt.run(vt(wt,xt,st(),"bool"),xt)],_.greater=(wt,xt)=>[wt.run(vt(wt,xt,it(),"bool"),xt)],_.less=(wt,xt)=>[wt.run(vt(wt,xt,ct(),"bool"),xt)],_.mul=(wt,xt)=>[wt.run(vt(wt,xt,ut()),xt)],_.or=(wt,xt)=>[wt.run(vt(wt,xt,ht(),"bool"),xt)],_.pow=(wt,xt)=>[wt.run(vt(wt,xt,pt()),xt)],_.pRelu=(wt,xt)=>[wt.run(vt(wt,xt,_t()),xt)],_.sub=(wt,xt)=>[wt.run(vt(wt,xt,dt()),xt)],_.xor=(wt,xt)=>[wt.run(vt(wt,xt,mt(),"bool"),xt)]},4196:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.parseCastAttributes=_.cast=void 0;const tt=_e(2517);_.cast=(rt,ot,at)=>(nt(ot),[rt.cast(ot[0],at)]),_.parseCastAttributes=rt=>tt.ProtoUtil.tensorDataTypeFromProto(rt.attributes.getInt("to"));const nt=rt=>{if(!rt||rt.length!==1)throw new Error("Cast requires 1 input.");if(rt[0].type==="string")throw new Error("Invalid input type.")}},1163:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.createPackedConcatProgramInfoLoader=void 0;const tt=_e(5060),nt=_e(2039),rt=_e(9390),ot=_e(2827);_.createPackedConcatProgramInfoLoader=(lt,ut,dt)=>{const st=(it=ut.length,ct=dt.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:it},(ft,ht)=>`X${ht}`),inputTypes:Array(it).fill(nt.TextureType.packed),cacheHint:ct});var it,ct;return Object.assign(Object.assign({},st),{get:()=>((ft,ht,mt,pt)=>{const _t=mt[0].dims.slice();if(pt>=_t.length||pt<-1*_t.length)throw new Error("axis specified for concat doesn't match input dimensionality");pt<0&&(pt=_t.length+pt);const vt=_t.slice(0);for(let zt=1;zt<mt.length;zt++){const Yt=mt[zt].dims.slice();for(let en=0;en<_t.length;en++)if(en===pt)vt[pt]+=Yt[en];else if(_t[en]!==Yt[en])throw new Error("non concat dimensions must match")}const bt=vt.length,wt=(0,ot.getChannels)("coords",bt),xt=(0,rt.getCoordsDataType)(bt),Mt=(0,ot.unpackFromChannel)(),At=mt.map(zt=>zt.dims),St=(0,rt.getGlChannels)(bt),Tt=new Array(At.length-1);Tt[0]=At[0][pt];for(let zt=1;zt<Tt.length;zt++)Tt[zt]=Tt[zt-1]+At[zt][pt];const Ct=St[pt],It=St.slice(-2),$t=St.join();let Nt=`if (${Ct} < ${Tt[0]}) {
        return getChannel(
            getX0(${$t}), vec2(${It.join()}));
        }`;for(let zt=1;zt<Tt.length;zt++){const Yt=Tt[zt-1];Nt+=`
            if (${Ct} < ${Tt[zt]}  && ${Ct} >= ${Tt[zt-1]}) {
              return getChannel(
                getX${zt}(${at(St,Ct,Yt)}),
                vec2(${at(It,Ct,Yt)}));
            }`}const Bt=Tt.length,Ot=Tt[Tt.length-1];Nt+=`
            return getChannel(
              getX${Bt}(${at(St,Ct,Ot)}),
              vec2(${at(It,Ct,Ot)}));`;const Ut=(0,tt.getGlsl)(ft.session.backend.glContext.version),Lt=`
          ${Mt}
          float getValue(${St.map(zt=>"int "+zt)}) {
            ${Nt}
          }

          void main() {
            ${xt} coords = getOutputCoords();
            int lastDim = coords.${St[bt-1]};
            coords.${St[bt-1]} = coords.${St[bt-2]};
            coords.${St[bt-2]} = lastDim;

            vec4 result = vec4(getValue(${wt}), 0., 0., 0.);

            ${wt[bt-1]} = ${wt[bt-1]} + 1;
            if (${wt[bt-1]} < ${vt[bt-1]}) {
              result.g = getValue(${wt});
            }

            ${wt[bt-2]} = ${wt[bt-2]} + 1;
            if (${wt[bt-2]} < ${vt[bt-2]}) {
              result.a = getValue(${wt});
            }

            ${wt[bt-1]} = ${wt[bt-1]} - 1;
            if (${wt[bt-2]} < ${vt[bt-2]} &&
                ${wt[bt-1]} < ${vt[bt-1]}) {
              result.b = getValue(${wt});
            }
            ${Ut.output} = result;
          }
        `;return Object.assign(Object.assign({},ht),{output:{dims:vt,type:mt[0].type,textureType:nt.TextureType.packed},shaderSource:Lt,hasMain:!0})})(lt,st,ut,dt.axis)})};const at=(lt,ut,dt)=>{const st=lt.indexOf(ut);return lt.map((it,ct)=>ct===st?`${it} - ${dt}`:it).join()}},2069:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.parseConcatAttributes=_.concat=void 0;const tt=_e(246),nt=_e(2039),rt=_e(1163);_.concat=(it,ct,ft)=>(st(ct),it.session.pack&&ct[0].dims.length>1?[it.run((0,rt.createPackedConcatProgramInfoLoader)(it,ct,ft),ct)]:[it.run(ot(it,ct,ft),ct)]);const ot=(it,ct,ft)=>{const ht=(mt=ct.length,pt=ft.cacheKey,{name:"Concat",inputNames:Array.from({length:mt},(_t,vt)=>`X${vt}`),inputTypes:Array(mt).fill(nt.TextureType.unpacked),cacheHint:pt});var mt,pt;return Object.assign(Object.assign({},ht),{get:()=>((_t,vt,bt,wt)=>{const xt=bt[0].dims.slice();if(wt>=xt.length||wt<-1*xt.length)throw new Error("axis specified for concat doesn't match input dimensionality");wt<0&&(wt=xt.length+wt);const Mt=xt.slice(0);for(let $t=1;$t<bt.length;$t++){const Nt=bt[$t].dims.slice();for(let Bt=0;Bt<xt.length;Bt++)if(Bt===wt)Mt[wt]+=Nt[Bt];else if(xt[Bt]!==Nt[Bt])throw new Error("non concat dimensions must match")}const At=Mt.length,St=new Array(bt.length);let Tt=0;for(let $t=0;$t<St.length;++$t)Tt+=bt[$t].dims[wt],St[$t]=Tt;let Ct="";Ct=bt.length<5?at(St):lt(St);const It=`
        ${ut(bt.length,At)}
        ${dt(St)}
        ${Ct}
        float process(int indices[${At}]) {
          int textureIndex = getTextureWhereDataResides (indices[${wt}]);

          if(textureIndex != 0) {
            indices[${wt}] = indices[${wt}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return Object.assign(Object.assign({},vt),{output:{dims:Mt,type:bt[0].type,textureType:nt.TextureType.unpacked},shaderSource:It})})(0,ht,ct,ft.axis)})},at=it=>`int getTextureWhereDataResides(int index) {
      ${it.map((ct,ft)=>`if(index<${ct}) {return ${ft};}
`).join("")}
    }`,lt=it=>at(it),ut=(it,ct)=>{const ft=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${ct}]) {`];for(let ht=0;ht<it;++ht)ht===0?ft.push(`	if (textureIndex == ${ht}) { return _X${ht}(indices); }`):ht===it-1?ft.push(`	else { return _X${ht}(indices); }`):ft.push(`	else if (textureIndex == ${ht}) { return _X${ht}(indices); }`);return ft.push("	}"),ft.join(`
`)},dt=it=>{const ct=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let ft=0;ft<it.length;++ft)ft===0?ct.push(`	if (index == ${ft}) { return ${it[ft]}; }`):ft===it.length-1?ct.push(`	else { return ${it[ft]}; }`):ct.push(`	else if (index == ${ft}) { return ${it[ft]}; }`);return ct.push("	}"),ct.join(`
`)};_.parseConcatAttributes=it=>(0,tt.createAttributeWithCacheKey)({axis:it.attributes.getInt("axis")});const st=it=>{if(!it||it.length<1)throw new Error("too few inputs");const ct=it[0].type,ft=it[0].dims.length;if(ct==="string")throw new Error("string tensor is not supported yet");for(const ht of it){if(ht.type!==ct)throw new Error("input tensors should be one type");if(ht.dims.length!==ft)throw new Error("input tensors should have the same shape")}}},4770:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.createUnpackedGroupedConvProgramInfoLoader=void 0;const tt=_e(6231),nt=_e(5060),rt=_e(2039),ot=_e(8138),at=_e(2823);_.createUnpackedGroupedConvProgramInfoLoader=(lt,ut,dt)=>{const st=(it=ut.length>2,ct=dt.cacheKey,{name:"GroupedConv",inputNames:it?["X","W","Bias"]:["X","W"],inputTypes:it?[rt.TextureType.unpacked,rt.TextureType.unpacked,rt.TextureType.unpacked]:[rt.TextureType.unpacked,rt.TextureType.unpacked],cacheHint:ct});var it,ct;return Object.assign(Object.assign({},st),{get:()=>((ft,ht,mt,pt)=>{const _t=ht.length>2?"value += getBias(output_channel);":"",vt=ht[0].dims.slice(),bt=ht[1].dims.slice(),wt=bt[0]/pt.group;tt.Logger.verbose("GroupedConv",`autpPad:${pt.autoPad}, dilations:${pt.dilations}, group:${pt.group}, kernelShape:${pt.kernelShape}, pads:${pt.pads}, strides:${pt.strides}`);const xt=(0,ot.calculateOutputShape)(vt,bt,pt.dilations,pt.pads,pt.strides),Mt=(0,nt.getGlsl)(ft.session.backend.glContext.version),{activationFunction:At,applyActivation:St}=(0,at.getActivationSnippet)(pt),Tt=`
  const ivec2 strides = ivec2(${pt.strides[0]}, ${pt.strides[1]});
  const ivec2 pads = ivec2(${pt.pads[0]}, ${pt.pads[1]});
  ${At}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${wt};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${bt[1]}; wInChannel++) {
      int input_channel = group_id * ${bt[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${bt[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${pt.dilations[0]};

        if (xHeight < 0 || xHeight >= ${vt[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${bt[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${pt.dilations[1]};
          if (xWidth < 0 || xWidth >= ${vt[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${_t}
    ${St}
    ${Mt.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},mt),{output:{dims:xt,type:ht[0].type,textureType:rt.TextureType.unpacked},shaderSource:Tt,hasMain:!0})})(lt,ut,st,dt)})}},1386:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.conv2DPacked=_.conv2DPackedPointwise=void 0;const tt=_e(8138),nt=_e(8555),rt=_e(708);_.conv2DPackedPointwise=(ot,at,lt)=>{const ut=at[0].dims,dt=at[1].dims,st=(0,tt.calculateOutputShape)(ut,dt,lt.dilations,lt.pads,lt.strides),it=ot.reshapePacked(at[0],[ut[1],ut[2]*ut[3]]),ct=ot.reshapePacked(at[1],[dt[0],dt[1]]),ft=at.length>2?[ct,it,at[2]]:[ct,it],ht=ot.run((0,rt.createPackedMatmulProgramInfoLoader)(ot,ft,lt),ft);return ot.reshapePacked(ht,st)},_.conv2DPacked=(ot,at,lt)=>{const ut=at[0].dims,dt=at[1].dims,st=(0,tt.calculateOutputShape)(ut,dt,lt.dilations,lt.pads,lt.strides),it=ot.run((0,nt.createPackedIm2ColProgramInfoLoader)(ot,at[0],at[1],st,lt),[at[0]]),ct=ot.reshapePacked(at[1],[dt[0],dt[1]*dt[2]*dt[3]]),ft=at.length===3?[ct,it,at[2]]:[ct,it],ht=ot.run((0,rt.createPackedMatmulProgramInfoLoader)(ot,ft,lt),ft);return ot.reshapePacked(ht,st)}},9663:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.parseConvTransposeAttributes=_.convTranspose=void 0;const tt=_e(246),nt=_e(5060),rt=_e(2039),ot=_e(2823),at=(ct,ft,ht,mt,pt,_t)=>(ct-1)*ft+ht+(mt-1)*pt+1-_t,lt=(ct,ft,ht,mt,pt)=>{const _t=Math.floor(ct/2);ft==="SAME_UPPER"?(ht[mt]=_t,ht[pt]=ct-_t):ft==="SAME_LOWER"&&(ht[mt]=ct-_t,ht[pt]=_t)};_.convTranspose=(ct,ft,ht)=>(it(ft,ht),ut(ct,ft,ht));const ut=(ct,ft,ht)=>{const mt=st(ht,ft);return[dt(ct,ft,mt)]},dt=(ct,ft,ht)=>ct.run(((mt,pt,_t)=>{const vt=(bt=pt.length>2,wt=_t.cacheKey,{name:"ConvTranspose",inputNames:bt?["X","W","B"]:["X","W"],inputTypes:bt?[rt.TextureType.unpacked,rt.TextureType.unpacked,rt.TextureType.unpacked]:[rt.TextureType.unpacked,rt.TextureType.unpacked],cacheHint:wt});var bt,wt;return Object.assign(Object.assign({},vt),{get:()=>((xt,Mt,At,St)=>{const Tt=Mt.length>2?"getB(output_channel)":"0.0",Ct=Mt[0].dims,It=Mt[1].dims,$t=It[1],Nt=It[0]/St.group,Bt=[Mt[0].dims[0],Mt[1].dims[1]*St.group,...St.outputShape],Ot=(0,nt.getGlsl)(xt.session.backend.glContext.version),{activationFunction:Ut,applyActivation:Lt}=(0,ot.getActivationSnippet)(St),zt=`
  const ivec2 strides = ivec2(${St.strides[0]}, ${St.strides[1]});
  const ivec2 pads = ivec2(${St.pads[0]}, ${St.pads[1]});
  ${Ut}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${$t};
    int wOutChannel = output_channel - group_id * ${$t};

    float value = ${Tt};
    for (int inChannelOffset = 0; inChannelOffset < ${Nt}; inChannelOffset++) {
      int input_channel = group_id * ${Nt} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${It[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${It[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${St.dilations[0]}, wHOff * ${St.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${Ct[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${Ct[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${Lt}
    ${Ot.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},At),{output:{dims:Bt,type:Mt[0].type,textureType:rt.TextureType.unpacked},shaderSource:zt,hasMain:!0})})(mt,pt,vt,_t)})})(ct,ft,ht),ft),st=(ct,ft)=>{const ht=ct.kernelShape.slice();if(ct.kernelShape.length===0)for(let vt=2;vt<ft[1].dims.length;++vt)ht.push(ft[1].dims[vt]);const mt=ct.pads.slice(),pt=ct.outputShape.slice();((vt,bt,wt,xt,Mt,At,St,Tt)=>{const Ct=vt.length-2,It=Tt.length===0;for(let $t=0;$t<Ct;++$t){const Nt=It?vt[$t+2]*At[$t]:Tt[$t],Bt=at(vt[$t+2],At[$t],Mt[$t],bt[$t],wt[$t],Nt);lt(Bt,xt,Mt,$t,$t+Ct),It&&Tt.push(At[$t]*(vt[$t+2]-1)+St[$t]+(bt[$t]-1)*wt[$t]+1-Mt[$t]-Mt[$t+Ct])}})(ft[0].dims,ht,ct.dilations,ct.autoPad,mt,ct.strides,ct.outputPadding,pt);const _t=Object.assign({},ct);return Object.assign(_t,{kernelShape:ht,pads:mt,outputShape:pt,cacheKey:ct.cacheKey}),_t};_.parseConvTransposeAttributes=ct=>{const ft=ct.attributes,ht=(0,ot.parseInternalActivationAttributes)(ft),mt=ft.getString("auto_pad","NOTSET"),pt=ft.getInts("dilations",[1,1]),_t=ft.getInt("group",1),vt=ft.getInts("kernel_shape",[]),bt=ft.getInts("output_padding",[0,0]),wt=ft.getInts("output_shape",[]),xt=ft.getInts("pads",[0,0,0,0]),Mt=ft.getInts("strides",[1,1]);return(0,tt.createAttributeWithCacheKey)(Object.assign({autoPad:mt,dilations:pt,group:_t,kernelShape:vt,outputPadding:bt,outputShape:wt,pads:xt,strides:Mt},ht))};const it=(ct,ft)=>{if(!ct||ct.length!==2&&ct.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(ct[0].dims.length!==4||ct[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(ct[0].dims[1]!==ct[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const ht=ct[1].dims[1]*ft.group;if(ct.length===3&&(ct[2].dims.length!==1||ct[2].dims[0]!==ht))throw new Error("invalid bias");const mt=ct[0].dims.length-2;if(ft.dilations.length!==mt)throw new Error(`dilations should be ${mt}D`);if(ft.strides.length!==mt)throw new Error(`strides should be ${mt}D`);if(ft.pads.length!==2*mt)throw new Error(`pads should be ${2*mt}D`);if(ft.outputPadding.length!==mt)throw new Error(`output_padding should be ${mt}D`);if(ft.kernelShape.length!==0&&ft.kernelShape.length!==ct[1].dims.length-2)throw new Error("invalid kernel shape");if(ft.outputShape.length!==0&&ft.outputShape.length!==ct[0].dims.length-2)throw new Error("invalid output shape");if(ct[0].type!=="float32"||ct[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(ct.length===3&&ct[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}},8138:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.parseConvAttributes=_.conv=_.calculateOutputShape=void 0;const tt=_e(246),nt=_e(2517),rt=_e(4770),ot=_e(1386),at=_e(9828),lt=_e(2823),ut=_e(3248),dt=_e(5623);_.calculateOutputShape=(mt,pt,_t,vt,bt)=>{const wt=mt[0],xt=mt.slice(2),Mt=xt.length,At=pt[0],St=pt.slice(2).map((Ct,It)=>Ct+(Ct-1)*(_t[It]-1)),Tt=xt.map((Ct,It)=>Ct+vt[It]+vt[It+Mt]).map((Ct,It)=>Math.floor((Ct-St[It]+bt[It])/bt[It]));return[wt,At].concat(...Tt)},_.conv=(mt,pt,_t)=>(ht(pt,_t),st(mt,pt,_t));const st=(mt,pt,_t)=>{const vt=ft(_t,pt),bt=mt.session.pack,wt=vt.kernelShape[0]===1&&vt.kernelShape[1]===1;return vt.group>1?[mt.run((0,rt.createUnpackedGroupedConvProgramInfoLoader)(mt,pt,vt),pt)]:wt&&bt?[it(mt,pt,vt)]:bt&&pt[0].dims.length===4&&pt[0].dims[0]===1&&!wt?[(0,ot.conv2DPacked)(mt,pt,vt)]:[ct(mt,pt,vt)]},it=(mt,pt,_t)=>{const vt=pt[0].dims,bt=pt[1].dims,wt=(0,_.calculateOutputShape)(vt,bt,_t.dilations,_t.pads,_t.strides),xt=mt.reshapeUnpacked(pt[0],[vt[1],vt[2]*vt[3]]),Mt=mt.reshapeUnpacked(pt[1],[bt[0],bt[1]]),At=pt.length>2?[Mt,xt,pt[2]]:[Mt,xt],St=mt.run((0,dt.createMatmulProgramInfoLoader)(At,_t),At);return mt.reshapeUnpacked(St,wt)},ct=(mt,pt,_t)=>{const vt=pt[0].dims,bt=pt[1].dims,wt=(0,_.calculateOutputShape)(vt,bt,_t.dilations,_t.pads,_t.strides),xt=mt.run((0,ut.createIm2ColProgramInfoLoader)(mt,pt[0],pt[1],wt,_t),[pt[0]]),Mt=pt.length===3?[xt,pt[1],pt[2]]:[xt,pt[1]];return mt.run((0,at.createDotProductProgramInfoLoader)(mt,pt,wt,_t),Mt)},ft=(mt,pt)=>{const _t=mt.kernelShape.slice();if(mt.kernelShape.length===0)for(let wt=2;wt<pt[1].dims.length;++wt)_t.push(pt[1].dims[wt]);const vt=mt.pads.slice();nt.PoolConvUtil.adjustPadsBasedOnAutoPad(pt[0].dims,mt.strides,mt.dilations,_t,vt,mt.autoPad);const bt=Object.assign({},mt);return Object.assign(bt,{kernelShape:_t,pads:vt,cacheKey:mt.cacheKey}),bt};_.parseConvAttributes=mt=>{const pt=mt.attributes,_t=(0,lt.parseInternalActivationAttributes)(pt),vt=pt.getString("auto_pad","NOTSET"),bt=pt.getInts("dilations",[1,1]),wt=pt.getInt("group",1),xt=pt.getInts("kernel_shape",[]),Mt=pt.getInts("pads",[0,0,0,0]),At=pt.getInts("strides",[1,1]);return(0,tt.createAttributeWithCacheKey)(Object.assign({autoPad:vt,dilations:bt,group:wt,kernelShape:xt,pads:Mt,strides:At},_t))};const ht=(mt,pt)=>{if(!mt||mt.length!==2&&mt.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(mt[0].dims.length!==4||mt[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(mt[0].dims[1]!==mt[1].dims[1]*pt.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(mt.length===3&&(mt[2].dims.length!==1||mt[1].dims[0]!==mt[2].dims[0]))throw new Error("invalid bias");const _t=mt[0].dims.length-2;if(pt.dilations.length!==_t)throw new Error(`dilations should be ${_t}D`);if(pt.strides.length!==_t)throw new Error(`strides should be ${_t}D`);if(pt.pads.length!==2*_t)throw new Error(`pads should be ${2*_t}D`);if(pt.kernelShape.length!==0&&pt.kernelShape.length!==mt[1].dims.length-2)throw new Error("invalid kernel shape");if(mt[0].type!=="float32"||mt[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(mt.length===3&&mt[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}},5193:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.parseDepthToSpaceAttributes=_.depthToSpace=void 0;const tt=_e(3738);_.depthToSpace=(rt,ot,at)=>{nt(ot);const lt=at.blocksize,ut=lt*lt,dt=at.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],st=at.mode==="DCR"?[ot[0].dims[0],lt,lt,ot[0].dims[1]/ut,ot[0].dims[2],ot[0].dims[3]]:[ot[0].dims[0],ot[0].dims[1]/ut,lt,lt,ot[0].dims[2],ot[0].dims[3]],it=rt.reshapeUnpacked(ot[0],st),ct={perm:dt,cacheKey:`${dt}`},[ft]=(0,tt.transpose)(rt,[it],ct),ht=[ot[0].dims[0],ot[0].dims[1]/ut,ot[0].dims[2]*lt,ot[0].dims[3]*lt];return[rt.reshapeUnpacked(ft,ht)]},_.parseDepthToSpaceAttributes=rt=>{const ot=rt.attributes.getInt("blocksize");if(ot<1)throw new Error(`blocksize must be >= 1, but got : ${ot} for DepthToSpace`);const at=rt.attributes.getString("mode","DCR");if(at!=="DCR"&&at!=="CRD")throw new Error(`unrecognized mode: ${at} for DepthToSpace`);return{mode:at,blocksize:ot}};const nt=rt=>{if(rt.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${rt.length}`);if(rt[0].type==="string"||rt[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},9828:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.createDotProductProgramInfoLoader=void 0;const tt=_e(2517),nt=_e(5060),rt=_e(2039),ot=_e(2823),at=_e(3248);_.createDotProductProgramInfoLoader=(lt,ut,dt,st)=>{const it=((ct,ft)=>({name:"ConvDotProduct",inputNames:ct?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:ct?[rt.TextureType.unpacked,rt.TextureType.packedLastDimension,rt.TextureType.unpacked]:[rt.TextureType.unpacked,rt.TextureType.packedLastDimension],cacheKey:ft.activationCacheKey}))(ut.length>2,st);return Object.assign(Object.assign({},it),{get:()=>((ct,ft,ht,mt,pt)=>{const _t=ht[0].dims,vt=ht[1].dims,bt=[vt[0],Math.ceil(_t[1]*vt[2]*vt[3]/4)],wt=(0,at.calculateIm2ColDims)(_t,vt,mt),[xt,Mt]=ct.calculateTextureWidthAndHeight(bt,rt.TextureType.packedLastDimension),At=tt.ShapeUtil.computeStrides(wt),[St,Tt]=ct.calculateTextureWidthAndHeight(wt,rt.TextureType.packedLastDimension),Ct=mt.length,It=ht.length<3?"0.0":"_B(b)",$t=Math.ceil(_t[1]*vt[2]*vt[3]/4),{activationFunction:Nt,applyActivation:Bt}=(0,ot.getActivationSnippet)(pt),Ot=(0,nt.getGlsl)(ct.session.backend.glContext.version),Ut=`
${Nt}
float process(int indices[${Ct}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${At[0]} + im2col[1] * ${At[1]} + im2col[2] * ${At[2]};
  int kernelOffset = indices[1] * ${bt[1]};
  float value = ${It};
  for (int i = 0; i < ${$t}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${St}, ${Tt});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${xt}, ${Mt});
    value += dot(${Ot.texture2D}(Im2Col, im2colCoords), ${Ot.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${Bt}
  return value;
}`;return Object.assign(Object.assign({},ft),{output:{dims:mt,type:ht[0].type,textureType:rt.TextureType.unpacked},shaderSource:Ut})})(lt,it,ut,dt,st)})}},7992:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.parseFlattenAttributes=_.flatten=void 0;const tt=_e(2517);_.flatten=(rt,ot,at)=>{nt(ot,at);const lt=tt.ShapeUtil.flattenShape(ot[0].dims,at);return[rt.reshapeUnpacked(ot[0],lt)]},_.parseFlattenAttributes=rt=>rt.attributes.getInt("axis",1);const nt=(rt,ot)=>{if(!rt||rt.length!==1)throw new Error("Flatten requires 1 input.");const at=rt[0].dims.length;if(at===0)throw new Error("scalar tensor is not supported.");if(ot<-at||ot>at)throw new Error("Invalid axis");if(rt[0].type==="string")throw new Error("string tensor is not supported.")}},2823:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.parseInternalActivationAttributes=_.getActivationSnippet=void 0;const tt=_e(2517),nt=_e(4909);_.getActivationSnippet=function(rt){let ot;switch(rt.activation){case"Relu":ot=(0,nt.glslRelu)();break;case"Sigmoid":ot=(0,nt.glslSigmoid)();break;case"Clip":ot=(0,nt.glslClip)(rt.clipMin,rt.clipMax);break;default:return{activationFunction:"",applyActivation:""}}const at=ot.name;return{activationFunction:ot.body,applyActivation:`value = ${at}_(value);`}},_.parseInternalActivationAttributes=rt=>{const ot=rt.getString("activation","");if(ot==="Clip"){const[at,lt]=rt.getFloats("activation_params",[tt.MIN_CLIP,tt.MAX_CLIP]);return{activation:ot,clipMax:lt,clipMin:at,activationCacheKey:`${ot}:${at},${lt}`}}return{activation:ot,activationCacheKey:ot}}},1253:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.parseGatherAttributes=_.gather=void 0;const tt=_e(246),nt=_e(782),rt=_e(2517),ot=_e(2039);_.gather=(dt,st,it)=>(ut(st,it.axis),[dt.run(lt(dt,st,it),st)]),_.parseGatherAttributes=dt=>(0,tt.createAttributeWithCacheKey)({axis:dt.attributes.getInt("axis",0)});const at={name:"Gather",inputNames:["A","B"],inputTypes:[ot.TextureType.unpacked,ot.TextureType.unpacked]},lt=(dt,st,it)=>{const ct=Object.assign(Object.assign({},at),{cacheHint:it.cacheKey});return Object.assign(Object.assign({},ct),{get:()=>((ft,ht,mt,pt)=>{const _t=mt[0].dims.slice(),vt=mt[1].dims.slice(),bt=new Array(_t.length+vt.length-1);pt=rt.ShapeUtil.normalizeAxis(pt,_t.length);const wt=[];for(let Mt=0;Mt<bt.length;Mt++)Mt<pt?(bt[Mt]=_t[Mt],wt.push(`inputIdx[${Mt}] = outputIdx[${Mt}];`)):Mt<pt+vt.length?(bt[Mt]=vt[Mt-pt],wt.push(`indexDataIdx[${Mt-pt}] = outputIdx[${Mt}];`)):(bt[Mt]=_t[Mt-vt.length+1],wt.push(`inputIdx[${Mt-vt.length+1}] = outputIdx[${Mt}];`));const xt=`
      float process(int outputIdx[${bt.length||1}]) {
        int inputIdx[${_t.length}];
        int indexDataIdx[${vt.length||1}];
        indexDataIdx[0] = 0;
        ${wt.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${pt}] = idx < 0 ? idx + ${_t[pt]} : idx;
        return _A(inputIdx);
      }`;return Object.assign(Object.assign({},ht),{output:{dims:bt,type:mt[0].type,textureType:ot.TextureType.unpacked},shaderSource:xt})})(0,ct,st,it.axis)})},ut=(dt,st)=>{if(!dt||dt.length!==2)throw new Error("Gather requires 2 inputs.");const it=dt[0].dims.length;if(it<1)throw new Error("Invalid input shape.");if(st<-it||st>it-1)throw new Error("Invalid axis.");if(nt.NUMBER_TYPES.indexOf(dt[0].type)===-1)throw new Error("Invaid input type.");if(dt[1].type!=="int32"&&dt[1].type!=="int16")throw new Error("Invaid input type.")}},4776:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.parseGemmAttributesV11=_.parseGemmAttributesV7=_.gemm=void 0;const tt=_e(246),nt=_e(2517),rt=_e(2039);_.gemm=(dt,st,it)=>(ut(st,it),[dt.run(at(st,it),st)]);const ot=(dt,st)=>{const it=dt.attributes.getInt("transA",0)!==0,ct=dt.attributes.getInt("transB",0)!==0,ft=dt.attributes.getFloat("alpha",1),ht=dt.attributes.getFloat("beta",1);return(0,tt.createAttributeWithCacheKey)({transA:it,transB:ct,alpha:ft,beta:ht,isOptionalC:st})};_.parseGemmAttributesV7=dt=>ot(dt,!1),_.parseGemmAttributesV11=dt=>ot(dt,!0);const at=(dt,st)=>{const it={name:"Gemm",inputNames:dt.length===3?["A","B","C"]:["A","B"],inputTypes:dt.length===3?[rt.TextureType.unpacked,rt.TextureType.unpacked,rt.TextureType.unpacked]:[rt.TextureType.unpacked,rt.TextureType.unpacked],key:st.cacheKey};return Object.assign(Object.assign({},it),{get:()=>lt(it,dt,st)})},lt=(dt,st,it)=>{const ct=st[0].dims.slice(),ft=st[1].dims.slice(),[ht,mt]=nt.GemmUtil.getShapeOfGemmResult(ct,it.transA,ft,it.transB,st.length===3?st[2].dims:void 0),pt=[ht,mt];if(!pt)throw new Error("Can't use gemm on the given tensors");let _t=ct[ct.length-1],vt="";it.transA&&(_t=ct[0]),it.transA&&it.transB?vt="value += _A_T(a) * _B_T(b);":it.transA&&!it.transB?vt="value += _A_T(a) * _B(b);":!it.transA&&it.transB?vt="value += _A(a) * _B_T(b);":it.transA||it.transB||(vt="value += _A(a) * _B(b);");const bt=pt.length,wt=`
      float process(int indices[${bt}]) {
          int a[${bt}];
          int b[${bt}];
          ${st.length===3?`int c[${st[2].dims.length}];`:""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${st.length===3?"bcastIndices_C(indices, c);":""}

          float value = 0.0;
          for (int k=0; k<${_t}; ++k) {
              a[${bt-1}] = k;
              b[${bt-2}] = k;
              ${vt}
          }

          value = value * alpha;
          ${st.length===3?"value += beta * _C(c);":""}
          return value;
      }`;return Object.assign(Object.assign({},dt),{output:{dims:pt,type:st[0].type,textureType:rt.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:it.alpha},{name:"beta",type:"float",data:it.beta}],shaderSource:wt})},ut=(dt,st)=>{if(!dt)throw new Error("Input is missing");if(st.isOptionalC&&(dt.length<2||dt.length>3))throw new Error("Invaid input shape.");if(!st.isOptionalC&&dt.length!==3)throw new Error("Gemm requires 3 inputs");if(dt.length===3&&dt[2].dims.length!==1&&dt[2].dims.length!==2)throw new Error("Invalid input shape of C");if(dt[0].type!=="float32"&&dt[0].type!=="float64"||dt[1].type!=="float32"&&dt[1].type!=="float64"||dt.length===3&&dt[2].type!=="float32"&&dt[2].type!=="float64")throw new Error("Invalid input type.");if(dt[0].type!==dt[1].type||dt.length===3&&dt[0].type!==dt[2].type)throw new Error("Input types are mismatched")}},8555:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.createPackedIm2ColProgramInfoLoader=void 0;const tt=_e(5060),nt=_e(2039),rt=_e(2827);_.createPackedIm2ColProgramInfoLoader=(ot,at,lt,ut,dt)=>{const st=(it=dt.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[nt.TextureType.packed],cacheHint:it});var it;return Object.assign(Object.assign({},st),{get:()=>((ct,ft,ht,mt,pt,_t)=>{const vt=ht.dims,bt=mt.dims,wt=pt.length,xt=[bt[1]*bt[2]*bt[3],pt[2]*pt[3]],Mt=bt[2]*bt[3],At=(0,rt.unpackFromChannel)(),St=(0,tt.getGlsl)(ct.session.backend.glContext.version);let Tt="";for(let It=0;It<=1;It++)for(let $t=0;$t<=1;$t++)Tt+=`
            blockIndex = rc.x + ${$t};
            pos = rc.y + ${It};

            if(blockIndex < ${xt[1]} && pos < ${xt[0]}) {
              offsetY = int(blockIndex / (${pt[wt-1]})) * ${_t.strides[0]} -
                ${_t.pads[0]};
              d0 = offsetY + ${_t.dilations[0]} * (imod(pos, ${Mt}) / ${bt[2]});

              if(d0 < ${vt[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${pt[wt-1]}) * ${_t.strides[1]} -
                  ${_t.pads[1]};
                d1 = offsetX + ${_t.dilations[1]} * imod(imod(pos, ${Mt}), ${bt[2]});

                if(d1 < ${vt[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${Mt}.);
                    innerDims = vec2(d0, d1);
                    result[${2*It+$t}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;const Ct=`
      ${At}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${Tt}
          ${St.output} = result;
      }
            `;return Object.assign(Object.assign({},ft),{output:{dims:xt,type:ht.type,textureType:nt.TextureType.packed},shaderSource:Ct,hasMain:!0})})(ot,st,at,lt,ut,dt)})}},3248:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.calculateIm2ColDims=_.createIm2ColProgramInfoLoader=void 0;const tt=_e(2039);_.createIm2ColProgramInfoLoader=(nt,rt,ot,at,lt)=>{const ut=(dt=lt.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[tt.TextureType.unpacked],cacheHint:dt});var dt;return Object.assign(Object.assign({},ut),{get:()=>((st,it,ct,ft,ht,mt)=>{const pt=ct.dims,_t=ft.dims,vt=ht.length,bt=(0,_.calculateIm2ColDims)(pt,_t,ht,4),wt=`
        const int XC = ${pt[1]};
        const int XH = ${pt[2]};
        const int XW = ${pt[3]};
        const int KH = ${mt.kernelShape[0]};
        const int KW = ${mt.kernelShape[1]};
        const int dilationH = ${mt.dilations[0]};
        const int dilationW = ${mt.dilations[1]};
        const int strideH = ${mt.strides[0]};
        const int strideW = ${mt.strides[1]};
        const int padH = ${mt.pads[0]};
        const int padW = ${mt.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${vt}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${pt.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return Object.assign(Object.assign({},it),{output:{dims:bt,type:ct.type,textureType:tt.TextureType.packedLastDimension},shaderSource:wt})})(0,ut,rt,ot,at,lt)})},_.calculateIm2ColDims=(nt,rt,ot,at=4)=>[ot[0],ot[2],ot[3],Math.ceil(nt[1]*rt[2]*rt[3]/at)]},6572:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.parseImageScalerAttributes=_.imageScaler=void 0;const tt=_e(246),nt=_e(2039);_.imageScaler=(ut,dt,st)=>(lt(dt),[ut.run(ot(ut,dt,st),dt)]),_.parseImageScalerAttributes=ut=>{const dt=ut.attributes.getFloat("scale"),st=ut.attributes.getFloats("bias");return(0,tt.createAttributeWithCacheKey)({scale:dt,bias:st})};const rt={name:"ImageScaler",inputNames:["X"],inputTypes:[nt.TextureType.unpacked]},ot=(ut,dt,st)=>{const it=Object.assign(Object.assign({},rt),{cacheHint:st.cacheKey});return Object.assign(Object.assign({},it),{get:()=>((ct,ft,ht,mt)=>{const pt=ht[0].dims.slice(),_t=pt.length,vt=`
      ${at(mt.bias.length)}
      float process(int indices[${_t}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return Object.assign(Object.assign({},ft),{output:{dims:pt,type:ht[0].type,textureType:nt.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:mt.bias.length,data:mt.bias},{name:"scale",type:"float",data:mt.scale}],shaderSource:vt})})(0,it,dt,st)})},at=ut=>{const dt=[`float getBias(float bias[${ut}], int channel) {`];for(let st=0;st<ut;++st)st===0?dt.push(`	if (channel == ${st}) { return bias[${st}]; }`):st===ut-1?dt.push(`	else { return bias[${st}]; }`):dt.push(`	else if (channel == ${st}) { return bias[${st}]; }`);return dt.push("	}"),dt.join(`
`)},lt=ut=>{if(!ut||ut.length!==1)throw new Error("ImageScaler requires 1 input.");if(ut[0].dims.length!==4)throw new Error("Invalid input shape.");if(ut[0].type!=="float32"&&ut[0].type!=="float64")throw new Error("Invalid input type.")}},3346:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.parseInstanceNormalizationAttributes=_.instanceNormalization=void 0;const tt=_e(5060),nt=_e(2039);_.instanceNormalization=(dt,st,it)=>{ut(st);const ct=dt.run(ot(st[0]),st);return[dt.run(lt(dt,st[0],it,ct.dims),[st[0],ct,st[1],st[2]])]},_.parseInstanceNormalizationAttributes=dt=>dt.attributes.getFloat("epsilon",1e-5);const rt={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[nt.TextureType.unpacked]},ot=dt=>Object.assign(Object.assign({},rt),{get:()=>((st,it)=>{const ct=it.dims.slice(),ft=ct[1],ht=ct[2]*ct[3],mt=[ct[0],ft],pt=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${ct[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${ct[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${ht});
        temp = 0.0;
        for(int a2=0; a2<${ct[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${ct[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${ht});

        return v;
      }`;return Object.assign(Object.assign({},st),{output:{dims:mt,type:it.type,textureType:nt.TextureType.packedLastDimension},shaderSource:pt})})(rt,dt)}),at={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[nt.TextureType.unpacked,nt.TextureType.packedLastDimension,nt.TextureType.unpacked,nt.TextureType.unpacked]},lt=(dt,st,it,ct)=>{const ft=Object.assign(Object.assign({},at),{cacheHint:`${it}`});return Object.assign(Object.assign({},ft),{get:()=>((ht,mt,pt,_t,vt)=>{const bt=(0,tt.getGlsl)(ht.session.backend.glContext.version),[wt,xt]=ht.calculateTextureWidthAndHeight(vt,nt.TextureType.packedLastDimension),[Mt,At]=[wt/4,xt],St=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${Mt}, ${At});
        return ${bt.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return Object.assign(Object.assign({},mt),{output:{dims:pt.dims,type:pt.type,textureType:nt.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:_t}],shaderSource:St})})(dt,ft,st,it,ct)})},ut=dt=>{if(!dt||dt.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");const st=dt[0],it=dt[1],ct=dt[2];if(st.dims.length<3||it.dims.length!==1||ct.dims.length!==1)throw new Error("Invalid input shape.");if(it.dims[0]!==st.dims[1]||ct.dims[0]!==st.dims[1])throw new Error("Input shapes are mismatched.");if(st.type!=="float32"&&st.type!=="float64"||it.type!=="float32"&&it.type!=="float64"||ct.type!=="float32"&&ct.type!=="float64")throw new Error("Invalid input type.");if(dt[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}},708:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.createPackedMatmulProgramInfoLoader=void 0;const tt=_e(2517),nt=_e(5060),rt=_e(2039),ot=_e(9390),at=_e(2823),lt=_e(5623);_.createPackedMatmulProgramInfoLoader=(ut,dt,st)=>{const it=(ct=dt.length>2,ft=st.activationCacheKey,{name:"MatMul (packed)",inputNames:ct?["A","B","Bias"]:["A","B"],inputTypes:ct?[rt.TextureType.packed,rt.TextureType.packed,rt.TextureType.packed]:[rt.TextureType.packed,rt.TextureType.packed],cacheHint:ft});var ct,ft;return Object.assign(Object.assign({},it),{get:()=>((ht,mt,pt,_t)=>{const vt=pt.length>2,bt=vt?"value += getBiasForMatmul();":"",wt=pt[0].dims,xt=pt[1].dims,Mt=tt.BroadcastUtil.calcShape(wt,xt,!0),At=!tt.ShapeUtil.areEqual(pt[0].dims,pt[1].dims);if(!Mt)throw new Error("Can't use matmul on the given tensors");const St=wt[wt.length-1],Tt=Math.ceil(St/2),Ct=wt.length,It=xt.length,$t=(0,nt.getGlsl)(ht.session.backend.glContext.version),Nt=(0,ot.getCoordsDataType)(Mt.length),Bt=Mt.length,Ot=(0,ot.getGlChannels)(),{activationFunction:Ut,applyActivation:Lt}=(0,at.getActivationSnippet)(_t),zt=vt?`${(0,lt.getBiasForMatmul)(Nt,Ot,pt[2].dims,Mt,!0)}`:"",Yt=At?`${function(mn,vn,In,Cn){let En=[],jt=[];const Kt=In[0].dims,nn=In[1].dims,Vt=Kt.length,on=nn.length,dn=Cn.length,Ln=dn-Vt,Sn=dn-on;En=Kt.map((fn,hn)=>`coords.${vn[hn+Ln]}`),En[Vt-1]="i*2",En.join(", "),jt=nn.map((fn,hn)=>`coords.${vn[hn+Sn]}`),jt[on-2]="i*2",jt.join(", ");const Xn=tt.BroadcastUtil.getBroadcastDims(Kt,Cn),Vn=tt.BroadcastUtil.getBroadcastDims(nn,Cn),Hn=Xn.map(fn=>`coords.${vn[fn+Ln]} = 0;`).join(`
`),Zt=Vn.map(fn=>`coords.${vn[fn+Sn]} = 0;`).join(`
`),Gt=`int lastDim = coords.${vn[dn-1]};
  coords.${vn[dn-1]} = coords.${vn[dn-2]};
  coords.${vn[dn-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${mn} coords = getOutputCoords();
  ${Gt}
  ${Hn}
  vec4 outputValue = getA(${En});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${mn} coords = getOutputCoords();
  ${Gt}
  ${Zt}
  vec4 outputValue = getB(${jt});
  return outputValue;
}`}(Nt,Ot,pt,Mt)}`:"",en=At?"getAAtOutCoordsMatmul(i)":`getA(${function(mn,vn){let In="";for(let Cn=0;Cn<vn-2;Cn++)In+=`rc.${mn[Cn]}, `;return In+=`rc.${mn[vn-2]}, i*2`,In}(Ot,Ct)})`,bn=At?"getBAtOutCoordsMatmul(i)":`getB(${function(mn,vn){let In="";for(let Cn=0;Cn<vn-2;Cn++)In+=`rc.${mn[Cn]}, `;return In+=`i*2, rc.${mn[vn-1]}`,In}(Ot,It)})`,Un=`
            ${Yt}
            ${zt}
            ${Ut}
            void main() {
              ${At?"":`${Nt} rc =
          getOutputCoords(); int lastDim = rc.${Ot[Bt-1]}; rc.${Ot[Bt-1]} =
          rc.${Ot[Bt-2]}; rc.${Ot[Bt-2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${Tt}; i++) {
                vec4 a = ${en};
                vec4 b = ${bn};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${bt}
              ${Lt}
              ${$t.output} = value;
            }`;return Object.assign(Object.assign({},mt),{output:{dims:Mt,type:pt[0].type,textureType:rt.TextureType.packed},shaderSource:Un,hasMain:!0})})(ut,it,dt,st)})}},5623:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.getBiasForMatmul=_.createMatmulProgramInfoLoader=_.parseMatMulAttributes=_.matMul=void 0;const tt=_e(2517),nt=_e(2039),rt=_e(9390),ot=_e(2823),at=_e(708);function lt(st,it){const ct=(ft=st.length>2,ht=it.activationCacheKey,{name:"MatMul",inputNames:ft?["A","B","Bias"]:["A","B"],inputTypes:ft?[nt.TextureType.unpacked,nt.TextureType.unpacked,nt.TextureType.unpacked]:[nt.TextureType.unpacked,nt.TextureType.unpacked],cacheHint:ht});var ft,ht;return Object.assign(Object.assign({},ct),{get:()=>function(mt,pt,_t){const vt=pt[0].dims,bt=pt[1].dims,wt=tt.BroadcastUtil.calcShape(vt,bt,!0);if(!wt)throw new Error("Can't use matmul on the given tensors");const xt=(0,rt.getCoordsDataType)(wt.length),Mt=(0,rt.getGlChannels)(),{activationFunction:At,applyActivation:St}=(0,ot.getActivationSnippet)(_t),Tt=pt.length>2,Ct=Tt?"value += getBiasForMatmul();":"",It=Tt?`${dt(xt,Mt,pt[2].dims,wt,!1)}`:"",$t=wt.length,Nt=vt.length,Bt=bt.length,Ot=`
    ${At}
    ${It}
    float process(int indices[${$t}]) {
        int a[${Nt}];
        int b[${Bt}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${vt[vt.length-1]}; ++k) {
            a[${Nt-1}] = k;
            b[${Bt-2}] = k;
            value += _A(a) * _B(b);
        }
        ${Ct}
        ${St}
        return value;
    }`;return Object.assign(Object.assign({},mt),{output:{dims:wt,type:pt[0].type,textureType:nt.TextureType.unpacked},shaderSource:Ot})}(ct,st,it)})}_.matMul=(st,it,ct)=>(ut(it),st.session.pack?[st.run((0,at.createPackedMatmulProgramInfoLoader)(st,it,ct),it)]:[st.run(lt(it,ct),it)]),_.parseMatMulAttributes=st=>(0,ot.parseInternalActivationAttributes)(st.attributes),_.createMatmulProgramInfoLoader=lt;const ut=st=>{if(!st||st.length!==2)throw new Error("MatMul requires 2 inputs.");if(st[0].dims[st[0].dims.length-1]!==st[1].dims[st[1].dims.length-2])throw new Error("shared dimension does not match.");if(st[0].type!=="float32"&&st[0].type!=="float64"||st[1].type!=="float32"&&st[1].type!=="float64")throw new Error("inputs should be float type");if(st[0].type!==st[1].type)throw new Error("inputs types should match")};function dt(st,it,ct,ft,ht){let mt="";const pt=ct.length,_t=ft.length,vt=_t-pt;mt=_t<2&&pt>0?"coords":ct.map((xt,Mt)=>`coords.${it[Mt+vt]}`).join(", ");const bt=tt.BroadcastUtil.getBroadcastDims(ct,ft).map(xt=>`coords.${it[xt+vt]} = 0;`).join(`
`);let wt="vec4(outputValue.xx, outputValue.yy)";return tt.ShapeUtil.size(ct)===1&&(wt="vec4(outputValue.x)"),ht?`
vec4 getBiasForMatmul() {
  ${st} coords = getOutputCoords();
  ${bt}
  vec4 outputValue = getBias(${mt});
  return ${wt};
}`:`
float getBiasForMatmul() {
  ${st} coords = getOutputCoords();
  ${bt}
  return getBias(coords.x);
}`}_.getBiasForMatmul=dt},2403:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.createPackProgramInfoLoader=void 0;const tt=_e(5060),nt=_e(2039),rt=_e(9390),ot=_e(2827),at={name:"pack",inputNames:["A"],inputTypes:[nt.TextureType.unpackedReversed]};_.createPackProgramInfoLoader=(lt,ut)=>Object.assign(Object.assign({},at),{get:()=>((dt,st)=>{const it=(0,tt.getGlsl)(dt.session.backend.glContext.version),ct=st.dims,ft=ct.length,ht=st.dims.length,mt=(0,rt.getCoordsDataType)(ht),pt=(0,ot.getChannels)("rc",ht),_t=(vt=ht,bt=pt,wt=ct[ct.length-2],xt=ct[ct.length-1],vt===0||vt===1?"":`
    int r = ${bt[vt-2]};
    int c = ${bt[vt-1]};
    int rp1 = ${bt[vt-2]} + 1;
    int cp1 = ${bt[vt-1]} + 1;
    bool rEdge = rp1 >= ${xt};
    bool cEdge = cp1 >= ${wt};
    `);var vt,bt,wt,xt;let Mt;Mt=ft===0?[1,1]:ft===1?[ct[0],1]:[ct[ht-1],ct[ht-2]];const At=function(Ct,It,$t){if(Ct===0)return"false";if(Ct===1)return`rc > ${It[0]}`;let Nt="";for(let Bt=Ct-2;Bt<Ct;Bt++)Nt+=`${$t[Bt]} >= ${It[Bt-Ct+2]}`,Bt<Ct-1&&(Nt+="||");return Nt}(ht,Mt,pt),St=function(Ct,It){const $t=Ct.length;if($t===0)return"getA(), 0, 0, 0";if($t===1)return`getA(rc),
            rc + 1 >= ${Ct[0]} ? 0. : getA(rc + 1),
            0, 0`;let Nt="";if($t>2)for(let Bt=0;Bt<$t-2;++Bt)Nt+=`${It[Bt]},`;return`getA(${Nt}r, c),
          rEdge ? 0. : getA(${Nt}rp1, c),
          cEdge ? 0. : getA(${Nt}r, cp1),
          rEdge || cEdge ? 0. : getA(${Nt}rp1, cp1)`}(ct,pt),Tt=`
        void main() {
          ${mt} rc = getOutputCoords();

          if(${At}) {
            ${it.output} = vec4(0);
          } else {
            ${_t}

            ${it.output} = vec4(${St});
          }
        }
      `;return Object.assign(Object.assign({},at),{hasMain:!0,output:{dims:st.dims,type:st.type,textureType:nt.TextureType.packed},shaderSource:Tt})})(lt,ut)})},2827:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.unpackFromChannel=_.getChannels=_.getVecChannels=void 0;const tt=_e(9390);function nt(rt,ot){return(0,tt.getGlChannels)(ot).map(at=>`${rt}.${at}`)}_.getVecChannels=nt,_.getChannels=function(rt,ot){return ot===1?[rt]:nt(rt,ot)},_.unpackFromChannel=function(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}},2870:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.parsePadAttributesV11=_.padV11=_.parsePadAttributesV2=_.padV2=void 0;const tt=_e(246),nt=_e(2517),rt=_e(5060),ot=_e(2039),at={name:"Pad",inputNames:["A"],inputTypes:[ot.TextureType.unpacked]};_.padV2=(mt,pt,_t)=>(dt(pt),[mt.run(Object.assign(Object.assign({},at),{cacheHint:_t.cacheKey,get:()=>ut(mt,pt[0],_t)}),pt)]),_.parsePadAttributesV2=mt=>{const pt=mt.attributes.getString("mode","constant"),_t=mt.attributes.getFloat("value",0),vt=mt.attributes.getInts("pads");return(0,tt.createAttributeWithCacheKey)({mode:pt,value:_t,pads:vt})},_.padV11=(mt,pt,_t)=>{st(pt);const vt=lt(mt,pt,_t);return(0,_.padV2)(mt,[pt[0]],vt)},_.parsePadAttributesV11=mt=>mt.attributes.getString("mode","constant");const lt=(mt,pt,_t)=>{if(!mt.session.isInitializer(pt[1].dataId)||pt.length>=3&&!mt.session.isInitializer(pt[2].dataId))throw new Error("dynamic pad attributes are not allowed");const vt=Array.from(pt[1].integerData),bt=pt.length>=3?pt[2].floatData[0]:0;return(0,tt.createAttributeWithCacheKey)({mode:_t,pads:vt,value:bt})},ut=(mt,pt,_t)=>{const vt=nt.ShapeUtil.padShape(pt.dims.slice(),_t.pads),bt=vt.length,wt=`
      ${it(mt,pt,_t)}
      float process(int[${bt}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[ot.TextureType.unpacked],output:{dims:vt,type:pt.type,textureType:ot.TextureType.unpacked},shaderSource:wt}},dt=mt=>{if(!mt||mt.length!==1)throw new Error("Pad requires 1 input");if(mt[0].type!=="float32"&&mt[0].type!=="float64")throw new Error("Invalid input type.")},st=mt=>{if(!mt||mt.length!==2&&mt.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(mt[1].type!=="int32")throw new Error("Invalid input type.");if(mt.length>=3&&mt[2].type==="string")throw new Error("Invalid input type.")},it=(mt,pt,_t)=>{const vt=(0,rt.getGlsl)(mt.session.backend.glContext.version),[bt,wt]=mt.calculateTextureWidthAndHeight(pt.dims,ot.TextureType.unpacked),xt=nt.ShapeUtil.computeStrides(pt.dims);switch(_t.mode){case"constant":return ct(vt,pt.dims,xt,bt,wt,_t.pads,_t.value);case"reflect":return ft(vt,pt.dims,xt,bt,wt,_t.pads);case"edge":return ht(vt,pt.dims,xt,bt,wt,_t.pads);default:throw new Error("Invalid mode")}},ct=(mt,pt,_t,vt,bt,wt,xt)=>{const Mt=pt.length;let At="";for(let St=Mt-1;St>=0;--St)At+=`
        k = m[${St}] - ${wt[St]};
        if (k < 0)  return constant;
        if (k >= ${pt[St]}) return constant;
        offset += k * ${_t[St]};
        `;return`
      float padA(int m[${Mt}]) {
        const float constant = float(${xt});
        int offset = 0;
        int k = 0;
        ${At}
        vec2 coords = offsetToCoords(offset, ${vt}, ${bt});
        float value = getColorAsFloat(${mt.texture2D}(A, coords));
        return value;
      }
      `},ft=(mt,pt,_t,vt,bt,wt)=>{const xt=pt.length;let Mt="";for(let At=xt-1;At>=0;--At)Mt+=`
        k = m[${At}] - ${wt[At]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(pt[At]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${pt[At]}) { k = _2n_1 - k; }
        }
        offset += k * ${_t[At]};
        `;return`
      float padA(int m[${xt}]) {
        int offset = 0;
        int k = 0;
        ${Mt}
        vec2 coords = offsetToCoords(offset, ${vt}, ${bt});
        float value = getColorAsFloat(${mt.texture2D}(A, coords));
        return value;
      }
      `},ht=(mt,pt,_t,vt,bt,wt)=>{const xt=pt.length;let Mt="";for(let At=xt-1;At>=0;--At)Mt+=`
        k = m[${At}] - ${wt[At]};
        if (k < 0)  k = 0;
        if (k >= ${pt[At]}) k = ${pt[At]-1};
        offset += k * ${_t[At]};
      `;return`
      float padA(int m[${xt}]) {
        int offset = 0;
        int k = 0;
        ${Mt}
        vec2 coords = offsetToCoords(offset, ${vt}, ${bt});
        float value = getColorAsFloat(${mt.texture2D}(A, coords));
        return value;
      }
      `}},2143:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.globalMaxPool=_.parseMaxPoolAttributes=_.maxPool=_.parseGlobalAveragePoolAttributes=_.globalAveragePool=_.parseAveragePoolAttributes=_.averagePool=void 0;const tt=_e(246),nt=_e(2517),rt=_e(2039);_.averagePool=(ht,mt,pt)=>{st(mt);const _t={name:"AveragePool",inputNames:["X"],inputTypes:[rt.TextureType.unpacked],cacheHint:pt.cacheKey};return[ht.run(Object.assign(Object.assign({},_t),{get:()=>ot(mt,_t,!1,pt)}),mt)]},_.parseAveragePoolAttributes=ht=>{const mt=ht.attributes.getString("auto_pad","NOTSET"),pt=ht.attributes.getInt("ceil_mode",0),_t=ht.attributes.getInt("count_include_pad",0)!==0,vt=ht.attributes.getInts("kernel_shape"),bt=ht.attributes.getInts("strides",[]),wt=ht.attributes.getInts("pads",[]);if(pt!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,tt.createAttributeWithCacheKey)({autoPad:mt,ceilMode:pt,countIncludePad:_t,kernelShape:vt,strides:bt,pads:wt})};const ot=(ht,mt,pt,_t)=>{const[vt,bt]=lt(ht,_t,pt),wt=nt.ShapeUtil.size(vt.kernelShape);let xt="";vt.countIncludePad?xt+=`value /= float(${wt});`:xt+=`value /= float(${wt} - pad);`;const Mt=`
        ${it(ht[0].dims,vt,"value += _X(x);",xt,"0.0")}
      `;return Object.assign(Object.assign({},mt),{output:{dims:bt,type:ht[0].type,textureType:rt.TextureType.unpacked},shaderSource:Mt})};_.globalAveragePool=(ht,mt,pt)=>{st(mt);const _t={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[rt.TextureType.unpacked],cacheHint:`${pt.countIncludePad}`};return[ht.run(Object.assign(Object.assign({},_t),{get:()=>ot(mt,_t,!0,pt)}),mt)]},_.parseGlobalAveragePoolAttributes=ht=>{const mt=ht.attributes.getInt("count_include_pad",0)!==0;return(0,tt.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:mt,kernelShape:[],strides:[],pads:[]})},_.maxPool=(ht,mt,pt)=>{st(mt);const _t={name:"MaxPool",inputNames:["X"],inputTypes:[rt.TextureType.unpacked],cacheHint:pt.cacheKey};return[ht.run(Object.assign(Object.assign({},_t),{get:()=>at(mt,_t,!1,pt)}),mt)]},_.parseMaxPoolAttributes=ht=>{const mt=ht.attributes.getString("auto_pad","NOTSET"),pt=ht.attributes.getInt("ceil_mode",0),_t=ht.attributes.getInts("kernel_shape"),vt=ht.attributes.getInts("strides",[]),bt=ht.attributes.getInts("pads",[]),wt=ht.attributes.getInt("storage_order",0),xt=ht.attributes.getInts("dilations",[]);if(wt!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(pt!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,tt.createAttributeWithCacheKey)({autoPad:mt,ceilMode:pt,countIncludePad:!1,kernelShape:_t,strides:vt,pads:bt,storageOrder:wt,dilations:xt})};const at=(ht,mt,pt,_t)=>{const[vt,bt]=lt(ht,_t,pt),wt=`
      ${it(ht[0].dims,vt,`
      value = max(_X(x), value);
    `,"","-1e5")}
    `;return Object.assign(Object.assign({},mt),{output:{dims:bt,type:ht[0].type,textureType:rt.TextureType.unpacked},shaderSource:wt})},lt=(ht,mt,pt)=>{const _t=ht[0].dims.slice(),vt=Object.hasOwnProperty.call(mt,"dilations"),bt=mt.kernelShape.slice(),wt=mt.strides.slice(),xt=vt?mt.dilations.slice():[],Mt=mt.pads.slice();nt.PoolConvUtil.adjustPoolAttributes(pt,_t,bt,wt,xt,Mt);const At=nt.PoolConvUtil.computePoolOutputShape(pt,_t,wt,xt,bt,Mt,mt.autoPad),St=Object.assign({},mt);return vt?Object.assign(St,{kernelShape:bt,strides:wt,pads:Mt,dilations:xt,cacheKey:mt.cacheKey}):Object.assign(St,{kernelShape:bt,strides:wt,pads:Mt,cacheKey:mt.cacheKey}),[St,At]},ut={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},dt={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[rt.TextureType.unpacked]};_.globalMaxPool=(ht,mt)=>(st(mt),[ht.run(Object.assign(Object.assign({},dt),{get:()=>at(mt,dt,!0,ut)}),mt)]);const st=ht=>{if(!ht||ht.length!==1)throw new Error("Pool ops requires 1 input.");if(ht[0].type!=="float32"&&ht[0].type!=="float64")throw new Error("Invalid input type.")},it=(ht,mt,pt,_t,vt)=>{const bt=ht.length;if(mt.kernelShape.length<=2){const wt=mt.kernelShape[mt.kernelShape.length-1],xt=mt.strides[mt.strides.length-1],Mt=mt.pads[mt.pads.length/2-1],At=mt.pads[mt.pads.length-1],St=ht[bt-1];let Tt="",Ct="",It="";if(Tt=Mt+At!==0?`
          for (int i = 0; i < ${wt}; i++) {
            x[${bt} - 1] = indices[${bt} - 1] * ${xt} - ${Mt} + i;
            if (x[${bt} - 1] < 0 || x[${bt} - 1] >= ${St}) {
              pad++;
              continue;
            }
            ${pt}
          }`:`
          for (int i = 0; i < ${wt}; i++) {
            x[${bt} - 1] = indices[${bt} - 1] * ${xt} - ${Mt} + i;
            ${pt}
          }`,mt.kernelShape.length===2){const $t=mt.kernelShape[mt.kernelShape.length-2],Nt=mt.strides[mt.strides.length-2],Bt=mt.pads[mt.pads.length/2-2],Ot=mt.pads[mt.pads.length-2],Ut=ht[bt-2];Ct=Bt+Ot!==0?`
            for (int j = 0; j < ${$t}; j++) {
              x[${bt} - 2] = indices[${bt} - 2] * ${Nt} - ${Bt} + j;
              if (x[${bt} - 2] < 0 || x[${bt} - 2] >= ${Ut}) {
                pad+= ${wt};
                continue;
              }
          `:`
            for (int j = 0; j < ${$t}; j++) {
              x[${bt} - 2] = indices[${bt} - 2] * ${Nt} - ${Bt} + j;
            `,It=`
          }
        `}return`
        float process(int indices[${bt}]) {
          int x[${bt}];
          copyVec(indices, x);

          float value = ${vt};
          int pad = 0;
          ${Ct}
          ${Tt}
          ${It}
          ${_t}
          return value;
        }
      `}{const wt=nt.ShapeUtil.size(mt.kernelShape),xt=nt.ShapeUtil.computeStrides(mt.kernelShape),Mt=xt.length,At=mt.pads.length,St=ft(Mt),Tt=ct(ht,"inputDims"),Ct=ct(mt.pads,"pads"),It=ct(xt,"kernelStrides"),$t=ct(mt.strides,"strides");let Nt="";return Nt=mt.pads.reduce((Bt,Ot)=>Bt+Ot)?`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${pt}
          }`:`
          }
          ${pt}
        `,`
        ${St}
        float process(int indices[${bt}]) {
          int x[${bt}];
          copyVec(indices, x);
          int offset[${Mt}];
          int pads[${At}];
          int inputDims[${bt}];
          int kernelStrides[${Mt}];
          int strides[${Mt}];
          ${Ct}
          ${Tt}
          ${$t}
          ${It}

          float value = ${vt};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${wt}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${bt} - ${Mt}; j < ${bt}; j++) {
              x[j] = indices[j] * strides[j - ${bt} + ${Mt}]
                + offset[j - ${bt} + ${Mt}] - pads[j - 2];
              ${Nt}
          }
          ${_t}

          return value;
        }
      `}},ct=(ht,mt)=>{let pt="";for(let _t=0;_t<ht.length;_t++)pt+=`
      ${mt}[${_t}] = ${ht[_t]};
    `;return pt},ft=ht=>`
  void offsetToIndices(int offset, int[${ht}] strides, out int[${ht}] indices) {
    if (${ht} == 0) {
      return;
    }
    for (int i = 0; i < ${ht} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${ht} - 1] = offset;
  }`},4939:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.reduceLogSumSquare=_.reduceLogSum=_.reduceProd=_.reduceMin=_.reduceMax=_.reduceMean=_.reduceSum=_.parseReduceAttributes=void 0;const tt=_e(246),nt=_e(782),rt=_e(2517),ot=_e(2039),at=(dt,st,it,ct,ft)=>{ut(st);const ht={name:ct,inputNames:["A"],inputTypes:[ot.TextureType.unpacked]};return[dt.run(Object.assign(Object.assign({},ht),{cacheHint:it.cacheKey,get:()=>lt(dt,st,it,ct,ft,ht)}),st)]};_.parseReduceAttributes=dt=>{const st=dt.attributes.getInts("axes",[]),it=dt.attributes.getInt("keepdims",1)===1;return(0,tt.createAttributeWithCacheKey)({axes:st,keepDims:it})};const lt=(dt,st,it,ct,ft,ht)=>{const mt=[],pt=st[0].dims.length||1,_t=[],vt=rt.ShapeUtil.normalizeAxes(it.axes,st[0].dims.length),bt=ft(st,vt);let wt=bt[1];for(let Mt=0;Mt<st[0].dims.length;Mt++)vt.indexOf(Mt)>=0||vt.length===0?(it.keepDims&&mt.push(1),wt=`
          for(int j${Mt} = 0; j${Mt} < ${st[0].dims[Mt]}; j${Mt}++) {
            inputIdx[${Mt}] = j${Mt};
            ${wt}
          }`):(_t.push(`inputIdx[${Mt}] = outputIdx[${mt.length}];`),mt.push(st[0].dims[Mt]));const xt=`
      float process(int outputIdx[${mt.length||1}]) {
        float value;                 // final result
        int inputIdx[${pt}];      // addressing input data
        ${_t.join(`
`)}
        ${bt[0]}       // init ops for reduce max/min
        ${wt}
        ${bt[2]}       // final computation for reduce mean
        return value;
      }`;return Object.assign(Object.assign({},ht),{output:{dims:mt,type:st[0].type,textureType:ot.TextureType.unpacked},shaderSource:xt})},ut=dt=>{if(!dt||dt.length!==1)throw new Error("Reduce op requires 1 input.");if(nt.NUMBER_TYPES.indexOf(dt[0].type)===-1)throw new Error("Invalid input type.")};_.reduceSum=(dt,st,it)=>at(dt,st,it,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),_.reduceMean=(dt,st,it)=>at(dt,st,it,"ReduceMean",(ct,ft)=>{let ht=1;for(let mt=0;mt<ct[0].dims.length;mt++)(ft.indexOf(mt)>=0||ft.length===0)&&(ht*=ct[0].dims[mt]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${ht}.;`]}),_.reduceMax=(dt,st,it)=>at(dt,st,it,"ReduceMax",(ct,ft)=>{const ht=[];for(let mt=0;mt<ct[0].dims.length;mt++)(ft.indexOf(mt)>=0||ft.length===0)&&ht.push(`inputIdx[${mt}] = 0;`);return[`${ht.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),_.reduceMin=(dt,st,it)=>at(dt,st,it,"ReduceMin",(ct,ft)=>{const ht=[];for(let mt=0;mt<ct[0].dims.length;mt++)(ft.indexOf(mt)>=0||ft.length===0)&&ht.push(`inputIdx[${mt}] = 0;`);return[`${ht.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),_.reduceProd=(dt,st,it)=>at(dt,st,it,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),_.reduceLogSum=(dt,st,it)=>at(dt,st,it,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),_.reduceLogSumSquare=(dt,st,it)=>at(dt,st,it,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])},7019:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.isReshapeCheap=_.processDims3D=_.createPackedReshape3DProgramInfoLoader=void 0;const tt=_e(2517),nt=_e(5060),rt=_e(2039),ot=_e(2827);_.createPackedReshape3DProgramInfoLoader=(at,lt,ut)=>{const dt=(st=>({name:"Reshape (packed)",inputTypes:[rt.TextureType.packed],inputNames:["A"],cacheHint:`${st}`}))(ut);return Object.assign(Object.assign({},dt),{get:()=>((st,it,ct,ft)=>{const ht=it.dims,mt=ft;let pt="";for(let bt=0;bt<4;bt++){let wt="";switch(bt){case 0:wt="outputCoords = rc;";break;case 1:wt="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:wt="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:wt="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}pt+=`
        ${wt}
        ${bt>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${bt}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${bt>0?"}":""}
      `}const _t=(0,nt.getGlsl)(st.session.backend.glContext.version),vt=`
      ${function(bt){const wt=tt.ShapeUtil.computeStrides(bt),xt=["b","r","c"],Mt="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${wt.map((At,St)=>`int ${xt[St]} = ${Mt} / ${At}; ${St===wt.length-1?`int ${xt[St+1]} = ${Mt} - ${xt[St]} * ${At}`:`index -= ${xt[St]} * ${At}`};`).join("")}
      return ivec3(b, r, c);
    }
  `}(ht)}
      ${function(bt){const wt=tt.ShapeUtil.computeStrides(bt);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${wt[0]} + coords.z * ${wt[1]} + coords.y;
  }
`}(mt)}
      ${(0,ot.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${mt[2]};
        int cols = ${mt[1]};

        ${pt}
        ${_t.output} = result;
      }
    `;return Object.assign(Object.assign({},ct),{output:{dims:mt,type:it.type,textureType:rt.TextureType.packed},shaderSource:vt,hasMain:!0})})(at,lt,dt,ut)})},_.processDims3D=function(at){if(at.length===0)return[1,1,1];let lt=1;for(let ut=0;ut<at.length-2;++ut)lt*=at[ut];return[lt,at.length>1?at[at.length-2]:1,at[at.length-1]]},_.isReshapeCheap=function(at,lt){let ut=!1;return ut=at.length===0||lt.length===0||(at.length<2||lt.length<2?at[at.length-1]===lt[lt.length-1]:at[at.length-1]===lt[lt.length-1]&&at[at.length-2]===lt[lt.length-2]),ut}},718:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.reshape=void 0;const tt=_e(2517);_.reshape=(nt,rt)=>{const ot=tt.ShapeUtil.calculateReshapedDims(rt[0].dims,rt[1].integerData);return nt.session.pack?[nt.reshapePacked(rt[0],ot)]:[nt.reshapeUnpacked(rt[0],ot)]}},2268:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.parseResizeAttributesV11=_.parseResizeAttributesV10=_.resize=void 0;const tt=_e(5060),nt=_e(2039),rt=_e(9390),ot=_e(2827),at=_e(9793),lt={name:"Resize",inputNames:["A"],inputTypes:[nt.TextureType.packed]};_.resize=(ct,ft,ht)=>((0,at.validateInputs)(ft,ht),[ct.run(Object.assign(Object.assign({},lt),{cacheHint:ht.cacheKey,get:()=>ut(ct,ft,ht)}),ft)]),_.parseResizeAttributesV10=ct=>(0,at.parseUpsampleAttributes)(ct,10),_.parseResizeAttributesV11=ct=>(0,at.parseUpsampleAttributes)(ct,11);const ut=(ct,ft,ht)=>{const mt=(0,tt.getGlsl)(ct.session.backend.glContext.version),[pt,_t]=dt(ft,ht);if(pt.every(Nt=>Nt===1)&&ht.coordinateTransformMode!=="tf_crop_and_resize")return Object.assign(Object.assign({},lt),{output:{dims:_t,type:ft[0].type,textureType:nt.TextureType.packed},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${mt.texture2D}(X, TexCoords);
                    ${mt.output} = v;
                }`});const vt=_t.length;if(vt<2)throw new Error(`output dimension should be at least 2, but got ${vt}`);const bt=_t[vt-2],wt=_t[vt-1],xt=ft[0].dims;if(vt!==xt.length)throw new Error(`output dimension should match input ${xt.length}, but got ${vt}`);const Mt=xt[vt-2],At=xt[vt-1],St=pt[vt-2],Tt=pt[vt-1];let Ct="";if(ht.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${ht.mode}'`);switch(ht.coordinateTransformMode){case"asymmetric":Ct=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":Ct=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":Ct=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${wt}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${bt}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${wt}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${bt}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":Ct=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${wt}.0 - 1.0, ${bt}.0 - 1.0, ${wt}.0 - 1.0,
                            ${bt}.0 - 1.0);
                        vec4 original = vec4(${At}.0 - 1.0, ${Mt}.0 - 1.0, ${At}.0 - 1.0,
                            ${Mt}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${ht.coordinateTransformMode}'`)}const It=(0,rt.getCoordsDataType)(vt),$t=`
            const vec2 inputWH = vec2(${Mt}.0, ${At}.0);
            const vec4 scaleWHWH = vec4(float(${St}), float(${Tt}), float(${St}), float(${Tt}));
            ${(0,ot.unpackFromChannel)()}
            ${Ct}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${It} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${bt-1};
                bool hasNextCol = rc.z < ${wt-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${mt.output} = vec4(newValue);
            }
        `;return Object.assign(Object.assign({},lt),{output:{dims:_t,type:ft[0].type,textureType:nt.TextureType.packed},hasMain:!0,shaderSource:$t})},dt=(ct,ft)=>{const ht=ct[0].dims;let mt,pt=ft.scales;if(pt.length===0){const vt=ct[ft.scalesInputIdx];if(vt&&vt.size!==0){if(ct[ft.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");pt=st(vt,ft.mode,ft.isResize)}else{const bt=ct[ft.sizesInputIdx];if(!bt||bt.size===0)throw new Error("Either scales or sizes MUST be provided as input.");mt=Array.from(bt.integerData),pt=it(mt,ht,ft.mode,ft.isResize)}}else if(ct[ft.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const _t=mt||ht.map((vt,bt)=>Math.floor(vt*pt[bt]));return[pt,_t]},st=(ct,ft,ht)=>{const mt=Array.from(ct.floatData);return(0,at.scalesValidation)(mt,ft,ht),mt},it=(ct,ft,ht,mt)=>{const pt=ft.length,_t=new Array(pt);for(let vt=0,bt=pt;vt<bt;vt++)if(ft[vt]===0){if(ct[vt]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");_t[vt]=1}else _t[vt]=ct[vt]/ft[vt];return(0,at.scalesValidation)(_t,ht,mt),_t}},8117:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.shape=void 0;const tt=_e(9162);_.shape=(rt,ot)=>(nt(ot),[new tt.Tensor([ot[0].dims.length],"int32",void 0,void 0,new Int32Array(ot[0].dims))]);const nt=rt=>{if(!rt||rt.length!==1)throw new Error("Shape requires 1 input.")}},2278:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.sliceV10=_.parseSliceAttributes=_.slice=void 0;const tt=_e(246),nt=_e(782),rt=_e(2517),ot=_e(2039),at={name:"Slice",inputNames:["A"],inputTypes:[ot.TextureType.unpacked]};_.slice=(it,ct,ft)=>(ut(ct),[it.run(Object.assign(Object.assign({},at),{cacheHint:ft.cacheKey,get:()=>lt(it,ct[0],ft)}),ct)]),_.parseSliceAttributes=it=>{const ct=it.attributes.getInts("starts"),ft=it.attributes.getInts("ends"),ht=it.attributes.getInts("axes",[]);return(0,tt.createAttributeWithCacheKey)({starts:ct,ends:ft,axes:ht})};const lt=(it,ct,ft)=>{const ht=ft.axes.length===0?ct.dims.slice(0).map((xt,Mt)=>Mt):ft.axes,mt=rt.ShapeUtil.normalizeAxes(ht,ct.dims.length),pt=ft.starts.map((xt,Mt)=>xt>ct.dims[mt[Mt]]-1?ct.dims[mt[Mt]]:rt.ShapeUtil.normalizeAxis(xt,ct.dims[mt[Mt]])),_t=ft.ends.map((xt,Mt)=>xt>ct.dims[mt[Mt]]-1?ct.dims[mt[Mt]]:rt.ShapeUtil.normalizeAxis(xt,ct.dims[mt[Mt]])),vt=ct.dims.slice(),bt=[];for(let xt=0;xt<mt.length;xt++)vt[mt[xt]]=_t[xt]-pt[xt],pt[xt]>0&&bt.push(`outputIdx[${mt[xt]}] += ${pt[xt]};`);const wt=`
      float process(int outputIdx[${vt.length}]) {
        ${bt.join(`
      `)}
        return _A(outputIdx);
      }`;return Object.assign(Object.assign({},at),{output:{dims:vt,type:ct.type,textureType:ot.TextureType.unpacked},shaderSource:wt})},ut=it=>{if(!it||it.length!==1)throw new Error("Slice requires 1 input.");if(nt.NUMBER_TYPES.indexOf(it[0].type)===-1)throw new Error("Invalid input type.")};_.sliceV10=(it,ct)=>{st(ct);const ft=dt(it,ct);return[it.run(Object.assign(Object.assign({},at),{cacheHint:ft.cacheKey,get:()=>lt(it,ct[0],ft)}),[ct[0]])]};const dt=(it,ct)=>{if(!it.session.isInitializer(ct[1].dataId)||!it.session.isInitializer(ct[2].dataId)||ct.length>=4&&!it.session.isInitializer(ct[3].dataId)||ct.length>=5&&!it.session.isInitializer(ct[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(ct.length>=5&&ct[4].integerData.some(pt=>pt!==1))throw new Error("currently non-1 steps is not supported for Slice");const ft=Array.from(ct[1].integerData),ht=Array.from(ct[2].integerData),mt=ct.length>=4?Array.from(ct[3].integerData):[];return{starts:ft,ends:ht,axes:mt,cacheKey:`${mt};${ft};${ht}`}},st=it=>{if(!it||it.length<3||it.length>5)throw new Error("Invalid input number.");if(it[1].type!=="int32"||it[1].dims.length!==1)throw new Error("Invalid input type.");if(it[2].type!=="int32"||it[2].dims.length!==1)throw new Error("Invalid input type.");if(it.length>=4&&(it[3].type!=="int32"||it[3].dims.length!==1))throw new Error("Invalid input type.");if(it.length>=5&&(it[4].type!=="int32"||it[4].dims.length!==1))throw new Error("Invalid input type.")}},5524:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.softmaxV13=_.parseSoftmaxAttributesV13=_.parseSoftmaxAttributes=_.softmax=void 0;const tt=_e(246),nt=_e(2517),rt=_e(5060),ot=_e(2039),at=_e(3738),lt={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[ot.TextureType.unpacked]},ut={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[ot.TextureType.unpacked,ot.TextureType.unpacked]},dt={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[ot.TextureType.unpacked,ot.TextureType.unpacked,ot.TextureType.unpacked]};_.softmax=(mt,pt,_t)=>{ht(pt);const vt=pt[0].dims.slice(),bt=nt.ShapeUtil.normalizeAxis(_t.axis,vt.length),wt=nt.ShapeUtil.sizeToDimension(vt,bt),xt=nt.ShapeUtil.sizeFromDimension(vt,bt);return st(mt,pt,_t,wt,xt)},_.parseSoftmaxAttributes=mt=>(0,tt.createAttributeWithCacheKey)({axis:mt.attributes.getInt("axis",1)}),_.parseSoftmaxAttributesV13=mt=>(0,tt.createAttributeWithCacheKey)({axis:mt.attributes.getInt("axis",-1)}),_.softmaxV13=(mt,pt,_t)=>{ht(pt);const vt=pt[0].dims.slice(),bt=nt.ShapeUtil.normalizeAxis(_t.axis,vt.length),wt=vt.length,xt=bt!==wt-1,Mt=[];let At,St=[],Tt=[];xt&&(St=Array.from({length:wt}).map((Nt,Bt)=>Bt),St[bt]=wt-1,St[wt-1]=bt,St.map(Nt=>Mt.push(vt[Nt])),At=(0,tt.createAttributeWithCacheKey)({perm:St}),Tt=(0,at.transpose)(mt,pt,At));const Ct=xt?nt.ShapeUtil.sizeToDimension(Mt,wt-1):nt.ShapeUtil.sizeToDimension(vt,wt-1),It=xt?nt.ShapeUtil.sizeFromDimension(Mt,wt-1):nt.ShapeUtil.sizeFromDimension(vt,wt-1),$t=st(mt,xt?Tt:pt,_t,Ct,It);return xt?(0,at.transpose)(mt,$t,At):$t};const st=(mt,pt,_t,vt,bt)=>{const wt=it(mt,pt[0],vt,bt,[vt]),xt=mt.run(Object.assign(Object.assign({},lt),{cacheHint:_t.cacheKey,get:()=>wt}),pt),Mt=ct(mt,pt[0],vt,bt,wt.output.dims,[vt]),At=mt.run(Object.assign(Object.assign({},ut),{cacheHint:_t.cacheKey,get:()=>Mt}),[pt[0],xt]),St=ft(mt,pt[0],vt,bt,wt.output.dims,Mt.output.dims);return[mt.run(Object.assign(Object.assign({},dt),{cacheHint:_t.cacheKey,get:()=>St}),[pt[0],xt,At])]},it=(mt,pt,_t,vt,bt)=>{const[wt,xt]=mt.calculateTextureWidthAndHeight(pt.dims,ot.TextureType.unpacked),Mt=bt.length;if(_t<1||vt<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(bt.length!==1)throw new Error("Dimensionality of the output should be 1");if(bt[0]!==_t)throw new Error("Shape of the output should be equal to logical row count");const At=(0,rt.getGlsl)(mt.session.backend.glContext.version),St=`
      float process(int[${Mt}] indices) {
        int logical_row_start_offset = indices[0] * ${vt};

        float max = getColorAsFloat(${At.texture2D}(A, offsetToCoords(logical_row_start_offset, ${wt},
        ${xt} )));
        for(int i=1; i<${vt}; ++i)
        {
          float current = getColorAsFloat(${At.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${wt}, ${xt})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return Object.assign(Object.assign({},lt),{output:{dims:bt,type:pt.type,textureType:ot.TextureType.unpacked},shaderSource:St})},ct=(mt,pt,_t,vt,bt,wt)=>{const[xt,Mt]=mt.calculateTextureWidthAndHeight(pt.dims,ot.TextureType.unpacked),At=wt.length;if(_t<1||vt<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(wt.length!==1)throw new Error("Dimensionality of the output should be 1");if(wt[0]!==_t)throw new Error("Shape of the output should be equal to logical row count");if(bt.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(bt[0]!==_t)throw new Error("Shape of the intermediate results should be equal to logical row count");const St=`
      float process(int[${At}] indices) {
        int logical_row_start_offset = indices[0] * ${vt};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${vt}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0,rt.getGlsl)(mt.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${xt}, ${Mt}))) - max);
        }

        return norm_factor;
      }`;return Object.assign(Object.assign({},ut),{output:{dims:wt,type:pt.type,textureType:ot.TextureType.unpacked},shaderSource:St})},ft=(mt,pt,_t,vt,bt,wt)=>{const[xt,Mt]=mt.calculateTextureWidthAndHeight(pt.dims,ot.TextureType.unpacked),At=pt.dims.length;if(_t<1||vt<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(bt.length!==1||wt.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(bt[0]!==_t||wt[0]!==_t)throw new Error("Shape of the intermediate results should be equal to logical row count");const St=`
      float process(int[${At}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${xt}, ${Mt});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${vt};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return Object.assign(Object.assign({},dt),{output:{dims:pt.dims,type:pt.type,textureType:ot.TextureType.unpacked},shaderSource:St})},ht=mt=>{if(!mt||mt.length!==1)throw new Error("Softmax requires 1 input.");if(mt[0].type!=="float32"&&mt[0].type!=="float64")throw new Error("Invalid input type")}},5975:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.parseSplitAttributes=_.split=void 0;const tt=_e(246),nt=_e(2517),rt=_e(2039),ot={name:"Split",inputNames:["A"],inputTypes:[rt.TextureType.unpacked]};_.split=(dt,st,it)=>{ut(st);const ct=nt.ShapeUtil.normalizeAxis(it.axis,st[0].dims.length),ft=at(dt,st,ct,it),ht=[];for(let mt=0;mt<ft;++mt)ht.push(dt.run(Object.assign(Object.assign({},ot),{cacheHint:`${it.cacheKey};${mt}`,get:()=>lt(dt,st[0],it,ct,mt)}),st));return ht},_.parseSplitAttributes=dt=>{const st=dt.attributes.getInt("axis",0),it=dt.attributes.getInts("split",[]),ct=dt.outputs.length;return(0,tt.createAttributeWithCacheKey)({axis:st,split:it,numOutputs:ct})};const at=(dt,st,it,ct)=>{const[,ft]=nt.SplitUtil.splitShape(st[0].dims,it,ct.split,ct.numOutputs);return ft.length},lt=(dt,st,it,ct,ft)=>{const[ht,mt]=nt.SplitUtil.splitShape(st.dims,ct,it.split,it.numOutputs),pt=mt[ft],_t=ht[ft],vt=`
      float process(int indices[${_t.length}]) {
        indices[${ct}] += ${pt};
        return _A(indices);
      }
    `;return Object.assign(Object.assign({},ot),{cacheHint:`${it.cacheKey}:${ft}`,output:{dims:_t,type:st.type,textureType:rt.TextureType.unpacked},shaderSource:vt})},ut=dt=>{if(!dt||dt.length!==1)throw new Error("Split requires one input.");if(dt[0].type!=="int8"&&dt[0].type!=="uint8"&&dt[0].type!=="int16"&&dt[0].type!=="uint16"&&dt[0].type!=="int32"&&dt[0].type!=="uint32"&&dt[0].type!=="float32"&&dt[0].type!=="float64"&&dt[0].type!=="bool")throw new Error("Invalid input type.")}},3933:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.parseSqueezeAttributes=_.squeezeV13=_.squeeze=void 0;const tt=_e(2517);_.squeeze=(ot,at,lt)=>{nt(at);const ut=tt.ShapeUtil.squeezeShape(at[0].dims,lt);return[ot.reshapeUnpacked(at[0],ut)]},_.squeezeV13=(ot,at)=>(rt(at),(0,_.squeeze)(ot,[at[0]],Array.from(at[1].integerData))),_.parseSqueezeAttributes=ot=>ot.attributes.getInts("axes");const nt=ot=>{if(!ot||ot.length!==1)throw new Error("Squeeze requires 1 input.");if(ot[0].type==="string")throw new Error("invalid input tensor types.")},rt=ot=>{if(!ot||ot.length!==2)throw new Error("Squeeze requires 2 inputs.");if(ot[1].type!=="int32")throw new Error("Invalid input type.")}},6558:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.sum=void 0;const tt=_e(5060),nt=_e(2039);_.sum=(at,lt)=>{ot(lt);const ut={name:"Sum",inputNames:lt.map((dt,st)=>`X${st}`),inputTypes:new Array(lt.length).fill(nt.TextureType.unpacked)};return[at.run(Object.assign(Object.assign({},ut),{get:()=>rt(at,lt,ut)}),lt)]};const rt=(at,lt,ut)=>{const dt=(0,tt.getGlsl)(at.session.backend.glContext.version),st=lt[0].dims.slice(),it=`
      void main() {
        vec4 result = ${lt.map((ct,ft)=>`${dt.texture2D}(X${ft},TexCoords)`).join(" + ")};
        ${dt.output} = result;
      }
    `;return Object.assign(Object.assign({},ut),{output:{dims:st,type:lt[0].type,textureType:nt.TextureType.unpacked},hasMain:!0,shaderSource:it})},ot=at=>{if(!at||at.length===0)throw new Error("Sum requires inputs.");const lt=at[0].dims.length;for(let ut=1;ut<at.length;ut++){if(lt!==at[ut].dims.length)throw new Error("Input shapes are mismatched.");for(let dt=0;dt<lt;dt++)if(at[0].dims[dt]!==at[ut].dims[dt])throw new Error("Input shapes are not matched.")}if(at[0].type!=="float32"&&at[0].type!=="float64")throw new Error("Invalid input type.");for(let ut=1;ut<at.length;ut++)if(at[0].type!==at[ut].type)throw new Error("Input types are not matched.")}},5723:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.tile=void 0;const tt=_e(782),nt=_e(2039);_.tile=(at,lt)=>{ot(lt);const ut={name:"Tile",inputNames:["A"],inputTypes:[nt.TextureType.unpacked]};return[at.run(Object.assign(Object.assign({},ut),{get:()=>rt(at,lt,ut)}),lt)]};const rt=(at,lt,ut)=>{const dt=lt[0].dims.slice(),st=new Array(dt.length),it=[];for(let ht=0;ht<dt.length;ht++)st[ht]=dt[ht]*lt[1].numberData[ht],it.push(`inputIdx[${ht}] = int(mod(float(outputIdx[${ht}]), ${dt[ht]}.));`);const ct=st.length,ft=`
      float process(int outputIdx[${ct}]) {
        int inputIdx[${ct}];
        ${it.join(`
`)}
        return _A(inputIdx);
      }
    `;return Object.assign(Object.assign({},ut),{output:{dims:st,type:lt[0].type,textureType:nt.TextureType.unpacked},shaderSource:ft})},ot=at=>{if(!at||at.length!==2)throw new Error("Tile requires 2 input.");if(at[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(at[1].dims[0]!==at[0].dims.length)throw new Error("Invalid input shape.");if(tt.NUMBER_TYPES.indexOf(at[0].type)===-1)throw new Error("Invalid input type.");if(at[1].type!=="int32"&&at[1].type!=="int16")throw new Error("Invalid repeat type.")}},3738:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.parseTransposeAttributes=_.transpose=void 0;const tt=_e(246),nt=_e(2517),rt=_e(2039),ot={name:"Transpose",inputNames:["A"],inputTypes:[rt.TextureType.unpacked]};_.transpose=(it,ct,ft)=>(st(ct),[it.run(Object.assign(Object.assign({},ot),{cacheHint:ft.cacheKey,get:()=>at(it,ct[0],ft.perm)}),ct)]),_.parseTransposeAttributes=it=>(0,tt.createAttributeWithCacheKey)({perm:it.attributes.getInts("perm",[])});const at=(it,ct,ft)=>{const ht=ct.dims;ft=lt(ht,ft);const mt=ut(ht,ft),pt=ht.length,_t=`
      ${dt("perm",ft,pt)}
      float process(int indices[${pt}]) {
        int a[${pt}];
        perm(a, indices);
        return _A(a);
      }`;return Object.assign(Object.assign({},ot),{output:{dims:mt,type:ct.type,textureType:rt.TextureType.unpacked},shaderSource:_t})},lt=(it,ct)=>(ct&&ct.length!==it.length&&(ct=[...it.keys()].reverse()),ct),ut=(it,ct)=>(ct=lt(it,ct),nt.ShapeUtil.sortBasedOnPerm(it,ct)),dt=(it,ct,ft)=>{const ht=[];ht.push(`void ${it}(out int a[${ft}], int src[${ft}]) {`);for(let mt=0;mt<ft;++mt)ht.push(`	a[${ct[mt]}]=src[${mt}];`);return ht.push("	}"),ht.join(`
`)},st=it=>{if(!it||it.length!==1)throw new Error("Transpose requires 1 input.");if(it[0].type!=="float32"&&it[0].type!=="float64")throw new Error("input should be float tensor")}},8710:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.encodeAsUint8=void 0;const tt=_e(5060),nt=_e(2039);_.encodeAsUint8=(rt,ot)=>{const at=ot.shape,lt=(0,tt.getGlsl)(rt.session.backend.glContext.version),ut=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${lt.texture2D}(X,TexCoords).r;
      ${lt.output} = encodeAsUint8(value);
    }`,dt={name:"Uint8Encode",inputTypes:[nt.TextureType.unpacked],inputNames:["X"],output:{dims:at,type:ot.tensor.type,textureType:nt.TextureType.downloadUint8AsFloat},shaderSource:ut,hasMain:!0};return rt.executeProgram(dt,[ot.tensor])}},4909:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.tanh=_.tan=_.sqrt=_.sin=_.sigmoid=_.relu=_.not=_.neg=_.log=_.parseLeakyReluAttributes=_.leakyRelu=_.identity=_.floor=_.exp=_.parseEluAttributes=_.elu=_.cos=_.ceil=_.clipV11=_.parseClipAttributes=_.clip=_.atan=_.asin=_.acos=_.abs=_.glslTanh=_.glslTan=_.glslSqrt=_.glslSigmoid=_.glslRelu=_.glslSin=_.glslNot=_.glslNeg=_.glslLog=_.glslLeakyRelu=_.glslIdentity=_.glslClip=_.glslFloor=_.glslExp=_.glslElu=_.glslCos=_.glslCeil=_.glslAtan=_.glslAsin=_.glslAcos=_.glslAbs=void 0;const tt=_e(246),nt=_e(2517),rt=_e(8520),ot=_e(5060),at=_e(2039);function lt(){return $t("abs")}function ut(){return $t("acos")}function dt(){return $t("asin")}function st(){return $t("atan")}function it(){return $t("ceil")}function ct(){return $t("cos")}function ft(Ot){const Ut="elu";return{body:`
  const float alpha = float(${Ot});

  float ${Ut}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${Ut}_(vec4 v) {
    return vec4(${Ut}_(v.x), ${Ut}_(v.y), ${Ut}_(v.z), ${Ut}_(v.w));
  }
  `,name:Ut,type:rt.FunctionType.ValueBased}}function ht(){return $t("exp")}function mt(){return $t("floor")}function pt(Ot,Ut){const Lt="clip";return{body:`
  const float min = float(${Ot});
  const float max = float(${Ut});

  float ${Lt}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${Lt}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:Lt,type:rt.FunctionType.ValueBased}}function _t(){const Ot="indentity";return{body:`
  float ${Ot}_(float a) {
    return a;
  }
  vec4 ${Ot}_(vec4 v) {
    return v;
  }
  `,name:Ot,type:rt.FunctionType.ValueBased}}function vt(Ot){const Ut="leakyRelu";return{body:`
  const float alpha = float(${Ot});

  float ${Ut}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${Ut}_(vec4 v) {
    return vec4(${Ut}_(v.x), ${Ut}_(v.y), ${Ut}_(v.z), ${Ut}_(v.w));
  }
  `,name:Ut,type:rt.FunctionType.ValueBased}}function bt(){return $t("log")}function wt(){const Ot="neg";return{body:`
  float ${Ot}_(float a) {
    return -a;
  }
  vec4 ${Ot}_(vec4 v) {
    return -v;
  }
  `,name:Ot,type:rt.FunctionType.ValueBased}}function xt(){const Ot="not";return{body:`
  float ${Ot}_(float a) {
    return float( ! bool(a) );
  }
  bool ${Ot}_(bool a) {
    return !a;
  }
  vec4 ${Ot}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${Ot}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:Ot,type:rt.FunctionType.ValueBased}}function Mt(){return $t("sin")}function At(){const Ot="relu";return{body:`
  float ${Ot}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${Ot}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:Ot,type:rt.FunctionType.ValueBased}}function St(){const Ot="sigmoid";return{body:`
  float ${Ot}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${Ot}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:Ot,type:rt.FunctionType.ValueBased}}function Tt(){return $t("sqrt")}function Ct(){return $t("tan")}function It(){const Ot="tanh";return{body:`
  float ${Ot}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${Ot}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:Ot,type:rt.FunctionType.ValueBased}}function $t(Ot){return{body:`
  float ${Ot}_(float a) {
    return ${Ot}(a);
  }
  vec4 ${Ot}_(vec4 v) {
    return ${Ot}(v);
  }
  `,name:Ot,type:rt.FunctionType.ValueBased}}_.glslAbs=lt,_.glslAcos=ut,_.glslAsin=dt,_.glslAtan=st,_.glslCeil=it,_.glslCos=ct,_.glslElu=ft,_.glslExp=ht,_.glslFloor=mt,_.glslClip=pt,_.glslIdentity=_t,_.glslLeakyRelu=vt,_.glslLog=bt,_.glslNeg=wt,_.glslNot=xt,_.glslSin=Mt,_.glslRelu=At,_.glslSigmoid=St,_.glslSqrt=Tt,_.glslTan=Ct,_.glslTanh=It;const Nt=(Ot,Ut,Lt,zt)=>{const Yt=Ot.session.pack?at.TextureType.packed:at.TextureType.unpacked,en={name:Lt.name,inputTypes:[Yt],inputNames:["A"],cacheHint:zt};return Object.assign(Object.assign({},en),{get:()=>((bn,Un,mn,vn)=>{const In=bn.session.pack?at.TextureType.packed:at.TextureType.unpacked,Cn=(0,ot.getGlsl)(bn.session.backend.glContext.version);return Object.assign(Object.assign({},Un),{output:{dims:mn.dims,type:mn.type,textureType:In},shaderSource:`
     ${vn.body}
     void main() {
       vec4 v = ${Cn.texture2D}(A, TexCoords);
       v = ${vn.name}_(v);
       ${Cn.output} = v;
     }
     `,hasMain:!0})})(Ot,en,Ut,Lt)})};_.abs=(Ot,Ut)=>[Ot.run(Nt(Ot,Ut[0],lt()),Ut)],_.acos=(Ot,Ut)=>[Ot.run(Nt(Ot,Ut[0],ut()),Ut)],_.asin=(Ot,Ut)=>[Ot.run(Nt(Ot,Ut[0],dt()),Ut)],_.atan=(Ot,Ut)=>[Ot.run(Nt(Ot,Ut[0],st()),Ut)],_.clip=(Ot,Ut,Lt)=>[Ot.run(Nt(Ot,Ut[0],pt(Lt.min,Lt.max),Lt.cacheKey),Ut)],_.parseClipAttributes=Ot=>(0,tt.createAttributeWithCacheKey)({min:Ot.attributes.getFloat("min",nt.MIN_CLIP),max:Ot.attributes.getFloat("max",nt.MAX_CLIP)}),_.clipV11=(Ot,Ut)=>{const Lt=Bt(Ot,Ut);return(0,_.clip)(Ot,[Ut[0]],Lt)};const Bt=(Ot,Ut)=>{if(Ut.length>=3&&(!Ot.session.isInitializer(Ut[1].dataId)||!Ot.session.isInitializer(Ut[2].dataId)))throw new Error("dynamic clip attributes are not allowed");const Lt=Ut.length>=3?Ut[1].numberData[0]:nt.MIN_CLIP,zt=Ut.length>=3?Ut[2].numberData[0]:nt.MAX_CLIP;return(0,tt.createAttributeWithCacheKey)({min:Lt,max:zt})};_.ceil=(Ot,Ut)=>[Ot.run(Nt(Ot,Ut[0],it()),Ut)],_.cos=(Ot,Ut)=>[Ot.run(Nt(Ot,Ut[0],ct()),Ut)],_.elu=(Ot,Ut,Lt)=>[Ot.run(Nt(Ot,Ut[0],ft(Lt.alpha),Lt.cacheKey),Ut)],_.parseEluAttributes=Ot=>(0,tt.createAttributeWithCacheKey)({alpha:Ot.attributes.getFloat("alpha",1)}),_.exp=(Ot,Ut)=>[Ot.run(Nt(Ot,Ut[0],ht()),Ut)],_.floor=(Ot,Ut)=>[Ot.run(Nt(Ot,Ut[0],mt()),Ut)],_.identity=(Ot,Ut)=>[Ot.run(Nt(Ot,Ut[0],_t()),Ut)],_.leakyRelu=(Ot,Ut,Lt)=>[Ot.run(Nt(Ot,Ut[0],vt(Lt.alpha),Lt.cacheKey),Ut)],_.parseLeakyReluAttributes=Ot=>(0,tt.createAttributeWithCacheKey)({alpha:Ot.attributes.getFloat("alpha",.01)}),_.log=(Ot,Ut)=>[Ot.run(Nt(Ot,Ut[0],bt()),Ut)],_.neg=(Ot,Ut)=>[Ot.run(Nt(Ot,Ut[0],wt()),Ut)],_.not=(Ot,Ut)=>[Ot.run(Nt(Ot,Ut[0],xt()),Ut)],_.relu=(Ot,Ut)=>[Ot.run(Nt(Ot,Ut[0],At()),Ut)],_.sigmoid=(Ot,Ut)=>[Ot.run(Nt(Ot,Ut[0],St()),Ut)],_.sin=(Ot,Ut)=>[Ot.run(Nt(Ot,Ut[0],Mt()),Ut)],_.sqrt=(Ot,Ut)=>[Ot.run(Nt(Ot,Ut[0],Tt()),Ut)],_.tan=(Ot,Ut)=>[Ot.run(Nt(Ot,Ut[0],Ct()),Ut)],_.tanh=(Ot,Ut)=>[Ot.run(Nt(Ot,Ut[0],It()),Ut)]},5611:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.createUnpackProgramInfoLoader=_.createUnpackProgramInfo=void 0;const tt=_e(5060),nt=_e(2039),rt=_e(9390),ot=_e(2827),at={name:"unpack",inputNames:["A"],inputTypes:[nt.TextureType.packed]};_.createUnpackProgramInfo=(lt,ut)=>{const dt=ut.dims.length,st=(0,ot.getChannels)("rc",dt),it=st.slice(-2),ct=(0,rt.getCoordsDataType)(dt),ft=(0,ot.unpackFromChannel)(),ht=ut.dims.length===0?"":function(_t,vt){if(_t===1)return"rc";let bt="";for(let wt=0;wt<_t;wt++)bt+=vt[wt],wt<_t-1&&(bt+=",");return bt}(dt,st),mt=dt<=1?"rc":`vec2(${it.join(",")})`,pt=`
    ${ft}
    void main() {
      ${ct} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${ht});

       ${(0,tt.getGlsl)(lt.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${mt}), 0, 0, 0);
     }
   `;return Object.assign(Object.assign({},at),{hasMain:!0,output:{dims:ut.dims,type:ut.type,textureType:nt.TextureType.unpacked},shaderSource:pt})},_.createUnpackProgramInfoLoader=(lt,ut)=>Object.assign(Object.assign({},at),{get:()=>(0,_.createUnpackProgramInfo)(lt,ut)})},8428:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.parseUnsqueezeAttributes=_.unsqueezeV13=_.unsqueeze=void 0;const tt=_e(2517);_.unsqueeze=(ot,at,lt)=>{nt(at);const ut=tt.ShapeUtil.unsqueezeShape(at[0].dims,lt);return[ot.reshapeUnpacked(at[0],ut)]},_.unsqueezeV13=(ot,at)=>(rt(at),(0,_.unsqueeze)(ot,[at[0]],Array.from(at[1].integerData))),_.parseUnsqueezeAttributes=ot=>ot.attributes.getInts("axes");const nt=ot=>{if(!ot||ot.length!==1)throw new Error("Unsqueeze requires 1 input.");if(ot[0].type==="string")throw new Error("invalid input tensor types.")},rt=ot=>{if(!ot||ot.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(ot[1].type!=="int32")throw new Error("Invalid input type.")}},9793:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.scalesValidation=_.validateInputs=_.parseUpsampleAttributes=_.parseUpsampleAttributesV9=_.parseUpsampleAttributesV7=_.upsample=void 0;const tt=_e(246),nt=_e(5060),rt=_e(2039),ot={name:"Upsample",inputNames:["X"],inputTypes:[rt.TextureType.unpacked]};_.upsample=(lt,ut,dt)=>((0,_.validateInputs)(ut,dt),[lt.run(Object.assign(Object.assign({},ot),{cacheHint:dt.cacheKey,get:()=>at(lt,ut,dt)}),ut)]),_.parseUpsampleAttributesV7=lt=>(0,_.parseUpsampleAttributes)(lt,7),_.parseUpsampleAttributesV9=lt=>(0,_.parseUpsampleAttributes)(lt,9),_.parseUpsampleAttributes=(lt,ut)=>{const dt=ut>=10,st=lt.attributes.getString("mode","nearest");if(st!=="nearest"&&st!=="linear"&&(ut<11||st!=="cubic"))throw new Error(`unrecognized mode: ${st}`);let it=[];ut<9&&(it=lt.attributes.getFloats("scales"),(0,_.scalesValidation)(it,st,dt));const ct=lt.attributes.getFloat("extrapolation_value",0),ft=ut>10?lt.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(ft)===-1)throw new Error(`coordinate_transform_mode '${ft}' is not supported`);const ht=ft==="tf_crop_and_resize",mt=ht,pt=st==="nearest"&&ut>=11?lt.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(pt)===-1)throw new Error(`nearest_mode '${pt}' is not supported`);const _t=lt.attributes.getFloat("cubic_coeff_a",-.75),vt=lt.attributes.getInt("exclude_outside",0)!==0;if(vt&&st!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");const bt=ut<11||st==="nearest"&&ft==="asymmetric"&&pt==="floor";let wt=0,xt=0,Mt=0;return ut>10?lt.inputs.length>2?(wt=1,xt=2,Mt=3):(xt=1,Mt=2):ut===9&&(xt=1),(0,tt.createAttributeWithCacheKey)({opset:ut,isResize:dt,mode:st,scales:it,extrapolationValue:ct,coordinateTransformMode:ft,useExtrapolation:mt,needRoiInput:ht,nearestMode:pt,cubicCoefficientA:_t,excludeOutside:vt,useNearest2xOptimization:bt,roiInputIdx:wt,scalesInputIdx:xt,sizesInputIdx:Mt})};const at=(lt,ut,dt)=>{const st=(0,nt.getGlsl)(lt.session.backend.glContext.version),[it,ct]=lt.calculateTextureWidthAndHeight(ut[0].dims,rt.TextureType.unpacked),ft=ut[0].dims.map((Mt,At)=>Math.floor(Mt*dt.scales[At])),[ht,mt]=lt.calculateTextureWidthAndHeight(ft,rt.TextureType.unpacked),pt=ft.length,_t=new Array(pt),vt=new Array(pt);let bt=`
      int output_pitches[${pt}];
      int input_pitches[${pt}];
      `;for(let Mt=pt-1;Mt>=0;Mt--)_t[Mt]=Mt===pt-1?1:_t[Mt+1]*ft[Mt+1],vt[Mt]=Mt===pt-1?1:vt[Mt+1]*ut[0].dims[Mt+1],bt+=`
        output_pitches[${Mt}] = ${_t[Mt]};
        input_pitches[${Mt}] = ${vt[Mt]};
        `;const wt=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${it}, ${ct});
        float value = getColorAsFloat(${st.texture2D}(X, coords));
        return value;
      }
      `,xt=dt.mode==="nearest"?`
    ${wt}
    float process(int indices[${pt}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${ht}, ${mt});

      ${bt}

      int d, m;
      for (int dim = 0; dim < ${pt}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:pt===4?`
    ${wt}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${ht}, ${mt});

      ${bt}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${ut[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${wt}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${ht}, ${mt});

      ${bt}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${ut[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return Object.assign(Object.assign({},ot),{output:{dims:ft,type:ut[0].type,textureType:rt.TextureType.unpacked},shaderSource:xt,variables:[{name:"scales",type:"int",arrayLength:dt.scales.length,data:dt.scales.map(Mt=>Math.ceil(Mt))}]})};_.validateInputs=(lt,ut)=>{if(!lt||ut.opset<9&&lt.length!==1||ut.opset>=9&&ut.opset<11&&lt.length!==2||ut.opset>=11&&lt.length<2)throw new Error("invalid inputs.");if(ut.scales.length>0&&lt[0].dims.length!==ut.scales.length)throw new Error("Invalid input shape.");if(lt[0].type==="string")throw new Error("Invalid input tensor types.")},_.scalesValidation=(lt,ut,dt)=>{if(dt){for(const st of lt)if(st<=0)throw new Error("Scale value should be greater than 0.")}else for(const st of lt)if(st<1)throw new Error("Scale value should be greater than or equal to 1.");if(!(ut!=="linear"&&ut!=="cubic"||lt.length===2||lt.length===4&&lt[0]===1&&lt[1]===1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${dt?"Resize":"Upsample"} opeartor.`)}},1958:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.ProgramManager=void 0;const tt=_e(1670),nt=_e(6231),rt=_e(8879),ot=_e(5060);_.ProgramManager=class{constructor(at,lt,ut){this.profiler=at,this.glContext=lt,this.textureLayoutStrategy=ut,this.repo=new Map,this.attributesBound=!1}getArtifact(at){return this.repo.get(at)}setArtifact(at,lt){this.repo.set(at,lt)}run(at,lt,ut){var dt;this.profiler.event("op",`ProgramManager.run ${(dt=at.programInfo.name)!==null&&dt!==void 0?dt:"unknown kernel"}`,()=>{var st;const it=this.glContext.gl,ct=at.program;it.useProgram(ct);try{this.bindOutput(ut),this.attributesBound||this.bindAttributes(at.attribLocations),this.bindUniforms(at.uniformLocations,(st=at.programInfo.variables)!==null&&st!==void 0?st:[],lt)}catch(ft){throw nt.Logger.error("ProgramManager",at.programInfo.shaderSource),ft}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(at=>this.glContext.deleteProgram(at.program))}build(at,lt,ut){return this.profiler.event("backend","ProgramManager.build",()=>{const dt=new rt.GlslPreprocessor(this.glContext,at,lt,ut),st=dt.preprocess(),it=this.compile(st);return{programInfo:at,program:it,uniformLocations:this.getUniformLocations(it,dt.context.programInfo.inputNames,dt.context.programInfo.variables),attribLocations:this.getAttribLocations(it)}})}compile(at){if(!this.vertexShader){nt.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const dt=(0,ot.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(dt,this.glContext.gl.VERTEX_SHADER)}tt.env.debug&&nt.Logger.verbose("ProrgramManager",`FragShader:
${at}
`);const lt=this.glContext.compileShader(at,this.glContext.gl.FRAGMENT_SHADER),ut=this.glContext.createProgram(this.vertexShader,lt);return this.glContext.deleteShader(lt),ut}bindOutput(at){const lt=at.width,ut=at.height;nt.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${lt}/${ut}, shape=${at.shape}, type=${at.tensor.type}`),this.glContext.attachFramebuffer(at.texture,lt,ut)}bindAttributes(at){const lt=at.position,ut=at.textureCoord;this.glContext.setVertexAttributes(lt,ut),this.attributesBound=!0}bindUniforms(at,lt,ut){var dt;const st=this.glContext.gl;let it=0;for(const{name:ct,type:ft,location:ht,arrayLength:mt}of at){const pt=(dt=lt.find(_t=>_t.name===ct))===null||dt===void 0?void 0:dt.data;if(ft!=="sampler2D"&&!pt)throw new Error(`variable '${ct}' does not have data defined in program info`);switch(ft){case"sampler2D":this.bindTexture(ut[it],ht,it),it++;break;case"float":mt?st.uniform1fv(ht,pt):st.uniform1f(ht,pt);break;case"int":mt?st.uniform1iv(ht,pt):st.uniform1i(ht,pt);break;default:throw new Error(`Uniform not implemented: ${ft}`)}}}bindTexture(at,lt,ut){this.glContext.bindTextureToUniform(at.texture,ut,lt)}getAttribLocations(at){return{position:this.getAttribLocation(at,"position"),textureCoord:this.getAttribLocation(at,"textureCoord")}}getUniformLocations(at,lt,ut){const dt=[];if(lt)for(const st of lt)dt.push({name:st,type:"sampler2D",location:this.getUniformLocation(at,st)});if(ut)for(const st of ut)dt.push(Object.assign(Object.assign({},st),{location:this.getUniformLocation(at,st.name)}));return dt}getUniformLocation(at,lt){const ut=this.glContext.gl.getUniformLocation(at,lt);if(ut===null)throw new Error(`Uniform ${lt} not found.`);return ut}getAttribLocation(at,lt){return this.glContext.gl.getAttribLocation(at,lt)}}},6416:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.WebGLSessionHandler=void 0;const tt=_e(6231),nt=_e(1047),rt=_e(8316),ot=_e(1640),at=_e(1958),lt=_e(7859),ut=_e(5702);_.WebGLSessionHandler=class{constructor(dt,st){this.backend=dt,this.context=st,this.layoutStrategy=new lt.PreferLogicalStrategy(dt.glContext.maxTextureSize),this.programManager=new at.ProgramManager(this.context.profiler,dt.glContext,this.layoutStrategy),this.textureManager=new ut.TextureManager(dt.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:dt.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=dt.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new rt.WebGLInferenceHandler(this)}onGraphInitialized(dt){const st=dt.getValues().filter(it=>it.from===-1&&it.tensor).map(it=>it.tensor.dataId);this.initializers=new Set(st)}isInitializer(dt){return!!this.initializers&&this.initializers.has(dt)}addInitializer(dt){this.initializers.add(dt)}getTextureData(dt,st){return st?this.packedTextureDataCache.get(dt):this.unpackedTextureDataCache.get(dt)}setTextureData(dt,st,it=!1){tt.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),it?this.packedTextureDataCache.set(dt,st):this.unpackedTextureDataCache.set(dt,st)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(dt=>this.textureManager.releaseTexture(dt,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(dt=>this.textureManager.releaseTexture(dt,!0)),this.unpackedTextureDataCache=new Map}resolve(dt,st,it){const ct=(0,nt.resolveOperator)(dt,st,ot.WEBGL_OP_RESOLVE_RULES);return{impl:ct.opImpl,context:ct.opInit?ct.opInit(dt,it):dt}}}},7769:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.Uint8DataEncoder=_.RGBAFloatDataEncoder=_.RedFloat32DataEncoder=void 0;const tt=_e(6231);_.RedFloat32DataEncoder=class{constructor(nt,rt=1){if(rt===1)this.internalFormat=nt.R32F,this.format=nt.RED,this.textureType=nt.FLOAT,this.channelSize=rt;else{if(rt!==4)throw new Error(`Invalid number of channels: ${rt}`);this.internalFormat=nt.RGBA32F,this.format=nt.RGBA,this.textureType=nt.FLOAT,this.channelSize=rt}}encode(nt,rt){let ot,at;return nt.constructor!==Float32Array&&(tt.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),at=new Float32Array(nt)),rt*this.channelSize>nt.length?(tt.Logger.warning("Encoder","Source data too small. Allocating larger array"),at=nt,ot=this.allocate(rt*this.channelSize),at.forEach((lt,ut)=>ot[ut]=lt)):(at=nt,ot=at),ot}allocate(nt){return new Float32Array(4*nt)}decode(nt,rt){return this.channelSize===1?nt.filter((ot,at)=>at%4==0).subarray(0,rt):nt.subarray(0,rt)}},_.RGBAFloatDataEncoder=class{constructor(nt,rt=1,ot){if(rt!==1&&rt!==4)throw new Error(`Invalid number of channels: ${rt}`);this.internalFormat=nt.RGBA,this.format=nt.RGBA,this.channelSize=rt,this.textureType=ot||nt.FLOAT}encode(nt,rt){let ot=nt;return this.channelSize===1&&(tt.Logger.verbose("Encoder","Exploding into a larger array"),ot=this.allocate(rt),nt.forEach((at,lt)=>ot[4*lt]=at)),ot}allocate(nt){return new Float32Array(4*nt)}decode(nt,rt){return this.channelSize===1?nt.filter((ot,at)=>at%4==0).subarray(0,rt):nt.subarray(0,rt)}},_.Uint8DataEncoder=class{constructor(nt,rt=1){if(this.channelSize=4,rt===1)this.internalFormat=nt.ALPHA,this.format=nt.ALPHA,this.textureType=nt.UNSIGNED_BYTE,this.channelSize=rt;else{if(rt!==4)throw new Error(`Invalid number of channels: ${rt}`);this.internalFormat=nt.RGBA,this.format=nt.RGBA,this.textureType=nt.UNSIGNED_BYTE,this.channelSize=rt}}encode(nt,rt){return new Uint8Array(nt.buffer,nt.byteOffset,nt.byteLength)}allocate(nt){return new Uint8Array(nt*this.channelSize)}decode(nt,rt){if(nt instanceof Uint8Array)return nt.subarray(0,rt);throw new Error(`Invalid array type: ${nt.constructor}`)}}},7859:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.getBatchDim=_.sizeToSquarishShape=_.getRowsCols=_.sizeFromShape=_.isInt=_.parseAxisParam=_.squeezeShape=_.PreferLogicalStrategy=_.AlwaysKeepOriginalSizeStrategy=void 0;const tt=_e(6231),nt=_e(2517);function rt(dt,st){const it=[],ct=[],ft=st!=null&&Array.isArray(st)&&st.length===0,ht=st==null||ft?null:ot(st,dt).sort();let mt=0;for(let pt=0;pt<dt.length;++pt){if(ht!=null){if(ht[mt]===pt&&dt[pt]!==1)throw new Error(`Can't squeeze axis ${pt} since its dim '${dt[pt]}' is not 1`);(ht[mt]==null||ht[mt]>pt)&&dt[pt]===1&&(it.push(dt[pt]),ct.push(pt)),ht[mt]<=pt&&mt++}dt[pt]!==1&&(it.push(dt[pt]),ct.push(pt))}return{newShape:it,keptDims:ct}}function ot(dt,st){const it=st.length;return dt=dt==null?st.map((ct,ft)=>ft):[].concat(dt),(0,nt.assert)(dt.every(ct=>ct>=-it&&ct<it),()=>`All values in axis param must be in range [-${it}, ${it}) but got axis ${dt}`),(0,nt.assert)(dt.every(at),()=>`All values in axis param must be integers but got axis ${dt}`),dt.map(ct=>ct<0?it+ct:ct)}function at(dt){return dt%1==0}function lt(dt){if(dt.length===0)return 1;let st=dt[0];for(let it=1;it<dt.length;it++)st*=dt[it];return st}function ut(dt){const st=Math.ceil(Math.sqrt(dt));return[st,Math.ceil(dt/st)]}_.AlwaysKeepOriginalSizeStrategy=class{constructor(dt){this.maxTextureSize=dt}computeTextureWH(dt,st){if(dt.length===0)return[1,1];const it=this.maxTextureSize;if(st&&st.breakAxis!==void 0){const ht=st.breakAxis>=dt.length?1:dt.slice(st.breakAxis).reduce((pt,_t)=>pt*_t),mt=st.breakAxis<=0?1:dt.slice(0,st.breakAxis).reduce((pt,_t)=>pt*_t);if(!(ht>it||mt>it))return[ht,mt];tt.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${dt}, breakAxis:${st.breakAxis}`)}const ct=dt.reduce((ht,mt)=>ht*mt);let ft=Math.floor(Math.sqrt(ct));for(;ft<it&&ft<ct&&ct%ft!=0;ft++);if(ft>=it||ct%ft!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${dt}`);return[ft,ct/ft]}},_.PreferLogicalStrategy=class{constructor(dt){this.maxTextureSize=dt}computeTextureWH(dt,st){const it=this.computeTexture(dt,st);return st&&st.isPacked&&(it[0]/=2,it[1]/=2),st&&st.reverseWH?[it[1],it[0]]:it}computeTexture(dt,st){const it=st&&st.isPacked;if(dt.length===0)return it?[2,2]:[1,1];let ct=this.maxTextureSize;if(st&&st.breakAxis!==void 0){const mt=st.breakAxis>=dt.length?1:dt.slice(st.breakAxis).reduce((_t,vt)=>_t*vt),pt=st.breakAxis<=0?1:dt.slice(0,st.breakAxis).reduce((_t,vt)=>_t*vt);if(!(mt>ct||pt>ct))return[mt,pt];tt.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${dt}, breakAxis:${st.breakAxis}`)}let ft=dt.slice(0);it&&(ct*=2,ft=ft.map((mt,pt)=>pt>=ft.length-2?ft[pt]%2==0?ft[pt]:ft[pt]+1:ft[pt]),ft.length===1&&(ft=[2,ft[0]])),ft.length!==2&&(ft=rt(ft).newShape);const ht=lt(ft);return ft.length<=1&&ht<=ct?[1,ht]:ft.length===2&&ft[0]<=ct&&ft[1]<=ct?ft:ft.length===3&&ft[0]*ft[1]<=ct&&ft[2]<=ct?[ft[0]*ft[1],ft[2]]:ft.length===3&&ft[0]<=ct&&ft[1]*ft[2]<=ct?[ft[0],ft[1]*ft[2]]:ft.length===4&&ft[0]*ft[1]*ft[2]<=ct&&ft[3]<=ct?[ft[0]*ft[1]*ft[2],ft[3]]:ft.length===4&&ft[0]<=ct&&ft[1]*ft[2]*ft[3]<=ct?[ft[0],ft[1]*ft[2]*ft[3]]:it?ut(ht/4).map(mt=>2*mt):ut(ht)}},_.squeezeShape=rt,_.parseAxisParam=ot,_.isInt=at,_.sizeFromShape=lt,_.getRowsCols=function(dt){if(dt.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[dt.length>1?dt[dt.length-2]:1,dt[dt.length-1]]},_.sizeToSquarishShape=ut,_.getBatchDim=function(dt,st=2){return lt(dt.slice(0,dt.length-st))}},4057:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.createTextureLayoutFromShape=_.calculateTextureWidthAndHeight=_.createTextureLayoutFromTextureType=void 0;const tt=_e(2517),nt=_e(2039);_.createTextureLayoutFromTextureType=(rt,ot,at)=>{const lt=at===nt.TextureType.unpacked||at===nt.TextureType.unpackedReversed?1:4,ut=at===nt.TextureType.packed,dt=at===nt.TextureType.unpackedReversed||at===nt.TextureType.packed,st=at===nt.TextureType.packedLastDimension?ot.length-1:void 0,it=at===nt.TextureType.packedLastDimension?ot.map((ct,ft)=>ft===ot.length-1?4*ct:ct):void 0;return(0,_.createTextureLayoutFromShape)(rt,ot,lt,it,{isPacked:ut,reverseWH:dt,breakAxis:st})},_.calculateTextureWidthAndHeight=(rt,ot,at)=>{const lt=(0,_.createTextureLayoutFromTextureType)(rt,ot,at);return[lt.width,lt.height]},_.createTextureLayoutFromShape=(rt,ot,at=1,lt,ut)=>{const dt=!(!ut||!ut.isPacked),[st,it]=rt.computeTextureWH(dt&&lt||ot,ut),ct=ot.length;let ft=ot.slice(0);if(ct===0&&(ft=[1]),at===1)lt=ot;else if(dt){if(at!==4)throw new Error("a packed texture must be 4-channel");lt=ot,ct>0&&(ft[ct-1]=Math.ceil(ft[ct-1]/2)),ct>1&&(ft[ct-2]=Math.ceil(ft[ct-2]/2))}else if(!lt)throw new Error("Unpacked shape is needed when using channels > 1");return{width:st,height:it,channels:at,isPacked:dt,shape:ft,strides:tt.ShapeUtil.computeStrides(ft),unpackedShape:lt,reversedWH:ut&&ut.reverseWH}}},5702:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.TextureManager=void 0;const tt=_e(6231);_.TextureManager=class{constructor(nt,rt,ot,at){this.glContext=nt,this.layoutStrategy=rt,this.profiler=ot,this.config=at,this.pendingRead=new Map,at.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(nt,rt,ot,at){const lt=this.toEncoderType(nt),ut=this.glContext.getEncoder(lt,rt.channels||1,at);if(rt.isPacked&&at===1)throw new Error("not implemented");const dt=rt.width,st=rt.height;let it,ct;if(this.config.reuseTextures){it=`${dt}x${st}_${ut.format}_${ut.internalFormat}_${ut.textureType}`,ct=this.inUseTextures.get(it),ct||(ct=[],this.inUseTextures.set(it,ct));const ht=this.idleTextures.get(it);if(ht&&ht.length>0){const mt=ht.pop();return ct.push(mt),at===1&&this.glContext.updateTexture(mt,dt,st,ut,this.toTextureData(nt,ot)),mt}}tt.Logger.verbose("TextureManager",`Creating new texture of size ${rt.width}x${rt.height}`);const ft=this.glContext.allocateTexture(dt,st,ut,this.toTextureData(nt,ot));return this.config.reuseTextures&&(ct.push(ft),this.textureLookup.set(ft,it)),ft}readTexture(nt,rt,ot){return ot||(ot=1),this.profiler.event("backend","TextureManager.readTexture",()=>{const at=nt.shape.reduce((ut,dt)=>ut*dt)*ot,lt=this.glContext.readTexture(nt.texture,nt.width,nt.height,at,this.toEncoderType(rt),ot);return this.toTensorData(rt,lt)})}async readTextureAsync(nt,rt,ot){const at=nt.tensor.dataId;if(ot||(ot=1),this.pendingRead.has(at)){const lt=this.pendingRead.get(at);return new Promise(ut=>lt==null?void 0:lt.push(ut))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(at,[]);const lt=nt.shape.reduce((it,ct)=>it*ct)*ot;await this.glContext.createAndWaitForFence();const ut=this.glContext.readTexture(nt.texture,nt.width,nt.height,lt,this.toEncoderType(rt),ot),dt=this.toTensorData(rt,ut),st=this.pendingRead.get(at);return this.pendingRead.delete(at),st==null||st.forEach(it=>it(dt)),dt})}readUint8TextureAsFloat(nt){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{const rt=nt.shape.reduce((at,lt)=>at*lt),ot=this.glContext.readTexture(nt.texture,nt.width,nt.height,4*rt,"byte",4);return new Float32Array(ot.buffer,ot.byteOffset,rt)})}releaseTexture(nt,rt){let ot;if(this.config.reuseTextures&&(ot=this.textureLookup.get(nt.texture),ot)){rt&&this.textureLookup.delete(ot);const at=this.inUseTextures.get(ot);if(at){const lt=at.indexOf(nt.texture);if(lt!==-1){at.splice(lt,1);let ut=this.idleTextures.get(ot);ut||(ut=[],this.idleTextures.set(ot,ut)),ut.push(nt.texture)}}}ot&&!rt||(tt.Logger.verbose("TextureManager",`Deleting texture of size ${nt.width}x${nt.height}`),this.glContext.deleteTexture(nt.texture))}toTensorData(nt,rt){switch(nt){case"int16":return rt instanceof Int16Array?rt:Int16Array.from(rt);case"int32":return rt instanceof Int32Array?rt:Int32Array.from(rt);case"int8":return rt instanceof Int8Array?rt:Int8Array.from(rt);case"uint16":return rt instanceof Uint16Array?rt:Uint16Array.from(rt);case"uint32":return rt instanceof Uint32Array?rt:Uint32Array.from(rt);case"uint8":case"bool":return rt instanceof Uint8Array?rt:Uint8Array.from(rt);case"float32":return rt instanceof Float32Array?rt:Float32Array.from(rt);case"float64":return rt instanceof Float64Array?rt:Float64Array.from(rt);default:throw new Error(`TensorData type ${nt} is not supported`)}}toTextureData(nt,rt){if(rt)return rt instanceof Float32Array?rt:new Float32Array(rt)}toEncoderType(nt){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},2039:(et,_)=>{var _e;Object.defineProperty(_,"__esModule",{value:!0}),_.TextureType=void 0,(_e=_.TextureType||(_.TextureType={}))[_e.unpacked=0]="unpacked",_e[_e.unpackedReversed=1]="unpackedReversed",_e[_e.packed=2]="packed",_e[_e.downloadUint8AsFloat=3]="downloadUint8AsFloat",_e[_e.packedLastDimension=4]="packedLastDimension"},9390:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.getGlChannels=_.getCoordsDataType=_.getSqueezedParams=_.squeezeInputShape=_.generateShaderFuncNameFromInputSamplerNameAtOutCoords=_.generateShaderFuncNameFromInputSamplerName=_.repeatedTry=_.getPackedShape=void 0;const tt=_e(2517);_.getPackedShape=function(nt){const rt=nt.length;return nt.slice(0,rt-1).concat(nt[rt-1]/4)},_.repeatedTry=async function(nt,rt=at=>0,ot){return new Promise((at,lt)=>{let ut=0;const dt=()=>{if(nt())return void at();ut++;const st=rt(ut);ot!=null&&ut>=ot?lt():setTimeout(dt,st)};dt()})},_.generateShaderFuncNameFromInputSamplerName=function(nt){return(0,tt.assert)(nt!==void 0&&nt.length!==0,()=>"empty string found for sampler name"),"get"+nt.charAt(0).toUpperCase()+nt.slice(1)},_.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(nt){return(0,tt.assert)(nt!==void 0&&nt.length!==0,()=>"empty string found for sampler name"),"get"+nt.charAt(0).toUpperCase()+nt.slice(1)+"AtOutCoords"},_.squeezeInputShape=function(nt,rt){let ot=JSON.parse(JSON.stringify(nt));return ot=rt,ot},_.getSqueezedParams=function(nt,rt){return rt.map(ot=>nt[ot]).join(", ")},_.getCoordsDataType=function(nt){if(nt<=1)return"int";if(nt===2)return"ivec2";if(nt===3)return"ivec3";if(nt===4)return"ivec4";if(nt===5)return"ivec5";if(nt===6)return"ivec6";throw Error(`GPU for rank ${nt} is not yet supported`)},_.getGlChannels=function(nt=6){return["x","y","z","w","u","v"].slice(0,nt)}},7305:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.createNewWebGLContext=_.createWebGLContext=void 0;const tt=_e(6231),nt=_e(1713),rt={};function ot(at){const lt=function(){if(typeof document>"u"){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}const st=document.createElement("canvas");return st.width=1,st.height=1,st}();let ut;const dt={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!at||at==="webgl2")&&(ut=lt.getContext("webgl2",dt),ut))try{return new nt.WebGLContext(ut,2)}catch(st){tt.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${st}`)}if((!at||at==="webgl")&&(ut=lt.getContext("webgl",dt)||lt.getContext("experimental-webgl",dt),ut))try{return new nt.WebGLContext(ut,1)}catch(st){tt.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${st}`)}throw new Error("WebGL is not supported")}_.createWebGLContext=function at(lt){let ut;lt&&lt!=="webgl2"||!("webgl2"in rt)?lt&&lt!=="webgl"||!("webgl"in rt)||(ut=rt.webgl):ut=rt.webgl2,ut=ut||ot(lt),lt=lt||ut.version===1?"webgl":"webgl2";const dt=ut.gl;return rt[lt]=ut,dt.isContextLost()?(delete rt[lt],at(lt)):(dt.disable(dt.DEPTH_TEST),dt.disable(dt.STENCIL_TEST),dt.disable(dt.BLEND),dt.disable(dt.DITHER),dt.disable(dt.POLYGON_OFFSET_FILL),dt.disable(dt.SAMPLE_COVERAGE),dt.enable(dt.SCISSOR_TEST),dt.enable(dt.CULL_FACE),dt.cullFace(dt.BACK),ut)},_.createNewWebGLContext=ot},1713:function(et,_,_e){var tt=this&&this.__createBinding||(Object.create?function(dt,st,it,ct){ct===void 0&&(ct=it);var ft=Object.getOwnPropertyDescriptor(st,it);ft&&!("get"in ft?!st.__esModule:ft.writable||ft.configurable)||(ft={enumerable:!0,get:function(){return st[it]}}),Object.defineProperty(dt,ct,ft)}:function(dt,st,it,ct){ct===void 0&&(ct=it),dt[ct]=st[it]}),nt=this&&this.__setModuleDefault||(Object.create?function(dt,st){Object.defineProperty(dt,"default",{enumerable:!0,value:st})}:function(dt,st){dt.default=st}),rt=this&&this.__importStar||function(dt){if(dt&&dt.__esModule)return dt;var st={};if(dt!=null)for(var it in dt)it!=="default"&&Object.prototype.hasOwnProperty.call(dt,it)&&tt(st,dt,it);return nt(st,dt),st};Object.defineProperty(_,"__esModule",{value:!0}),_.WebGLContext=_.linearSearchLastTrue=void 0;const ot=_e(1670),at=rt(_e(7769)),lt=_e(9390);function ut(dt){let st=0;for(;st<dt.length&&dt[st]();++st);return st-1}_.linearSearchLastTrue=ut,_.WebGLContext=class{constructor(dt,st){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=dt,this.version=st,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(dt,st,it,ct){const ft=this.gl,ht=ft.createTexture();ft.bindTexture(ft.TEXTURE_2D,ht),ft.texParameteri(ft.TEXTURE_2D,ft.TEXTURE_MIN_FILTER,ft.NEAREST),ft.texParameteri(ft.TEXTURE_2D,ft.TEXTURE_MAG_FILTER,ft.NEAREST),ft.texParameteri(ft.TEXTURE_2D,ft.TEXTURE_WRAP_S,ft.CLAMP_TO_EDGE),ft.texParameteri(ft.TEXTURE_2D,ft.TEXTURE_WRAP_T,ft.CLAMP_TO_EDGE);const mt=ct?it.encode(ct,dt*st):null;return ft.texImage2D(ft.TEXTURE_2D,0,it.internalFormat,dt,st,0,it.format,it.textureType,mt),this.checkError(),ht}updateTexture(dt,st,it,ct,ft){const ht=this.gl;ht.bindTexture(ht.TEXTURE_2D,dt);const mt=ct.encode(ft,st*it);ht.texSubImage2D(ht.TEXTURE_2D,0,0,0,st,it,ct.format,ct.textureType,mt),this.checkError()}attachFramebuffer(dt,st,it){const ct=this.gl;ct.bindTexture(ct.TEXTURE_2D,dt),ct.bindFramebuffer(ct.FRAMEBUFFER,this.framebuffer),ct.framebufferTexture2D(ct.FRAMEBUFFER,ct.COLOR_ATTACHMENT0,ct.TEXTURE_2D,dt,0),this.checkError(),ct.viewport(0,0,st,it),ct.scissor(0,0,st,it)}readTexture(dt,st,it,ct,ft,ht){const mt=this.gl;ht||(ht=1),this.frameBufferBound||this.attachFramebuffer(dt,st,it);const pt=this.getEncoder(ft,ht),_t=pt.allocate(st*it);return mt.bindTexture(mt.TEXTURE_2D,dt),mt.framebufferTexture2D(mt.FRAMEBUFFER,mt.COLOR_ATTACHMENT0,mt.TEXTURE_2D,dt,0),mt.readPixels(0,0,st,it,mt.RGBA,pt.textureType,_t),this.checkError(),pt.decode(_t,ct)}isFramebufferReady(){return!0}getActiveTexture(){const dt=this.gl;return"TEXTURE"+(dt.getParameter(this.gl.ACTIVE_TEXTURE)-dt.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(dt,st){const it=this.gl;it.vertexAttribPointer(dt,3,it.FLOAT,!1,20,0),it.enableVertexAttribArray(dt),st!==-1&&(it.vertexAttribPointer(st,2,it.FLOAT,!1,20,12),it.enableVertexAttribArray(st)),this.checkError()}createProgram(dt,st){const it=this.gl,ct=it.createProgram();return it.attachShader(ct,dt),it.attachShader(ct,st),it.linkProgram(ct),ct}compileShader(dt,st){const it=this.gl,ct=it.createShader(st);if(!ct)throw new Error(`createShader() returned null with type ${st}`);if(it.shaderSource(ct,dt),it.compileShader(ct),it.getShaderParameter(ct,it.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${it.getShaderInfoLog(ct)}
Shader source:
${dt}`);return ct}deleteShader(dt){this.gl.deleteShader(dt)}bindTextureToUniform(dt,st,it){const ct=this.gl;ct.activeTexture(ct.TEXTURE0+st),this.checkError(),ct.bindTexture(ct.TEXTURE_2D,dt),this.checkError(),ct.uniform1i(it,st),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(ot.env.debug){const dt=this.gl,st=dt.getError();let it="";switch(st){case dt.NO_ERROR:return;case dt.INVALID_ENUM:it="INVALID_ENUM";break;case dt.INVALID_VALUE:it="INVALID_VALUE";break;case dt.INVALID_OPERATION:it="INVALID_OPERATION";break;case dt.INVALID_FRAMEBUFFER_OPERATION:it="INVALID_FRAMEBUFFER_OPERATION";break;case dt.OUT_OF_MEMORY:it="OUT_OF_MEMORY";break;case dt.CONTEXT_LOST_WEBGL:it="CONTEXT_LOST_WEBGL";break;default:it=`Unknown WebGL Error: ${st.toString(16)}`}throw new Error(it)}}deleteTexture(dt){this.gl.deleteTexture(dt)}deleteProgram(dt){this.gl.deleteProgram(dt)}getEncoder(dt,st,it=0){if(this.version===2)return new at.RedFloat32DataEncoder(this.gl,st);switch(dt){case"float":return it===1||this.isRenderFloat32Supported?new at.RGBAFloatDataEncoder(this.gl,st):new at.RGBAFloatDataEncoder(this.gl,st,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new at.Uint8DataEncoder(this.gl,st);default:throw new Error(`Invalid dataType: ${dt}`)}}clearActiveTextures(){const dt=this.gl;for(let st=0;st<this.maxTextureImageUnits;++st)dt.activeTexture(dt.TEXTURE0+st),dt.bindTexture(dt.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const dt=this.gl;dt.bindFramebuffer(dt.FRAMEBUFFER,null),dt.deleteFramebuffer(this.framebuffer),dt.bindBuffer(dt.ARRAY_BUFFER,null),dt.deleteBuffer(this.vertexbuffer),dt.bindBuffer(dt.ELEMENT_ARRAY_BUFFER,null),dt.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const dt=this.gl,st=dt.createBuffer();if(!st)throw new Error("createBuffer() returned null");const it=this.createDefaultGeometry();return dt.bindBuffer(dt.ARRAY_BUFFER,st),dt.bufferData(dt.ARRAY_BUFFER,it,dt.STATIC_DRAW),this.checkError(),st}createFramebuffer(){const dt=this.gl.createFramebuffer();if(!dt)throw new Error("createFramebuffer returned null");return dt}queryVitalParameters(){const dt=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=dt.getParameter(dt.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=dt.getParameter(dt.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const dt=this.gl,st=dt.createTexture();dt.bindTexture(dt.TEXTURE_2D,st);const it=this.version===2?dt.RGBA32F:dt.RGBA;dt.texImage2D(dt.TEXTURE_2D,0,it,1,1,0,dt.RGBA,dt.FLOAT,null);const ct=dt.createFramebuffer();dt.bindFramebuffer(dt.FRAMEBUFFER,ct),dt.framebufferTexture2D(dt.FRAMEBUFFER,dt.COLOR_ATTACHMENT0,dt.TEXTURE_2D,st,0);const ft=dt.checkFramebufferStatus(dt.FRAMEBUFFER)===dt.FRAMEBUFFER_COMPLETE;return dt.bindTexture(dt.TEXTURE_2D,null),dt.bindFramebuffer(dt.FRAMEBUFFER,null),dt.deleteTexture(st),dt.deleteFramebuffer(ct),ft}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const dt=this.gl;let st,it,ct,ft,ht;try{st=dt.createTexture(),it=dt.createFramebuffer(),dt.bindTexture(dt.TEXTURE_2D,st);const mt=this.version===2?dt.RGBA32F:dt.RGBA;return dt.texImage2D(dt.TEXTURE_2D,0,mt,1,1,0,dt.RGBA,dt.FLOAT,null),dt.bindFramebuffer(dt.FRAMEBUFFER,it),dt.framebufferTexture2D(dt.FRAMEBUFFER,dt.COLOR_ATTACHMENT0,dt.TEXTURE_2D,st,0),dt.enable(dt.BLEND),ct=dt.createShader(dt.VERTEX_SHADER),!!ct&&(dt.shaderSource(ct,"void main(){}"),dt.compileShader(ct),ft=dt.createShader(dt.FRAGMENT_SHADER),!!ft&&(dt.shaderSource(ft,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),dt.compileShader(ft),ht=dt.createProgram(),!!ht&&(dt.attachShader(ht,ct),dt.attachShader(ht,ft),dt.linkProgram(ht),dt.useProgram(ht),dt.drawArrays(dt.POINTS,0,1),dt.getError()===dt.NO_ERROR)))}finally{dt.disable(dt.BLEND),ht&&dt.deleteProgram(ht),ct&&dt.deleteShader(ct),ft&&dt.deleteShader(ft),it&&(dt.bindFramebuffer(dt.FRAMEBUFFER,null),dt.deleteFramebuffer(it)),st&&(dt.bindTexture(dt.TEXTURE_2D,null),dt.deleteTexture(st))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){const dt=this.gl,st=this.disjointTimerQueryWebgl2Extension,it=dt.createQuery();return dt.beginQuery(st.TIME_ELAPSED_EXT,it),it}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const dt=this.gl,st=this.disjointTimerQueryWebgl2Extension;dt.endQuery(st.TIME_ELAPSED_EXT)}}isTimerResultAvailable(dt){let st=!1,it=!1;if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const ct=this.gl,ft=this.disjointTimerQueryWebgl2Extension;st=ct.getQueryParameter(dt,ct.QUERY_RESULT_AVAILABLE),it=ct.getParameter(ft.GPU_DISJOINT_EXT)}return st&&!it}getTimerResult(dt){let st=0;if(this.version!==2)throw new Error("WebGL1 profiling currently not supported");{const it=this.gl;st=it.getQueryParameter(dt,it.QUERY_RESULT),it.deleteQuery(dt)}return st/1e6}async waitForQueryAndGetTime(dt){return await(0,lt.repeatedTry)(()=>this.isTimerResultAvailable(dt)),this.getTimerResult(dt)}async createAndWaitForFence(){const dt=this.createFence(this.gl);return this.pollFence(dt)}createFence(dt){let st;const it=dt,ct=it.fenceSync(it.SYNC_GPU_COMMANDS_COMPLETE,0);return dt.flush(),st=ct===null?()=>!0:()=>{const ft=it.clientWaitSync(ct,0,0);return ft===it.ALREADY_SIGNALED||ft===it.CONDITION_SATISFIED},{query:ct,isFencePassed:st}}async pollFence(dt){return new Promise(st=>{this.addItemToPoll(()=>dt.isFencePassed(),()=>st())})}pollItems(){const dt=ut(this.itemsToPoll.map(st=>st.isDoneFn));for(let st=0;st<=dt;++st){const{resolveFn:it}=this.itemsToPoll[st];it()}this.itemsToPoll=this.itemsToPoll.slice(dt+1)}async addItemToPoll(dt,st){this.itemsToPoll.push({isDoneFn:dt,resolveFn:st}),this.itemsToPoll.length>1||await(0,lt.repeatedTry)(()=>(this.pollItems(),this.itemsToPoll.length===0))}}},1036:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.ExecutionPlan=void 0;const tt=_e(6231);class nt{constructor(ot,at){this.op=ot,this.node=at}}_.ExecutionPlan=class{constructor(rt,ot,at){this.graph=rt,this.profiler=at,this.initialize(ot)}initialize(rt){this.profiler.event("session","ExecutionPlan.initialize",()=>{const ot=this.graph.getNodes();if(ot.length!==rt.length)throw new Error("The size of nodes and OPs do not match.");this._ops=rt.map((at,lt)=>new nt(at,ot[lt])),this.reset(),this._starter=[],this._ops.forEach((at,lt)=>{let ut=!0;for(const dt of at.node.inputs)if(!this._values[dt]&&this.graph.getInputIndices().indexOf(dt)===-1){ut=!1;break}ut&&this._starter.push(lt)})})}reset(){this._values=this.graph.getValues().map(rt=>rt.tensor)}async execute(rt,ot){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();const at=rt.createInferenceHandler(),lt=this.graph.getInputIndices();if(ot.length!==lt.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${ot.length} expected: ${lt.length}`);ot.forEach((ft,ht)=>{const mt=lt[ht];this._values[mt]=ft});const ut=this._starter.slice(0),dt=this.graph.getValues(),st=this.graph.getNodes();let it=0;for(;it<ut.length;){const ft=ut[it++],ht=this._ops[ft],mt=ht.node.inputs.map(bt=>this._values[bt]);if(mt.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${ht.node}`);const pt=mt;tt.Logger.verbose("ExecPlan",`Runing op:${ht.node.name} (${pt.map((bt,wt)=>`'${ht.node.inputs[wt]}': ${bt.type}[${bt.dims.join(",")}]`).join(", ")})`);const _t=await this.profiler.event("node",ht.node.name,async()=>ht.op.impl(at,pt,ht.op.context));if(_t.length!==ht.node.outputs.length)throw new Error("the size of output does not match model definition.");_t.forEach((bt,wt)=>{const xt=ht.node.outputs[wt];if(this._values[xt])throw new Error(`output [${xt}] already has value: op:${ht.node.name}`);this._values[xt]=bt});const vt=new Set;_t.forEach((bt,wt)=>{const xt=ht.node.outputs[wt];for(const Mt of dt[xt].to){const At=st[Mt];let St=!0;for(const Tt of At.inputs)if(!this._values[Tt]){St=!1;break}St&&vt.add(Mt)}}),ut.push(...vt)}const ct=[];for(let ft=0;ft<this.graph.getOutputIndices().length;ft++){const ht=this.graph.getOutputIndices()[ft],mt=this._values[ht];if(mt===void 0)throw new Error(`required output [${ht}] does not have value`);ht===0?await mt.getData():mt.data,ct.push(mt)}return tt.Logger.verbose("ExecPlan","disposing of inferenceHandler"),at.dispose(),ct})}}},7070:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.Graph=void 0;const tt=_e(1446),nt=_e(7778),rt=_e(9395),ot=_e(9162),at=_e(2517);var lt=rt.onnxruntime.experimental.fbs;_.Graph={from:(it,ct)=>new st(it,ct)};class ut{constructor(ct){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,ct&&(this.type=at.ProtoUtil.tensorValueTypeFromProto(ct.type.tensorType))}get from(){return this._from}get to(){return this._to}}class dt{constructor(ct,ft){ct instanceof tt.onnx.NodeProto?(this.name=ct.name,this.opType=ct.opType,this.attributes=new nt.Attribute(ct.attribute)):ct instanceof lt.Node&&(this.name=ft??ct.name(),this.opType=ct.opType(),this.attributes=new nt.Attribute(at.ProtoUtil.tensorAttributesFromORTFormat(ct))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class st{constructor(ct,ft){if(!ct)throw new TypeError("graph is empty");this.buildGraph(ct),this.transformGraph(ft),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(ct){if(ct instanceof tt.onnx.GraphProto)this.buildGraphFromOnnxFormat(ct);else{if(!(ct instanceof lt.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(ct)}}buildGraphFromOnnxFormat(ct){const ft=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const ht=new Map;if(!ct.input)throw new Error("missing information in graph: input");const mt=[];for(const pt of ct.input){if(ft.has(pt.name))throw new Error(`duplicated input name: ${pt.name}`);const _t=this._allData.push(new ut(pt))-1;ft.set(pt.name,_t),mt.push(pt.name)}if(!ct.initializer)throw new Error("missing information in graph: initializer");for(const pt of ct.initializer){let _t=ft.get(pt.name);if(_t===void 0){const vt=new ut;vt.type={shape:{dims:at.ProtoUtil.tensorDimsFromProto(pt.dims)},tensorType:at.ProtoUtil.tensorDataTypeFromProto(pt.dataType)},_t=this._allData.push(vt)-1,ft.set(pt.name,_t)}this._allData[_t]._from=-1,this._allData[_t].tensor=ot.Tensor.fromProto(pt)}for(let pt=0;pt<this._allData.length;pt++)this._allData[pt].tensor||(this._allInputIndices.push(pt),this._allInputNames.push(mt[pt]));if(!ct.output)throw new Error("missing information in graph: output");for(const pt of ct.output){if(ft.has(pt.name))throw new Error(`duplicated output name: ${pt.name}`);const _t=this._allData.push(new ut(pt))-1;ft.set(pt.name,_t),this._allOutputIndices.push(_t),this._allOutputNames.push(pt.name)}if(!ct.node)throw new Error("missing information in graph: node");for(const pt of ct.node){if(!pt.name)for(let vt=0;;vt++){const bt=`unnamed_${pt.opType}_${vt}`;if(!ht.has(bt)){pt.name=bt;break}}if(ht.has(pt.name))throw new Error(`duplicated node name: ${pt.name}`);const _t=this._nodes.push(new dt(pt))-1;ht.set(pt.name,_t)}for(let pt=0;pt<this._nodes.length;pt++){const _t=this._nodes[pt],vt=ct.node[pt];if(!vt.output)throw new Error(`missing output for node: ${vt.name}`);for(const bt of vt.output){let wt=ft.get(bt);if(wt===void 0&&(wt=this._allData.push(new ut)-1,ft.set(bt,wt)),_t.outputs.push(wt),this._allData[wt]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${wt}`);if(this._allData[wt]._from=pt,vt.opType==="Constant"){if(!vt.attribute||vt.attribute.length!==1||!vt.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!vt.output||vt.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");_t.outputs.pop(),_t.executeNode=!1,this._allData[wt]._from=-1,this._allData[wt].tensor=ot.Tensor.fromProto(vt.attribute[0].t)}}}for(let pt=0;pt<this._nodes.length;pt++){const _t=this._nodes[pt],vt=ct.node[pt];if(!vt.input)throw new Error(`missing input for node: ${vt.name}`);for(const bt of vt.input){const wt=ft.get(bt);if(wt===void 0){if(bt===""&&vt.input.length===3&&vt.opType==="Resize")continue;throw new Error(`unrecognized input '${bt}' for node: ${vt.name}`)}_t.inputs.push(wt),this._allData[wt]._to.push(pt)}}return!0}buildGraphFromOrtFormat(ct){var ft,ht,mt;const pt=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const _t=new Map,vt=[];for(let bt=0;bt<ct.inputsLength();bt++){const wt=ct.inputs(bt);if(pt.has(wt))throw new Error(`duplicated input name: ${wt}`);for(let xt=0;xt<ct.nodeArgsLength();xt++)if(((ft=ct.nodeArgs(xt))===null||ft===void 0?void 0:ft.name())===wt){const Mt=new ut;if(((mt=(ht=ct.nodeArgs(xt))===null||ht===void 0?void 0:ht.type())===null||mt===void 0?void 0:mt.valueType())!==lt.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const At=ct.nodeArgs(xt).type().value(new lt.TensorTypeAndShape),St=at.ProtoUtil.tensorDataTypeFromProto(At.elemType()),Tt=At.shape(),Ct=[];for(let $t=0;$t<Tt.dimLength();$t++)Ct.push(at.LongUtil.longToNumber(Tt.dim($t).value().dimValue()));Mt.type={shape:{dims:Ct},tensorType:St};const It=this._allData.push(Mt)-1;pt.set(wt,It),vt.push(wt)}}for(let bt=0;bt<ct.initializersLength();bt++){const wt=ct.initializers(bt);let xt=pt.get(wt.name());if(xt===void 0){const Mt=new ut,At=at.ProtoUtil.tensorDimsFromORTFormat(wt),St=at.ProtoUtil.tensorDataTypeFromProto(wt.dataType());Mt.type={shape:{dims:At},tensorType:St},xt=this._allData.push(Mt)-1,pt.set(wt.name(),xt)}this._allData[xt]._from=-1,this._allData[xt].tensor=ot.Tensor.fromOrtTensor(wt)}for(let bt=0;bt<this._allData.length;bt++)this._allData[bt].tensor||(this._allInputIndices.push(bt),this._allInputNames.push(vt[bt]));for(let bt=0;bt<ct.outputsLength();bt++){const wt=ct.outputs(bt);if(pt.has(wt))throw new Error(`duplicated output name: ${wt}`);const xt=this._allData.push(new ut)-1;pt.set(wt,xt),this._allOutputIndices.push(xt),this._allOutputNames.push(wt)}if(!ct.nodes)throw new Error("missing information in graph: node");for(let bt=0;bt<ct.nodesLength();bt++){const wt=ct.nodes(bt);let xt=wt.name();if(!xt)for(let At=0;xt=`unnamed_${wt.opType()}_${At}`,_t.has(xt);At++);if(_t.has(xt))throw new Error(`duplicated node name: ${xt}`);const Mt=this._nodes.push(new dt(wt,xt))-1;_t.set(xt,Mt)}for(let bt=0;bt<this._nodes.length;bt++){const wt=this._nodes[bt],xt=ct.nodes(bt);if(xt==null)throw new Error(`No node exists at index ${bt}`);if((xt==null?void 0:xt.outputsLength())===0)throw new Error(`missing output for node: ${xt.name}`);for(let Mt=0;Mt<(xt==null?void 0:xt.outputsLength());Mt++){const At=xt==null?void 0:xt.outputs(Mt);let St=pt.get(At);if(St===void 0&&(St=this._allData.push(new ut)-1,pt.set(At,St)),wt.outputs.push(St),this._allData[St]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${St}`);if(this._allData[St]._from=bt,xt.opType()==="Constant"){if(xt.attributesLength()!==1||!xt.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(xt.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");wt.outputs.pop(),wt.executeNode=!1,this._allData[St]._from=-1,this._allData[St].tensor=ot.Tensor.fromOrtTensor(xt.attributes(0).t())}}}for(let bt=0;bt<this._nodes.length;bt++){const wt=this._nodes[bt],xt=ct.nodes(bt);if(xt.inputsLength()===0)throw new Error(`missing input for node: ${xt.name}`);for(let Mt=0;Mt<xt.inputsLength();Mt++){const At=xt.inputs(Mt),St=pt.get(At);if(St===void 0)throw new Error(`unrecognized input '${At}' for node: ${xt.name()}`);wt.inputs.push(St),this._allData[St]._to.push(bt)}}}checkIsAcyclic(){const ct=new Set;this._allInputIndices.forEach(mt=>{this._allData[mt]._to.forEach(pt=>{ct.add(pt)})});const ft=Array.from(ct),ht=new Array(this._nodes.length).fill("white");for(;ft.length>0;){const mt=ft.pop();ht[mt]==="gray"?ht[mt]="black":(ft.push(mt),ht[mt]="gray",this._nodes[mt].outputs.forEach(pt=>{const _t=this._allData[pt];if(_t.tensor!==void 0)throw new Error("node outputs should not be initialized");if(_t._from!==mt)throw new Error("from property of the Value object doesn't match index of Node being processed");_t._to.forEach(vt=>{if(ht[vt]==="gray")throw new Error("model graph is cyclic");ht[vt]==="white"&&ft.push(vt)})}))}}transformGraph(ct){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),ct&&ct.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let ct=0;for(let ft=0;ft<this._nodes.length;ft++)this._nodes[ft].executeNode?ct>0&&(this._nodes[ft].inputs.forEach(ht=>{const mt=this._allData[ht]._to.indexOf(ft+ct);mt!==-1&&(this._allData[ht]._to[mt]=ft)}),this._nodes[ft].outputs.forEach(ht=>{this._allData[ht]._from&&this._allData[ht]._from===ft+ct&&(this._allData[ht]._from=ft)})):(ct++,this._nodes[ft].outputs.forEach(ht=>{this._allData[ht]._from=-2}),this._nodes.splice(ft,1),ft--);ct=0;for(let ft=0;ft<this._allData.length;ft++)if(this._allData[ft].from!==-2||this._allOutputIndices.indexOf(ft+ct)!==-1){if(ct>0){let ht=-1;this._allData[ft].from!==void 0&&this._allData[ft].from!==-1?(ht=this._nodes[this._allData[ft].from].outputs.indexOf(ft+ct),ht!==-1&&(this._nodes[this._allData[ft].from].outputs[ht]=ft)):(ht=this._allInputIndices.indexOf(ft+ct),ht!==-1&&(this._allInputIndices[ht]=ft)),this._allData[ft].to.forEach(mt=>{ht=this._nodes[mt].inputs.indexOf(ft+ct),ht!==-1&&(this._nodes[mt].inputs[ht]=ft)}),this._allData[ft].to.length===0&&(ht=this._allOutputIndices.indexOf(ft+ct),ht!==-1&&(this._allOutputIndices[ht]=ft))}}else ct++,this._allData.splice(ft,1),ft--}deleteNode(ct){const ft=this._nodes[ct];if(ft.outputs.length>1){for(let bt=1;bt<ft.outputs.length;bt++)if(this._allData[ft.outputs[bt]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}ft.executeNode=!1;const ht=ft.inputs[0],mt=ft.outputs[0],pt=this._allData[mt].to,_t=this._allData[ht].to.indexOf(ct);if(_t===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[ht].to.splice(_t,1),this._allData[mt]._to=[];const vt=this._allOutputIndices.indexOf(mt);if(vt!==-1&&(this._allOutputIndices[vt]=ht),pt&&pt.length>0)for(const bt of pt){const wt=this._nodes[bt].inputs.indexOf(mt);if(wt===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[bt].inputs[wt]=ht,this._allData[ht].to.push(bt)}}removeAllDropoutNodes(){let ct=0;for(const ft of this._nodes){if(ft.opType==="Dropout"){if(ft.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(ft.outputs.length!==1&&ft.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(ft.outputs.length===2&&this._allData[ft.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(ct)}ct++}}removeAllIdentityNodes(){let ct=0;for(const ft of this._nodes)ft.opType==="Identity"&&this.deleteNode(ct),ct++}isActivation(ct){switch(ct.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const ct of this._nodes)if(ct.opType==="Conv"){const ft=this._allData[ct.outputs[0]]._to;if(ft.length===1&&this.isActivation(this._nodes[ft[0]])){const ht=this._nodes[ft[0]];if(ht.opType==="Clip")if(ht.inputs.length===1)try{ct.attributes.set("activation_params","floats",[ht.attributes.getFloat("min"),ht.attributes.getFloat("max")])}catch{ct.attributes.set("activation_params","floats",[at.MIN_CLIP,at.MAX_CLIP])}else{if(!(ht.inputs.length>=3&&this._allData[ht.inputs[1]].tensor!==void 0&&this._allData[ht.inputs[2]].tensor!==void 0))continue;ct.attributes.set("activation_params","floats",[this._allData[ht.inputs[1]].tensor.floatData[0],this._allData[ht.inputs[2]].tensor.floatData[0]])}ct.attributes.set("activation","string",ht.opType),this.deleteNode(ft[0])}}}}},6231:(et,_)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.now=_.Profiler=_.Logger=void 0;const _e={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},tt={none:new class{log(dt,st,it){}},console:new class{log(dt,st,it){console.log(`${this.color(dt)} ${it?"\x1B[35m"+it+"\x1B[0m ":""}${st}`)}color(dt){switch(dt){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${dt}`)}}}},nt={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1};let rt={"":nt};function ot(dt,st,it,ct){if(st===void 0)return ft=dt,{verbose:ot.verbose.bind(null,ft),info:ot.info.bind(null,ft),warning:ot.warning.bind(null,ft),error:ot.error.bind(null,ft),fatal:ot.fatal.bind(null,ft)};if(it===void 0)at(dt,st);else if(typeof it=="number"&&ct===void 0)at(dt,st);else if(typeof it=="string"&&ct===void 0)at(dt,it,0,st);else{if(typeof it!="string"||typeof ct!="number")throw new TypeError("input is valid");at(dt,it,0,st)}var ft}function at(dt,st,it,ct){const ft=rt[ct||""]||rt[""];_e[dt]<_e[ft.minimalSeverity]||(ft.logDateTime&&(st=`${new Date().toISOString()}|${st}`),ft.logSourceLocation,tt[ft.provider].log(dt,st,ct))}(function(dt){function st(ct){rt={},it("",ct||{})}function it(ct,ft){if(ct==="*")st(ft);else{const ht=rt[ct]||nt;rt[ct]={provider:ft.provider||ht.provider,minimalSeverity:ft.minimalSeverity||ht.minimalSeverity,logDateTime:ft.logDateTime===void 0?ht.logDateTime:ft.logDateTime,logSourceLocation:ft.logSourceLocation===void 0?ht.logSourceLocation:ft.logSourceLocation}}}dt.verbose=function(ct,ft){dt("verbose",ct,ft)},dt.info=function(ct,ft){dt("info",ct,ft)},dt.warning=function(ct,ft){dt("warning",ct,ft)},dt.error=function(ct,ft){dt("error",ct,ft)},dt.fatal=function(ct,ft){dt("fatal",ct,ft)},dt.reset=st,dt.set=it,dt.setWithEnv=function(ct){const ft={};ct.logLevel&&(ft.minimalSeverity=ct.logLevel),it("",ft)}})(ot||(ot={})),_.Logger=ot;class lt{constructor(st,it,ct,ft,ht,mt){this.category=st,this.name=it,this.startTime=ct,this.endCallback=ft,this.timer=ht,this.ctx=mt}end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class ut{constructor(st,it,ct,ft){this.category=st,this.name=it,this.startTime=ct,this.endTime=ft}}_.Profiler=class{static create(dt){return dt===void 0?new this:new this(dt.maxNumberEvents,dt.flushBatchSize,dt.flushIntervalInMilliseconds)}constructor(dt,st,it){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=dt===void 0?1e4:dt,this._flushBatchSize=st===void 0?10:st,this._flushIntervalInMilliseconds=it===void 0?5e3:it}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,_.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(dt,st,it,ct){const ft=this._started?this.begin(dt,st,ct):void 0;let ht=!1;const mt=it();if(mt&&typeof mt.then=="function")return ht=!0,new Promise((pt,_t)=>{mt.then(async vt=>{ft&&await ft.end(),pt(vt)},async vt=>{ft&&await ft.end(),_t(vt)})});if(!ht&&ft){const pt=ft.end();if(pt&&typeof pt.then=="function")return new Promise((_t,vt)=>{pt.then(()=>{_t(mt)},bt=>{vt(bt)})})}return mt}begin(dt,st,it){if(!this._started)throw new Error("profiler is not started yet");if(it===void 0){const ct=(0,_.now)();return this.flush(ct),new lt(dt,st,ct,ft=>this.endSync(ft))}{const ct=it.beginTimer();return new lt(dt,st,0,async ft=>this.end(ft),ct,it)}}async end(dt){const st=await dt.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new ut(dt.category,dt.name,dt.startTime,st)),this.flush(st))}endSync(dt){const st=(0,_.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new ut(dt.category,dt.name,dt.startTime,st)),this.flush(st))}logOneEvent(dt){_.Logger.verbose(`Profiler.${dt.category}`,`${(dt.endTime-dt.startTime).toFixed(2)}ms on event '${dt.name}' at ${dt.endTime.toFixed(2)}`)}flush(dt){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||dt-this._flushTime>=this._flushIntervalInMilliseconds){for(const st=this._flushPointer;this._flushPointer<st+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,_.now)()}}get started(){return this._started}},_.now=typeof performance<"u"&&performance.now?()=>performance.now():Date.now},2644:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.Model=void 0;const tt=_e(5686),nt=_e(1446),rt=_e(7070),ot=_e(9395),at=_e(2517);var lt=ot.onnxruntime.experimental.fbs;_.Model=class{constructor(){}load(ut,dt,st){if(!st)try{return void this.loadFromOnnxFormat(ut,dt)}catch(it){if(st!==void 0)throw it}this.loadFromOrtFormat(ut,dt)}loadFromOnnxFormat(ut,dt){const st=nt.onnx.ModelProto.decode(ut);if(at.LongUtil.longToNumber(st.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=st.opsetImport.map(it=>({domain:it.domain,version:at.LongUtil.longToNumber(it.version)})),this._graph=rt.Graph.from(st.graph,dt)}loadFromOrtFormat(ut,dt){const st=new tt.flatbuffers.ByteBuffer(ut),it=lt.InferenceSession.getRootAsInferenceSession(st).model();if(at.LongUtil.longToNumber(it.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let ct=0;ct<it.opsetImportLength();ct++){const ft=it.opsetImport(ct);this._opsets.push({domain:ft==null?void 0:ft.domain(),version:at.LongUtil.longToNumber(ft.version())})}this._graph=rt.Graph.from(it.graph(),dt)}get graph(){return this._graph}get opsets(){return this._opsets}}},782:(et,_)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.FLOAT_TYPES=_.INT_TYPES=_.NUMBER_TYPES=void 0,_.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],_.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],_.FLOAT_TYPES=["float32","float64"]},1047:(et,_)=>{function _e(tt,nt){if(nt.endsWith("+")){const rt=Number.parseInt(nt.substring(0,nt.length-1),10);return!isNaN(rt)&&rt<=tt}if(nt.split("-").length===2){const rt=nt.split("-"),ot=Number.parseInt(rt[0],10),at=Number.parseInt(rt[1],10);return!isNaN(ot)&&!isNaN(at)&&ot<=tt&&tt<=at}return Number.parseInt(nt,10)===tt}Object.defineProperty(_,"__esModule",{value:!0}),_.resolveOperator=void 0,_.resolveOperator=function(tt,nt,rt){for(const ot of rt){const at=ot[0],lt=ot[1],ut=ot[2],dt=ot[3],st=ot[4];if(tt.opType===at){for(const it of nt)if((it.domain===lt||it.domain==="ai.onnx"&&lt==="")&&_e(it.version,ut))return{opImpl:dt,opInit:st}}}throw new TypeError(`cannot resolve operator '${tt.opType}' with opsets: ${nt.map(ot=>`${ot.domain||"ai.onnx"} v${ot.version}`).join(", ")}`)}},9395:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.onnxruntime=void 0;const tt=_e(5686);var nt,rt;nt=_.onnxruntime||(_.onnxruntime={}),function(ot){(function(at){at[at.UNDEFINED=0]="UNDEFINED",at[at.FLOAT=1]="FLOAT",at[at.INT=2]="INT",at[at.STRING=3]="STRING",at[at.TENSOR=4]="TENSOR",at[at.GRAPH=5]="GRAPH",at[at.FLOATS=6]="FLOATS",at[at.INTS=7]="INTS",at[at.STRINGS=8]="STRINGS",at[at.TENSORS=9]="TENSORS",at[at.GRAPHS=10]="GRAPHS",at[at.SPARSE_TENSOR=11]="SPARSE_TENSOR",at[at.SPARSE_TENSORS=12]="SPARSE_TENSORS"})(ot.AttributeType||(ot.AttributeType={}))}((rt=nt.experimental||(nt.experimental={})).fbs||(rt.fbs={})),function(ot){(function(at){(function(lt){(function(ut){ut[ut.UNKNOWN=0]="UNKNOWN",ut[ut.VALUE=1]="VALUE",ut[ut.PARAM=2]="PARAM"})(lt.DimensionValueType||(lt.DimensionValueType={}))})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){(function(ut){ut[ut.UNDEFINED=0]="UNDEFINED",ut[ut.FLOAT=1]="FLOAT",ut[ut.UINT8=2]="UINT8",ut[ut.INT8=3]="INT8",ut[ut.UINT16=4]="UINT16",ut[ut.INT16=5]="INT16",ut[ut.INT32=6]="INT32",ut[ut.INT64=7]="INT64",ut[ut.STRING=8]="STRING",ut[ut.BOOL=9]="BOOL",ut[ut.FLOAT16=10]="FLOAT16",ut[ut.DOUBLE=11]="DOUBLE",ut[ut.UINT32=12]="UINT32",ut[ut.UINT64=13]="UINT64",ut[ut.COMPLEX64=14]="COMPLEX64",ut[ut.COMPLEX128=15]="COMPLEX128",ut[ut.BFLOAT16=16]="BFLOAT16"})(lt.TensorDataType||(lt.TensorDataType={}))})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){(function(ut){ut[ut.Primitive=0]="Primitive",ut[ut.Fused=1]="Fused"})(lt.NodeType||(lt.NodeType={}))})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){(function(ut){ut[ut.NONE=0]="NONE",ut[ut.tensor_type=1]="tensor_type",ut[ut.sequence_type=2]="sequence_type",ut[ut.map_type=3]="map_type"})(lt.TypeInfoValue||(lt.TypeInfoValue={}))})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){class ut{constructor(){this.bb=null,this.bb_pos=0}__init(st,it){return this.bb_pos=st,this.bb=it,this}static getRootAsShape(st,it){return(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}static getSizePrefixedRootAsShape(st,it){return st.setPosition(st.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}dim(st,it){let ct=this.bb.__offset(this.bb_pos,4);return ct?(it||new ot.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+ct)+4*st),this.bb):null}dimLength(){let st=this.bb.__offset(this.bb_pos,4);return st?this.bb.__vector_len(this.bb_pos+st):0}static startShape(st){st.startObject(1)}static addDim(st,it){st.addFieldOffset(0,it,0)}static createDimVector(st,it){st.startVector(4,it.length,4);for(let ct=it.length-1;ct>=0;ct--)st.addOffset(it[ct]);return st.endVector()}static startDimVector(st,it){st.startVector(4,it,4)}static endShape(st){return st.endObject()}static createShape(st,it){return ut.startShape(st),ut.addDim(st,it),ut.endShape(st)}}lt.Shape=ut})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){class ut{constructor(){this.bb=null,this.bb_pos=0}__init(st,it){return this.bb_pos=st,this.bb=it,this}static getRootAsDimension(st,it){return(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}static getSizePrefixedRootAsDimension(st,it){return st.setPosition(st.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}value(st){let it=this.bb.__offset(this.bb_pos,4);return it?(st||new ot.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+it),this.bb):null}denotation(st){let it=this.bb.__offset(this.bb_pos,6);return it?this.bb.__string(this.bb_pos+it,st):null}static startDimension(st){st.startObject(2)}static addValue(st,it){st.addFieldOffset(0,it,0)}static addDenotation(st,it){st.addFieldOffset(1,it,0)}static endDimension(st){return st.endObject()}static createDimension(st,it,ct){return ut.startDimension(st),ut.addValue(st,it),ut.addDenotation(st,ct),ut.endDimension(st)}}lt.Dimension=ut})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){class ut{constructor(){this.bb=null,this.bb_pos=0}__init(st,it){return this.bb_pos=st,this.bb=it,this}static getRootAsDimensionValue(st,it){return(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}static getSizePrefixedRootAsDimensionValue(st,it){return st.setPosition(st.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}dimType(){let st=this.bb.__offset(this.bb_pos,4);return st?this.bb.readInt8(this.bb_pos+st):ot.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let st=this.bb.__offset(this.bb_pos,6);return st?this.bb.readInt64(this.bb_pos+st):this.bb.createLong(0,0)}dimParam(st){let it=this.bb.__offset(this.bb_pos,8);return it?this.bb.__string(this.bb_pos+it,st):null}static startDimensionValue(st){st.startObject(3)}static addDimType(st,it){st.addFieldInt8(0,it,ot.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(st,it){st.addFieldInt64(1,it,st.createLong(0,0))}static addDimParam(st,it){st.addFieldOffset(2,it,0)}static endDimensionValue(st){return st.endObject()}static createDimensionValue(st,it,ct,ft){return ut.startDimensionValue(st),ut.addDimType(st,it),ut.addDimValue(st,ct),ut.addDimParam(st,ft),ut.endDimensionValue(st)}}lt.DimensionValue=ut})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){class ut{constructor(){this.bb=null,this.bb_pos=0}__init(st,it){return this.bb_pos=st,this.bb=it,this}static getRootAsTensorTypeAndShape(st,it){return(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}static getSizePrefixedRootAsTensorTypeAndShape(st,it){return st.setPosition(st.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}elemType(){let st=this.bb.__offset(this.bb_pos,4);return st?this.bb.readInt32(this.bb_pos+st):ot.experimental.fbs.TensorDataType.UNDEFINED}shape(st){let it=this.bb.__offset(this.bb_pos,6);return it?(st||new ot.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+it),this.bb):null}static startTensorTypeAndShape(st){st.startObject(2)}static addElemType(st,it){st.addFieldInt32(0,it,ot.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(st,it){st.addFieldOffset(1,it,0)}static endTensorTypeAndShape(st){return st.endObject()}static createTensorTypeAndShape(st,it,ct){return ut.startTensorTypeAndShape(st),ut.addElemType(st,it),ut.addShape(st,ct),ut.endTensorTypeAndShape(st)}}lt.TensorTypeAndShape=ut})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){class ut{constructor(){this.bb=null,this.bb_pos=0}__init(st,it){return this.bb_pos=st,this.bb=it,this}static getRootAsMapType(st,it){return(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}static getSizePrefixedRootAsMapType(st,it){return st.setPosition(st.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}keyType(){let st=this.bb.__offset(this.bb_pos,4);return st?this.bb.readInt32(this.bb_pos+st):ot.experimental.fbs.TensorDataType.UNDEFINED}valueType(st){let it=this.bb.__offset(this.bb_pos,6);return it?(st||new ot.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+it),this.bb):null}static startMapType(st){st.startObject(2)}static addKeyType(st,it){st.addFieldInt32(0,it,ot.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(st,it){st.addFieldOffset(1,it,0)}static endMapType(st){return st.endObject()}static createMapType(st,it,ct){return ut.startMapType(st),ut.addKeyType(st,it),ut.addValueType(st,ct),ut.endMapType(st)}}lt.MapType=ut})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){class ut{constructor(){this.bb=null,this.bb_pos=0}__init(st,it){return this.bb_pos=st,this.bb=it,this}static getRootAsSequenceType(st,it){return(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}static getSizePrefixedRootAsSequenceType(st,it){return st.setPosition(st.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}elemType(st){let it=this.bb.__offset(this.bb_pos,4);return it?(st||new ot.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+it),this.bb):null}static startSequenceType(st){st.startObject(1)}static addElemType(st,it){st.addFieldOffset(0,it,0)}static endSequenceType(st){return st.endObject()}static createSequenceType(st,it){return ut.startSequenceType(st),ut.addElemType(st,it),ut.endSequenceType(st)}}lt.SequenceType=ut})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(at.fbs||(at.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(lt,ut){return this.bb_pos=lt,this.bb=ut,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(lt,ut,dt,st){return lt.prep(4,12),lt.writeInt32(st),lt.writeInt32(dt),lt.writeInt32(ut),lt.offset()}}})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){class ut{constructor(){this.bb=null,this.bb_pos=0}__init(st,it){return this.bb_pos=st,this.bb=it,this}static getRootAsNodeEdge(st,it){return(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}static getSizePrefixedRootAsNodeEdge(st,it){return st.setPosition(st.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}nodeIndex(){let st=this.bb.__offset(this.bb_pos,4);return st?this.bb.readUint32(this.bb_pos+st):0}inputEdges(st,it){let ct=this.bb.__offset(this.bb_pos,6);return ct?(it||new ot.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+ct)+12*st,this.bb):null}inputEdgesLength(){let st=this.bb.__offset(this.bb_pos,6);return st?this.bb.__vector_len(this.bb_pos+st):0}outputEdges(st,it){let ct=this.bb.__offset(this.bb_pos,8);return ct?(it||new ot.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+ct)+12*st,this.bb):null}outputEdgesLength(){let st=this.bb.__offset(this.bb_pos,8);return st?this.bb.__vector_len(this.bb_pos+st):0}static startNodeEdge(st){st.startObject(3)}static addNodeIndex(st,it){st.addFieldInt32(0,it,0)}static addInputEdges(st,it){st.addFieldOffset(1,it,0)}static startInputEdgesVector(st,it){st.startVector(12,it,4)}static addOutputEdges(st,it){st.addFieldOffset(2,it,0)}static startOutputEdgesVector(st,it){st.startVector(12,it,4)}static endNodeEdge(st){return st.endObject()}static createNodeEdge(st,it,ct,ft){return ut.startNodeEdge(st),ut.addNodeIndex(st,it),ut.addInputEdges(st,ct),ut.addOutputEdges(st,ft),ut.endNodeEdge(st)}}lt.NodeEdge=ut})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){class ut{constructor(){this.bb=null,this.bb_pos=0}__init(st,it){return this.bb_pos=st,this.bb=it,this}static getRootAsNode(st,it){return(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}static getSizePrefixedRootAsNode(st,it){return st.setPosition(st.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}name(st){let it=this.bb.__offset(this.bb_pos,4);return it?this.bb.__string(this.bb_pos+it,st):null}docString(st){let it=this.bb.__offset(this.bb_pos,6);return it?this.bb.__string(this.bb_pos+it,st):null}domain(st){let it=this.bb.__offset(this.bb_pos,8);return it?this.bb.__string(this.bb_pos+it,st):null}sinceVersion(){let st=this.bb.__offset(this.bb_pos,10);return st?this.bb.readInt32(this.bb_pos+st):0}index(){let st=this.bb.__offset(this.bb_pos,12);return st?this.bb.readUint32(this.bb_pos+st):0}opType(st){let it=this.bb.__offset(this.bb_pos,14);return it?this.bb.__string(this.bb_pos+it,st):null}type(){let st=this.bb.__offset(this.bb_pos,16);return st?this.bb.readInt32(this.bb_pos+st):ot.experimental.fbs.NodeType.Primitive}executionProviderType(st){let it=this.bb.__offset(this.bb_pos,18);return it?this.bb.__string(this.bb_pos+it,st):null}inputs(st,it){let ct=this.bb.__offset(this.bb_pos,20);return ct?this.bb.__string(this.bb.__vector(this.bb_pos+ct)+4*st,it):null}inputsLength(){let st=this.bb.__offset(this.bb_pos,20);return st?this.bb.__vector_len(this.bb_pos+st):0}outputs(st,it){let ct=this.bb.__offset(this.bb_pos,22);return ct?this.bb.__string(this.bb.__vector(this.bb_pos+ct)+4*st,it):null}outputsLength(){let st=this.bb.__offset(this.bb_pos,22);return st?this.bb.__vector_len(this.bb_pos+st):0}attributes(st,it){let ct=this.bb.__offset(this.bb_pos,24);return ct?(it||new ot.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+ct)+4*st),this.bb):null}attributesLength(){let st=this.bb.__offset(this.bb_pos,24);return st?this.bb.__vector_len(this.bb_pos+st):0}inputArgCounts(st){let it=this.bb.__offset(this.bb_pos,26);return it?this.bb.readInt32(this.bb.__vector(this.bb_pos+it)+4*st):0}inputArgCountsLength(){let st=this.bb.__offset(this.bb_pos,26);return st?this.bb.__vector_len(this.bb_pos+st):0}inputArgCountsArray(){let st=this.bb.__offset(this.bb_pos,26);return st?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+st),this.bb.__vector_len(this.bb_pos+st)):null}implicitInputs(st,it){let ct=this.bb.__offset(this.bb_pos,28);return ct?this.bb.__string(this.bb.__vector(this.bb_pos+ct)+4*st,it):null}implicitInputsLength(){let st=this.bb.__offset(this.bb_pos,28);return st?this.bb.__vector_len(this.bb_pos+st):0}static startNode(st){st.startObject(13)}static addName(st,it){st.addFieldOffset(0,it,0)}static addDocString(st,it){st.addFieldOffset(1,it,0)}static addDomain(st,it){st.addFieldOffset(2,it,0)}static addSinceVersion(st,it){st.addFieldInt32(3,it,0)}static addIndex(st,it){st.addFieldInt32(4,it,0)}static addOpType(st,it){st.addFieldOffset(5,it,0)}static addType(st,it){st.addFieldInt32(6,it,ot.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(st,it){st.addFieldOffset(7,it,0)}static addInputs(st,it){st.addFieldOffset(8,it,0)}static createInputsVector(st,it){st.startVector(4,it.length,4);for(let ct=it.length-1;ct>=0;ct--)st.addOffset(it[ct]);return st.endVector()}static startInputsVector(st,it){st.startVector(4,it,4)}static addOutputs(st,it){st.addFieldOffset(9,it,0)}static createOutputsVector(st,it){st.startVector(4,it.length,4);for(let ct=it.length-1;ct>=0;ct--)st.addOffset(it[ct]);return st.endVector()}static startOutputsVector(st,it){st.startVector(4,it,4)}static addAttributes(st,it){st.addFieldOffset(10,it,0)}static createAttributesVector(st,it){st.startVector(4,it.length,4);for(let ct=it.length-1;ct>=0;ct--)st.addOffset(it[ct]);return st.endVector()}static startAttributesVector(st,it){st.startVector(4,it,4)}static addInputArgCounts(st,it){st.addFieldOffset(11,it,0)}static createInputArgCountsVector(st,it){st.startVector(4,it.length,4);for(let ct=it.length-1;ct>=0;ct--)st.addInt32(it[ct]);return st.endVector()}static startInputArgCountsVector(st,it){st.startVector(4,it,4)}static addImplicitInputs(st,it){st.addFieldOffset(12,it,0)}static createImplicitInputsVector(st,it){st.startVector(4,it.length,4);for(let ct=it.length-1;ct>=0;ct--)st.addOffset(it[ct]);return st.endVector()}static startImplicitInputsVector(st,it){st.startVector(4,it,4)}static endNode(st){return st.endObject()}static createNode(st,it,ct,ft,ht,mt,pt,_t,vt,bt,wt,xt,Mt,At){return ut.startNode(st),ut.addName(st,it),ut.addDocString(st,ct),ut.addDomain(st,ft),ut.addSinceVersion(st,ht),ut.addIndex(st,mt),ut.addOpType(st,pt),ut.addType(st,_t),ut.addExecutionProviderType(st,vt),ut.addInputs(st,bt),ut.addOutputs(st,wt),ut.addAttributes(st,xt),ut.addInputArgCounts(st,Mt),ut.addImplicitInputs(st,At),ut.endNode(st)}}lt.Node=ut})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){class ut{constructor(){this.bb=null,this.bb_pos=0}__init(st,it){return this.bb_pos=st,this.bb=it,this}static getRootAsValueInfo(st,it){return(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}static getSizePrefixedRootAsValueInfo(st,it){return st.setPosition(st.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}name(st){let it=this.bb.__offset(this.bb_pos,4);return it?this.bb.__string(this.bb_pos+it,st):null}docString(st){let it=this.bb.__offset(this.bb_pos,6);return it?this.bb.__string(this.bb_pos+it,st):null}type(st){let it=this.bb.__offset(this.bb_pos,8);return it?(st||new ot.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+it),this.bb):null}static startValueInfo(st){st.startObject(3)}static addName(st,it){st.addFieldOffset(0,it,0)}static addDocString(st,it){st.addFieldOffset(1,it,0)}static addType(st,it){st.addFieldOffset(2,it,0)}static endValueInfo(st){return st.endObject()}static createValueInfo(st,it,ct,ft){return ut.startValueInfo(st),ut.addName(st,it),ut.addDocString(st,ct),ut.addType(st,ft),ut.endValueInfo(st)}}lt.ValueInfo=ut})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){class ut{constructor(){this.bb=null,this.bb_pos=0}__init(st,it){return this.bb_pos=st,this.bb=it,this}static getRootAsTypeInfo(st,it){return(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}static getSizePrefixedRootAsTypeInfo(st,it){return st.setPosition(st.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}denotation(st){let it=this.bb.__offset(this.bb_pos,4);return it?this.bb.__string(this.bb_pos+it,st):null}valueType(){let st=this.bb.__offset(this.bb_pos,6);return st?this.bb.readUint8(this.bb_pos+st):ot.experimental.fbs.TypeInfoValue.NONE}value(st){let it=this.bb.__offset(this.bb_pos,8);return it?this.bb.__union(st,this.bb_pos+it):null}static startTypeInfo(st){st.startObject(3)}static addDenotation(st,it){st.addFieldOffset(0,it,0)}static addValueType(st,it){st.addFieldInt8(1,it,ot.experimental.fbs.TypeInfoValue.NONE)}static addValue(st,it){st.addFieldOffset(2,it,0)}static endTypeInfo(st){return st.endObject()}static createTypeInfo(st,it,ct,ft){return ut.startTypeInfo(st),ut.addDenotation(st,it),ut.addValueType(st,ct),ut.addValue(st,ft),ut.endTypeInfo(st)}}lt.TypeInfo=ut})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){class ut{constructor(){this.bb=null,this.bb_pos=0}__init(st,it){return this.bb_pos=st,this.bb=it,this}static getRootAsOperatorSetId(st,it){return(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}static getSizePrefixedRootAsOperatorSetId(st,it){return st.setPosition(st.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}domain(st){let it=this.bb.__offset(this.bb_pos,4);return it?this.bb.__string(this.bb_pos+it,st):null}version(){let st=this.bb.__offset(this.bb_pos,6);return st?this.bb.readInt64(this.bb_pos+st):this.bb.createLong(0,0)}static startOperatorSetId(st){st.startObject(2)}static addDomain(st,it){st.addFieldOffset(0,it,0)}static addVersion(st,it){st.addFieldInt64(1,it,st.createLong(0,0))}static endOperatorSetId(st){return st.endObject()}static createOperatorSetId(st,it,ct){return ut.startOperatorSetId(st),ut.addDomain(st,it),ut.addVersion(st,ct),ut.endOperatorSetId(st)}}lt.OperatorSetId=ut})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){class ut{constructor(){this.bb=null,this.bb_pos=0}__init(st,it){return this.bb_pos=st,this.bb=it,this}static getRootAsTensor(st,it){return(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}static getSizePrefixedRootAsTensor(st,it){return st.setPosition(st.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}name(st){let it=this.bb.__offset(this.bb_pos,4);return it?this.bb.__string(this.bb_pos+it,st):null}docString(st){let it=this.bb.__offset(this.bb_pos,6);return it?this.bb.__string(this.bb_pos+it,st):null}dims(st){let it=this.bb.__offset(this.bb_pos,8);return it?this.bb.readInt64(this.bb.__vector(this.bb_pos+it)+8*st):this.bb.createLong(0,0)}dimsLength(){let st=this.bb.__offset(this.bb_pos,8);return st?this.bb.__vector_len(this.bb_pos+st):0}dataType(){let st=this.bb.__offset(this.bb_pos,10);return st?this.bb.readInt32(this.bb_pos+st):ot.experimental.fbs.TensorDataType.UNDEFINED}rawData(st){let it=this.bb.__offset(this.bb_pos,12);return it?this.bb.readUint8(this.bb.__vector(this.bb_pos+it)+st):0}rawDataLength(){let st=this.bb.__offset(this.bb_pos,12);return st?this.bb.__vector_len(this.bb_pos+st):0}rawDataArray(){let st=this.bb.__offset(this.bb_pos,12);return st?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+st),this.bb.__vector_len(this.bb_pos+st)):null}stringData(st,it){let ct=this.bb.__offset(this.bb_pos,14);return ct?this.bb.__string(this.bb.__vector(this.bb_pos+ct)+4*st,it):null}stringDataLength(){let st=this.bb.__offset(this.bb_pos,14);return st?this.bb.__vector_len(this.bb_pos+st):0}static startTensor(st){st.startObject(6)}static addName(st,it){st.addFieldOffset(0,it,0)}static addDocString(st,it){st.addFieldOffset(1,it,0)}static addDims(st,it){st.addFieldOffset(2,it,0)}static createDimsVector(st,it){st.startVector(8,it.length,8);for(let ct=it.length-1;ct>=0;ct--)st.addInt64(it[ct]);return st.endVector()}static startDimsVector(st,it){st.startVector(8,it,8)}static addDataType(st,it){st.addFieldInt32(3,it,ot.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(st,it){st.addFieldOffset(4,it,0)}static createRawDataVector(st,it){st.startVector(1,it.length,1);for(let ct=it.length-1;ct>=0;ct--)st.addInt8(it[ct]);return st.endVector()}static startRawDataVector(st,it){st.startVector(1,it,1)}static addStringData(st,it){st.addFieldOffset(5,it,0)}static createStringDataVector(st,it){st.startVector(4,it.length,4);for(let ct=it.length-1;ct>=0;ct--)st.addOffset(it[ct]);return st.endVector()}static startStringDataVector(st,it){st.startVector(4,it,4)}static endTensor(st){return st.endObject()}static createTensor(st,it,ct,ft,ht,mt,pt){return ut.startTensor(st),ut.addName(st,it),ut.addDocString(st,ct),ut.addDims(st,ft),ut.addDataType(st,ht),ut.addRawData(st,mt),ut.addStringData(st,pt),ut.endTensor(st)}}lt.Tensor=ut})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){class ut{constructor(){this.bb=null,this.bb_pos=0}__init(st,it){return this.bb_pos=st,this.bb=it,this}static getRootAsSparseTensor(st,it){return(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}static getSizePrefixedRootAsSparseTensor(st,it){return st.setPosition(st.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}values(st){let it=this.bb.__offset(this.bb_pos,4);return it?(st||new ot.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+it),this.bb):null}indices(st){let it=this.bb.__offset(this.bb_pos,6);return it?(st||new ot.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+it),this.bb):null}dims(st){let it=this.bb.__offset(this.bb_pos,8);return it?this.bb.readInt64(this.bb.__vector(this.bb_pos+it)+8*st):this.bb.createLong(0,0)}dimsLength(){let st=this.bb.__offset(this.bb_pos,8);return st?this.bb.__vector_len(this.bb_pos+st):0}static startSparseTensor(st){st.startObject(3)}static addValues(st,it){st.addFieldOffset(0,it,0)}static addIndices(st,it){st.addFieldOffset(1,it,0)}static addDims(st,it){st.addFieldOffset(2,it,0)}static createDimsVector(st,it){st.startVector(8,it.length,8);for(let ct=it.length-1;ct>=0;ct--)st.addInt64(it[ct]);return st.endVector()}static startDimsVector(st,it){st.startVector(8,it,8)}static endSparseTensor(st){return st.endObject()}static createSparseTensor(st,it,ct,ft){return ut.startSparseTensor(st),ut.addValues(st,it),ut.addIndices(st,ct),ut.addDims(st,ft),ut.endSparseTensor(st)}}lt.SparseTensor=ut})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){class ut{constructor(){this.bb=null,this.bb_pos=0}__init(st,it){return this.bb_pos=st,this.bb=it,this}static getRootAsAttribute(st,it){return(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}static getSizePrefixedRootAsAttribute(st,it){return st.setPosition(st.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}name(st){let it=this.bb.__offset(this.bb_pos,4);return it?this.bb.__string(this.bb_pos+it,st):null}docString(st){let it=this.bb.__offset(this.bb_pos,6);return it?this.bb.__string(this.bb_pos+it,st):null}type(){let st=this.bb.__offset(this.bb_pos,8);return st?this.bb.readInt32(this.bb_pos+st):ot.experimental.fbs.AttributeType.UNDEFINED}f(){let st=this.bb.__offset(this.bb_pos,10);return st?this.bb.readFloat32(this.bb_pos+st):0}i(){let st=this.bb.__offset(this.bb_pos,12);return st?this.bb.readInt64(this.bb_pos+st):this.bb.createLong(0,0)}s(st){let it=this.bb.__offset(this.bb_pos,14);return it?this.bb.__string(this.bb_pos+it,st):null}t(st){let it=this.bb.__offset(this.bb_pos,16);return it?(st||new ot.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+it),this.bb):null}g(st){let it=this.bb.__offset(this.bb_pos,18);return it?(st||new ot.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+it),this.bb):null}floats(st){let it=this.bb.__offset(this.bb_pos,20);return it?this.bb.readFloat32(this.bb.__vector(this.bb_pos+it)+4*st):0}floatsLength(){let st=this.bb.__offset(this.bb_pos,20);return st?this.bb.__vector_len(this.bb_pos+st):0}floatsArray(){let st=this.bb.__offset(this.bb_pos,20);return st?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+st),this.bb.__vector_len(this.bb_pos+st)):null}ints(st){let it=this.bb.__offset(this.bb_pos,22);return it?this.bb.readInt64(this.bb.__vector(this.bb_pos+it)+8*st):this.bb.createLong(0,0)}intsLength(){let st=this.bb.__offset(this.bb_pos,22);return st?this.bb.__vector_len(this.bb_pos+st):0}strings(st,it){let ct=this.bb.__offset(this.bb_pos,24);return ct?this.bb.__string(this.bb.__vector(this.bb_pos+ct)+4*st,it):null}stringsLength(){let st=this.bb.__offset(this.bb_pos,24);return st?this.bb.__vector_len(this.bb_pos+st):0}tensors(st,it){let ct=this.bb.__offset(this.bb_pos,26);return ct?(it||new ot.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+ct)+4*st),this.bb):null}tensorsLength(){let st=this.bb.__offset(this.bb_pos,26);return st?this.bb.__vector_len(this.bb_pos+st):0}graphs(st,it){let ct=this.bb.__offset(this.bb_pos,28);return ct?(it||new ot.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+ct)+4*st),this.bb):null}graphsLength(){let st=this.bb.__offset(this.bb_pos,28);return st?this.bb.__vector_len(this.bb_pos+st):0}static startAttribute(st){st.startObject(13)}static addName(st,it){st.addFieldOffset(0,it,0)}static addDocString(st,it){st.addFieldOffset(1,it,0)}static addType(st,it){st.addFieldInt32(2,it,ot.experimental.fbs.AttributeType.UNDEFINED)}static addF(st,it){st.addFieldFloat32(3,it,0)}static addI(st,it){st.addFieldInt64(4,it,st.createLong(0,0))}static addS(st,it){st.addFieldOffset(5,it,0)}static addT(st,it){st.addFieldOffset(6,it,0)}static addG(st,it){st.addFieldOffset(7,it,0)}static addFloats(st,it){st.addFieldOffset(8,it,0)}static createFloatsVector(st,it){st.startVector(4,it.length,4);for(let ct=it.length-1;ct>=0;ct--)st.addFloat32(it[ct]);return st.endVector()}static startFloatsVector(st,it){st.startVector(4,it,4)}static addInts(st,it){st.addFieldOffset(9,it,0)}static createIntsVector(st,it){st.startVector(8,it.length,8);for(let ct=it.length-1;ct>=0;ct--)st.addInt64(it[ct]);return st.endVector()}static startIntsVector(st,it){st.startVector(8,it,8)}static addStrings(st,it){st.addFieldOffset(10,it,0)}static createStringsVector(st,it){st.startVector(4,it.length,4);for(let ct=it.length-1;ct>=0;ct--)st.addOffset(it[ct]);return st.endVector()}static startStringsVector(st,it){st.startVector(4,it,4)}static addTensors(st,it){st.addFieldOffset(11,it,0)}static createTensorsVector(st,it){st.startVector(4,it.length,4);for(let ct=it.length-1;ct>=0;ct--)st.addOffset(it[ct]);return st.endVector()}static startTensorsVector(st,it){st.startVector(4,it,4)}static addGraphs(st,it){st.addFieldOffset(12,it,0)}static createGraphsVector(st,it){st.startVector(4,it.length,4);for(let ct=it.length-1;ct>=0;ct--)st.addOffset(it[ct]);return st.endVector()}static startGraphsVector(st,it){st.startVector(4,it,4)}static endAttribute(st){return st.endObject()}static createAttribute(st,it,ct,ft,ht,mt,pt,_t,vt,bt,wt,xt,Mt,At){return ut.startAttribute(st),ut.addName(st,it),ut.addDocString(st,ct),ut.addType(st,ft),ut.addF(st,ht),ut.addI(st,mt),ut.addS(st,pt),ut.addT(st,_t),ut.addG(st,vt),ut.addFloats(st,bt),ut.addInts(st,wt),ut.addStrings(st,xt),ut.addTensors(st,Mt),ut.addGraphs(st,At),ut.endAttribute(st)}}lt.Attribute=ut})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){class ut{constructor(){this.bb=null,this.bb_pos=0}__init(st,it){return this.bb_pos=st,this.bb=it,this}static getRootAsGraph(st,it){return(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}static getSizePrefixedRootAsGraph(st,it){return st.setPosition(st.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}initializers(st,it){let ct=this.bb.__offset(this.bb_pos,4);return ct?(it||new ot.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+ct)+4*st),this.bb):null}initializersLength(){let st=this.bb.__offset(this.bb_pos,4);return st?this.bb.__vector_len(this.bb_pos+st):0}nodeArgs(st,it){let ct=this.bb.__offset(this.bb_pos,6);return ct?(it||new ot.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+ct)+4*st),this.bb):null}nodeArgsLength(){let st=this.bb.__offset(this.bb_pos,6);return st?this.bb.__vector_len(this.bb_pos+st):0}nodes(st,it){let ct=this.bb.__offset(this.bb_pos,8);return ct?(it||new ot.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+ct)+4*st),this.bb):null}nodesLength(){let st=this.bb.__offset(this.bb_pos,8);return st?this.bb.__vector_len(this.bb_pos+st):0}maxNodeIndex(){let st=this.bb.__offset(this.bb_pos,10);return st?this.bb.readUint32(this.bb_pos+st):0}nodeEdges(st,it){let ct=this.bb.__offset(this.bb_pos,12);return ct?(it||new ot.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+ct)+4*st),this.bb):null}nodeEdgesLength(){let st=this.bb.__offset(this.bb_pos,12);return st?this.bb.__vector_len(this.bb_pos+st):0}inputs(st,it){let ct=this.bb.__offset(this.bb_pos,14);return ct?this.bb.__string(this.bb.__vector(this.bb_pos+ct)+4*st,it):null}inputsLength(){let st=this.bb.__offset(this.bb_pos,14);return st?this.bb.__vector_len(this.bb_pos+st):0}outputs(st,it){let ct=this.bb.__offset(this.bb_pos,16);return ct?this.bb.__string(this.bb.__vector(this.bb_pos+ct)+4*st,it):null}outputsLength(){let st=this.bb.__offset(this.bb_pos,16);return st?this.bb.__vector_len(this.bb_pos+st):0}sparseInitializers(st,it){let ct=this.bb.__offset(this.bb_pos,18);return ct?(it||new ot.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+ct)+4*st),this.bb):null}sparseInitializersLength(){let st=this.bb.__offset(this.bb_pos,18);return st?this.bb.__vector_len(this.bb_pos+st):0}static startGraph(st){st.startObject(8)}static addInitializers(st,it){st.addFieldOffset(0,it,0)}static createInitializersVector(st,it){st.startVector(4,it.length,4);for(let ct=it.length-1;ct>=0;ct--)st.addOffset(it[ct]);return st.endVector()}static startInitializersVector(st,it){st.startVector(4,it,4)}static addNodeArgs(st,it){st.addFieldOffset(1,it,0)}static createNodeArgsVector(st,it){st.startVector(4,it.length,4);for(let ct=it.length-1;ct>=0;ct--)st.addOffset(it[ct]);return st.endVector()}static startNodeArgsVector(st,it){st.startVector(4,it,4)}static addNodes(st,it){st.addFieldOffset(2,it,0)}static createNodesVector(st,it){st.startVector(4,it.length,4);for(let ct=it.length-1;ct>=0;ct--)st.addOffset(it[ct]);return st.endVector()}static startNodesVector(st,it){st.startVector(4,it,4)}static addMaxNodeIndex(st,it){st.addFieldInt32(3,it,0)}static addNodeEdges(st,it){st.addFieldOffset(4,it,0)}static createNodeEdgesVector(st,it){st.startVector(4,it.length,4);for(let ct=it.length-1;ct>=0;ct--)st.addOffset(it[ct]);return st.endVector()}static startNodeEdgesVector(st,it){st.startVector(4,it,4)}static addInputs(st,it){st.addFieldOffset(5,it,0)}static createInputsVector(st,it){st.startVector(4,it.length,4);for(let ct=it.length-1;ct>=0;ct--)st.addOffset(it[ct]);return st.endVector()}static startInputsVector(st,it){st.startVector(4,it,4)}static addOutputs(st,it){st.addFieldOffset(6,it,0)}static createOutputsVector(st,it){st.startVector(4,it.length,4);for(let ct=it.length-1;ct>=0;ct--)st.addOffset(it[ct]);return st.endVector()}static startOutputsVector(st,it){st.startVector(4,it,4)}static addSparseInitializers(st,it){st.addFieldOffset(7,it,0)}static createSparseInitializersVector(st,it){st.startVector(4,it.length,4);for(let ct=it.length-1;ct>=0;ct--)st.addOffset(it[ct]);return st.endVector()}static startSparseInitializersVector(st,it){st.startVector(4,it,4)}static endGraph(st){return st.endObject()}static createGraph(st,it,ct,ft,ht,mt,pt,_t,vt){return ut.startGraph(st),ut.addInitializers(st,it),ut.addNodeArgs(st,ct),ut.addNodes(st,ft),ut.addMaxNodeIndex(st,ht),ut.addNodeEdges(st,mt),ut.addInputs(st,pt),ut.addOutputs(st,_t),ut.addSparseInitializers(st,vt),ut.endGraph(st)}}lt.Graph=ut})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){class ut{constructor(){this.bb=null,this.bb_pos=0}__init(st,it){return this.bb_pos=st,this.bb=it,this}static getRootAsModel(st,it){return(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}static getSizePrefixedRootAsModel(st,it){return st.setPosition(st.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}irVersion(){let st=this.bb.__offset(this.bb_pos,4);return st?this.bb.readInt64(this.bb_pos+st):this.bb.createLong(0,0)}opsetImport(st,it){let ct=this.bb.__offset(this.bb_pos,6);return ct?(it||new ot.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+ct)+4*st),this.bb):null}opsetImportLength(){let st=this.bb.__offset(this.bb_pos,6);return st?this.bb.__vector_len(this.bb_pos+st):0}producerName(st){let it=this.bb.__offset(this.bb_pos,8);return it?this.bb.__string(this.bb_pos+it,st):null}producerVersion(st){let it=this.bb.__offset(this.bb_pos,10);return it?this.bb.__string(this.bb_pos+it,st):null}domain(st){let it=this.bb.__offset(this.bb_pos,12);return it?this.bb.__string(this.bb_pos+it,st):null}modelVersion(){let st=this.bb.__offset(this.bb_pos,14);return st?this.bb.readInt64(this.bb_pos+st):this.bb.createLong(0,0)}docString(st){let it=this.bb.__offset(this.bb_pos,16);return it?this.bb.__string(this.bb_pos+it,st):null}graph(st){let it=this.bb.__offset(this.bb_pos,18);return it?(st||new ot.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+it),this.bb):null}graphDocString(st){let it=this.bb.__offset(this.bb_pos,20);return it?this.bb.__string(this.bb_pos+it,st):null}static startModel(st){st.startObject(9)}static addIrVersion(st,it){st.addFieldInt64(0,it,st.createLong(0,0))}static addOpsetImport(st,it){st.addFieldOffset(1,it,0)}static createOpsetImportVector(st,it){st.startVector(4,it.length,4);for(let ct=it.length-1;ct>=0;ct--)st.addOffset(it[ct]);return st.endVector()}static startOpsetImportVector(st,it){st.startVector(4,it,4)}static addProducerName(st,it){st.addFieldOffset(2,it,0)}static addProducerVersion(st,it){st.addFieldOffset(3,it,0)}static addDomain(st,it){st.addFieldOffset(4,it,0)}static addModelVersion(st,it){st.addFieldInt64(5,it,st.createLong(0,0))}static addDocString(st,it){st.addFieldOffset(6,it,0)}static addGraph(st,it){st.addFieldOffset(7,it,0)}static addGraphDocString(st,it){st.addFieldOffset(8,it,0)}static endModel(st){return st.endObject()}static createModel(st,it,ct,ft,ht,mt,pt,_t,vt,bt){return ut.startModel(st),ut.addIrVersion(st,it),ut.addOpsetImport(st,ct),ut.addProducerName(st,ft),ut.addProducerVersion(st,ht),ut.addDomain(st,mt),ut.addModelVersion(st,pt),ut.addDocString(st,_t),ut.addGraph(st,vt),ut.addGraphDocString(st,bt),ut.endModel(st)}}lt.Model=ut})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){class ut{constructor(){this.bb=null,this.bb_pos=0}__init(st,it){return this.bb_pos=st,this.bb=it,this}static getRootAsKernelCreateInfos(st,it){return(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}static getSizePrefixedRootAsKernelCreateInfos(st,it){return st.setPosition(st.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}nodeIndices(st){let it=this.bb.__offset(this.bb_pos,4);return it?this.bb.readUint32(this.bb.__vector(this.bb_pos+it)+4*st):0}nodeIndicesLength(){let st=this.bb.__offset(this.bb_pos,4);return st?this.bb.__vector_len(this.bb_pos+st):0}nodeIndicesArray(){let st=this.bb.__offset(this.bb_pos,4);return st?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+st),this.bb.__vector_len(this.bb_pos+st)):null}kernelDefHashes(st){let it=this.bb.__offset(this.bb_pos,6);return it?this.bb.readUint64(this.bb.__vector(this.bb_pos+it)+8*st):this.bb.createLong(0,0)}kernelDefHashesLength(){let st=this.bb.__offset(this.bb_pos,6);return st?this.bb.__vector_len(this.bb_pos+st):0}static startKernelCreateInfos(st){st.startObject(2)}static addNodeIndices(st,it){st.addFieldOffset(0,it,0)}static createNodeIndicesVector(st,it){st.startVector(4,it.length,4);for(let ct=it.length-1;ct>=0;ct--)st.addInt32(it[ct]);return st.endVector()}static startNodeIndicesVector(st,it){st.startVector(4,it,4)}static addKernelDefHashes(st,it){st.addFieldOffset(1,it,0)}static createKernelDefHashesVector(st,it){st.startVector(8,it.length,8);for(let ct=it.length-1;ct>=0;ct--)st.addInt64(it[ct]);return st.endVector()}static startKernelDefHashesVector(st,it){st.startVector(8,it,8)}static endKernelCreateInfos(st){return st.endObject()}static createKernelCreateInfos(st,it,ct){return ut.startKernelCreateInfos(st),ut.addNodeIndices(st,it),ut.addKernelDefHashes(st,ct),ut.endKernelCreateInfos(st)}}lt.KernelCreateInfos=ut})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){class ut{constructor(){this.bb=null,this.bb_pos=0}__init(st,it){return this.bb_pos=st,this.bb=it,this}static getRootAsSubGraphSessionState(st,it){return(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}static getSizePrefixedRootAsSubGraphSessionState(st,it){return st.setPosition(st.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}graphId(st){let it=this.bb.__offset(this.bb_pos,4);return it?this.bb.__string(this.bb_pos+it,st):null}sessionState(st){let it=this.bb.__offset(this.bb_pos,6);return it?(st||new ot.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+it),this.bb):null}static startSubGraphSessionState(st){st.startObject(2)}static addGraphId(st,it){st.addFieldOffset(0,it,0)}static addSessionState(st,it){st.addFieldOffset(1,it,0)}static endSubGraphSessionState(st){let it=st.endObject();return st.requiredField(it,4),it}static createSubGraphSessionState(st,it,ct){return ut.startSubGraphSessionState(st),ut.addGraphId(st,it),ut.addSessionState(st,ct),ut.endSubGraphSessionState(st)}}lt.SubGraphSessionState=ut})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){class ut{constructor(){this.bb=null,this.bb_pos=0}__init(st,it){return this.bb_pos=st,this.bb=it,this}static getRootAsSessionState(st,it){return(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}static getSizePrefixedRootAsSessionState(st,it){return st.setPosition(st.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}kernels(st){let it=this.bb.__offset(this.bb_pos,4);return it?(st||new ot.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+it),this.bb):null}subGraphSessionStates(st,it){let ct=this.bb.__offset(this.bb_pos,6);return ct?(it||new ot.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+ct)+4*st),this.bb):null}subGraphSessionStatesLength(){let st=this.bb.__offset(this.bb_pos,6);return st?this.bb.__vector_len(this.bb_pos+st):0}static startSessionState(st){st.startObject(2)}static addKernels(st,it){st.addFieldOffset(0,it,0)}static addSubGraphSessionStates(st,it){st.addFieldOffset(1,it,0)}static createSubGraphSessionStatesVector(st,it){st.startVector(4,it.length,4);for(let ct=it.length-1;ct>=0;ct--)st.addOffset(it[ct]);return st.endVector()}static startSubGraphSessionStatesVector(st,it){st.startVector(4,it,4)}static endSessionState(st){return st.endObject()}static createSessionState(st,it,ct){return ut.startSessionState(st),ut.addKernels(st,it),ut.addSubGraphSessionStates(st,ct),ut.endSessionState(st)}}lt.SessionState=ut})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={})),function(ot){(function(at){(function(lt){class ut{constructor(){this.bb=null,this.bb_pos=0}__init(st,it){return this.bb_pos=st,this.bb=it,this}static getRootAsInferenceSession(st,it){return(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}static getSizePrefixedRootAsInferenceSession(st,it){return st.setPosition(st.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(it||new ut).__init(st.readInt32(st.position())+st.position(),st)}static bufferHasIdentifier(st){return st.__has_identifier("ORTM")}ortVersion(st){let it=this.bb.__offset(this.bb_pos,4);return it?this.bb.__string(this.bb_pos+it,st):null}model(st){let it=this.bb.__offset(this.bb_pos,6);return it?(st||new ot.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+it),this.bb):null}sessionState(st){let it=this.bb.__offset(this.bb_pos,8);return it?(st||new ot.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+it),this.bb):null}static startInferenceSession(st){st.startObject(3)}static addOrtVersion(st,it){st.addFieldOffset(0,it,0)}static addModel(st,it){st.addFieldOffset(1,it,0)}static addSessionState(st,it){st.addFieldOffset(2,it,0)}static endInferenceSession(st){return st.endObject()}static finishInferenceSessionBuffer(st,it){st.finish(it,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(st,it){st.finish(it,"ORTM",!0)}static createInferenceSession(st,it,ct,ft){return ut.startInferenceSession(st),ut.addOrtVersion(st,it),ut.addModel(st,ct),ut.addSessionState(st,ft),ut.endInferenceSession(st)}}lt.InferenceSession=ut})(at.fbs||(at.fbs={}))})(ot.experimental||(ot.experimental={}))}(_.onnxruntime||(_.onnxruntime={}))},7448:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.OnnxjsSessionHandler=void 0;const tt=_e(1670),nt=_e(9162);_.OnnxjsSessionHandler=class{constructor(rt){this.session=rt,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(rt,ot,at){const lt=new Map;for(const st in rt)if(Object.hasOwnProperty.call(rt,st)){const it=rt[st];lt.set(st,new nt.Tensor(it.dims,it.type,void 0,void 0,it.data))}const ut=await this.session.run(lt),dt={};return ut.forEach((st,it)=>{dt[it]=new tt.Tensor(st.type,st.data,st.dims)}),dt}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6919:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.Session=void 0;const tt=_e(7067),nt=_e(1296),rt=_e(7091),ot=_e(1036),at=_e(6231),lt=_e(2644);_.Session=class{constructor(ut={}){this._initialized=!1,this.backendHint=ut.backendHint,this.profiler=at.Profiler.create(ut.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(ut,dt,st){await this.profiler.event("session","Session.loadModel",async()=>{const it=await(0,rt.resolveBackend)(this.backendHint);if(this.sessionHandler=it.createSessionHandler(this.context),this._model=new lt.Model,typeof ut=="string"){const ct=ut.endsWith(".ort");if(typeof fetch>"u"){const ft=await(0,nt.promisify)(tt.readFile)(ut);this.initialize(ft,ct)}else{const ft=await fetch(ut),ht=await ft.arrayBuffer();this.initialize(new Uint8Array(ht),ct)}}else if(ArrayBuffer.isView(ut))this.initialize(ut);else{const ct=new Uint8Array(ut,dt||0,st||ut.byteLength);this.initialize(ct)}})}initialize(ut,dt){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{const st=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(ut,st,dt),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new ot.ExecutionPlan(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(ut){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{const dt=this.normalizeAndValidateInputs(ut),st=await this._executionPlan.execute(this.sessionHandler,dt);return this.createOutput(st)})}normalizeAndValidateInputs(ut){const dt=this._model.graph.getInputNames();if(Array.isArray(ut)){if(ut.length!==dt.length)throw new Error(`incorrect input array length: expected ${dt.length} but got ${ut.length}`)}else{if(ut.size!==dt.length)throw new Error(`incorrect input map size: expected ${dt.length} but got ${ut.size}`);const st=new Array(ut.size);let it=0;for(let ct=0;ct<dt.length;++ct){const ft=ut.get(dt[ct]);if(!ft)throw new Error(`missing input tensor for: '${name}'`);st[it++]=ft}ut=st}if(this.context.graphInputTypes&&this.context.graphInputTypes.length!==0&&this.context.graphInputDims&&this.context.graphInputDims.length!==0)this.validateInputTensorDims(this.context.graphInputDims,ut,!1);else{const st=this._model.graph.getInputIndices(),it=this._model.graph.getValues(),ct=new Array(st.length);for(let ft=0;ft<st.length;++ft){const ht=it[st[ft]];ct[ft]=ht.type.shape.dims,this.context.graphInputTypes.push(ht.type.tensorType),this.context.graphInputDims.push(ut[ft].dims)}this.validateInputTensorDims(ct,ut,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,ut),ut}validateInputTensorTypes(ut,dt){for(let st=0;st<dt.length;st++){const it=ut[st],ct=dt[st].type;if(it!==ct)throw new Error(`input tensor[${st}] check failed: expected type '${it}' but got ${ct}`)}}validateInputTensorDims(ut,dt,st){for(let it=0;it<dt.length;it++){const ct=ut[it],ft=dt[it].dims;if(!this.compareTensorDims(ct,ft,st))throw new Error(`input tensor[${it}] check failed: expected shape '[${ct.join(",")}]' but got [${ft.join(",")}]`)}}compareTensorDims(ut,dt,st){if(ut.length!==dt.length)return!1;for(let it=0;it<ut.length;++it)if(ut[it]!==dt[it]&&(!st||ut[it]!==0))return!1;return!0}createOutput(ut){const dt=this._model.graph.getOutputNames();if(ut.length!==dt.length)throw new Error("expected number of outputs do not match number of generated outputs");const st=new Map;for(let it=0;it<dt.length;++it)st.set(dt[it],ut[it]);return st}initializeOps(ut){const dt=ut.getNodes();this._ops=new Array(dt.length);for(let st=0;st<dt.length;st++)this._ops[st]=this.sessionHandler.resolve(dt[st],this._model.opsets,ut)}}},9162:function(et,_,_e){var tt=this&&this.__importDefault||function(ht){return ht&&ht.__esModule?ht:{default:ht}};Object.defineProperty(_,"__esModule",{value:!0}),_.Tensor=void 0;const nt=_e(3442),rt=tt(_e(3720)),ot=_e(1446),at=_e(9395),lt=_e(2517);var ut=at.onnxruntime.experimental.fbs;class dt{get data(){if(this.cache===void 0){const mt=this.dataProvider(this.dataId);if(mt.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=mt}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(mt){return this.data[lt.ShapeUtil.indicesToOffset(mt,this.strides)]}set(mt,pt){this.data[lt.ShapeUtil.indicesToOffset(mt,this.strides)]=pt}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=lt.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(mt,pt,_t,vt,bt,wt=nt.Guid.create()){this.dims=mt,this.type=pt,this.dataProvider=_t,this.asyncDataProvider=vt,this.cache=bt,this.dataId=wt,this.size=lt.ShapeUtil.validateDimsAndCalcSize(mt);const xt=this.size,Mt=_t===void 0&&vt===void 0&&bt===void 0;if(bt!==void 0&&bt.length!==xt)throw new RangeError("Input dims doesn't match data length.");if(pt==="string"){if(!(bt===void 0||Array.isArray(bt)&&bt.every(At=>typeof At=="string")))throw new TypeError("cache should be a string array");Mt&&(this.cache=new Array(xt))}else{if(bt!==void 0){const At=it(pt);if(!(bt instanceof At))throw new TypeError(`cache should be type ${At.name}`)}if(Mt){const At=new ArrayBuffer(xt*function(St){switch(St){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${St}`)}}(pt));this.cache=function(St,Tt){return new(it(Tt))(St)}(At,pt)}}}static fromProto(mt){if(!mt)throw new Error("cannot construct Value from an empty tensor");const pt=lt.ProtoUtil.tensorDataTypeFromProto(mt.dataType),_t=lt.ProtoUtil.tensorDimsFromProto(mt.dims),vt=new dt(_t,pt);if(pt==="string")mt.stringData.forEach((bt,wt)=>{vt.data[wt]=(0,lt.decodeUtf8String)(bt)});else if(mt.rawData&&typeof mt.rawData.byteLength=="number"&&mt.rawData.byteLength>0){const bt=vt.data,wt=new DataView(mt.rawData.buffer,mt.rawData.byteOffset,mt.rawData.byteLength),xt=st(mt.dataType),Mt=mt.rawData.byteLength/xt;if(mt.rawData.byteLength%xt!=0)throw new Error("invalid buffer length");if(bt.length!==Mt)throw new Error("buffer length mismatch");for(let At=0;At<Mt;At++){const St=ft(wt,mt.dataType,At*xt);bt[At]=St}}else{let bt;switch(mt.dataType){case ot.onnx.TensorProto.DataType.FLOAT:bt=mt.floatData;break;case ot.onnx.TensorProto.DataType.INT32:case ot.onnx.TensorProto.DataType.INT16:case ot.onnx.TensorProto.DataType.UINT16:case ot.onnx.TensorProto.DataType.INT8:case ot.onnx.TensorProto.DataType.UINT8:case ot.onnx.TensorProto.DataType.BOOL:bt=mt.int32Data;break;case ot.onnx.TensorProto.DataType.INT64:bt=mt.int64Data;break;case ot.onnx.TensorProto.DataType.DOUBLE:bt=mt.doubleData;break;case ot.onnx.TensorProto.DataType.UINT32:case ot.onnx.TensorProto.DataType.UINT64:bt=mt.uint64Data;break;default:throw new Error("unspecific error")}if(bt==null)throw new Error("failed to populate data from a tensorproto value");const wt=vt.data;if(wt.length!==bt.length)throw new Error("array length mismatch");for(let xt=0;xt<bt.length;xt++){const Mt=bt[xt];rt.default.isLong(Mt)?wt[xt]=ct(Mt,mt.dataType):wt[xt]=Mt}}return vt}static fromData(mt,pt,_t){return new dt(pt,_t,void 0,void 0,mt)}static fromOrtTensor(mt){if(!mt)throw new Error("cannot construct Value from an empty tensor");const pt=lt.ProtoUtil.tensorDimsFromORTFormat(mt),_t=lt.ProtoUtil.tensorDataTypeFromProto(mt.dataType()),vt=new dt(pt,_t);if(_t==="string")for(let bt=0;bt<mt.stringDataLength();bt++)vt.data[bt]=mt.stringData(bt);else if(mt.rawDataArray()&&typeof mt.rawDataLength()=="number"&&mt.rawDataLength()>0){const bt=vt.data,wt=new DataView(mt.rawDataArray().buffer,mt.rawDataArray().byteOffset,mt.rawDataLength()),xt=st(mt.dataType()),Mt=mt.rawDataLength()/xt;if(mt.rawDataLength()%xt!=0)throw new Error("invalid buffer length");if(bt.length!==Mt)throw new Error("buffer length mismatch");for(let At=0;At<Mt;At++){const St=ft(wt,mt.dataType(),At*xt);bt[At]=St}}return vt}}function st(ht){switch(ht){case ot.onnx.TensorProto.DataType.UINT8:case ot.onnx.TensorProto.DataType.INT8:case ot.onnx.TensorProto.DataType.BOOL:return 1;case ot.onnx.TensorProto.DataType.UINT16:case ot.onnx.TensorProto.DataType.INT16:return 2;case ot.onnx.TensorProto.DataType.FLOAT:case ot.onnx.TensorProto.DataType.INT32:case ot.onnx.TensorProto.DataType.UINT32:return 4;case ot.onnx.TensorProto.DataType.INT64:case ot.onnx.TensorProto.DataType.DOUBLE:case ot.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${ot.onnx.TensorProto.DataType[ht]}`)}}function it(ht){switch(ht){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function ct(ht,mt){if(mt===ot.onnx.TensorProto.DataType.INT64||mt===ut.TensorDataType.INT64){if(ht.greaterThanOrEqual(2147483648)||ht.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(mt!==ot.onnx.TensorProto.DataType.UINT32&&mt!==ut.TensorDataType.UINT32&&mt!==ot.onnx.TensorProto.DataType.UINT64&&mt!==ut.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${ot.onnx.TensorProto.DataType[mt]}`);if(ht.greaterThanOrEqual(4294967296)||ht.lessThan(0))throw new TypeError("uint64 is not supported")}return ht.toNumber()}function ft(ht,mt,pt){switch(mt){case ot.onnx.TensorProto.DataType.BOOL:case ot.onnx.TensorProto.DataType.UINT8:return ht.getUint8(pt);case ot.onnx.TensorProto.DataType.INT8:return ht.getInt8(pt);case ot.onnx.TensorProto.DataType.UINT16:return ht.getUint16(pt,!0);case ot.onnx.TensorProto.DataType.INT16:return ht.getInt16(pt,!0);case ot.onnx.TensorProto.DataType.FLOAT:return ht.getFloat32(pt,!0);case ot.onnx.TensorProto.DataType.INT32:return ht.getInt32(pt,!0);case ot.onnx.TensorProto.DataType.UINT32:return ht.getUint32(pt,!0);case ot.onnx.TensorProto.DataType.INT64:return ct(rt.default.fromBits(ht.getUint32(pt,!0),ht.getUint32(pt+4,!0),!1),mt);case ot.onnx.TensorProto.DataType.DOUBLE:return ht.getFloat64(pt,!0);case ot.onnx.TensorProto.DataType.UINT64:return ct(rt.default.fromBits(ht.getUint32(pt,!0),ht.getUint32(pt+4,!0),!0),mt);default:throw new Error(`cannot read from DataView for type ${ot.onnx.TensorProto.DataType[mt]}`)}}_.Tensor=dt},2517:function(et,_,_e){var tt=this&&this.__importDefault||function(mt){return mt&&mt.__esModule?mt:{default:mt}};Object.defineProperty(_,"__esModule",{value:!0}),_.decodeUtf8String=_.MAX_CLIP=_.MIN_CLIP=_.PoolConvUtil=_.ReduceUtil=_.SplitUtil=_.MathUtil=_.ShapeUtil=_.LongUtil=_.ProtoUtil=_.GemmUtil=_.arrayCopyHelper=_.BroadcastUtil=_.MatMulUtil=_.ArrayUtil=_.assert=_.checkInputsShape=void 0;const nt=_e(5686),rt=tt(_e(3720)),ot=_e(1446),at=_e(9162);_.checkInputsShape=function(mt,...pt){if(!mt||mt.length!==pt.length)return!1;for(let _t=0;_t<mt.length;_t++)if(!mt[_t].dims||mt[_t].dims.length!==pt[_t])return!1;return!0},_.assert=function(mt,pt){if(!mt)throw new Error(typeof pt=="string"?pt:pt())},_.ArrayUtil=class{static arraysEqual(mt,pt){if(mt.length!==pt.length)return!1;for(let _t=0;_t<mt.length;_t++)if(mt[_t]!==pt[_t])return!1;return!0}};class lt{static preprocessInputShapes(pt,_t){return[pt.length===1?[1,pt[0]]:pt,_t.length===1?[_t[0],1]:_t]}static postprocessOutputShape(pt,_t,vt){_t===1&&pt.splice(pt.length-2,1),vt===1&&pt.pop()}static calcMatMulShape(pt,_t){return pt[1]!==_t[0]?void 0:[pt[0],_t[1]]}}_.MatMulUtil=lt;class ut{static calcShape(pt,_t,vt=!1){const bt=pt.length,wt=_t.length;if(bt===0)return _t;if(wt===0)return pt;const xt=Math.max(pt.length,_t.length),Mt=new Array(xt);if(vt){if(bt<2||wt<2)return;const At=lt.calcMatMulShape([pt[bt-2],pt[bt-1]],[_t[wt-2],_t[wt-1]]);if(At===void 0)return;[Mt[xt-2],Mt[xt-1]]=At}for(let At=vt?3:1;At<=xt;At++){const St=bt-At<0?1:pt[bt-At],Tt=wt-At<0?1:_t[wt-At];if(St!==Tt&&St>1&&Tt>1)return;Mt[xt-At]=Math.max(St,Tt)}return Mt}static index(pt,_t){const vt=new Array(_t.length);return ut.fillIndex(pt,_t,vt),vt}static fillIndex(pt,_t,vt){const bt=pt.length-_t.length;for(let wt=0;wt<_t.length;wt++)vt[wt]=pt[bt+wt]%_t[wt]}static calc(pt,_t,vt,bt,wt){const xt=ut.calcShape(pt.dims,_t.dims);if(xt){if(bt&&!it.areEqual(xt,pt.dims))return;const Mt=it.size(xt),At=bt?pt:new at.Tensor(xt,wt||pt.type);if(xt.length===0)At.set([],vt(pt.get([]),_t.get([])));else{const St=new Array(xt.length),Tt=new Array(pt.dims.length),Ct=new Array(_t.dims.length);let It,$t=0,Nt=0,Bt=!1,Ot=!1;pt.dims.length===0&&($t=pt.get([]),Bt=!0),_t.dims.length===0&&(Nt=_t.get([]),Ot=!0);for(let Ut=0;Ut<Mt;Ut++){It=Ut;for(let Lt=xt.length-1;Lt>=0;Lt--)St[Lt]=It%xt[Lt],It=Math.floor(It/xt[Lt]);Bt||(ut.fillIndex(St,pt.dims,Tt),$t=pt.get(Tt)),Ot||(ut.fillIndex(St,_t.dims,Ct),Nt=_t.get(Ct)),At.set(St,vt($t,Nt))}}return At}}static isValidBroadcast(pt,_t){const vt=pt.length,bt=_t.length;if(vt>bt)return!1;for(let wt=1;wt<=vt;wt++)if(pt[vt-wt]!==1&&pt[vt-wt]!==_t[bt-wt])return!1;return!0}static getBroadcastDims(pt,_t){const vt=pt.length,bt=[];for(let wt=0;wt<vt;wt++){const xt=vt-1-wt,Mt=pt[xt]||1;(_t[_t.length-1-wt]||1)>1&&Mt===1&&bt.unshift(xt)}return bt}}_.BroadcastUtil=ut,_.arrayCopyHelper=function(mt,pt,_t,vt,bt){if(vt<0||vt>=pt.length)throw new Error("sourceIndex out of bounds");if(_t<0||_t>=mt.length)throw new Error("targetIndex out of bounds");if(vt+bt>pt.length)throw new Error("source indices to be copied are outside bounds");if(_t+bt>mt.length)throw new Error("target array is too small to hold result");for(let wt=0;wt<bt;wt++)mt[_t+wt]=pt[vt+wt]},_.GemmUtil=class{static getShapeOfGemmResult(mt,pt,_t,vt,bt){if(mt.length!==2||_t.length!==2)throw new Error("shape need to be of size 2");let wt,xt,Mt;pt?(wt=mt[1],xt=mt[0]):(wt=mt[0],xt=mt[1]);let At=-1;if(vt?(Mt=_t[0],At=1):(Mt=_t[1],At=0),_t[At]!==xt)throw new Error("dimension mismatch");if(wt<=0||Mt<=0||xt<=0)throw new Error("invalid shape specified");if(bt&&!ut.isValidBroadcast(bt,[wt,Mt]))throw new Error("gemm: invalid bias shape for broadcast");return[wt,Mt,xt]}};class dt{static tensorDataTypeFromProto(pt){switch(pt){case ot.onnx.TensorProto.DataType.INT8:return"int8";case ot.onnx.TensorProto.DataType.UINT8:return"uint8";case ot.onnx.TensorProto.DataType.BOOL:return"bool";case ot.onnx.TensorProto.DataType.INT16:return"int16";case ot.onnx.TensorProto.DataType.UINT16:return"uint16";case ot.onnx.TensorProto.DataType.INT32:return"int32";case ot.onnx.TensorProto.DataType.UINT32:return"uint32";case ot.onnx.TensorProto.DataType.FLOAT:return"float32";case ot.onnx.TensorProto.DataType.DOUBLE:return"float64";case ot.onnx.TensorProto.DataType.STRING:return"string";case ot.onnx.TensorProto.DataType.INT64:return"int32";case ot.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${ot.onnx.TensorProto.DataType[pt]}`)}}static tensorDataTypeStringToEnum(pt){switch(pt){case"int8":return ot.onnx.TensorProto.DataType.INT8;case"uint8":return ot.onnx.TensorProto.DataType.UINT8;case"bool":return ot.onnx.TensorProto.DataType.BOOL;case"int16":return ot.onnx.TensorProto.DataType.INT16;case"uint16":return ot.onnx.TensorProto.DataType.UINT16;case"int32":return ot.onnx.TensorProto.DataType.INT32;case"uint32":return ot.onnx.TensorProto.DataType.UINT32;case"float32":return ot.onnx.TensorProto.DataType.FLOAT;case"float64":return ot.onnx.TensorProto.DataType.DOUBLE;case"string":return ot.onnx.TensorProto.DataType.STRING;case"int64":return ot.onnx.TensorProto.DataType.INT64;case"uint64":return ot.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${pt}`)}}static tensorDimsFromProto(pt){return pt.map(_t=>rt.default.isLong(_t)?_t.toNumber():_t)}static tensorValueTypeFromProto(pt){return{tensorType:dt.tensorDataTypeFromProto(pt.elemType),shape:{dims:dt.tensorDimsFromProto(pt.shape.dim.map(_t=>_t.dimValue))}}}static tensorDimsFromORTFormat(pt){const _t=[];for(let vt=0;vt<pt.dimsLength();vt++)_t.push(st.longToNumber(pt.dims(vt)));return _t}static tensorAttributesFromORTFormat(pt){const _t=[];for(let vt=0;vt<pt.attributesLength();vt++)_t.push(pt.attributes(vt));return _t}}_.ProtoUtil=dt;class st{static longToNumber(pt,_t){return rt.default.isLong(pt)?pt.toNumber():pt instanceof nt.flatbuffers.Long?rt.default.fromValue({low:pt.low,high:pt.high,unsigned:_t!=null&&_t}).toNumber():pt}static isLong(pt){return rt.default.isLong(pt)||pt instanceof nt.flatbuffers.Long}}_.LongUtil=st;class it{static size(pt){return it.getSizeFromDimensionRange(pt,0,pt.length)}static sizeFromDimension(pt,_t){if(_t<0||_t>pt.length)throw new Error(`invalid dimension of ${_t} for sizeFromDimension as Tensor has ${pt.length} dimensions.`);return it.getSizeFromDimensionRange(pt,_t,pt.length)}static sizeToDimension(pt,_t){if(_t<0||_t>pt.length)throw new Error(`invalid dimension of ${_t} for sizeToDimension as Tensor has ${pt.length} dimensions.`);return it.getSizeFromDimensionRange(pt,0,_t)}static getSizeFromDimensionRange(pt,_t,vt){let bt=1;for(let wt=_t;wt<vt;wt++){if(pt[wt]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");bt*=pt[wt]}return bt}static computeStrides(pt){const _t=pt.length;if(_t===0)return[];if(_t===1)return[1];const vt=new Array(_t);vt[_t-1]=1,vt[_t-2]=pt[_t-1];for(let bt=_t-3;bt>=0;--bt)vt[bt]=vt[bt+1]*pt[bt+1];return vt}static transpose(pt){return pt.slice().reverse()}static indicesToOffset(pt,_t,vt){vt===void 0&&(vt=pt.length);let bt=0;for(let wt=0;wt<vt;++wt)bt+=_t[wt]*pt[wt];return bt}static offsetToIndices(pt,_t){const vt=_t.length;if(vt===0)return[];if(vt===1)return[pt*_t[0]];const bt=new Array(_t.length);for(let wt=0;wt<bt.length-1;++wt)bt[wt]=Math.floor(pt/_t[wt]),pt-=bt[wt]*_t[wt];return bt[bt.length-1]=pt,bt}static normalizeAxis(pt,_t){if(pt<-_t&&pt>=_t)throw new Error("unsupported axis for this operation.");return pt<0?pt+_t:pt}static normalizeAxes(pt,_t){return pt.map(vt=>this.normalizeAxis(vt,_t))}static incrementIndex(pt,_t,vt){if(_t.length===0||pt.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(vt===void 0)vt=_t.length;else if(vt<=0||vt>_t.length)throw new Error("Incorrect axis to increment on");for(let bt=vt-1;bt>=0&&(pt[bt]++,!(pt[bt]<_t[bt]));--bt)pt[bt]=0}static calculateReshapedDims(pt,_t){if(_t.length===0){if(pt.length===0||it.size(pt)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}const vt=_t.length,bt=new Array(vt);let wt=-1,xt=1;for(let At=0;At<vt;At++){if(_t[At]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(_t[At]===-1){if(wt!==-1)throw new Error("at most one dimension in shape hints can be -1");wt=At}else{if(_t[At]===0){if(At>=pt.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");bt[At]=pt[At]}else bt[At]=_t[At];xt*=bt[At]}}const Mt=it.size(pt);if(wt!==-1){if(Mt%xt!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${pt}] Output shape: [${_t}]`);bt[wt]=Mt/xt}else if(xt!==Mt)throw new Error("reshapedDims and originalDims don't have matching sizes");return bt}static sortBasedOnPerm(pt,_t){return _t?_t.map(vt=>pt[vt]):pt.slice().reverse()}static padShape(pt,_t){const vt=pt.length;return pt.map((bt,wt)=>bt+_t[wt]+_t[wt+vt])}static areEqual(pt,_t){return pt.length===_t.length&&pt.every((vt,bt)=>vt===_t[bt])}static validateDimsAndCalcSize(pt){if(pt.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let _t=1;for(const vt of pt){if(!Number.isInteger(vt))throw new TypeError(`Invalid shape: ${vt} is not an integer`);if(vt<0||vt>2147483647)throw new TypeError(`Invalid shape: length ${vt} is not allowed`);_t*=vt}return _t}static flattenShape(pt,_t){_t<0&&(_t+=pt.length);const vt=pt.reduce((wt,xt)=>wt*xt,1),bt=pt.slice(_t).reduce((wt,xt)=>wt*xt,1);return[vt/bt,bt]}static squeezeShape(pt,_t){const vt=new Array;_t=it.normalizeAxes(_t,pt.length);for(let bt=0;bt<pt.length;bt++){const wt=_t.indexOf(bt)>=0;if(wt&&pt[bt]!==1)throw new Error("squeeze an axis of size different than 1");(_t.length===0&&pt[bt]>1||_t.length>0&&!wt)&&vt.push(pt[bt])}return vt}static unsqueezeShape(pt,_t){const vt=new Array(pt.length+_t.length);vt.fill(0);for(let wt=0;wt<_t.length;wt++){const xt=it.normalizeAxis(_t[wt],vt.length);if(xt>=vt.length)throw new Error("'axes' has an out of range axis");if(vt[xt]!==0)throw new Error("'axes' has a duplicate axis");vt[xt]=1}let bt=0;for(let wt=0;wt<vt.length;wt++)vt[wt]===0&&(vt[wt]=pt[bt++]);if(bt!==pt.length)throw new Error("the unsqueezed dimension could not be established");return vt}}_.ShapeUtil=it,_.MathUtil=class{static sqr(mt,pt,_t,vt,bt){if(vt<0||vt>=pt.length)throw new Error("sourceIndex out of bounds");if(_t<0||_t>=mt.length)throw new Error("targetIndex out of bounds");if(vt+bt>pt.length)throw new Error("source indices to be copied are outside bounds");if(_t+bt>mt.length)throw new Error("target array is too small to hold result");for(let wt=0;wt<bt;wt++)mt[_t+wt]+=Math.pow(pt[vt+wt],2)}static axpy(mt,pt,_t,vt,bt,wt){if(vt<0||vt>=pt.length)throw new Error("sourceIndex out of bounds");if(_t<0||_t>=mt.length)throw new Error("targetIndex out of bounds");if(vt+bt>pt.length)throw new Error("source indices to be copied are outside bounds");if(_t+bt>mt.length)throw new Error("target array is too small to hold result");for(let xt=0;xt<bt;xt++)mt[_t+xt]+=wt*pt[vt+xt]}static powx(mt,pt,_t,vt,bt,wt){if(vt<0||vt>=pt.length)throw new Error("sourceIndex out of bounds");if(_t<0||_t>=mt.length)throw new Error("targetIndex out of bounds");if(vt+bt>pt.length)throw new Error("source indices to be copied are outside bounds");if(_t+bt>mt.length)throw new Error("target array is too small to hold result");for(let xt=0;xt<bt;xt++)mt[_t+xt]=Math.pow(pt[vt+xt],wt)}static mul(mt,pt,_t,vt,bt){if(vt<0||vt>=pt.length)throw new Error("sourceIndex out of bounds");if(_t<0||_t>=mt.length)throw new Error("targetIndex out of bounds");if(vt+bt>pt.length)throw new Error("source indices to be copied are outside bounds");if(_t+bt>mt.length)throw new Error("target array is too small to hold result");for(let wt=0;wt<bt;wt++)mt[_t+wt]=pt[vt+wt]*mt[_t+wt]}};class ct{static splitShape(pt,_t,vt,bt){if(vt.length===0){if(!bt)throw new Error("need to know number of outputs when the 'split' attribute is not specified");ct.determineSplit(pt[_t],bt,vt)}const wt=[],xt=[0];for(let Mt=0;Mt<vt.length;++Mt){Mt!==0&&xt.push(xt[Mt-1]+vt[Mt-1]);const At=pt.slice();At[_t]=vt[Mt],wt.push(At)}return[wt,xt]}static determineSplit(pt,_t,vt){if(pt%_t!=0)throw new Error("cannot split tensor to equal sized parts");for(let bt=0;bt<_t;++bt)vt.push(pt/_t)}}_.SplitUtil=ct;class ft{static calcReduce(pt,_t,vt,bt,wt){const xt=pt.dims.slice(0);_t.length===0&&xt.forEach(($t,Nt)=>_t.push(Nt));const Mt=ft.calcReduceShape(xt,_t,!0),At=it.size(Mt),St=new at.Tensor(Mt,pt.type),Tt=it.computeStrides(Mt),Ct=it.computeStrides(xt),It=new Array(xt.length);for(let $t=0;$t<At;$t++){const Nt=it.offsetToIndices($t,Tt);ut.fillIndex(Nt,xt,It),St.set(Nt,ft.calcReduceByAxis(pt.numberData,_t,xt,0,it.indicesToOffset(It,Ct),bt,wt))}return vt?St:new at.Tensor(ft.calcReduceShape(xt,_t,vt),St.type,void 0,void 0,St.data,St.dataId)}static calcReduceByAxis(pt,_t,vt,bt,wt,xt,Mt){let At=0;if(bt>=_t.length)return xt(pt[wt]);const St=_t[bt],Tt=St>=vt.length?1:it.size(vt.slice(St+1));for(let Ct=0;Ct<vt[St];Ct++)At=Ct===0?ft.calcReduceByAxis(pt,_t,vt,bt+1,wt,xt,Mt):Mt(At,ft.calcReduceByAxis(pt,_t,vt,bt+1,wt,xt,Mt)),wt+=Tt;return At}static calcReduceShape(pt,_t,vt){const bt=pt.slice();for(let wt=0;wt<_t.length;wt++)bt[_t[wt]]=vt?1:0;return bt.filter(wt=>wt!==0)}}_.ReduceUtil=ft;class ht{static adjustPoolAttributes(pt,_t,vt,bt,wt,xt){if(!pt&&vt.length!==_t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(pt)for(let Mt=0;Mt<_t.length-2;Mt++)Mt>=vt.length?vt.push(_t[Mt+2]):vt[Mt]=_t[Mt+2];for(let Mt=0;Mt<vt.length;Mt++)if(Mt<bt.length){if(bt[Mt]<0)throw new Error("strides should be greater than or equal to 1")}else bt.push(1);for(let Mt=0;Mt<vt.length;Mt++)if(Mt<wt.length){if(wt[Mt]<0)throw new Error("dilations should be greater than or equal to 1")}else wt.push(1);for(let Mt=0;Mt<2*vt.length;Mt++)if(Mt<xt.length){if(xt[Mt]<0)throw new Error("pad should be greater than or equal to 1")}else xt.push(0);for(let Mt=0;Mt<vt.length;Mt++){if(vt[Mt]<=0)throw new Error("kernel shapes need to be greater than 0");if(xt[Mt]>=vt[Mt]||xt[Mt+vt.length]>=vt[Mt])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(pt,_t,vt,bt,wt,xt){if(xt){if(wt.length!==2*(pt.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(_t.length!==pt.length-2)throw new Error("length of strides should be the length of data dimensions");if(bt.length!==pt.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let Mt=0;Mt<pt.length-2;Mt++)ht.adjustPadAndReturnShape(pt[Mt+2],_t[Mt],vt[Mt],bt[Mt],wt,Mt,Mt+pt.length-2,xt)}}static computePoolOutputShape(pt,_t,vt,bt,wt,xt,Mt){if(_t.length<=0)throw new Error("input shape must be of size greater than 0");const At=[_t[0],_t[1]];return ht.computeShapeHelper(pt,_t,At,vt,bt,wt,xt,Mt),At}static computeConvOutputShape(pt,_t,vt,bt,wt,xt,Mt){if(pt.length<=0||_t.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const At=[pt[0],_t[0]];return ht.computeShapeHelper(!1,pt,At,vt,bt,wt,xt,Mt),At}static computeShapeHelper(pt,_t,vt,bt,wt,xt,Mt,At){if(pt)for(let St=0;St<_t.length-2;St++)vt.push(1);else for(let St=0;St<_t.length-2;St++)vt.push(ht.adjustPadAndReturnShape(_t[St+2],bt[St],wt[St],xt[St],Mt,St,St+_t.length-2,At))}static adjustPadAndReturnShape(pt,_t,vt,bt,wt,xt,Mt,At){const St=vt*(bt-1)+1;if(!At||At==="NOTSET")return Math.floor((pt+wt[xt]+wt[Mt]-St)/_t+1);switch(At){case"VALID":return wt[xt]=0,wt[Mt]=0,Math.floor((pt-St)/_t+1);case"SAME_LOWER":case"SAME_UPPER":if(vt!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const Tt=((pt+_t-1)/_t-1)*_t+bt-pt;return wt[xt]=Math.floor(At==="SAME_LOWER"?(Tt+1)/2:Tt/2),wt[Mt]=Tt-wt[xt],Math.floor((pt+Tt-bt)/_t+1)}default:throw new Error("Unsupported AutoPad type")}}}_.PoolConvUtil=ht,_.MIN_CLIP=-34028234663852886e22,_.MAX_CLIP=34028234663852886e22,_.decodeUtf8String=function(mt){return new TextDecoder().decode(mt)}},7967:(et,_)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.iterateExtraOptions=void 0,_.iterateExtraOptions=(_e,tt,nt,rt)=>{if(typeof _e=="object"&&_e!==null){if(nt.has(_e))throw new Error("Circular reference in options");nt.add(_e)}Object.entries(_e).forEach(([ot,at])=>{const lt=tt?tt+ot:ot;if(typeof at=="object")(0,_.iterateExtraOptions)(at,lt+".",nt,rt);else if(typeof at=="string"||typeof at=="number")rt(lt,at.toString());else{if(typeof at!="boolean")throw new Error("Can't handle extra config type: "+typeof at);rt(lt,at?"1":"0")}})}},2157:function(et,_,_e){var tt,nt=this&&this.__createBinding||(Object.create?function(Tt,Ct,It,$t){$t===void 0&&($t=It);var Nt=Object.getOwnPropertyDescriptor(Ct,It);Nt&&!("get"in Nt?!Ct.__esModule:Nt.writable||Nt.configurable)||(Nt={enumerable:!0,get:function(){return Ct[It]}}),Object.defineProperty(Tt,$t,Nt)}:function(Tt,Ct,It,$t){$t===void 0&&($t=It),Tt[$t]=Ct[It]}),rt=this&&this.__setModuleDefault||(Object.create?function(Tt,Ct){Object.defineProperty(Tt,"default",{enumerable:!0,value:Ct})}:function(Tt,Ct){Tt.default=Ct}),ot=this&&this.__importStar||function(Tt){if(Tt&&Tt.__esModule)return Tt;var Ct={};if(Tt!=null)for(var It in Tt)It!=="default"&&Object.prototype.hasOwnProperty.call(Tt,It)&&nt(Ct,Tt,It);return rt(Ct,Tt),Ct};Object.defineProperty(_,"__esModule",{value:!0}),_.endProfiling=_.run=_.releaseSession=_.createSession=_.createSessionFinalize=_.createSessionAllocate=_.initOrt=_.initWasm=void 0;const at=_e(1670),lt=ot(_e(349)),ut=_e(6361),dt=()=>!!at.env.wasm.proxy&&typeof document<"u";let st,it,ct,ft=!1,ht=!1,mt=!1;const pt=[],_t=[],vt=[],bt=[],wt=[],xt=[],Mt=()=>{if(ft||!ht||mt||!st)throw new Error("worker not ready")},At=Tt=>{switch(Tt.data.type){case"init-wasm":ft=!1,Tt.data.err?(mt=!0,it[1](Tt.data.err)):(ht=!0,it[0]());break;case"init-ort":Tt.data.err?ct[1](Tt.data.err):ct[0]();break;case"create_allocate":Tt.data.err?pt.shift()[1](Tt.data.err):pt.shift()[0](Tt.data.out);break;case"create_finalize":Tt.data.err?_t.shift()[1](Tt.data.err):_t.shift()[0](Tt.data.out);break;case"create":Tt.data.err?vt.shift()[1](Tt.data.err):vt.shift()[0](Tt.data.out);break;case"release":Tt.data.err?bt.shift()[1](Tt.data.err):bt.shift()[0]();break;case"run":Tt.data.err?wt.shift()[1](Tt.data.err):wt.shift()[0](Tt.data.out);break;case"end-profiling":Tt.data.err?xt.shift()[1](Tt.data.err):xt.shift()[0]()}},St=typeof document<"u"?(tt=document==null?void 0:document.currentScript)===null||tt===void 0?void 0:tt.src:void 0;_.initWasm=async()=>{if(dt()){if(ht)return;if(ft)throw new Error("multiple calls to 'initWasm()' detected.");if(mt)throw new Error("previous call to 'initWasm()' failed.");return ft=!0,at.env.wasm.wasmPaths===void 0&&St&&St.indexOf("blob:")!==0&&(at.env.wasm.wasmPaths=St.substr(0,+St.lastIndexOf("/")+1)),new Promise((Tt,Ct)=>{st==null||st.terminate(),st=_e(9710).Z(),st.onmessage=At,it=[Tt,Ct];const It={type:"init-wasm",in:at.env.wasm};st.postMessage(It)})}return(0,ut.initializeWebAssembly)(at.env.wasm)},_.initOrt=async(Tt,Ct)=>{if(dt())return Mt(),new Promise((It,$t)=>{ct=[It,$t];const Nt={type:"init-ort",in:{numThreads:Tt,loggingLevel:Ct}};st.postMessage(Nt)});lt.initOrt(Tt,Ct)},_.createSessionAllocate=async Tt=>dt()?(Mt(),new Promise((Ct,It)=>{pt.push([Ct,It]);const $t={type:"create_allocate",in:{model:Tt}};st.postMessage($t,[Tt.buffer])})):lt.createSessionAllocate(Tt),_.createSessionFinalize=async(Tt,Ct)=>dt()?(Mt(),new Promise((It,$t)=>{_t.push([It,$t]);const Nt={type:"create_finalize",in:{modeldata:Tt,options:Ct}};st.postMessage(Nt)})):lt.createSessionFinalize(Tt,Ct),_.createSession=async(Tt,Ct)=>dt()?(Mt(),new Promise((It,$t)=>{vt.push([It,$t]);const Nt={type:"create",in:{model:Tt,options:Ct}};st.postMessage(Nt,[Tt.buffer])})):lt.createSession(Tt,Ct),_.releaseSession=async Tt=>{if(dt())return Mt(),new Promise((Ct,It)=>{bt.push([Ct,It]);const $t={type:"release",in:Tt};st.postMessage($t)});lt.releaseSession(Tt)},_.run=async(Tt,Ct,It,$t,Nt)=>dt()?(Mt(),new Promise((Bt,Ot)=>{wt.push([Bt,Ot]);const Ut={type:"run",in:{sessionId:Tt,inputIndices:Ct,inputs:It,outputIndices:$t,options:Nt}};st.postMessage(Ut,lt.extractTransferableBuffers(It))})):lt.run(Tt,Ct,It,$t,Nt),_.endProfiling=async Tt=>{if(dt())return Mt(),new Promise((Ct,It)=>{xt.push([Ct,It]);const $t={type:"end-profiling",in:Tt};st.postMessage($t)});lt.endProfiling(Tt)}},586:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.setRunOptions=void 0;const tt=_e(7967),nt=_e(4983),rt=_e(6361);_.setRunOptions=ot=>{const at=(0,rt.getInstance)();let lt=0;const ut=[],dt=ot||{};try{if((ot==null?void 0:ot.logSeverityLevel)===void 0)dt.logSeverityLevel=2;else if(typeof ot.logSeverityLevel!="number"||!Number.isInteger(ot.logSeverityLevel)||ot.logSeverityLevel<0||ot.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${ot.logSeverityLevel}`);if((ot==null?void 0:ot.logVerbosityLevel)===void 0)dt.logVerbosityLevel=0;else if(typeof ot.logVerbosityLevel!="number"||!Number.isInteger(ot.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${ot.logVerbosityLevel}`);(ot==null?void 0:ot.terminate)===void 0&&(dt.terminate=!1);let st=0;if((ot==null?void 0:ot.tag)!==void 0&&(st=(0,nt.allocWasmString)(ot.tag,ut)),lt=at._OrtCreateRunOptions(dt.logSeverityLevel,dt.logVerbosityLevel,!!dt.terminate,st),lt===0)throw new Error("Can't create run options");return(ot==null?void 0:ot.extra)!==void 0&&(0,tt.iterateExtraOptions)(ot.extra,"",new WeakSet,(it,ct)=>{const ft=(0,nt.allocWasmString)(it,ut),ht=(0,nt.allocWasmString)(ct,ut);if(at._OrtAddRunConfigEntry(lt,ft,ht)!==0)throw new Error(`Can't set a run config entry: ${it} - ${ct}`)}),[lt,ut]}catch(st){throw lt!==0&&at._OrtReleaseRunOptions(lt),ut.forEach(at._free),st}}},2306:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.OnnxruntimeWebAssemblySessionHandler=void 0;const tt=_e(2806),nt=_e(1670),rt=_e(2850),ot=_e(2157);let at;_.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(lt){const ut=await fetch(lt),dt=await ut.arrayBuffer();return(0,ot.createSessionAllocate)(new Uint8Array(dt))}async loadModel(lt,ut){if(at||(await(0,ot.initOrt)(nt.env.wasm.numThreads,(dt=>{switch(dt){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${dt}`)}})(nt.env.logLevel)),at=!0),typeof lt=="string")if(typeof fetch>"u"){const dt=await(0,rt.promisify)(tt.readFile)(lt);[this.sessionId,this.inputNames,this.outputNames]=await(0,ot.createSession)(dt,ut)}else{const dt=await this.createSessionAllocate(lt);[this.sessionId,this.inputNames,this.outputNames]=await(0,ot.createSessionFinalize)(dt,ut)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,ot.createSession)(lt,ut)}async dispose(){return(0,ot.releaseSession)(this.sessionId)}async run(lt,ut,dt){const st=[],it=[];Object.entries(lt).forEach(mt=>{const pt=mt[0],_t=mt[1],vt=this.inputNames.indexOf(pt);if(vt===-1)throw new Error(`invalid input '${pt}'`);st.push(_t),it.push(vt)});const ct=[];Object.entries(ut).forEach(mt=>{const pt=mt[0],_t=this.outputNames.indexOf(pt);if(_t===-1)throw new Error(`invalid output '${pt}'`);ct.push(_t)});const ft=await(0,ot.run)(this.sessionId,it,st.map(mt=>[mt.type,mt.dims,mt.data]),ct,dt),ht={};for(let mt=0;mt<ft.length;mt++)ht[this.outputNames[ct[mt]]]=new nt.Tensor(ft[mt][0],ft[mt][2],ft[mt][1]);return ht}startProfiling(){}endProfiling(){(0,ot.endProfiling)(this.sessionId)}}},4919:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.setSessionOptions=void 0;const tt=_e(7967),nt=_e(4983),rt=_e(6361);_.setSessionOptions=ot=>{const at=(0,rt.getInstance)();let lt=0;const ut=[],dt=ot||{};(st=>{st.extra||(st.extra={}),st.extra.session||(st.extra.session={});const it=st.extra.session;it.use_ort_model_bytes_directly||(it.use_ort_model_bytes_directly="1")})(dt);try{(ot==null?void 0:ot.graphOptimizationLevel)===void 0&&(dt.graphOptimizationLevel="all");const st=(ft=>{switch(ft){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${ft}`)}})(dt.graphOptimizationLevel);(ot==null?void 0:ot.enableCpuMemArena)===void 0&&(dt.enableCpuMemArena=!0),(ot==null?void 0:ot.enableMemPattern)===void 0&&(dt.enableMemPattern=!0),(ot==null?void 0:ot.executionMode)===void 0&&(dt.executionMode="sequential");const it=(ft=>{switch(ft){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${ft}`)}})(dt.executionMode);let ct=0;if((ot==null?void 0:ot.logId)!==void 0&&(ct=(0,nt.allocWasmString)(ot.logId,ut)),(ot==null?void 0:ot.logSeverityLevel)===void 0)dt.logSeverityLevel=2;else if(typeof ot.logSeverityLevel!="number"||!Number.isInteger(ot.logSeverityLevel)||ot.logSeverityLevel<0||ot.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${ot.logSeverityLevel}`);if((ot==null?void 0:ot.logVerbosityLevel)===void 0)dt.logVerbosityLevel=0;else if(typeof ot.logVerbosityLevel!="number"||!Number.isInteger(ot.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${ot.logVerbosityLevel}`);if((ot==null?void 0:ot.enableProfiling)===void 0&&(dt.enableProfiling=!1),lt=at._OrtCreateSessionOptions(st,!!dt.enableCpuMemArena,!!dt.enableMemPattern,it,!!dt.enableProfiling,0,ct,dt.logSeverityLevel,dt.logVerbosityLevel),lt===0)throw new Error("Can't create session options");return ot!=null&&ot.executionProviders&&((ft,ht,mt)=>{for(const pt of ht){let _t=typeof pt=="string"?pt:pt.name;switch(_t){case"xnnpack":_t="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${_t}`)}const vt=(0,nt.allocWasmString)(_t,mt);if((0,rt.getInstance)()._OrtAppendExecutionProvider(ft,vt)!==0)throw new Error(`Can't append execution provider: ${_t}`)}})(lt,ot.executionProviders,ut),(ot==null?void 0:ot.extra)!==void 0&&(0,tt.iterateExtraOptions)(ot.extra,"",new WeakSet,(ft,ht)=>{const mt=(0,nt.allocWasmString)(ft,ut),pt=(0,nt.allocWasmString)(ht,ut);if(at._OrtAddSessionConfigEntry(lt,mt,pt)!==0)throw new Error(`Can't set a session config entry: ${ft} - ${ht}`)}),[lt,ut]}catch(st){throw lt!==0&&at._OrtReleaseSessionOptions(lt),ut.forEach(at._free),st}}},4983:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.allocWasmString=void 0;const tt=_e(6361);_.allocWasmString=(nt,rt)=>{const ot=(0,tt.getInstance)(),at=ot.lengthBytesUTF8(nt)+1,lt=ot._malloc(at);return ot.stringToUTF8(nt,lt,at),rt.push(lt),lt}},349:(et,_,_e)=>{Object.defineProperty(_,"__esModule",{value:!0}),_.extractTransferableBuffers=_.endProfiling=_.run=_.releaseSession=_.createSession=_.createSessionFinalize=_.createSessionAllocate=_.initOrt=void 0;const tt=_e(586),nt=_e(4919),rt=_e(4983),ot=_e(6361);_.initOrt=(st,it)=>{const ct=(0,ot.getInstance)()._OrtInit(st,it);if(ct!==0)throw new Error(`Can't initialize onnxruntime. error code = ${ct}`)};const at=new Map;_.createSessionAllocate=st=>{const it=(0,ot.getInstance)(),ct=it._malloc(st.byteLength);return it.HEAPU8.set(st,ct),[ct,st.byteLength]},_.createSessionFinalize=(st,it)=>{const ct=(0,ot.getInstance)();let ft=0,ht=0,mt=[];try{if([ht,mt]=(0,nt.setSessionOptions)(it),ft=ct._OrtCreateSession(st[0],st[1],ht),ft===0)throw new Error("Can't create a session")}finally{ct._free(st[0]),ct._OrtReleaseSessionOptions(ht),mt.forEach(ct._free)}const pt=ct._OrtGetInputCount(ft),_t=ct._OrtGetOutputCount(ft),vt=[],bt=[],wt=[],xt=[];for(let Mt=0;Mt<pt;Mt++){const At=ct._OrtGetInputName(ft,Mt);if(At===0)throw new Error("Can't get an input name");bt.push(At),vt.push(ct.UTF8ToString(At))}for(let Mt=0;Mt<_t;Mt++){const At=ct._OrtGetOutputName(ft,Mt);if(At===0)throw new Error("Can't get an output name");xt.push(At),wt.push(ct.UTF8ToString(At))}return at.set(ft,[ft,bt,xt]),[ft,vt,wt]},_.createSession=(st,it)=>{const ct=(0,_.createSessionAllocate)(st);return(0,_.createSessionFinalize)(ct,it)},_.releaseSession=st=>{const it=(0,ot.getInstance)(),ct=at.get(st);if(!ct)throw new Error("invalid session id");const ft=ct[0],ht=ct[1],mt=ct[2];ht.forEach(it._OrtFree),mt.forEach(it._OrtFree),it._OrtReleaseSession(ft),at.delete(st)};const lt=st=>{switch(st){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${st}`)}},ut=st=>{switch(st){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${st}`)}},dt=st=>{switch(st){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${st}`)}};_.run=(st,it,ct,ft,ht)=>{const mt=(0,ot.getInstance)(),pt=at.get(st);if(!pt)throw new Error("invalid session id");const _t=pt[0],vt=pt[1],bt=pt[2],wt=it.length,xt=ft.length;let Mt=0,At=[];const St=[],Tt=[];try{[Mt,At]=(0,tt.setRunOptions)(ht);for(let Ot=0;Ot<wt;Ot++){const Ut=ct[Ot][0],Lt=ct[Ot][1],zt=ct[Ot][2];let Yt,en;if(Array.isArray(zt)){en=4*zt.length,Yt=mt._malloc(en),Tt.push(Yt);let mn=Yt/4;for(let vn=0;vn<zt.length;vn++){if(typeof zt[vn]!="string")throw new TypeError(`tensor data at index ${vn} is not a string`);mt.HEAPU32[mn++]=(0,rt.allocWasmString)(zt[vn],Tt)}}else en=zt.byteLength,Yt=mt._malloc(en),Tt.push(Yt),mt.HEAPU8.set(new Uint8Array(zt.buffer,zt.byteOffset,en),Yt);const bn=mt.stackSave(),Un=mt.stackAlloc(4*Lt.length);try{let mn=Un/4;Lt.forEach(In=>mt.HEAP32[mn++]=In);const vn=mt._OrtCreateTensor(lt(Ut),Yt,en,Un,Lt.length);if(vn===0)throw new Error("Can't create a tensor");St.push(vn)}finally{mt.stackRestore(bn)}}const Ct=mt.stackSave(),It=mt.stackAlloc(4*wt),$t=mt.stackAlloc(4*wt),Nt=mt.stackAlloc(4*xt),Bt=mt.stackAlloc(4*xt);try{let Ot=It/4,Ut=$t/4,Lt=Nt/4,zt=Bt/4;for(let bn=0;bn<wt;bn++)mt.HEAPU32[Ot++]=St[bn],mt.HEAPU32[Ut++]=vt[it[bn]];for(let bn=0;bn<xt;bn++)mt.HEAPU32[Lt++]=0,mt.HEAPU32[zt++]=bt[ft[bn]];let Yt=mt._OrtRun(_t,$t,It,wt,Bt,xt,Nt,Mt);const en=[];if(Yt===0)for(let bn=0;bn<xt;bn++){const Un=mt.HEAPU32[Nt/4+bn],mn=mt.stackSave(),vn=mt.stackAlloc(16);let In,Cn=0;try{if(Yt=mt._OrtGetTensorData(Un,vn,vn+4,vn+8,vn+12),Yt!==0)throw new Error(`Can't access output tensor data. error code = ${Yt}`);let En=vn/4;const jt=mt.HEAPU32[En++];Cn=mt.HEAPU32[En++];const Kt=mt.HEAPU32[En++],nn=mt.HEAPU32[En++],Vt=[];for(let dn=0;dn<nn;dn++)Vt.push(mt.HEAPU32[Kt/4+dn]);mt._OrtFree(Kt);const on=Vt.length===0?1:Vt.reduce((dn,Ln)=>dn*Ln);if(In=ut(jt),In==="string"){const dn=[];let Ln=Cn/4;for(let Sn=0;Sn<on;Sn++){const Xn=mt.HEAPU32[Ln++],Vn=Sn===on-1?void 0:mt.HEAPU32[Ln]-Xn;dn.push(mt.UTF8ToString(Xn,Vn))}en.push([In,Vt,dn])}else{const dn=new(dt(In))(on);new Uint8Array(dn.buffer,dn.byteOffset,dn.byteLength).set(mt.HEAPU8.subarray(Cn,Cn+dn.byteLength)),en.push([In,Vt,dn])}}finally{mt.stackRestore(mn),In==="string"&&Cn&&mt._free(Cn),mt._OrtReleaseTensor(Un)}}if(Yt===0)return en;throw new Error(`failed to call OrtRun(). error code = ${Yt}.`)}finally{mt.stackRestore(Ct)}}finally{St.forEach(mt._OrtReleaseTensor),Tt.forEach(mt._free),mt._OrtReleaseRunOptions(Mt),At.forEach(mt._free)}},_.endProfiling=st=>{const it=(0,ot.getInstance)(),ct=at.get(st);if(!ct)throw new Error("invalid session id");const ft=ct[0],ht=it._OrtEndProfiling(ft);if(ht===0)throw new Error("Can't get an profile file name");it._OrtFree(ht)},_.extractTransferableBuffers=st=>{const it=[];for(const ct of st){const ft=ct[2];!Array.isArray(ft)&&ft.buffer&&it.push(ft.buffer)}return it}},6361:function(et,_,_e){var tt=this&&this.__createBinding||(Object.create?function(ht,mt,pt,_t){_t===void 0&&(_t=pt);var vt=Object.getOwnPropertyDescriptor(mt,pt);vt&&!("get"in vt?!mt.__esModule:vt.writable||vt.configurable)||(vt={enumerable:!0,get:function(){return mt[pt]}}),Object.defineProperty(ht,_t,vt)}:function(ht,mt,pt,_t){_t===void 0&&(_t=pt),ht[_t]=mt[pt]}),nt=this&&this.__setModuleDefault||(Object.create?function(ht,mt){Object.defineProperty(ht,"default",{enumerable:!0,value:mt})}:function(ht,mt){ht.default=mt}),rt=this&&this.__importStar||function(ht){if(ht&&ht.__esModule)return ht;var mt={};if(ht!=null)for(var pt in ht)pt!=="default"&&Object.prototype.hasOwnProperty.call(ht,pt)&&tt(mt,ht,pt);return nt(mt,ht),mt},ot=this&&this.__importDefault||function(ht){return ht&&ht.__esModule?ht:{default:ht}};Object.defineProperty(_,"__esModule",{value:!0}),_.dispose=_.getInstance=_.initializeWebAssembly=void 0;const at=rt(_e(6449)),lt=ot(_e(932)),ut=_e(3474);let dt,st=!1,it=!1,ct=!1;const ft=(ht,mt)=>mt?ht?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":ht?"ort-wasm-simd.wasm":"ort-wasm.wasm";_.initializeWebAssembly=async ht=>{if(st)return Promise.resolve();if(it)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(ct)throw new Error("previous call to 'initializeWebAssembly()' failed.");it=!0;const mt=ht.initTimeout,pt=ht.numThreads,_t=ht.simd,vt=pt>1&&(()=>{try{return typeof SharedArrayBuffer<"u"&&(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}})(),bt=_t&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}})(),wt=typeof ht.wasmPaths=="string"?ht.wasmPaths:void 0,xt=ft(!1,vt),Mt=ft(bt,vt),At=typeof ht.wasmPaths=="object"?ht.wasmPaths[Mt]:void 0;let St=!1;const Tt=[];if(mt>0&&Tt.push(new Promise(Ct=>{setTimeout(()=>{St=!0,Ct()},mt)})),Tt.push(new Promise((Ct,It)=>{const $t=vt?ut:lt.default,Nt={locateFile:(Bt,Ot)=>vt&&Bt.endsWith(".worker.js")&&typeof Blob<"u"?URL.createObjectURL(new Blob([_e(4154)],{type:"text/javascript"})):Bt===xt?At??(wt??Ot)+Mt:Ot+Bt};if(vt)if(typeof Blob>"u")Nt.mainScriptUrlOrBlob=at.join("/","ort-wasm-threaded.js");else{const Bt=`var ortWasmThreaded=(function(){var _scriptDir;return ${$t.toString()}})();`;Nt.mainScriptUrlOrBlob=new Blob([Bt],{type:"text/javascript"})}$t(Nt).then(Bt=>{it=!1,st=!0,dt=Bt,Ct()},Bt=>{it=!1,ct=!0,It(Bt)})})),await Promise.race(Tt),St)throw new Error(`WebAssembly backend initializing failed due to timeout: ${mt}ms`)},_.getInstance=()=>{if(st&&dt)return dt;throw new Error("WebAssembly is not initialized yet.")},_.dispose=()=>{var ht;!st||it||ct||(it=!0,(ht=dt.PThread)===null||ht===void 0||ht.terminateAllThreads(),dt=void 0,it=!1,st=!1,ct=!0)}},9710:(et,_,_e)=>{_e.d(_,{Z:()=>rt});var tt=_e(477),nt=_e.n(tt);function rt(){return nt()('/*!\n* ONNX Runtime Web v1.14.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){function e(){return j.buffer!=D&&N(j.buffer),P}function r(){return j.buffer!=D&&N(j.buffer),U}function a(){return j.buffer!=D&&N(j.buffer),F}function i(){return j.buffer!=D&&N(j.buffer),I}function o(){return j.buffer!=D&&N(j.buffer),W}var u,c,s;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){c=t,s=e}));var l,f,p,h,d,y,b=Object.assign({},u),m="./this.program",g=(t,e)=>{throw e},v="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A="";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(_){let e;A=w?n(908).dirname(A)+"/":"//",y=()=>{d||(h=n(384),d=n(908))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:"utf8")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof ct))throw t})),process.on("unhandledRejection",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof ct||x("exiting due to exception: "+e),process.exit(t)},u.inspect=function(){return"[Emscripten Module object]"};try{e=n(925)}catch(t){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),t}n.g.Worker=e.Worker}else(v||w)&&(w?A=self.location.href:"undefined"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf("blob:")?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},w&&(p=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var T=console.log.bind(console),E=console.warn.bind(console);_&&(y(),T=t=>h.writeSync(1,t+"\\n"),E=t=>h.writeSync(2,t+"\\n"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;"object"!=typeof WebAssembly&&at("no native wasm support detected");var j,k,D,P,U,F,I,W,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function z(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&L)return L.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?z(r(),t,e):""}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)j=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)j=u.wasmMemory;else if(!((j=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");j&&(D=j.buffer),V=D.byteLength,N(D);var $,q=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();q.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:"onAbort",arg:t}):u.onAbort&&u.onAbort(t),x(t="Aborted("+t+")"),H=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),s(t),t}function it(){return tt.startsWith("data:application/octet-stream;base64,")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw"both async and sync fetching of the wasm failed"}catch(t){at(t)}}tt="ort-wasm-threaded.wasm",it()||(tt=S(tt));var ut={};function ct(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function st(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:"run",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return $t(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new ct(t))}function pt(t,e){if(!e&&O)throw bt(t),"unwind";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?zt(n.queue):"spawnThread"===r?lt(n):"cleanupThread"===r?st(n.thread):"killThread"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?ht.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):"print"===r?C("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?t.postMessage(n):"onAbort"===r?u.onAbort&&u.onAbort(n.arg):r&&x("worker sent an unknown command "+r);ht.Bc=void 0},t.onerror=t=>{throw x("worker sent an error! "+t.filename+":"+t.lineno+": "+t.message),t},_&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:j,wasmModule:k})},yc:function(){var t=S("ort-wasm-threaded.worker.js");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return $t(2,0,t);try{pt(t)}catch(t){t instanceof ct||"unwind"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=$.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,wt,_t=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?$t(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc="spawnThread",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?$t(4,1,t,e,n):0}function xt(t,e){if(O)return $t(5,1,t,e)}function Rt(t,e){if(O)return $t(6,1,t,e)}function jt(t,e,n){if(O)return $t(7,1,t,e,n)}function kt(t,e,n){return O?$t(8,1,t,e,n):0}function Dt(t,e){if(O)return $t(9,1,t,e)}function Pt(t,e,n){if(O)return $t(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return $t(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return $t(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return $t(13,1,t,e,n,r)}function Wt(t){if(O)return $t(14,1,t)}function Ht(t,e){if(O)return $t(15,1,t,e)}function Lt(t,e,n){if(O)return $t(16,1,t,e,n)}function zt(t){Atomics.store(a(),t>>2,1),he()&&_e(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?$t(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return $t(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}if(O)return $t(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),c=new Date(o,6,1);o=u.getTimezoneOffset();var s=c.getTimezoneOffset(),l=Math.max(o,s);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=s),t=r(u),e=r(c),t=Nt(t),e=Nt(e),s<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function $t(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var c=r[2+u];o()[i+u>>>0]=c}return we(t,n,a,e)}))}u.executeNotifiedProxyingQueue=zt,wt=_?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var qt,Xt=[],Jt={};function Zt(){if(!qt){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+"="+e[t]);qt=n}return qt}function Qt(t,n){if(O)return $t(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return $t(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?$t(22,1,t):52}function ee(t,e,n,r){return O?$t(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?$t(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(z(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return $t(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var c=i()[e>>2>>>0],s=i()[e+4>>2>>>0];e+=8;for(var l=0;l<s;l++)ae(t,r()[c+l>>>0]);o+=s}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var ce=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,"0")}function c(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?ce:se)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=c(e,t)?0>=c(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):""},r=Y(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(t){return h[t.Tb].substring(0,3)},"%A":function(t){return h[t.Tb]},"%b":function(t){return d[t.ec].substring(0,3)},"%B":function(t){return d[t.ec]},"%C":function(t){return u((t.Xb+1900)/100|0,2)},"%d":function(t){return u(t.jc,2)},"%e":function(t){return o(t.jc,2," ")},"%g":function(t){return l(t).toString().substring(2)},"%G":function(t){return l(t)},"%H":function(t){return u(t.dc,2)},"%I":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?ce:se)[n++]);return u(t.jc+e,3)},"%m":function(t){return u(t.ec+1,2)},"%M":function(t){return u(t.Kc,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.dc&&12>t.dc?"AM":"PM"},"%S":function(t){return u(t.Lc,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Tb||7},"%U":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},"%V":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},"%w":function(t){return t.Tb},"%W":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},"%y":function(t){return(t.Xb+1900).toString().substring(2)},"%Y":function(t){return t.Xb+1900},"%z":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,jt,kt,Dt,Pt,Ut,Ft,It,Wt,Ht,Lt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),_t.push(t),t.sc(),t.vc()},ma:function(t){throw x("Unexpected exception thrown, this is not properly supported - aborting"),H=!0,t},x:function(){Se(0);var t=_t.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=_t.pop();t||at("no exception to throw");var e=t.Zb;throw t.kc()||(_t.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!w,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:"cleanupThread",thread:t}):st(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:jt,oa:kt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:Lt,Ta:function(){},X:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>zt(r)));else if(O)postMessage({targetThread:t,cmd:"processProxyingQueue",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),c=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&c==r):0<n!=(c==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?c:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at("")},U:function(){if(!_&&!w){var t="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";vt||(vt={}),vt[t]||(vt[t]=1,_&&(t="warning: "+t),x(t))}},ra:function(){return 4294901760},B:wt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{j.grow(i-D.byteLength+65535>>>16),N(j.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw"unwind"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(_)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>at("randomDevice")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var c=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return ke(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return Le(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return je(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var c=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,c){var s=Ee();try{gt(t)(e,n,r,a,i,o,u,c)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var c=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:j||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),$=u.asm.ub,X.unshift(u.asm.Va),k=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||w)){if("function"==typeof fetch&&!tt.startsWith("file://"))return fetch(tt,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+tt+"\'";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x("failed to asynchronously prepare wasm: "+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x("Module.instantiateWasm callback failed with error: "+t),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith("file://")||_||"function"!=typeof fetch?n(e):fetch(tt,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x("wasm streaming compile failed: "+t),x("falling back to ArrayBuffer instantiation"),n(e)}))}))).catch(s)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,we=u._emscripten_run_in_main_runtime_thread_js=function(){return(we=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},_e=u.__emscripten_proxy_execute_task_queue=function(){return(_e=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},je=u.dynCall_j=function(){return(je=u.dynCall_j=u.asm.Ib).apply(null,arguments)},ke=u.dynCall_iiiiij=function(){return(ke=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Le=u.dynCall_iiij=function(){return(Le=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function ze(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)c(u),O||dt(X),postMessage({cmd:"loaded"});else{if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt(q),0<et||(u.setStatus?(u.setStatus("Running..."),setTimeout((function(){setTimeout((function(){u.setStatus("")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=j,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=ct,u.PThread=ht,rt=function t(){ve||ze(),ve||(rt=t)},u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return ze(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,c,s,l,f=Object.assign({},e),p="./this.program",h=(t,e)=>{throw e},d="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";b?(m=y?n(908).dirname(m)+"/":"//",l=()=>{s||(c=n(384),s=n(908))},i=function(t,e){return l(),t=s.normalize(t),c.readFileSync(t,e?void 0:"utf8")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=s.normalize(t),c.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof J))throw t})),process.on("unhandledRejection",(function(t){throw t})),h=(t,e)=>{if(_||0<L)throw process.exitCode=t,e;e instanceof J||w("exiting due to exception: "+e),process.exit(t)},e.inspect=function(){return"[Emscripten Module object]"}):(d||y)&&(y?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),w=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var _=e.noExitRuntime||!1;"object"!=typeof WebAssembly&&V("no native wasm support detected");var O,A,S,T,E,M,C=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function j(t,e){return(t>>>=0)?R(T,t,e):""}function k(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],L=0;function z(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),w(t="Aborted("+t+")"),C=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),a(t),t}function $(){return Y.startsWith("data:application/octet-stream;base64,")}if(Y="ort-wasm.wasm",!$()){var q=Y;Y=e.locateFile?e.locateFile(q,m):m+q}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw"both async and sync fetching of the wasm failed"}catch(t){V(t)}}function J(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&k(t,S,n,e),n}var ot={};function ut(){if(!ct){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+"="+e[t]);ct=n}return ct}var ct,st=[null,[],[]];function lt(t,e){var n=st[t];0===e||10===e?((1===t?v:w)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,"0")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function c(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var s=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:s?j(s):""},n=j(n),s={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),s[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in s={"%a":function(t){return f[t.Ab].substring(0,3)},"%A":function(t){return f[t.Ab]},"%b":function(t){return p[t.Hb].substring(0,3)},"%B":function(t){return p[t.Hb]},"%C":function(t){return i((t.Cb+1900)/100|0,2)},"%d":function(t){return i(t.Kb,2)},"%e":function(t){return a(t.Kb,2," ")},"%g":function(t){return c(t).toString().substring(2)},"%G":function(t){return c(t)},"%H":function(t){return i(t.Gb,2)},"%I":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},"%m":function(t){return i(t.Hb+1,2)},"%M":function(t){return i(t.Zb,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.Gb&&12>t.Gb?"AM":"PM"},"%S":function(t){return i(t.$b,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Ab||7},"%U":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},"%V":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},"%w":function(t){return t.Ab},"%W":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},"%y":function(t){return(t.Cb+1900).toString().substring(2)},"%Y":function(t){return t.Cb+1900},"%z":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),s)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),s[l](r)));return l=function(t){var e=Array(D(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\0\\0/g,"%")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw w("Unexpected exception thrown, this is not properly supported - aborting"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V("no exception to throw");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V("")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){_||0<L||(_t(),Z(W),wt(0),st[1].length&&lt(1,10),st[2].length&&lt(2,10)),_||0<L||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var c=0;c<u;c++)lt(t,T[o+c>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>V("randomDevice")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var c=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var c=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var c=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,c){var s=At();try{at(t)(e,n,r,a,i,o,u,c)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,c,s,l){var f=At();try{at(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=At();try{jt(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{kt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if("function"==typeof fetch&&!Y.startsWith("file://"))return fetch(Y,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+Y+"\'";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){w("failed to asynchronously prepare wasm: "+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return w("Module.instantiateWasm callback failed with error: "+t),!1}(g||"function"!=typeof WebAssembly.instantiateStreaming||$()||Y.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(Y,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return w("wasm streaming compile failed: "+t),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},wt=e._fflush=function(){return(wt=e._fflush=e.asm.gb).apply(null,arguments)},_t=e.___funcs_on_exit=function(){return(_t=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},jt=e.dynCall_viiiiij=function(){return(jt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)z();Z(F),0<B||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),t()}),1)):t())}}if(e.UTF8ToString=j,e.stringToUTF8=function(t,e,n){return k(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if("object"==typeof t&&null!==t){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if("object"==typeof i)(0,e.iterateExtraOptions)(i,o+".",r,a);else if("string"==typeof i||"number"==typeof i)a(o,i.toString());else{if("boolean"!=typeof i)throw new Error("Can\'t handle extra config type: "+typeof i);a(o,i?"1":"0")}}))}},586:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error("Can\'t create run options");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can\'t set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel="all");const c=(t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode="sequential");const s=(t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(c,!!u.enableCpuMemArena,!!u.enableMemPattern,s,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error("Can\'t create session options");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e="string"==typeof r?r:r.name;switch(e){case"xnnpack":e="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can\'t append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can\'t set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,c=[];try{if([i,c]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error("Can\'t create a session")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),c.forEach(n._free)}const s=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<s;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error("Can\'t get an input name");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error("Can\'t get an output name");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const c=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},s=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error("invalid session id");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,w=[];const _=[],O=[];try{[v,w]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if("string"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const s=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(c(e),o,u,l,r.length);if(0===n)throw new Error("Can\'t create a tensor");_.push(n)}finally{p.stackRestore(s)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,c=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=_[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[c++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const w=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\'t access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],c=p.HEAPU32[t++],h=[];for(let t=0;t<c;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=s(o),"string"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}w.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),w.push([a,h,t])}}finally{p.stackRestore(n),"string"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return w;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{_.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),w.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!("get"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(449)),c=o(n(932)),s=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":t?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(h)throw new Error("previous call to \'initializeWebAssembly()\' failed.");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y="string"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g="object"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const w=[];if(e>0&&w.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),w.push(new Promise(((t,e)=>{const r=i?s:c.default,a={locateFile:(t,e)=>i&&t.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=u.join("/","ort-wasm-threaded.js");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:"text/javascript"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(w),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{"use strict";t.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),(()=>{"use strict";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(t=>postMessage({type:"init-wasm",err:t})));break;case"init-ort":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:"init-ort"})}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:"create_finalize",out:a})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:"create",out:a})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:"run",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}}}})()})();\n',"Worker",void 0,void 0)}},477:et=>{et.exports=function(_,_e,tt,nt){var rt=self||window;try{try{var ot;try{ot=new rt.Blob([_])}catch{(ot=new(rt.BlobBuilder||rt.WebKitBlobBuilder||rt.MozBlobBuilder||rt.MSBlobBuilder)).append(_),ot=ot.getBlob()}var at=rt.URL||rt.webkitURL,lt=at.createObjectURL(ot),ut=new rt[_e](lt,tt);return at.revokeObjectURL(lt),ut}catch{return new rt[_e]("data:application/javascript,".concat(encodeURIComponent(_)),tt)}}catch{if(!nt)throw Error("Inline worker is not supported");return new rt[_e](nt,tt)}}},4154:et=>{et.exports=`"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};
`},1670:et=>{et.exports=__WEBPACK_EXTERNAL_MODULE__1670__},7067:()=>{},1296:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},5686:(et,_,_e)=>{_e.r(_),_e.d(_,{flatbuffers:()=>tt});var tt={};tt.Offset,tt.Table,tt.SIZEOF_SHORT=2,tt.SIZEOF_INT=4,tt.FILE_IDENTIFIER_LENGTH=4,tt.SIZE_PREFIX_LENGTH=4,tt.Encoding={UTF8_BYTES:1,UTF16_STRING:2},tt.int32=new Int32Array(2),tt.float32=new Float32Array(tt.int32.buffer),tt.float64=new Float64Array(tt.int32.buffer),tt.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,tt.Long=function(nt,rt){this.low=0|nt,this.high=0|rt},tt.Long.create=function(nt,rt){return nt==0&&rt==0?tt.Long.ZERO:new tt.Long(nt,rt)},tt.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},tt.Long.prototype.equals=function(nt){return this.low==nt.low&&this.high==nt.high},tt.Long.ZERO=new tt.Long(0,0),tt.Builder=function(nt){if(nt)rt=nt;else var rt=1024;this.bb=tt.ByteBuffer.allocate(rt),this.space=rt,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},tt.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},tt.Builder.prototype.forceDefaults=function(nt){this.force_defaults=nt},tt.Builder.prototype.dataBuffer=function(){return this.bb},tt.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},tt.Builder.prototype.prep=function(nt,rt){nt>this.minalign&&(this.minalign=nt);for(var ot=1+~(this.bb.capacity()-this.space+rt)&nt-1;this.space<ot+nt+rt;){var at=this.bb.capacity();this.bb=tt.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-at}this.pad(ot)},tt.Builder.prototype.pad=function(nt){for(var rt=0;rt<nt;rt++)this.bb.writeInt8(--this.space,0)},tt.Builder.prototype.writeInt8=function(nt){this.bb.writeInt8(this.space-=1,nt)},tt.Builder.prototype.writeInt16=function(nt){this.bb.writeInt16(this.space-=2,nt)},tt.Builder.prototype.writeInt32=function(nt){this.bb.writeInt32(this.space-=4,nt)},tt.Builder.prototype.writeInt64=function(nt){this.bb.writeInt64(this.space-=8,nt)},tt.Builder.prototype.writeFloat32=function(nt){this.bb.writeFloat32(this.space-=4,nt)},tt.Builder.prototype.writeFloat64=function(nt){this.bb.writeFloat64(this.space-=8,nt)},tt.Builder.prototype.addInt8=function(nt){this.prep(1,0),this.writeInt8(nt)},tt.Builder.prototype.addInt16=function(nt){this.prep(2,0),this.writeInt16(nt)},tt.Builder.prototype.addInt32=function(nt){this.prep(4,0),this.writeInt32(nt)},tt.Builder.prototype.addInt64=function(nt){this.prep(8,0),this.writeInt64(nt)},tt.Builder.prototype.addFloat32=function(nt){this.prep(4,0),this.writeFloat32(nt)},tt.Builder.prototype.addFloat64=function(nt){this.prep(8,0),this.writeFloat64(nt)},tt.Builder.prototype.addFieldInt8=function(nt,rt,ot){(this.force_defaults||rt!=ot)&&(this.addInt8(rt),this.slot(nt))},tt.Builder.prototype.addFieldInt16=function(nt,rt,ot){(this.force_defaults||rt!=ot)&&(this.addInt16(rt),this.slot(nt))},tt.Builder.prototype.addFieldInt32=function(nt,rt,ot){(this.force_defaults||rt!=ot)&&(this.addInt32(rt),this.slot(nt))},tt.Builder.prototype.addFieldInt64=function(nt,rt,ot){!this.force_defaults&&rt.equals(ot)||(this.addInt64(rt),this.slot(nt))},tt.Builder.prototype.addFieldFloat32=function(nt,rt,ot){(this.force_defaults||rt!=ot)&&(this.addFloat32(rt),this.slot(nt))},tt.Builder.prototype.addFieldFloat64=function(nt,rt,ot){(this.force_defaults||rt!=ot)&&(this.addFloat64(rt),this.slot(nt))},tt.Builder.prototype.addFieldOffset=function(nt,rt,ot){(this.force_defaults||rt!=ot)&&(this.addOffset(rt),this.slot(nt))},tt.Builder.prototype.addFieldStruct=function(nt,rt,ot){rt!=ot&&(this.nested(rt),this.slot(nt))},tt.Builder.prototype.nested=function(nt){if(nt!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},tt.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},tt.Builder.prototype.slot=function(nt){this.vtable[nt]=this.offset()},tt.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},tt.Builder.growByteBuffer=function(nt){var rt=nt.capacity();if(3221225472&rt)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var ot=rt<<1,at=tt.ByteBuffer.allocate(ot);return at.setPosition(ot-rt),at.bytes().set(nt.bytes(),ot-rt),at},tt.Builder.prototype.addOffset=function(nt){this.prep(tt.SIZEOF_INT,0),this.writeInt32(this.offset()-nt+tt.SIZEOF_INT)},tt.Builder.prototype.startObject=function(nt){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=nt;for(var rt=0;rt<nt;rt++)this.vtable[rt]=0;this.isNested=!0,this.object_start=this.offset()},tt.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var nt=this.offset(),rt=this.vtable_in_use-1;rt>=0&&this.vtable[rt]==0;rt--);for(var ot=rt+1;rt>=0;rt--)this.addInt16(this.vtable[rt]!=0?nt-this.vtable[rt]:0);this.addInt16(nt-this.object_start);var at=(ot+2)*tt.SIZEOF_SHORT;this.addInt16(at);var lt=0,ut=this.space;e:for(rt=0;rt<this.vtables.length;rt++){var dt=this.bb.capacity()-this.vtables[rt];if(at==this.bb.readInt16(dt)){for(var st=tt.SIZEOF_SHORT;st<at;st+=tt.SIZEOF_SHORT)if(this.bb.readInt16(ut+st)!=this.bb.readInt16(dt+st))continue e;lt=this.vtables[rt];break}}return lt?(this.space=this.bb.capacity()-nt,this.bb.writeInt32(this.space,lt-nt)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-nt,this.offset()-nt)),this.isNested=!1,nt},tt.Builder.prototype.finish=function(nt,rt,ot){var at=ot?tt.SIZE_PREFIX_LENGTH:0;if(rt){var lt=rt;if(this.prep(this.minalign,tt.SIZEOF_INT+tt.FILE_IDENTIFIER_LENGTH+at),lt.length!=tt.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+tt.FILE_IDENTIFIER_LENGTH);for(var ut=tt.FILE_IDENTIFIER_LENGTH-1;ut>=0;ut--)this.writeInt8(lt.charCodeAt(ut))}this.prep(this.minalign,tt.SIZEOF_INT+at),this.addOffset(nt),at&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},tt.Builder.prototype.finishSizePrefixed=function(nt,rt){this.finish(nt,rt,!0)},tt.Builder.prototype.requiredField=function(nt,rt){var ot=this.bb.capacity()-nt,at=ot-this.bb.readInt32(ot);if(this.bb.readInt16(at+rt)==0)throw new Error("FlatBuffers: field "+rt+" must be set")},tt.Builder.prototype.startVector=function(nt,rt,ot){this.notNested(),this.vector_num_elems=rt,this.prep(tt.SIZEOF_INT,nt*rt),this.prep(ot,nt*rt)},tt.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},tt.Builder.prototype.createString=function(nt){if(nt instanceof Uint8Array)var rt=nt;else{rt=[];for(var ot=0;ot<nt.length;){var at,lt=nt.charCodeAt(ot++);(at=lt<55296||lt>=56320?lt:(lt<<10)+nt.charCodeAt(ot++)+-56613888)<128?rt.push(at):(at<2048?rt.push(at>>6&31|192):(at<65536?rt.push(at>>12&15|224):rt.push(at>>18&7|240,at>>12&63|128),rt.push(at>>6&63|128)),rt.push(63&at|128))}}this.addInt8(0),this.startVector(1,rt.length,1),this.bb.setPosition(this.space-=rt.length),ot=0;for(var ut=this.space,dt=this.bb.bytes();ot<rt.length;ot++)dt[ut++]=rt[ot];return this.endVector()},tt.Builder.prototype.createLong=function(nt,rt){return tt.Long.create(nt,rt)},tt.ByteBuffer=function(nt){this.bytes_=nt,this.position_=0},tt.ByteBuffer.allocate=function(nt){return new tt.ByteBuffer(new Uint8Array(nt))},tt.ByteBuffer.prototype.clear=function(){this.position_=0},tt.ByteBuffer.prototype.bytes=function(){return this.bytes_},tt.ByteBuffer.prototype.position=function(){return this.position_},tt.ByteBuffer.prototype.setPosition=function(nt){this.position_=nt},tt.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},tt.ByteBuffer.prototype.readInt8=function(nt){return this.readUint8(nt)<<24>>24},tt.ByteBuffer.prototype.readUint8=function(nt){return this.bytes_[nt]},tt.ByteBuffer.prototype.readInt16=function(nt){return this.readUint16(nt)<<16>>16},tt.ByteBuffer.prototype.readUint16=function(nt){return this.bytes_[nt]|this.bytes_[nt+1]<<8},tt.ByteBuffer.prototype.readInt32=function(nt){return this.bytes_[nt]|this.bytes_[nt+1]<<8|this.bytes_[nt+2]<<16|this.bytes_[nt+3]<<24},tt.ByteBuffer.prototype.readUint32=function(nt){return this.readInt32(nt)>>>0},tt.ByteBuffer.prototype.readInt64=function(nt){return new tt.Long(this.readInt32(nt),this.readInt32(nt+4))},tt.ByteBuffer.prototype.readUint64=function(nt){return new tt.Long(this.readUint32(nt),this.readUint32(nt+4))},tt.ByteBuffer.prototype.readFloat32=function(nt){return tt.int32[0]=this.readInt32(nt),tt.float32[0]},tt.ByteBuffer.prototype.readFloat64=function(nt){return tt.int32[tt.isLittleEndian?0:1]=this.readInt32(nt),tt.int32[tt.isLittleEndian?1:0]=this.readInt32(nt+4),tt.float64[0]},tt.ByteBuffer.prototype.writeInt8=function(nt,rt){this.bytes_[nt]=rt},tt.ByteBuffer.prototype.writeUint8=function(nt,rt){this.bytes_[nt]=rt},tt.ByteBuffer.prototype.writeInt16=function(nt,rt){this.bytes_[nt]=rt,this.bytes_[nt+1]=rt>>8},tt.ByteBuffer.prototype.writeUint16=function(nt,rt){this.bytes_[nt]=rt,this.bytes_[nt+1]=rt>>8},tt.ByteBuffer.prototype.writeInt32=function(nt,rt){this.bytes_[nt]=rt,this.bytes_[nt+1]=rt>>8,this.bytes_[nt+2]=rt>>16,this.bytes_[nt+3]=rt>>24},tt.ByteBuffer.prototype.writeUint32=function(nt,rt){this.bytes_[nt]=rt,this.bytes_[nt+1]=rt>>8,this.bytes_[nt+2]=rt>>16,this.bytes_[nt+3]=rt>>24},tt.ByteBuffer.prototype.writeInt64=function(nt,rt){this.writeInt32(nt,rt.low),this.writeInt32(nt+4,rt.high)},tt.ByteBuffer.prototype.writeUint64=function(nt,rt){this.writeUint32(nt,rt.low),this.writeUint32(nt+4,rt.high)},tt.ByteBuffer.prototype.writeFloat32=function(nt,rt){tt.float32[0]=rt,this.writeInt32(nt,tt.int32[0])},tt.ByteBuffer.prototype.writeFloat64=function(nt,rt){tt.float64[0]=rt,this.writeInt32(nt,tt.int32[tt.isLittleEndian?0:1]),this.writeInt32(nt+4,tt.int32[tt.isLittleEndian?1:0])},tt.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+tt.SIZEOF_INT+tt.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var nt="",rt=0;rt<tt.FILE_IDENTIFIER_LENGTH;rt++)nt+=String.fromCharCode(this.readInt8(this.position_+tt.SIZEOF_INT+rt));return nt},tt.ByteBuffer.prototype.__offset=function(nt,rt){var ot=nt-this.readInt32(nt);return rt<this.readInt16(ot)?this.readInt16(ot+rt):0},tt.ByteBuffer.prototype.__union=function(nt,rt){return nt.bb_pos=rt+this.readInt32(rt),nt.bb=this,nt},tt.ByteBuffer.prototype.__string=function(nt,rt){nt+=this.readInt32(nt);var ot=this.readInt32(nt),at="",lt=0;if(nt+=tt.SIZEOF_INT,rt===tt.Encoding.UTF8_BYTES)return this.bytes_.subarray(nt,nt+ot);for(;lt<ot;){var ut,dt=this.readUint8(nt+lt++);if(dt<192)ut=dt;else{var st=this.readUint8(nt+lt++);if(dt<224)ut=(31&dt)<<6|63&st;else{var it=this.readUint8(nt+lt++);ut=dt<240?(15&dt)<<12|(63&st)<<6|63&it:(7&dt)<<18|(63&st)<<12|(63&it)<<6|63&this.readUint8(nt+lt++)}}ut<65536?at+=String.fromCharCode(ut):(ut-=65536,at+=String.fromCharCode(55296+(ut>>10),56320+(1023&ut)))}return at},tt.ByteBuffer.prototype.__indirect=function(nt){return nt+this.readInt32(nt)},tt.ByteBuffer.prototype.__vector=function(nt){return nt+this.readInt32(nt)+tt.SIZEOF_INT},tt.ByteBuffer.prototype.__vector_len=function(nt){return this.readInt32(nt+this.readInt32(nt))},tt.ByteBuffer.prototype.__has_identifier=function(nt){if(nt.length!=tt.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+tt.FILE_IDENTIFIER_LENGTH);for(var rt=0;rt<tt.FILE_IDENTIFIER_LENGTH;rt++)if(nt.charCodeAt(rt)!=this.readInt8(this.position_+tt.SIZEOF_INT+rt))return!1;return!0},tt.ByteBuffer.prototype.createLong=function(nt,rt){return tt.Long.create(nt,rt)}}},__webpack_module_cache__={};function __webpack_require__(et){var _=__webpack_module_cache__[et];if(_!==void 0)return _.exports;var _e=__webpack_module_cache__[et]={exports:{}};return __webpack_modules__[et].call(_e.exports,_e,_e.exports,__webpack_require__),_e.exports}__webpack_require__.n=et=>{var _=et&&et.__esModule?()=>et.default:()=>et;return __webpack_require__.d(_,{a:_}),_},__webpack_require__.d=(et,_)=>{for(var _e in _)__webpack_require__.o(_,_e)&&!__webpack_require__.o(et,_e)&&Object.defineProperty(et,_e,{enumerable:!0,get:_[_e]})},__webpack_require__.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}(),__webpack_require__.o=(et,_)=>Object.prototype.hasOwnProperty.call(et,_),__webpack_require__.r=et=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(et,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(et,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(6018);return __webpack_exports__})())})(ortWeb_min$1);var ortWeb_minExports=ortWeb_min$1.exports;const ortWeb_min=getDefaultExportFromCjs(ortWeb_minExports),ONNX_WEB=_mergeNamespaces({__proto__:null,default:ortWeb_min},[ortWeb_minExports]);let ONNX;const executionProviders=["wasm"];var Bm;typeof process<"u"&&((Bm=process==null?void 0:process.release)==null?void 0:Bm.name)==="node"?(ONNX=sharp??ONNX_NODE,executionProviders.unshift("cpu")):(ONNX=ortWeb_min??ONNX_WEB,typeof navigator<"u"&&/iP(hone|od|ad).+16_4.+AppleWebKit/.test(navigator.userAgent)&&(ONNX.env.wasm.simd=!1));const{env:onnx_env}=ONNX,VERSION="2.17.2",WEB_CACHE_AVAILABLE=typeof self<"u"&&"caches"in self,FS_AVAILABLE=!isEmpty(sharp),PATH_AVAILABLE=!isEmpty(sharp),RUNNING_LOCALLY=FS_AVAILABLE&&PATH_AVAILABLE,__dirname=RUNNING_LOCALLY?sharp.dirname(sharp.dirname(sharp.fileURLToPath(import.meta.url))):"./",DEFAULT_CACHE_DIR=RUNNING_LOCALLY?sharp.join(__dirname,"/.cache/"):null,DEFAULT_LOCAL_MODEL_PATH="/models/",localModelPath=RUNNING_LOCALLY?sharp.join(__dirname,DEFAULT_LOCAL_MODEL_PATH):DEFAULT_LOCAL_MODEL_PATH;onnx_env!=null&&onnx_env.wasm&&(onnx_env.wasm.wasmPaths=RUNNING_LOCALLY?sharp.join(__dirname,"/dist/"):`https://cdn.jsdelivr.net/npm/@xenova/transformers@${VERSION}/dist/`);const env$1={backends:{onnx:onnx_env,tfjs:{}},__dirname,version:VERSION,allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!0,localModelPath,useFS:FS_AVAILABLE,useBrowserCache:WEB_CACHE_AVAILABLE,useFSCache:FS_AVAILABLE,cacheDir:DEFAULT_CACHE_DIR,useCustomCache:!1,customCache:null};function isEmpty(et){return Object.keys(et).length===0}var define_process_env_default={};class FileResponse{constructor(_){jn(this,"_CONTENT_TYPE_MAP",{txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"});if(this.filePath=_,this.headers=new Headers,this.exists=sharp.existsSync(_),this.exists){this.status=200,this.statusText="OK";let _e=sharp.statSync(_);this.headers.set("content-length",_e.size.toString()),this.updateContentType();let tt=this;this.body=new ReadableStream({start(nt){tt.arrayBuffer().then(rt=>{nt.enqueue(new Uint8Array(rt)),nt.close()})}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const _=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",this._CONTENT_TYPE_MAP[_]??"application/octet-stream")}clone(){let _=new FileResponse(this.filePath);return _.exists=this.exists,_.status=this.status,_.statusText=this.statusText,_.headers=new Headers(this.headers),_}async arrayBuffer(){return(await sharp.promises.readFile(this.filePath)).buffer}async blob(){const _=await sharp.promises.readFile(this.filePath);return new Blob([_],{type:this.headers.get("content-type")})}async text(){return await sharp.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function isValidUrl(et,_=null,_e=null){let tt;try{tt=new URL(et)}catch{return!1}return!(_&&!_.includes(tt.protocol)||_e&&!_e.includes(tt.hostname))}async function getFile(et){var _;if(env$1.useFS&&!isValidUrl(et,["http:","https:","blob:"]))return new FileResponse(et);if(typeof process<"u"&&((_=process==null?void 0:process.release)==null?void 0:_.name)==="node"){const _e=!!(define_process_env_default!=null&&define_process_env_default.TESTING_REMOTELY),tt=env$1.version,nt=new Headers;if(nt.set("User-Agent",`transformers.js/${tt}; is_ci/${_e};`),isValidUrl(et,["http:","https:"],["huggingface.co","hf.co"])){const ot=(define_process_env_default==null?void 0:define_process_env_default.HF_TOKEN)??(define_process_env_default==null?void 0:define_process_env_default.HF_ACCESS_TOKEN);ot&&nt.set("Authorization",`Bearer ${ot}`)}return fetch(et,{headers:nt})}else return fetch(et)}const ERROR_MAPPING={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};function handleError(et,_,_e){if(!_e)return null;const tt=ERROR_MAPPING[et]??`Error (${et}) occurred while trying to load file`;throw Error(`${tt}: "${_}".`)}class FileCache{constructor(_){this.path=_}async match(_){let _e=sharp.join(this.path,_),tt=new FileResponse(_e);if(tt.exists)return tt}async put(_,_e){const tt=Buffer.from(await _e.arrayBuffer());let nt=sharp.join(this.path,_);try{await sharp.promises.mkdir(sharp.dirname(nt),{recursive:!0}),await sharp.promises.writeFile(nt,tt)}catch(rt){console.warn("An error occurred while writing the file to cache:",rt)}}}async function tryCache(et,..._){for(let _e of _)try{let tt=await et.match(_e);if(tt)return tt}catch{continue}}async function getModelFile(et,_,_e=!0,tt={}){if(!env$1.allowLocalModels&&tt.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");dispatchCallback(tt.progress_callback,{status:"initiate",name:et,file:_});let nt;if(!nt&&env$1.useBrowserCache){if(typeof caches>"u")throw Error("Browser cache is not available in this environment.");try{nt=await caches.open("transformers-cache")}catch(pt){console.warn("An error occurred while opening the browser cache:",pt)}}if(!nt&&env$1.useFSCache&&(nt=new FileCache(tt.cache_dir??env$1.cacheDir)),!nt&&env$1.useCustomCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");const rt=tt.revision??"main";let ot=pathJoin(et,_),at=pathJoin(env$1.localModelPath,ot),lt=pathJoin(env$1.remoteHost,env$1.remotePathTemplate.replaceAll("{model}",et).replaceAll("{revision}",encodeURIComponent(rt)),_),ut=rt==="main"?ot:pathJoin(et,rt,_),dt,st=nt instanceof FileCache?ut:lt,it=!1,ct;nt&&(ct=await tryCache(nt,at,st));const ft=ct!==void 0;if(ct===void 0){if(env$1.allowLocalModels)if(isValidUrl(ot,["http:","https:"])){if(tt.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${ot}.`)}else try{ct=await getFile(at),dt=at}catch(_t){console.warn(`Unable to load from local path "${at}": "${_t}"`)}if(ct===void 0||ct.status===404){if(tt.local_files_only||!env$1.allowRemoteModels){if(_e)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${at}".`);return null}if(ct=await getFile(lt),ct.status!==200)return handleError(ct.status,lt,_e);dt=st}it=nt&&typeof Response<"u"&&ct instanceof Response&&ct.status===200}dispatchCallback(tt.progress_callback,{status:"download",name:et,file:_});const ht={status:"progress",name:et,file:_};let mt;return tt.progress_callback?ft&&typeof navigator<"u"&&/firefox/i.test(navigator.userAgent)?(mt=new Uint8Array(await ct.arrayBuffer()),dispatchCallback(tt.progress_callback,{...ht,progress:100,loaded:mt.length,total:mt.length})):mt=await readResponse(ct,pt=>{dispatchCallback(tt.progress_callback,{...ht,...pt})}):mt=new Uint8Array(await ct.arrayBuffer()),it&&dt&&await nt.match(dt)===void 0&&await nt.put(dt,new Response(mt,{headers:ct.headers})).catch(pt=>{console.warn(`Unable to add response to browser cache: ${pt}.`)}),dispatchCallback(tt.progress_callback,{status:"done",name:et,file:_}),mt}async function getModelJSON(et,_,_e=!0,tt={}){let nt=await getModelFile(et,_,_e,tt);if(nt===null)return{};let ot=new TextDecoder("utf-8").decode(nt);return JSON.parse(ot)}async function readResponse(et,_){const _e=et.headers.get("Content-Length");_e===null&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let tt=parseInt(_e??"0"),nt=new Uint8Array(tt),rt=0;const ot=et.body.getReader();async function at(){const{done:lt,value:ut}=await ot.read();if(lt)return;let dt=rt+ut.length;if(dt>tt){tt=dt;let it=new Uint8Array(tt);it.set(nt),nt=it}nt.set(ut,rt),rt=dt;const st=rt/tt*100;return _({progress:st,loaded:rt,total:tt}),at()}return await at(),nt}function pathJoin(...et){return et=et.map((_,_e)=>(_e&&(_=_.replace(new RegExp("^/"),"")),_e!==et.length-1&&(_=_.replace(new RegExp("/$"),"")),_)),et.join("/")}function interpolate_data(et,[_,_e,tt],[nt,rt],ot="bilinear",at=!1){const lt=rt/tt,ut=nt/_e,dt=new et.constructor(nt*rt*_),st=_e*tt,it=nt*rt;for(let ct=0;ct<nt;++ct)for(let ft=0;ft<rt;++ft){const ht=ct*rt+ft,mt=(ft+.5)/lt-.5,pt=(ct+.5)/ut-.5;let _t=Math.floor(mt),vt=Math.floor(pt);const bt=Math.min(_t+1,tt-1),wt=Math.min(vt+1,_e-1);_t=Math.max(_t,0),vt=Math.max(vt,0);const xt=mt-_t,Mt=pt-vt,At=(1-xt)*(1-Mt),St=xt*(1-Mt),Tt=(1-xt)*Mt,Ct=xt*Mt,It=vt*tt,$t=wt*tt,Nt=It+_t,Bt=It+bt,Ot=$t+_t,Ut=$t+bt;for(let Lt=0;Lt<_;++Lt){const zt=Lt*st;dt[Lt*it+ht]=At*et[zt+Nt]+St*et[zt+Bt]+Tt*et[zt+Ot]+Ct*et[zt+Ut]}}return dt}function permute_data(et,_,_e){const tt=new Array(_e.length),nt=new Array(_e.length);for(let at=_e.length-1,lt=1;at>=0;--at)nt[at]=lt,tt[at]=_[_e[at]],lt*=tt[at];const rt=_e.map((at,lt)=>nt[_e.indexOf(lt)]),ot=new et.constructor(et.length);for(let at=0;at<et.length;++at){let lt=0;for(let ut=_.length-1,dt=at;ut>=0;--ut)lt+=dt%_[ut]*rt[ut],dt=Math.floor(dt/_[ut]);ot[lt]=et[at]}return[ot,tt]}function softmax(et){const _=max$1(et)[0],_e=et.map(rt=>Math.exp(rt-_)),tt=_e.reduce((rt,ot)=>rt+ot,0);return _e.map(rt=>rt/tt)}function log_softmax(et){return softmax(et).map(tt=>Math.log(tt))}function getTopItems(et,_=0){return et=Array.from(et).map((_e,tt)=>[tt,_e]).sort((_e,tt)=>tt[1]-_e[1]),_!==null&&_>0&&(et=et.slice(0,_)),et}function min$1(et){if(et.length===0)throw Error("Array must not be empty");let _=et[0],_e=0;for(let tt=1;tt<et.length;++tt)et[tt]<_&&(_=et[tt],_e=tt);return[_,_e]}function max$1(et){if(et.length===0)throw Error("Array must not be empty");let _=et[0],_e=0;for(let tt=1;tt<et.length;++tt)et[tt]>_&&(_=et[tt],_e=tt);return[Number(_),_e]}function isPowerOfTwo(et){return et>0&&(et&et-1)===0}class P2FFT{constructor(_){if(this.size=_|0,this.size<=1||!isPowerOfTwo(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=_<<1,this.table=new Float64Array(this.size*2);for(let tt=0;tt<this.table.length;tt+=2){const nt=Math.PI*tt/this.size;this.table[tt]=Math.cos(nt),this.table[tt+1]=-Math.sin(nt)}let _e=0;for(let tt=1;this.size>tt;tt<<=1)++_e;this._width=_e%2===0?_e-1:_e,this._bitrev=new Int32Array(1<<this._width);for(let tt=0;tt<this._bitrev.length;++tt){this._bitrev[tt]=0;for(let nt=0;nt<this._width;nt+=2){const rt=this._width-nt-2;this._bitrev[tt]|=(tt>>>nt&3)<<rt}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(_,_e){const tt=_e||new Array(_.length>>>1);for(let nt=0;nt<_.length;nt+=2)tt[nt>>>1]=_[nt];return tt}toComplexArray(_,_e){const tt=_e||this.createComplexArray();for(let nt=0;nt<tt.length;nt+=2)tt[nt]=_[nt>>>1],tt[nt+1]=0;return tt}transform(_,_e){if(_===_e)throw new Error("Input and output buffers must be different");this._transform4(_,_e,1)}realTransform(_,_e){if(_===_e)throw new Error("Input and output buffers must be different");this._realTransform4(_,_e,1)}inverseTransform(_,_e){if(_===_e)throw new Error("Input and output buffers must be different");this._transform4(_,_e,-1);for(let tt=0;tt<_.length;++tt)_[tt]/=this.size}_transform4(_,_e,tt){const nt=this._csize;let ot=1<<this._width,at=nt/ot<<1,lt,ut;const dt=this._bitrev;if(at===4)for(lt=0,ut=0;lt<nt;lt+=at,++ut){const it=dt[ut];this._singleTransform2(_e,_,lt,it,ot)}else for(lt=0,ut=0;lt<nt;lt+=at,++ut){const it=dt[ut];this._singleTransform4(_e,_,lt,it,ot,tt)}const st=this.table;for(ot>>=2;ot>=2;ot>>=2){at=nt/ot<<1;const it=at>>>2;for(lt=0;lt<nt;lt+=at){const ct=lt+it-1;for(let ft=lt,ht=0;ft<ct;ft+=2,ht+=ot){const mt=ft,pt=mt+it,_t=pt+it,vt=_t+it,bt=_[mt],wt=_[mt+1],xt=_[pt],Mt=_[pt+1],At=_[_t],St=_[_t+1],Tt=_[vt],Ct=_[vt+1],It=st[ht],$t=tt*st[ht+1],Nt=xt*It-Mt*$t,Bt=xt*$t+Mt*It,Ot=st[2*ht],Ut=tt*st[2*ht+1],Lt=At*Ot-St*Ut,zt=At*Ut+St*Ot,Yt=st[3*ht],en=tt*st[3*ht+1],bn=Tt*Yt-Ct*en,Un=Tt*en+Ct*Yt,mn=bt+Lt,vn=wt+zt,In=bt-Lt,Cn=wt-zt,En=Nt+bn,jt=Bt+Un,Kt=tt*(Nt-bn),nn=tt*(Bt-Un);_[mt]=mn+En,_[mt+1]=vn+jt,_[pt]=In+nn,_[pt+1]=Cn-Kt,_[_t]=mn-En,_[_t+1]=vn-jt,_[vt]=In-nn,_[vt+1]=Cn+Kt}}}}_singleTransform2(_,_e,tt,nt,rt){const ot=_[nt],at=_[nt+1],lt=_[nt+rt],ut=_[nt+rt+1];_e[tt]=ot+lt,_e[tt+1]=at+ut,_e[tt+2]=ot-lt,_e[tt+3]=at-ut}_singleTransform4(_,_e,tt,nt,rt,ot){const at=rt*2,lt=rt*3,ut=_[nt],dt=_[nt+1],st=_[nt+rt],it=_[nt+rt+1],ct=_[nt+at],ft=_[nt+at+1],ht=_[nt+lt],mt=_[nt+lt+1],pt=ut+ct,_t=dt+ft,vt=ut-ct,bt=dt-ft,wt=st+ht,xt=it+mt,Mt=ot*(st-ht),At=ot*(it-mt);_e[tt]=pt+wt,_e[tt+1]=_t+xt,_e[tt+2]=vt+At,_e[tt+3]=bt-Mt,_e[tt+4]=pt-wt,_e[tt+5]=_t-xt,_e[tt+6]=vt-At,_e[tt+7]=bt+Mt}_realTransform4(_,_e,tt){const nt=this._csize;let ot=1<<this._width,at=nt/ot<<1,lt,ut;const dt=this._bitrev;if(at===4)for(lt=0,ut=0;lt<nt;lt+=at,++ut){const ct=dt[ut];this._singleRealTransform2(_e,_,lt,ct>>>1,ot>>>1)}else for(lt=0,ut=0;lt<nt;lt+=at,++ut){const ct=dt[ut];this._singleRealTransform4(_e,_,lt,ct>>>1,ot>>>1,tt)}const st=this.table;for(ot>>=2;ot>=2;ot>>=2){at=nt/ot<<1;const ct=at>>>1,ft=ct>>>1,ht=ft>>>1;for(lt=0;lt<nt;lt+=at)for(let mt=0,pt=0;mt<=ht;mt+=2,pt+=ot){const _t=lt+mt,vt=_t+ft,bt=vt+ft,wt=bt+ft,xt=_[_t],Mt=_[_t+1],At=_[vt],St=_[vt+1],Tt=_[bt],Ct=_[bt+1],It=_[wt],$t=_[wt+1],Nt=xt,Bt=Mt,Ot=st[pt],Ut=tt*st[pt+1],Lt=At*Ot-St*Ut,zt=At*Ut+St*Ot,Yt=st[2*pt],en=tt*st[2*pt+1],bn=Tt*Yt-Ct*en,Un=Tt*en+Ct*Yt,mn=st[3*pt],vn=tt*st[3*pt+1],In=It*mn-$t*vn,Cn=It*vn+$t*mn,En=Nt+bn,jt=Bt+Un,Kt=Nt-bn,nn=Bt-Un,Vt=Lt+In,on=zt+Cn,dn=tt*(Lt-In),Ln=tt*(zt-Cn);if(_[_t]=En+Vt,_[_t+1]=jt+on,_[vt]=Kt+Ln,_[vt+1]=nn-dn,mt===0){_[bt]=En-Vt,_[bt+1]=jt-on;continue}if(mt===ht)continue;const Sn=lt+ft-mt,Xn=lt+ct-mt;_[Sn]=Kt-tt*Ln,_[Sn+1]=-nn-tt*dn,_[Xn]=En-tt*Vt,_[Xn+1]=-jt+tt*on}}const it=nt>>>1;for(let ct=2;ct<it;ct+=2)_[nt-ct]=_[ct],_[nt-ct+1]=-_[ct+1]}_singleRealTransform2(_,_e,tt,nt,rt){const ot=_[nt],at=_[nt+rt];_e[tt]=ot+at,_e[tt+1]=0,_e[tt+2]=ot-at,_e[tt+3]=0}_singleRealTransform4(_,_e,tt,nt,rt,ot){const at=rt*2,lt=rt*3,ut=_[nt],dt=_[nt+rt],st=_[nt+at],it=_[nt+lt],ct=ut+st,ft=ut-st,ht=dt+it,mt=ot*(dt-it);_e[tt]=ct+ht,_e[tt+1]=0,_e[tt+2]=ft,_e[tt+3]=-mt,_e[tt+4]=ct-ht,_e[tt+5]=0,_e[tt+6]=ft,_e[tt+7]=mt}}class NP2FFT{constructor(_){const _e=2*(_-1),tt=2*(2*_-1),nt=2**Math.ceil(Math.log2(tt));this.bufferSize=nt,this._a=_e;const rt=new Float64Array(tt),ot=new Float64Array(nt);this._chirpBuffer=new Float64Array(nt),this._buffer1=new Float64Array(nt),this._buffer2=new Float64Array(nt),this._outBuffer1=new Float64Array(nt),this._outBuffer2=new Float64Array(nt);const at=-2*Math.PI/_,lt=Math.cos(at),ut=Math.sin(at);for(let dt=0;dt<tt>>1;++dt){const st=(dt+1-_)**2/2,it=Math.sqrt(lt**2+ut**2)**st,ct=st*Math.atan2(ut,lt),ft=2*dt;rt[ft]=it*Math.cos(ct),rt[ft+1]=it*Math.sin(ct),ot[ft]=rt[ft],ot[ft+1]=-rt[ft+1]}this._slicedChirpBuffer=rt.subarray(_e,tt),this._f=new P2FFT(nt>>1),this._f.transform(this._chirpBuffer,ot)}_transform(_,_e,tt){const nt=this._buffer1,rt=this._buffer2,ot=this._outBuffer1,at=this._outBuffer2,lt=this._chirpBuffer,ut=this._slicedChirpBuffer,dt=this._a;if(tt)for(let st=0;st<ut.length;st+=2){const it=st+1,ct=st>>1,ft=_e[ct];nt[st]=ft*ut[st],nt[it]=ft*ut[it]}else for(let st=0;st<ut.length;st+=2){const it=st+1;nt[st]=_e[st]*ut[st]-_e[it]*ut[it],nt[it]=_e[st]*ut[it]+_e[it]*ut[st]}this._f.transform(ot,nt);for(let st=0;st<lt.length;st+=2){const it=st+1;rt[st]=ot[st]*lt[st]-ot[it]*lt[it],rt[it]=ot[st]*lt[it]+ot[it]*lt[st]}this._f.inverseTransform(at,rt);for(let st=0;st<at.length;st+=2){const it=at[st+dt],ct=at[st+dt+1],ft=ut[st],ht=ut[st+1];_[st]=it*ft-ct*ht,_[st+1]=it*ht+ct*ft}}transform(_,_e){this._transform(_,_e,!1)}realTransform(_,_e){this._transform(_,_e,!0)}}class FFT{constructor(_){this.fft_length=_,this.isPowerOfTwo=isPowerOfTwo(_),this.isPowerOfTwo?(this.fft=new P2FFT(_),this.outputBufferSize=2*_):(this.fft=new NP2FFT(_),this.outputBufferSize=this.fft.bufferSize)}realTransform(_,_e){this.fft.realTransform(_,_e)}transform(_,_e){this.fft.transform(_,_e)}}function medianFilter(et,_){if(_%2===0||_<=0)throw new Error("Window size must be a positive odd number");const _e=new et.constructor(et.length),tt=new et.constructor(_),nt=Math.floor(_/2);for(let rt=0;rt<et.length;++rt){let ot=0;for(let at=-nt;at<=nt;++at){let lt=rt+at;lt<0?lt=Math.abs(lt):lt>=et.length&&(lt=2*(et.length-1)-lt),tt[ot++]=et[lt]}tt.sort(),_e[rt]=tt[nt]}return _e}function round$1(et,_){const _e=Math.pow(10,_);return Math.round(et*_e)/_e}function bankers_round(et){const _=Math.round(et);return Math.abs(et)%1===.5?_%2===0?_:_-1:_}const DataTypeMap=Object.freeze({float32:Float32Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array}),ONNXTensor$1=ONNX.Tensor;class Tensor{constructor(..._){jn(this,"dims");jn(this,"type");jn(this,"data");jn(this,"size");return _[0]instanceof ONNXTensor$1?Object.assign(this,_[0]):Object.assign(this,new ONNXTensor$1(_[0],_[1],_[2])),new Proxy(this,{get:(_e,tt)=>{if(typeof tt=="string"){let nt=Number(tt);if(Number.isInteger(nt))return _e._getitem(nt)}return _e[tt]},set:(_e,tt,nt)=>_e[tt]=nt})}*[Symbol.iterator](){const[_,..._e]=this.dims;if(_e.length>0){const tt=_e.reduce((nt,rt)=>nt*rt);for(let nt=0;nt<_;++nt)yield this._subarray(nt,tt,_e)}else yield*this.data}_getitem(_){const[_e,...tt]=this.dims;if(_=safeIndex(_,_e),tt.length>0){const nt=tt.reduce((rt,ot)=>rt*ot);return this._subarray(_,nt,tt)}else return new Tensor(this.type,[this.data[_]],tt)}indexOf(_){for(let _e=0;_e<this.data.length;++_e)if(this.data[_e]==_)return _e;return-1}_subarray(_,_e,tt){const nt=_*_e,rt=(_+1)*_e,ot="subarray"in this.data?this.data.subarray(nt,rt):this.data.slice(nt,rt);return new Tensor(this.type,ot,tt)}item(){if(this.data.length!==1)throw new Error(`a Tensor with ${this.data.length} elements cannot be converted to Scalar`);return this.data[0]}tolist(){return reshape(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){for(let _=0;_<this.data.length;++_)this.data[_]=1/(1+Math.exp(-this.data[_]));return this}mul(_){return this.clone().mul_(_)}mul_(_){for(let _e=0;_e<this.data.length;++_e)this.data[_e]*=_;return this}add(_){return this.clone().add_(_)}add_(_){for(let _e=0;_e<this.data.length;++_e)this.data[_e]+=_;return this}clone(){return new Tensor(this.type,this.data.slice(),this.dims.slice())}slice(..._){let _e=[],tt=[];for(let lt=0;lt<this.dims.length;++lt){let ut=_[lt];if(ut==null)tt.push([0,this.dims[lt]]),_e.push(this.dims[lt]);else if(typeof ut=="number")ut=safeIndex(ut,this.dims[lt],lt),tt.push([ut,ut+1]);else if(Array.isArray(ut)&&ut.length===2){if(ut[0]>ut[1])throw new Error(`Invalid slice: ${ut}`);let dt=[Math.max(ut[0],0),Math.min(ut[1],this.dims[lt])];tt.push(dt),_e.push(dt[1]-dt[0])}else throw new Error(`Invalid slice: ${ut}`)}let nt=tt.map(([lt,ut])=>ut-lt),rt=nt.reduce((lt,ut)=>lt*ut),ot=new this.data.constructor(rt);const at=this.stride();for(let lt=0;lt<rt;++lt){let ut=0;for(let dt=nt.length-1,st=lt;dt>=0;--dt){const it=nt[dt];ut+=(st%it+tt[dt][0])*at[dt],st=Math.floor(st/it)}ot[lt]=this.data[ut]}return new Tensor(this.type,ot,_e)}permute(..._){return permute(this,_)}transpose(..._){return this.permute(..._)}sum(_=null,_e=!1){return this.norm(1,_,_e)}norm(_="fro",_e=null,tt=!1){if(_==="fro")_=2;else if(typeof _=="string")throw Error(`Unsupported norm: ${_}`);if(_e===null){let ot=this.data.reduce((at,lt)=>at+lt**_,0)**(1/_);return new Tensor(this.type,[ot],[])}_e=safeIndex(_e,this.dims.length);const nt=this.dims.slice();nt[_e]=1;const rt=new this.data.constructor(this.data.length/this.dims[_e]);for(let ot=0;ot<this.data.length;++ot){let at=0;for(let lt=this.dims.length-1,ut=ot,dt=1;lt>=0;--lt){const st=this.dims[lt];if(lt!==_e){const it=ut%st;at+=it*dt,dt*=nt[lt]}ut=Math.floor(ut/st)}rt[at]+=this.data[ot]**_}if(_!==1)for(let ot=0;ot<rt.length;++ot)rt[ot]=rt[ot]**(1/_);return tt||nt.splice(_e,1),new Tensor(this.type,rt,nt)}normalize_(_=2,_e=1){_e=safeIndex(_e,this.dims.length);const tt=this.norm(_,_e,!0);for(let nt=0;nt<this.data.length;++nt){let rt=0;for(let ot=this.dims.length-1,at=nt,lt=1;ot>=0;--ot){const ut=this.dims[ot];if(ot!==_e){const dt=at%ut;rt+=dt*lt,lt*=this.dims[ot]}at=Math.floor(at/ut)}this.data[nt]/=tt.data[rt]}return this}normalize(_=2,_e=1){return this.clone().normalize_(_,_e)}stride(){return dimsToStride(this.dims)}squeeze(_=null){return new Tensor(this.type,this.data,calc_squeeze_dims(this.dims,_))}squeeze_(_=null){return this.dims=calc_squeeze_dims(this.dims,_),this}unsqueeze(_=null){return new Tensor(this.type,this.data,calc_unsqueeze_dims(this.dims,_))}unsqueeze_(_=null){return this.dims=calc_unsqueeze_dims(this.dims,_),this}flatten_(_=0,_e=-1){_e=(_e+this.dims.length)%this.dims.length;let tt=this.dims.slice(0,_),nt=this.dims.slice(_,_e+1),rt=this.dims.slice(_e+1);return this.dims=[...tt,nt.reduce((ot,at)=>ot*at,1),...rt],this}flatten(_=0,_e=-1){return this.clone().flatten_(_,_e)}view(..._){let _e=-1;for(let tt=0;tt<_.length;++tt)if(_[tt]===-1){if(_e!==-1)throw new Error("Only one dimension can be inferred");_e=tt}if(_e!==-1){const tt=_.reduce((nt,rt,ot)=>ot!==_e?nt*rt:nt,1);_[_e]=this.data.length/tt}return new Tensor(this.type,this.data,_)}neg_(){for(let _=0;_<this.data.length;++_)this.data[_]=-this.data[_];return this}neg(){return this.clone().neg_()}clamp_(_,_e){for(let tt=0;tt<this.data.length;++tt)this.data[tt]=Math.min(Math.max(this.data[tt],_),_e);return this}clamp(_,_e){return this.clone().clamp_(_,_e)}round_(){for(let _=0;_<this.data.length;++_)this.data[_]=Math.round(this.data[_]);return this}round(){return this.clone().round_()}to(_){if(this.type===_)return this;if(!DataTypeMap.hasOwnProperty(_))throw new Error(`Unsupported type: ${_}`);return new Tensor(_,DataTypeMap[_].from(this.data),this.dims)}}function reshape(et,_){const _e=et.length,tt=_.reduce((rt,ot)=>rt*ot);if(_e!==tt)throw Error(`cannot reshape array of size ${_e} into shape (${_})`);let nt=et;for(let rt=_.length-1;rt>=0;rt--)nt=nt.reduce((ot,at)=>{let lt=ot[ot.length-1];return lt.length<_[rt]?lt.push(at):ot.push([at]),ot},[[]]);return nt[0]}function permute(et,_){const[_e,tt]=permute_data(et.data,et.dims,_);return new Tensor(et.type,_e,tt)}function interpolate(et,[_,_e],tt="bilinear",nt=!1){const rt=et.dims.at(-3)??1,ot=et.dims.at(-2),at=et.dims.at(-1);let lt=interpolate_data(et.data,[rt,ot,at],[_,_e],tt,nt);return new Tensor(et.type,lt,[rt,_,_e])}function mean_pooling(et,_){let _e=[et.dims[0],et.dims[2]],tt=new et.data.constructor(_e[0]*_e[1]),[nt,rt,ot]=et.dims,at=0;for(let lt=0;lt<nt;++lt){let ut=lt*ot*rt;for(let dt=0;dt<ot;++dt){let st=0,it=0,ct=lt*rt,ft=ut+dt;for(let mt=0;mt<rt;++mt){let pt=Number(_.data[ct+mt]);it+=pt,st+=et.data[ft+mt*ot]*pt}let ht=st/it;tt[at++]=ht}}return new Tensor(et.type,tt,_e)}function calc_squeeze_dims(et,_){return et=et.slice(),_===null?et=et.filter(_e=>_e!==1):typeof _=="number"?et[_]===1&&et.splice(_,1):Array.isArray(_)&&(et=et.filter((_e,tt)=>_e!==1||!_.includes(tt))),et}function calc_unsqueeze_dims(et,_){return _=safeIndex(_,et.length+1),et=et.slice(),et.splice(_,0,1),et}function safeIndex(et,_,_e=null){if(et<-_||et>=_)throw new Error(`IndexError: index ${et} is out of bounds for dimension${_e===null?"":" "+_e} with size ${_}`);return et<0&&(et=(et%_+_)%_),et}function cat(et,_=0){_=safeIndex(_,et[0].dims.length);const _e=et[0].dims.slice();_e[_]=et.reduce((ot,at)=>ot+at.dims[_],0);const tt=_e.reduce((ot,at)=>ot*at,1),nt=new et[0].data.constructor(tt),rt=et[0].type;if(_===0){let ot=0;for(let at of et)nt.set(at.data,ot),ot+=at.data.length}else{let ot=0;for(let at=0;at<et.length;++at){let lt=et[at];for(let ut=0;ut<lt.data.length;++ut){let dt=0;for(let st=lt.dims.length-1,it=ut,ct=1;st>=0;--st){const ft=lt.dims[st];let ht=it%ft;st===_&&(ht+=ot),dt+=ht*ct,ct*=_e[st],it=Math.floor(it/ft)}nt[dt]=lt.data[ut]}ot+=lt.dims[_]}}return new Tensor(rt,nt,_e)}function stack(et,_=0){return cat(et.map(_e=>_e.unsqueeze(_)),_)}function std_mean(et,_=null,_e=1,tt=!1){if(_===null){const ut=et.data.reduce((ct,ft)=>ct+ft,0)/et.data.length,dt=Math.sqrt(et.data.reduce((ct,ft)=>ct+(ft-ut)**2,0)/(et.data.length-_e)),st=new Tensor(et.type,[ut],[]);return[new Tensor(et.type,[dt],[]),st]}_=safeIndex(_,et.dims.length);const nt=mean(et,_,tt),rt=et.dims.slice();rt[_]=1;const ot=new et.data.constructor(et.data.length/et.dims[_]);for(let lt=0;lt<et.data.length;++lt){let ut=0;for(let dt=et.dims.length-1,st=lt,it=1;dt>=0;--dt){const ct=et.dims[dt];if(dt!==_){const ft=st%ct;ut+=ft*it,it*=rt[dt]}st=Math.floor(st/ct)}ot[ut]+=(et.data[lt]-nt.data[ut])**2}for(let lt=0;lt<ot.length;++lt)ot[lt]=Math.sqrt(ot[lt]/(et.dims[_]-_e));return tt||rt.splice(_,1),[new Tensor(et.type,ot,rt),nt]}function mean(et,_=null,_e=!1){if(_===null){let rt=et.data.reduce((ot,at)=>ot+at,0);return new Tensor(et.type,[rt/et.data.length],[])}_=safeIndex(_,et.dims.length);const tt=et.dims.slice();tt[_]=1;const nt=new et.data.constructor(et.data.length/et.dims[_]);for(let rt=0;rt<et.data.length;++rt){let ot=0;for(let at=et.dims.length-1,lt=rt,ut=1;at>=0;--at){const dt=et.dims[at];if(at!==_){const st=lt%dt;ot+=st*ut,ut*=tt[at]}lt=Math.floor(lt/dt)}nt[ot]+=et.data[rt]}if(et.dims[_]!==1)for(let rt=0;rt<nt.length;++rt)nt[rt]=nt[rt]/et.dims[_];return _e||tt.splice(_,1),new Tensor(et.type,nt,tt)}function dynamicTimeWarping(et){const[_,_e]=et.dims,tt=[_+1,_e+1],nt=new Tensor("float32",new Float32Array(tt[0]*tt[1]).fill(1/0),tt),rt=new Tensor("float32",new Float32Array(tt[0]*tt[1]).fill(-1),tt);nt[0].data[0]=0;for(let dt=1;dt<_e+1;++dt)for(let st=1;st<_+1;++st){const it=nt[st-1][dt-1].item(),ct=nt[st-1][dt].item(),ft=nt[st][dt-1].item();let ht,mt;it<ct&&it<ft?(ht=it,mt=0):ct<it&&ct<ft?(ht=ct,mt=1):(ht=ft,mt=2),nt[st].data[dt]=et[st-1][dt-1].item()+ht,rt[st].data[dt]=mt}let ot=_,at=_e;rt.data.fill(2,0,tt[1]);for(let dt=0;dt<tt[0];++dt)rt[dt].data[0]=1;let lt=[],ut=[];for(;ot>0||at>0;)switch(lt.push(ot-1),ut.push(at-1),rt[ot][at].item()){case 0:--ot,--at;break;case 1:--ot;break;case 2:--at;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${ot}, ${at}]. Please file a bug report.`)}return lt.reverse(),ut.reverse(),[lt,ut]}function dimsToStride(et){const _=new Array(et.length);for(let _e=et.length-1,tt=1;_e>=0;--_e)_[_e]=tt,tt*=et[_e];return _}function ones(et){const _=et.reduce((_e,tt)=>_e*tt,1);return new Tensor("int64",new BigInt64Array(_).fill(1n),et)}function ones_like(et){return ones(et.dims)}function quantize_embeddings(et,_){if(et.dims.length!==2)throw new Error("The tensor must have 2 dimensions");if(et.dims.at(-1)%8!==0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(_))throw new Error("The precision must be either 'binary' or 'ubinary'");const _e=_==="binary",tt=_e?"int8":"uint8",nt=_e?Int8Array:Uint8Array,rt=et.data,ot=new nt(rt.length/8);for(let at=0;at<rt.length;++at){const lt=rt[at]>0?1:0,ut=Math.floor(at/8),dt=at%8;ot[ut]|=lt<<7-dt,_e&&dt===0&&(ot[ut]-=128)}return new Tensor(tt,ot,[et.dims[0],et.dims[1]/8])}class PriorityQueue{constructor(_=(_e,tt)=>_e>tt){this._heap=[],this._comparator=_}get size(){return this._heap.length}isEmpty(){return this.size===0}peek(){return this._heap[0]}push(..._){return this.extend(_)}extend(_){for(const _e of _)this._heap.push(_e),this._siftUp();return this.size}pop(){const _=this.peek(),_e=this.size-1;return _e>0&&this._swap(0,_e),this._heap.pop(),this._siftDown(),_}replace(_){const _e=this.peek();return this._heap[0]=_,this._siftDown(),_e}_parent(_){return(_+1>>>1)-1}_left(_){return(_<<1)+1}_right(_){return _+1<<1}_greater(_,_e){return this._comparator(this._heap[_],this._heap[_e])}_swap(_,_e){const tt=this._heap[_];this._heap[_]=this._heap[_e],this._heap[_e]=tt}_siftUp(){let _=this.size-1;for(;_>0&&this._greater(_,this._parent(_));)this._swap(_,this._parent(_)),_=this._parent(_)}_siftDown(){let _=0;for(;this._left(_)<this.size&&this._greater(this._left(_),_)||this._right(_)<this.size&&this._greater(this._right(_),_);){const _e=this._right(_)<this.size&&this._greater(this._right(_),this._left(_))?this._right(_):this._left(_);this._swap(_,_e),_=_e}}}class CharTrie{constructor(){this.root=CharTrieNode.default()}extend(_){for(let _e of _)this.push(_e)}push(_){let _e=this.root;for(let tt of _){let nt=_e.children.get(tt);nt===void 0&&(nt=CharTrieNode.default(),_e.children.set(tt,nt)),_e=nt}_e.isLeaf=!0}*commonPrefixSearch(_){let _e=this.root,tt="";for(let nt=0;nt<_.length&&_e!==void 0;++nt){const rt=_[nt];tt+=rt,_e=_e.children.get(rt),_e!==void 0&&_e.isLeaf&&(yield tt)}}}class CharTrieNode{constructor(_,_e){this.isLeaf=_,this.children=_e}static default(){return new CharTrieNode(!1,new Map)}}class TokenLattice{constructor(_,_e,tt){this.sentence=_,this.len=_.length,this.bosTokenId=_e,this.eosTokenId=tt,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);const nt=new TokenLatticeNode(this.bosTokenId,0,0,0,0),rt=new TokenLatticeNode(this.eosTokenId,1,this.len,0,0);this.nodes.push(nt.clone()),this.nodes.push(rt.clone()),this.beginNodes[this.len].push(rt),this.endNodes[0].push(nt)}insert(_,_e,tt,nt){const rt=this.nodes.length,ot=new TokenLatticeNode(nt,rt,_,_e,tt);this.beginNodes[_].push(ot),this.endNodes[_+_e].push(ot),this.nodes.push(ot)}viterbi(){const _=this.len;let _e=0;for(;_e<=_;){if(this.beginNodes[_e].length==0)return[];for(let at of this.beginNodes[_e]){at.prev=null;let lt=0,ut=null;for(let dt of this.endNodes[_e]){const st=dt.backtraceScore+at.score;(ut===null||st>lt)&&(ut=dt.clone(),lt=st)}if(ut!==null)at.prev=ut,at.backtraceScore=lt;else return[]}++_e}const tt=[],rt=this.beginNodes[_][0].prev;if(rt===null)return[];let ot=rt.clone();for(;ot.prev!==null;)tt.push(ot.clone()),ot=ot.clone().prev.clone();return tt.reverse(),tt}piece(_){return this.sentence.slice(_.pos,_.pos+_.length)}tokens(){return this.viterbi().map(_e=>this.piece(_e))}tokenIds(){return this.viterbi().map(_e=>_e.tokenId)}}class TokenLatticeNode{constructor(_,_e,tt,nt,rt){this.tokenId=_,this.nodeId=_e,this.pos=tt,this.length=nt,this.score=rt,this.prev=null,this.backtraceScore=0}clone(){const _=new TokenLatticeNode(this.tokenId,this.nodeId,this.pos,this.length,this.score);return _.prev=this.prev,_.backtraceScore=this.backtraceScore,_}}var TOKEN_TYPES=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",Is:"Is",NotIn:"NotIn",Else:"Else",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator"}),KEYWORDS=Object.freeze({set:TOKEN_TYPES.Set,for:TOKEN_TYPES.For,in:TOKEN_TYPES.In,is:TOKEN_TYPES.Is,if:TOKEN_TYPES.If,else:TOKEN_TYPES.Else,endif:TOKEN_TYPES.EndIf,elif:TOKEN_TYPES.ElseIf,endfor:TOKEN_TYPES.EndFor,and:TOKEN_TYPES.And,or:TOKEN_TYPES.Or,not:TOKEN_TYPES.Not,"not in":TOKEN_TYPES.NotIn,true:TOKEN_TYPES.BooleanLiteral,false:TOKEN_TYPES.BooleanLiteral}),Token=class{constructor(et,_){this.value=et,this.type=_}};function isWord(et){return/\w/.test(et)}function isInteger(et){return/[0-9]/.test(et)}var ORDERED_MAPPING_TABLE=[["{%",TOKEN_TYPES.OpenStatement],["%}",TOKEN_TYPES.CloseStatement],["{{",TOKEN_TYPES.OpenExpression],["}}",TOKEN_TYPES.CloseExpression],["(",TOKEN_TYPES.OpenParen],[")",TOKEN_TYPES.CloseParen],["{",TOKEN_TYPES.OpenCurlyBracket],["}",TOKEN_TYPES.CloseCurlyBracket],["[",TOKEN_TYPES.OpenSquareBracket],["]",TOKEN_TYPES.CloseSquareBracket],[",",TOKEN_TYPES.Comma],[".",TOKEN_TYPES.Dot],[":",TOKEN_TYPES.Colon],["|",TOKEN_TYPES.Pipe],["<=",TOKEN_TYPES.ComparisonBinaryOperator],[">=",TOKEN_TYPES.ComparisonBinaryOperator],["==",TOKEN_TYPES.ComparisonBinaryOperator],["!=",TOKEN_TYPES.ComparisonBinaryOperator],["<",TOKEN_TYPES.ComparisonBinaryOperator],[">",TOKEN_TYPES.ComparisonBinaryOperator],["+",TOKEN_TYPES.AdditiveBinaryOperator],["-",TOKEN_TYPES.AdditiveBinaryOperator],["*",TOKEN_TYPES.MultiplicativeBinaryOperator],["/",TOKEN_TYPES.MultiplicativeBinaryOperator],["%",TOKEN_TYPES.MultiplicativeBinaryOperator],["=",TOKEN_TYPES.Equals]],ESCAPE_CHARACTERS=new Map([["n",`
`],["t","	"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function preprocess(et,_={}){return et.endsWith(`
`)&&(et=et.slice(0,-1)),et=et.replace(/{#.*?#}/gs,"{##}"),_.lstrip_blocks&&(et=et.replace(/^[ \t]*({[#%])/gm,"$1")),_.trim_blocks&&(et=et.replace(/([#%]})\n/g,"$1")),et.replace(/{##}/g,"").replace(/-%}\s*/g,"%}").replace(/\s*{%-/g,"{%").replace(/-}}\s*/g,"}}").replace(/\s*{{-/g,"{{")}function tokenize(et,_={}){var ot,at,lt;const _e=[],tt=preprocess(et,_);let nt=0;const rt=ut=>{let dt="";for(;ut(tt[nt]);){if(tt[nt]==="\\"){if(++nt,nt>=tt.length)throw new SyntaxError("Unexpected end of input");const st=tt[nt++],it=ESCAPE_CHARACTERS.get(st);if(it===void 0)throw new SyntaxError(`Unexpected escaped character: ${st}`);dt+=it;continue}if(dt+=tt[nt++],nt>=tt.length)throw new SyntaxError("Unexpected end of input")}return dt};e:for(;nt<tt.length;){const ut=(ot=_e.at(-1))==null?void 0:ot.type;if(ut===void 0||ut===TOKEN_TYPES.CloseStatement||ut===TOKEN_TYPES.CloseExpression){let st="";for(;nt<tt.length&&!(tt[nt]==="{"&&(tt[nt+1]==="%"||tt[nt+1]==="{"));)st+=tt[nt++];if(st.length>0){_e.push(new Token(st,TOKEN_TYPES.Text));continue}}rt(st=>/\s/.test(st));const dt=tt[nt];if(dt==="-"||dt==="+"){const st=(at=_e.at(-1))==null?void 0:at.type;if(st===TOKEN_TYPES.Text||st===void 0)throw new SyntaxError(`Unexpected character: ${dt}`);switch(st){case TOKEN_TYPES.Identifier:case TOKEN_TYPES.NumericLiteral:case TOKEN_TYPES.BooleanLiteral:case TOKEN_TYPES.StringLiteral:case TOKEN_TYPES.CloseParen:case TOKEN_TYPES.CloseSquareBracket:break;default:{++nt;const it=rt(isInteger);_e.push(new Token(`${dt}${it}`,it.length>0?TOKEN_TYPES.NumericLiteral:TOKEN_TYPES.UnaryOperator));continue}}}for(const[st,it]of ORDERED_MAPPING_TABLE)if(tt.slice(nt,nt+st.length)===st){_e.push(new Token(st,it)),nt+=st.length;continue e}if(dt==="'"||dt==='"'){++nt;const st=rt(it=>it!==dt);_e.push(new Token(st,TOKEN_TYPES.StringLiteral)),++nt;continue}if(isInteger(dt)){const st=rt(isInteger);_e.push(new Token(st,TOKEN_TYPES.NumericLiteral));continue}if(isWord(dt)){const st=rt(isWord),it=Object.hasOwn(KEYWORDS,st)?KEYWORDS[st]:TOKEN_TYPES.Identifier;it===TOKEN_TYPES.In&&((lt=_e.at(-1))==null?void 0:lt.type)===TOKEN_TYPES.Not?(_e.pop(),_e.push(new Token("not in",TOKEN_TYPES.NotIn))):_e.push(new Token(st,it));continue}throw new SyntaxError(`Unexpected character: ${dt}`)}return _e}var Statement=class{constructor(){jn(this,"type","Statement")}},Program=class extends Statement{constructor(_){super();jn(this,"type","Program");this.body=_}},If=class extends Statement{constructor(_,_e,tt){super();jn(this,"type","If");this.test=_,this.body=_e,this.alternate=tt}},For=class extends Statement{constructor(_,_e,tt){super();jn(this,"type","For");this.loopvar=_,this.iterable=_e,this.body=tt}},SetStatement=class extends Statement{constructor(_,_e){super();jn(this,"type","Set");this.assignee=_,this.value=_e}},Expression=class extends Statement{constructor(){super(...arguments);jn(this,"type","Expression")}},MemberExpression=class extends Expression{constructor(_,_e,tt){super();jn(this,"type","MemberExpression");this.object=_,this.property=_e,this.computed=tt}},CallExpression=class extends Expression{constructor(_,_e){super();jn(this,"type","CallExpression");this.callee=_,this.args=_e}},Identifier=class extends Expression{constructor(_){super();jn(this,"type","Identifier");this.value=_}},Literal=class extends Expression{constructor(_){super();jn(this,"type","Literal");this.value=_}},NumericLiteral=class extends Literal{constructor(){super(...arguments);jn(this,"type","NumericLiteral")}},StringLiteral=class extends Literal{constructor(){super(...arguments);jn(this,"type","StringLiteral")}},BooleanLiteral=class extends Literal{constructor(){super(...arguments);jn(this,"type","BooleanLiteral")}},ArrayLiteral=class extends Literal{constructor(){super(...arguments);jn(this,"type","ArrayLiteral")}},TupleLiteral=class extends Literal{constructor(){super(...arguments);jn(this,"type","TupleLiteral")}},ObjectLiteral=class extends Literal{constructor(){super(...arguments);jn(this,"type","ObjectLiteral")}},BinaryExpression=class extends Expression{constructor(_,_e,tt){super();jn(this,"type","BinaryExpression");this.operator=_,this.left=_e,this.right=tt}},FilterExpression=class extends Expression{constructor(_,_e){super();jn(this,"type","FilterExpression");this.operand=_,this.filter=_e}},TestExpression=class extends Expression{constructor(_,_e,tt){super();jn(this,"type","TestExpression");this.operand=_,this.negate=_e,this.test=tt}},UnaryExpression=class extends Expression{constructor(_,_e){super();jn(this,"type","UnaryExpression");this.operator=_,this.argument=_e}},SliceExpression=class extends Expression{constructor(_=void 0,_e=void 0,tt=void 0){super();jn(this,"type","SliceExpression");this.start=_,this.stop=_e,this.step=tt}},KeywordArgumentExpression=class extends Expression{constructor(_,_e){super();jn(this,"type","KeywordArgumentExpression");this.key=_,this.value=_e}};function parse$1(et){const _=new Program([]);let _e=0;function tt(Bt,Ot){const Ut=et[_e++];if(!Ut||Ut.type!==Bt)throw new Error(`Parser Error: ${Ot}. ${Ut.type} !== ${Bt}.`);return Ut}function nt(){switch(et[_e].type){case TOKEN_TYPES.Text:return at();case TOKEN_TYPES.OpenStatement:return lt();case TOKEN_TYPES.OpenExpression:return ut();default:throw new SyntaxError(`Unexpected token type: ${et[_e].type}`)}}function rt(...Bt){return _e+Bt.length<=et.length&&Bt.some((Ot,Ut)=>Ot!==et[_e+Ut].type)}function ot(...Bt){return _e+Bt.length<=et.length&&Bt.every((Ot,Ut)=>Ot===et[_e+Ut].type)}function at(){return new StringLiteral(tt(TOKEN_TYPES.Text,"Expected text token").value)}function lt(){tt(TOKEN_TYPES.OpenStatement,"Expected opening statement token");let Bt;switch(et[_e].type){case TOKEN_TYPES.Set:++_e,Bt=dt(),tt(TOKEN_TYPES.CloseStatement,"Expected closing statement token");break;case TOKEN_TYPES.If:++_e,Bt=st(),tt(TOKEN_TYPES.OpenStatement,"Expected {% token"),tt(TOKEN_TYPES.EndIf,"Expected endif token"),tt(TOKEN_TYPES.CloseStatement,"Expected %} token");break;case TOKEN_TYPES.For:++_e,Bt=ct(),tt(TOKEN_TYPES.OpenStatement,"Expected {% token"),tt(TOKEN_TYPES.EndFor,"Expected endfor token"),tt(TOKEN_TYPES.CloseStatement,"Expected %} token");break;default:throw new SyntaxError(`Unknown statement type: ${et[_e].type}`)}return Bt}function ut(){tt(TOKEN_TYPES.OpenExpression,"Expected opening expression token");const Bt=ft();return tt(TOKEN_TYPES.CloseExpression,"Expected closing expression token"),Bt}function dt(){const Bt=ft();if(ot(TOKEN_TYPES.Equals)){++_e;const Ot=dt();return new SetStatement(Bt,Ot)}return Bt}function st(){var Lt,zt,Yt,en,bn,Un,mn,vn;const Bt=ft();tt(TOKEN_TYPES.CloseStatement,"Expected closing statement token");const Ot=[],Ut=[];for(;!(((Lt=et[_e])==null?void 0:Lt.type)===TOKEN_TYPES.OpenStatement&&(((zt=et[_e+1])==null?void 0:zt.type)===TOKEN_TYPES.ElseIf||((Yt=et[_e+1])==null?void 0:Yt.type)===TOKEN_TYPES.Else||((en=et[_e+1])==null?void 0:en.type)===TOKEN_TYPES.EndIf));)Ot.push(nt());if(((bn=et[_e])==null?void 0:bn.type)===TOKEN_TYPES.OpenStatement&&((Un=et[_e+1])==null?void 0:Un.type)!==TOKEN_TYPES.EndIf)if(++_e,ot(TOKEN_TYPES.ElseIf))tt(TOKEN_TYPES.ElseIf,"Expected elseif token"),Ut.push(st());else for(tt(TOKEN_TYPES.Else,"Expected else token"),tt(TOKEN_TYPES.CloseStatement,"Expected closing statement token");!(((mn=et[_e])==null?void 0:mn.type)===TOKEN_TYPES.OpenStatement&&((vn=et[_e+1])==null?void 0:vn.type)===TOKEN_TYPES.EndIf);)Ut.push(nt());return new If(Bt,Ot,Ut)}function it(Bt=!1){const Ot=Bt?Nt:ft,Ut=[Ot()],Lt=ot(TOKEN_TYPES.Comma);for(;Lt&&(++_e,Ut.push(Ot()),!!ot(TOKEN_TYPES.Comma)););return Lt?new TupleLiteral(Ut):Ut[0]}function ct(){const Bt=it(!0);if(!(Bt instanceof Identifier||Bt instanceof TupleLiteral))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${Bt.type} instead`);tt(TOKEN_TYPES.In,"Expected `in` keyword following loop variable");const Ot=ft();tt(TOKEN_TYPES.CloseStatement,"Expected closing statement token");const Ut=[];for(;rt(TOKEN_TYPES.OpenStatement,TOKEN_TYPES.EndFor);)Ut.push(nt());return new For(Bt,Ot,Ut)}function ft(){return ht()}function ht(){const Bt=mt();if(ot(TOKEN_TYPES.If)){++_e;const Ot=mt();tt(TOKEN_TYPES.Else,"Expected else token");const Ut=mt();return new If(Ot,[Bt],[Ut])}return Bt}function mt(){let Bt=pt();for(;ot(TOKEN_TYPES.Or);){const Ot=et[_e];++_e;const Ut=pt();Bt=new BinaryExpression(Ot,Bt,Ut)}return Bt}function pt(){let Bt=_t();for(;ot(TOKEN_TYPES.And);){const Ot=et[_e];++_e;const Ut=_t();Bt=new BinaryExpression(Ot,Bt,Ut)}return Bt}function _t(){let Bt;for(;ot(TOKEN_TYPES.Not);){const Ot=et[_e];++_e;const Ut=_t();Bt=new UnaryExpression(Ot,Ut)}return Bt??vt()}function vt(){let Bt=bt();for(;ot(TOKEN_TYPES.ComparisonBinaryOperator)||ot(TOKEN_TYPES.In)||ot(TOKEN_TYPES.NotIn);){const Ot=et[_e];++_e;const Ut=bt();Bt=new BinaryExpression(Ot,Bt,Ut)}return Bt}function bt(){let Bt=Ct();for(;ot(TOKEN_TYPES.AdditiveBinaryOperator);){const Ot=et[_e];++_e;const Ut=Ct();Bt=new BinaryExpression(Ot,Bt,Ut)}return Bt}function wt(){const Bt=Tt();return ot(TOKEN_TYPES.OpenParen)?xt(Bt):Bt}function xt(Bt){let Ot=new CallExpression(Bt,Mt());return ot(TOKEN_TYPES.OpenParen)&&(Ot=xt(Ot)),Ot}function Mt(){tt(TOKEN_TYPES.OpenParen,"Expected opening parenthesis for arguments list");const Bt=At();return tt(TOKEN_TYPES.CloseParen,"Expected closing parenthesis for arguments list"),Bt}function At(){const Bt=[];for(;!ot(TOKEN_TYPES.CloseParen);){let Ot=ft();if(ot(TOKEN_TYPES.Equals)){if(++_e,!(Ot instanceof Identifier))throw new SyntaxError("Expected identifier for keyword argument");const Ut=ft();Ot=new KeywordArgumentExpression(Ot,Ut)}Bt.push(Ot),ot(TOKEN_TYPES.Comma)&&++_e}return Bt}function St(){const Bt=[];let Ot=!1;for(;!ot(TOKEN_TYPES.CloseSquareBracket);)ot(TOKEN_TYPES.Colon)?(Bt.push(void 0),++_e,Ot=!0):(Bt.push(ft()),ot(TOKEN_TYPES.Colon)&&(++_e,Ot=!0));if(Bt.length===0)throw new SyntaxError("Expected at least one argument for member/slice expression");if(Ot){if(Bt.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new SliceExpression(...Bt)}return Bt[0]}function Tt(){let Bt=Nt();for(;ot(TOKEN_TYPES.Dot)||ot(TOKEN_TYPES.OpenSquareBracket);){const Ot=et[_e];++_e;let Ut;const Lt=Ot.type!==TOKEN_TYPES.Dot;if(Lt)Ut=St(),tt(TOKEN_TYPES.CloseSquareBracket,"Expected closing square bracket");else if(Ut=Nt(),Ut.type!=="Identifier")throw new SyntaxError("Expected identifier following dot operator");Bt=new MemberExpression(Bt,Ut,Lt)}return Bt}function Ct(){let Bt=It();for(;ot(TOKEN_TYPES.MultiplicativeBinaryOperator);){const Ot=et[_e];++_e;const Ut=It();Bt=new BinaryExpression(Ot,Bt,Ut)}return Bt}function It(){let Bt=$t();for(;ot(TOKEN_TYPES.Is);){++_e;const Ot=ot(TOKEN_TYPES.Not);Ot&&++_e;let Ut=Nt();if(Ut instanceof BooleanLiteral&&(Ut=new Identifier(Ut.value.toString())),!(Ut instanceof Identifier))throw new SyntaxError("Expected identifier for the test");Bt=new TestExpression(Bt,Ot,Ut)}return Bt}function $t(){let Bt=wt();for(;ot(TOKEN_TYPES.Pipe);){++_e;let Ot=Nt();if(!(Ot instanceof Identifier))throw new SyntaxError("Expected identifier for the filter");ot(TOKEN_TYPES.OpenParen)&&(Ot=xt(Ot)),Bt=new FilterExpression(Bt,Ot)}return Bt}function Nt(){const Bt=et[_e];switch(Bt.type){case TOKEN_TYPES.NumericLiteral:return++_e,new NumericLiteral(Number(Bt.value));case TOKEN_TYPES.StringLiteral:return++_e,new StringLiteral(Bt.value);case TOKEN_TYPES.BooleanLiteral:return++_e,new BooleanLiteral(Bt.value==="true");case TOKEN_TYPES.Identifier:return++_e,new Identifier(Bt.value);case TOKEN_TYPES.OpenParen:{++_e;const Ot=it();if(et[_e].type!==TOKEN_TYPES.CloseParen)throw new SyntaxError(`Expected closing parenthesis, got ${et[_e].type} instead`);return++_e,Ot}case TOKEN_TYPES.OpenSquareBracket:{++_e;const Ot=[];for(;!ot(TOKEN_TYPES.CloseSquareBracket);)Ot.push(ft()),ot(TOKEN_TYPES.Comma)&&++_e;return++_e,new ArrayLiteral(Ot)}case TOKEN_TYPES.OpenCurlyBracket:{++_e;const Ot=new Map;for(;!ot(TOKEN_TYPES.CloseCurlyBracket);){const Ut=ft();tt(TOKEN_TYPES.Colon,"Expected colon between key and value in object literal");const Lt=ft();Ot.set(Ut,Lt),ot(TOKEN_TYPES.Comma)&&++_e}return++_e,new ObjectLiteral(Ot)}default:throw new SyntaxError(`Unexpected token: ${Bt.type}`)}}for(;_e<et.length;)_.body.push(nt());return _}function range$1(et,_,_e=1){_===void 0&&(_=et,et=0);const tt=[];for(let nt=et;nt<_;nt+=_e)tt.push(nt);return tt}function slice(et,_,_e,tt=1){const nt=Math.sign(tt);nt>=0?(_=(_??(_=0))<0?Math.max(et.length+_,0):Math.min(_,et.length),_e=(_e??(_e=et.length))<0?Math.max(et.length+_e,0):Math.min(_e,et.length)):(_=(_??(_=et.length-1))<0?Math.max(et.length+_,-1):Math.min(_,et.length-1),_e=(_e??(_e=-1))<-1?Math.max(et.length+_e,-1):Math.min(_e,et.length-1));const rt=[];for(let ot=_;nt*ot<nt*_e;ot+=tt)rt.push(et[ot]);return rt}function titleCase(et){return et.replace(/\b\w/g,_=>_.toUpperCase())}var RuntimeValue=class{constructor(et=void 0){jn(this,"type","RuntimeValue");jn(this,"value");jn(this,"builtins",new Map);this.value=et}__bool__(){return new BooleanValue(!!this.value)}},NumericValue=class extends RuntimeValue{constructor(){super(...arguments);jn(this,"type","NumericValue")}},StringValue=class extends RuntimeValue{constructor(){super(...arguments);jn(this,"type","StringValue");jn(this,"builtins",new Map([["upper",new FunctionValue(()=>new StringValue(this.value.toUpperCase()))],["lower",new FunctionValue(()=>new StringValue(this.value.toLowerCase()))],["strip",new FunctionValue(()=>new StringValue(this.value.trim()))],["title",new FunctionValue(()=>new StringValue(titleCase(this.value)))],["length",new NumericValue(this.value.length)]]))}},BooleanValue=class extends RuntimeValue{constructor(){super(...arguments);jn(this,"type","BooleanValue")}},ObjectValue=class extends RuntimeValue{constructor(){super(...arguments);jn(this,"type","ObjectValue");jn(this,"builtins",new Map([["get",new FunctionValue(([_,_e])=>{if(!(_ instanceof StringValue))throw new Error(`Object key must be a string: got ${_.type}`);return this.value.get(_.value)??_e??new NullValue})],["items",new FunctionValue(()=>new ArrayValue(Array.from(this.value.entries()).map(([_,_e])=>new ArrayValue([new StringValue(_),_e]))))]]))}__bool__(){return new BooleanValue(this.value.size>0)}},ArrayValue=class extends RuntimeValue{constructor(){super(...arguments);jn(this,"type","ArrayValue");jn(this,"builtins",new Map([["length",new NumericValue(this.value.length)]]))}__bool__(){return new BooleanValue(this.value.length>0)}},TupleValue=class extends ArrayValue{constructor(){super(...arguments);jn(this,"type","TupleValue")}},FunctionValue=class extends RuntimeValue{constructor(){super(...arguments);jn(this,"type","FunctionValue")}},NullValue=class extends RuntimeValue{constructor(){super(...arguments);jn(this,"type","NullValue")}},UndefinedValue=class extends RuntimeValue{constructor(){super(...arguments);jn(this,"type","UndefinedValue")}},Environment=class{constructor(et){jn(this,"variables",new Map([["namespace",new FunctionValue(et=>{if(et.length===0)return new ObjectValue(new Map);if(et.length!==1||!(et[0]instanceof ObjectValue))throw new Error("`namespace` expects either zero arguments or a single object argument");return et[0]})]]));jn(this,"tests",new Map([["boolean",et=>et.type==="BooleanValue"],["callable",et=>et instanceof FunctionValue],["odd",et=>{if(et.type!=="NumericValue")throw new Error(`Cannot apply test "odd" to type: ${et.type}`);return et.value%2!==0}],["even",et=>{if(et.type!=="NumericValue")throw new Error(`Cannot apply test "even" to type: ${et.type}`);return et.value%2===0}],["false",et=>et.type==="BooleanValue"&&!et.value],["true",et=>et.type==="BooleanValue"&&et.value],["number",et=>et.type==="NumericValue"],["integer",et=>et.type==="NumericValue"&&Number.isInteger(et.value)],["iterable",et=>et instanceof ArrayValue||et instanceof StringValue],["lower",et=>{const _=et.value;return et.type==="StringValue"&&_===_.toLowerCase()}],["upper",et=>{const _=et.value;return et.type==="StringValue"&&_===_.toUpperCase()}],["none",et=>et.type==="NullValue"],["defined",et=>et.type!=="UndefinedValue"],["undefined",et=>et.type==="UndefinedValue"],["equalto",(et,_)=>et.value===_.value]]));this.parent=et}set(et,_){return this.declareVariable(et,convertToRuntimeValues(_))}declareVariable(et,_){if(this.variables.has(et))throw new SyntaxError(`Variable already declared: ${et}`);return this.variables.set(et,_),_}setVariable(et,_){return this.variables.set(et,_),_}resolve(et){if(this.variables.has(et))return this;if(this.parent)return this.parent.resolve(et);throw new Error(`Unknown variable: ${et}`)}lookupVariable(et){try{return this.resolve(et).variables.get(et)??new UndefinedValue}catch{return new UndefinedValue}}},Interpreter=class{constructor(et){jn(this,"global");this.global=et??new Environment}run(et){return this.evaluate(et,this.global)}evaluateBinaryExpression(et,_){const _e=this.evaluate(et.left,_);switch(et.operator.value){case"and":return _e.__bool__().value?this.evaluate(et.right,_):_e;case"or":return _e.__bool__().value?_e:this.evaluate(et.right,_)}const tt=this.evaluate(et.right,_);switch(et.operator.value){case"==":return new BooleanValue(_e.value==tt.value);case"!=":return new BooleanValue(_e.value!=tt.value)}if(_e instanceof UndefinedValue||tt instanceof UndefinedValue)throw new Error("Cannot perform operation on undefined values");if(_e instanceof NullValue||tt instanceof NullValue)throw new Error("Cannot perform operation on null values");if(_e instanceof NumericValue&&tt instanceof NumericValue)switch(et.operator.value){case"+":return new NumericValue(_e.value+tt.value);case"-":return new NumericValue(_e.value-tt.value);case"*":return new NumericValue(_e.value*tt.value);case"/":return new NumericValue(_e.value/tt.value);case"%":return new NumericValue(_e.value%tt.value);case"<":return new BooleanValue(_e.value<tt.value);case">":return new BooleanValue(_e.value>tt.value);case">=":return new BooleanValue(_e.value>=tt.value);case"<=":return new BooleanValue(_e.value<=tt.value)}else if(_e instanceof ArrayValue&&tt instanceof ArrayValue)switch(et.operator.value){case"+":return new ArrayValue(_e.value.concat(tt.value))}else if(tt instanceof ArrayValue){const nt=tt.value.find(rt=>rt.value===_e.value)!==void 0;switch(et.operator.value){case"in":return new BooleanValue(nt);case"not in":return new BooleanValue(!nt)}}if(_e instanceof StringValue||tt instanceof StringValue)switch(et.operator.value){case"+":return new StringValue(_e.value.toString()+tt.value.toString())}if(_e instanceof StringValue&&tt instanceof StringValue)switch(et.operator.value){case"in":return new BooleanValue(tt.value.includes(_e.value));case"not in":return new BooleanValue(!tt.value.includes(_e.value))}if(_e instanceof StringValue&&tt instanceof ObjectValue)switch(et.operator.value){case"in":return new BooleanValue(tt.value.has(_e.value));case"not in":return new BooleanValue(!tt.value.has(_e.value))}throw new SyntaxError(`Unknown operator "${et.operator.value}" between ${_e.type} and ${tt.type}`)}evaluateFilterExpression(et,_){const _e=this.evaluate(et.operand,_);if(et.filter.type==="Identifier"){const tt=et.filter;if(_e instanceof ArrayValue)switch(tt.value){case"list":return _e;case"first":return _e.value[0];case"last":return _e.value[_e.value.length-1];case"length":return new NumericValue(_e.value.length);case"reverse":return new ArrayValue(_e.value.reverse());case"sort":return new ArrayValue(_e.value.sort((nt,rt)=>{if(nt.type!==rt.type)throw new Error(`Cannot compare different types: ${nt.type} and ${rt.type}`);switch(nt.type){case"NumericValue":return nt.value-rt.value;case"StringValue":return nt.value.localeCompare(rt.value);default:throw new Error(`Cannot compare type: ${nt.type}`)}}));default:throw new Error(`Unknown ArrayValue filter: ${tt.value}`)}else if(_e instanceof StringValue)switch(tt.value){case"length":return new NumericValue(_e.value.length);case"upper":return new StringValue(_e.value.toUpperCase());case"lower":return new StringValue(_e.value.toLowerCase());case"title":return new StringValue(titleCase(_e.value));case"capitalize":return new StringValue(_e.value.charAt(0).toUpperCase()+_e.value.slice(1));case"trim":return new StringValue(_e.value.trim());default:throw new Error(`Unknown StringValue filter: ${tt.value}`)}else if(_e instanceof NumericValue)switch(tt.value){case"abs":return new NumericValue(Math.abs(_e.value));default:throw new Error(`Unknown NumericValue filter: ${tt.value}`)}else if(_e instanceof ObjectValue)switch(tt.value){case"items":return new ArrayValue(Array.from(_e.value.entries()).map(([nt,rt])=>new ArrayValue([new StringValue(nt),rt])));case"length":return new NumericValue(_e.value.size);default:throw new Error(`Unknown ObjectValue filter: ${tt.value}`)}throw new Error(`Cannot apply filter "${tt.value}" to type: ${_e.type}`)}else if(et.filter.type==="CallExpression"){const tt=et.filter;if(tt.callee.type!=="Identifier")throw new Error(`Unknown filter: ${tt.callee.type}`);const nt=tt.callee.value;if(_e instanceof ArrayValue){switch(nt){case"selectattr":{if(_e.value.some(dt=>!(dt instanceof ObjectValue)))throw new Error("`selectattr` can only be applied to array of objects");if(tt.args.some(dt=>dt.type!=="StringLiteral"))throw new Error("arguments of `selectattr` must be strings");const[rt,ot,at]=tt.args.map(dt=>this.evaluate(dt,_));let lt;if(ot){const dt=_.tests.get(ot.value);if(!dt)throw new Error(`Unknown test: ${ot.value}`);lt=dt}else lt=(...dt)=>dt[0].__bool__().value;const ut=_e.value.filter(dt=>{const st=dt.value.get(rt.value);return st?lt(st,at):!1});return new ArrayValue(ut)}}throw new Error(`Unknown ArrayValue filter: ${nt}`)}else throw new Error(`Cannot apply filter "${nt}" to type: ${_e.type}`)}throw new Error(`Unknown filter: ${et.filter.type}`)}evaluateTestExpression(et,_){const _e=this.evaluate(et.operand,_),tt=_.tests.get(et.test.value);if(!tt)throw new Error(`Unknown test: ${et.test.value}`);const nt=tt(_e);return new BooleanValue(et.negate?!nt:nt)}evaluateUnaryExpression(et,_){const _e=this.evaluate(et.argument,_);switch(et.operator.value){case"not":return new BooleanValue(!_e.value);default:throw new SyntaxError(`Unknown operator: ${et.operator.value}`)}}evalProgram(et,_){return this.evaluateBlock(et.body,_)}evaluateBlock(et,_){let _e="";for(const tt of et){const nt=this.evaluate(tt,_);nt.type!=="NullValue"&&nt.type!=="UndefinedValue"&&(_e+=nt.value)}return new StringValue(_e)}evaluateIdentifier(et,_){return _.lookupVariable(et.value)}evaluateCallExpression(et,_){const _e=[],tt=new Map;for(const rt of et.args)if(rt.type==="KeywordArgumentExpression"){const ot=rt;tt.set(ot.key.value,this.evaluate(ot.value,_))}else _e.push(this.evaluate(rt,_));tt.size>0&&_e.push(new ObjectValue(tt));const nt=this.evaluate(et.callee,_);if(nt.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${nt.type}`);return nt.value(_e,_)}evaluateSliceExpression(et,_,_e){if(!(et instanceof ArrayValue||et instanceof StringValue))throw new Error("Slice object must be an array or string");const tt=this.evaluate(_.start,_e),nt=this.evaluate(_.stop,_e),rt=this.evaluate(_.step,_e);if(!(tt instanceof NumericValue||tt instanceof UndefinedValue))throw new Error("Slice start must be numeric or undefined");if(!(nt instanceof NumericValue||nt instanceof UndefinedValue))throw new Error("Slice stop must be numeric or undefined");if(!(rt instanceof NumericValue||rt instanceof UndefinedValue))throw new Error("Slice step must be numeric or undefined");return et instanceof ArrayValue?new ArrayValue(slice(et.value,tt.value,nt.value,rt.value)):new StringValue(slice(Array.from(et.value),tt.value,nt.value,rt.value).join(""))}evaluateMemberExpression(et,_){const _e=this.evaluate(et.object,_);let tt;if(et.computed){if(et.property.type==="SliceExpression")return this.evaluateSliceExpression(_e,et.property,_);tt=this.evaluate(et.property,_)}else tt=new StringValue(et.property.value);let nt;if(_e instanceof ObjectValue){if(!(tt instanceof StringValue))throw new Error(`Cannot access property with non-string: got ${tt.type}`);nt=_e.value.get(tt.value)??_e.builtins.get(tt.value)}else if(_e instanceof ArrayValue||_e instanceof StringValue)if(tt instanceof NumericValue)nt=_e.value.at(tt.value),_e instanceof StringValue&&(nt=new StringValue(_e.value.at(tt.value)));else if(tt instanceof StringValue)nt=_e.builtins.get(tt.value);else throw new Error(`Cannot access property with non-string/non-number: got ${tt.type}`);else{if(!(tt instanceof StringValue))throw new Error(`Cannot access property with non-string: got ${tt.type}`);nt=_e.builtins.get(tt.value)}return nt instanceof RuntimeValue?nt:new UndefinedValue}evaluateSet(et,_){const _e=this.evaluate(et.value,_);if(et.assignee.type==="Identifier"){const tt=et.assignee.value;_.setVariable(tt,_e)}else if(et.assignee.type==="MemberExpression"){const tt=et.assignee,nt=this.evaluate(tt.object,_);if(!(nt instanceof ObjectValue))throw new Error("Cannot assign to member of non-object");if(tt.property.type!=="Identifier")throw new Error("Cannot assign to member with non-identifier property");nt.value.set(tt.property.value,_e)}else throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(et.assignee)}`);return new NullValue}evaluateIf(et,_){const _e=this.evaluate(et.test,_);return this.evaluateBlock(_e.__bool__().value?et.body:et.alternate,_)}evaluateFor(et,_){const _e=new Environment(_),tt=this.evaluate(et.iterable,_e);if(!(tt instanceof ArrayValue))throw new Error(`Expected iterable type in for loop: got ${tt.type}`);let nt="";for(let rt=0;rt<tt.value.length;++rt){const ot=new Map([["index",new NumericValue(rt+1)],["index0",new NumericValue(rt)],["revindex",new NumericValue(tt.value.length-rt)],["revindex0",new NumericValue(tt.value.length-rt-1)],["first",new BooleanValue(rt===0)],["last",new BooleanValue(rt===tt.value.length-1)],["length",new NumericValue(tt.value.length)],["previtem",rt>0?tt.value[rt-1]:new UndefinedValue],["nextitem",rt<tt.value.length-1?tt.value[rt+1]:new UndefinedValue]]);_e.setVariable("loop",new ObjectValue(ot));const at=tt.value[rt];if(et.loopvar.type==="Identifier")_e.setVariable(et.loopvar.value,at);else if(et.loopvar.type==="TupleLiteral"){const ut=et.loopvar;if(at.type!=="ArrayValue")throw new Error(`Cannot unpack non-iterable type: ${at.type}`);const dt=at;if(ut.value.length!==dt.value.length)throw new Error(`Too ${ut.value.length>dt.value.length?"few":"many"} items to unpack`);for(let st=0;st<ut.value.length;++st){if(ut.value[st].type!=="Identifier")throw new Error(`Cannot unpack non-identifier type: ${ut.value[st].type}`);_e.setVariable(ut.value[st].value,dt.value[st])}}const lt=this.evaluateBlock(et.body,_e);nt+=lt.value}return new StringValue(nt)}evaluate(et,_){if(et===void 0)return new UndefinedValue;switch(et.type){case"Program":return this.evalProgram(et,_);case"Set":return this.evaluateSet(et,_);case"If":return this.evaluateIf(et,_);case"For":return this.evaluateFor(et,_);case"NumericLiteral":return new NumericValue(Number(et.value));case"StringLiteral":return new StringValue(et.value);case"BooleanLiteral":return new BooleanValue(et.value);case"ArrayLiteral":return new ArrayValue(et.value.map(_e=>this.evaluate(_e,_)));case"TupleLiteral":return new TupleValue(et.value.map(_e=>this.evaluate(_e,_)));case"ObjectLiteral":{const _e=new Map;for(const[tt,nt]of et.value){const rt=this.evaluate(tt,_);if(!(rt instanceof StringValue))throw new Error(`Object keys must be strings: got ${rt.type}`);_e.set(rt.value,this.evaluate(nt,_))}return new ObjectValue(_e)}case"Identifier":return this.evaluateIdentifier(et,_);case"CallExpression":return this.evaluateCallExpression(et,_);case"MemberExpression":return this.evaluateMemberExpression(et,_);case"UnaryExpression":return this.evaluateUnaryExpression(et,_);case"BinaryExpression":return this.evaluateBinaryExpression(et,_);case"FilterExpression":return this.evaluateFilterExpression(et,_);case"TestExpression":return this.evaluateTestExpression(et,_);default:throw new SyntaxError(`Unknown node type: ${et.type}`)}}};function convertToRuntimeValues(et){switch(typeof et){case"number":return new NumericValue(et);case"string":return new StringValue(et);case"boolean":return new BooleanValue(et);case"object":return et===null?new NullValue:Array.isArray(et)?new ArrayValue(et.map(convertToRuntimeValues)):new ObjectValue(new Map(Object.entries(et).map(([_,_e])=>[_,convertToRuntimeValues(_e)])));case"function":return new FunctionValue((_,_e)=>{const tt=et(..._.map(nt=>nt.value))??null;return convertToRuntimeValues(tt)});default:throw new Error(`Cannot convert to runtime value: ${et}`)}}var Template=class{constructor(et){jn(this,"parsed");const _=tokenize(et,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=parse$1(_)}render(et){const _=new Environment;_.set("false",!1),_.set("true",!0),_.set("raise_exception",nt=>{throw new Error(nt)}),_.set("range",range$1);for(const[nt,rt]of Object.entries(et))_.set(nt,rt);return new Interpreter(_).run(this.parsed).value}};async function loadTokenizer(et,_){const _e=await Promise.all([getModelJSON(et,"tokenizer.json",!0,_),getModelJSON(et,"tokenizer_config.json",!0,_)]);return _.legacy!==null&&(_e[1].legacy=_.legacy),_e}function regexSplit(et,_){const _e=[];let tt=0;for(const nt of et.matchAll(_)){const rt=nt[0];tt<nt.index&&_e.push(et.slice(tt,nt.index)),rt.length>0&&_e.push(rt),tt=nt.index+rt.length}return tt<et.length&&_e.push(et.slice(tt)),_e}function createPattern(et,_=!0){if(et.Regex!==void 0){let _e=et.Regex.replace(/\\([#&~])/g,"$1");for(const[tt,nt]of PROBLEMATIC_REGEX_MAP)_e=_e.replaceAll(tt,nt);return new RegExp(_e,"gu")}else if(et.String!==void 0){const _e=escapeRegExp(et.String);return new RegExp(_?_e:`(${_e})`,"gu")}else return console.warn("Unknown pattern type:",et),null}function objectToMap(et){return new Map(Object.entries(et))}function prepareTensorForDecode(et){const _=et.dims;switch(_.length){case 1:return et.tolist();case 2:if(_[0]!==1)throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return et.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${_.length}.`)}}function clean_up_tokenization(et){return et.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function remove_accents(et){return et.replace(/[\u0300-\u036f]/g,"")}function lowercase_and_remove_accent(et){return remove_accents(et.toLowerCase())}function fuse(et,_,_e){const tt=[];let nt=0;for(;nt<et.length;){if(tt.push(et[nt]),(_e.get(et[nt])??_)!==_){++nt;continue}for(;nt<et.length&&(_e.get(et[nt])??_)===_;)++nt}return tt}function whitespace_split(et){return et.match(/\S+/g)||[]}const PUNCTUATION_REGEX="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",PROBLEMATIC_REGEX_MAP=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"]]);class AddedToken{constructor(_){this.content=_.content,this.id=_.id,this.single_word=_.single_word??!1,this.lstrip=_.lstrip??!1,this.rstrip=_.rstrip??!1,this.special=_.special??!1,this.normalized=_.normalized??null}}class TokenizerModel extends Callable{constructor(_){super(),this.config=_,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(_,..._e){switch(_.type){case"WordPiece":return new WordPieceTokenizer(_);case"Unigram":return new Unigram(_,..._e);case"BPE":return new BPE(_);default:if(_.vocab)return new LegacyTokenizerModel(_,..._e);throw new Error(`Unknown TokenizerModel type: ${_.type}`)}}_call(_){let _e=this.encode(_);return this.fuse_unk&&(_e=fuse(_e,this.unk_token_id,this.tokens_to_ids)),_e}encode(_){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(_){return _.map(_e=>this.tokens_to_ids.get(_e)??this.unk_token_id)}convert_ids_to_tokens(_){return _.map(_e=>this.vocab[_e]??this.unk_token)}}class WordPieceTokenizer extends TokenizerModel{constructor(_){super(_),this.tokens_to_ids=objectToMap(_.vocab),this.unk_token_id=this.tokens_to_ids.get(_.unk_token),this.unk_token=_.unk_token,this.max_input_chars_per_word=_.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[_e,tt]of this.tokens_to_ids)this.vocab[tt]=_e}encode(_){const _e=[];for(const tt of _){const nt=[...tt];if(nt.length>this.max_input_chars_per_word){_e.push(this.unk_token);continue}let rt=!1,ot=0;const at=[];for(;ot<nt.length;){let lt=nt.length,ut=null;for(;ot<lt;){let dt=nt.slice(ot,lt).join("");if(ot>0&&(dt=this.config.continuing_subword_prefix+dt),this.tokens_to_ids.has(dt)){ut=dt;break}--lt}if(ut===null){rt=!0;break}at.push(ut),ot=lt}rt?_e.push(this.unk_token):_e.push(...at)}return _e}}class Unigram extends TokenizerModel{constructor(_,_e){super(_);const tt=_.vocab.length;this.vocab=new Array(tt),this.scores=new Array(tt);for(let nt=0;nt<tt;++nt){const rt=_.vocab[nt];this.vocab[nt]=rt[0],this.scores[nt]=rt[1]}this.unk_token_id=_.unk_id,this.unk_token=this.vocab[_.unk_id],this.tokens_to_ids=new Map(this.vocab.map((nt,rt)=>[nt,rt])),this.bosToken=" ",this.bosTokenId=this.tokens_to_ids.get(this.bosToken),this.eosToken=_e.eos_token,this.eosTokenId=this.tokens_to_ids.get(this.eosToken),this.unkToken=this.vocab[this.unk_token_id],this.minScore=min$1(this.scores)[0],this.unkScore=this.minScore-10,this.scores[this.unk_token_id]=this.unkScore,this.trie=new CharTrie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(_){const _e=_.sentence,tt=_e.length;let nt=0;for(;nt<tt;){let ot=!1;for(let at of this.trie.commonPrefixSearch(_e.slice(nt))){const lt=this.tokens_to_ids.get(at),ut=this.scores[lt],dt=at.length;_.insert(nt,dt,ut,lt),!ot&&dt===1&&(ot=!0)}ot||_.insert(nt,1,this.unkScore,this.unk_token_id),nt+=1}}tokenize(_){const _e=new TokenLattice(_,this.bosTokenId,this.eosTokenId);return this.populateNodes(_e),_e.tokens()}encode(_){const _e=[];for(const tt of _){const nt=this.tokenize(tt);_e.push(...nt)}return _e}}const BYTES_TO_UNICODE=(()=>{const et=[...Array.from({length:94},(nt,rt)=>rt+33),...Array.from({length:12},(nt,rt)=>rt+161),...Array.from({length:82},(nt,rt)=>rt+174)],_=et.slice();let _e=0;for(let nt=0;nt<256;++nt)et.includes(nt)||(et.push(nt),_.push(256+_e),_e+=1);const tt=_.map(nt=>String.fromCharCode(nt));return Object.fromEntries(et.map((nt,rt)=>[nt,tt[rt]]))})(),UNICODE_TO_BYTES=reverseDictionary(BYTES_TO_UNICODE);class BPE extends TokenizerModel{constructor(_){super(_),this.BPE_SPLIT_TOKEN=" ",this.tokens_to_ids=objectToMap(_.vocab),this.unk_token_id=this.tokens_to_ids.get(_.unk_token),this.unk_token=_.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[_e,tt]of this.tokens_to_ids)this.vocab[tt]=_e;this.bpe_ranks=new Map(_.merges.map((_e,tt)=>[_e,tt])),this.merges=_.merges.map(_e=>_e.split(this.BPE_SPLIT_TOKEN)),this.end_of_word_suffix=_.end_of_word_suffix,this.continuing_subword_suffix=_.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.cache=new Map}bpe(_){if(_.length===0)return[];const _e=this.cache.get(_);if(_e!==void 0)return _e;const tt=Array.from(_);this.end_of_word_suffix&&(tt[tt.length-1]+=this.end_of_word_suffix);let nt=[];if(tt.length>1){const rt=new PriorityQueue((lt,ut)=>lt.score<ut.score);let ot={token:tt[0],bias:0,prev:null,next:null},at=ot;for(let lt=1;lt<tt.length;++lt){const ut={bias:lt/tt.length,token:tt[lt],prev:at,next:null};at.next=ut,this._add_node(rt,at),at=ut}for(;!rt.isEmpty();){const lt=rt.pop();if(lt.deleted||!lt.next||lt.next.deleted)continue;if(lt.deleted=!0,lt.next.deleted=!0,lt.prev){const dt={...lt.prev};lt.prev.deleted=!0,lt.prev=dt,dt.prev?dt.prev.next=dt:ot=dt}const ut={token:lt.token+lt.next.token,bias:lt.bias,prev:lt.prev,next:lt.next.next};ut.prev?(ut.prev.next=ut,this._add_node(rt,ut.prev)):ot=ut,ut.next&&(ut.next.prev=ut,this._add_node(rt,ut))}for(let lt=ot;lt!==null;lt=lt.next)nt.push(lt.token)}else nt=tt;if(this.continuing_subword_suffix)for(let rt=0;rt<nt.length-1;++rt)nt[rt]+=this.continuing_subword_suffix;return this.cache.set(_,nt),nt}_add_node(_,_e){const tt=this.bpe_ranks.get(_e.token+this.BPE_SPLIT_TOKEN+_e.next.token);tt!==void 0&&(_e.score=tt+_e.bias,_.push(_e))}encode(_){const _e=[];for(const tt of _){if(this.ignore_merges&&this.tokens_to_ids.has(tt)){_e.push(tt);continue}const nt=this.bpe(tt);for(const rt of nt)this.tokens_to_ids.has(rt)?_e.push(rt):this.byte_fallback?_e.push(...Array.from(this.text_encoder.encode(rt)).map(ot=>`<0x${ot.toString(16).toUpperCase().padStart(2,"0")}>`)):_e.push(this.unk_token)}return _e}}class LegacyTokenizerModel extends TokenizerModel{constructor(_,_e){super(_),this.tokens_to_ids=objectToMap(_e.target_lang?_.vocab[_e.target_lang]:_.vocab),this.bos_token=_e.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=_e.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=_e.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=_e.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[tt,nt]of this.tokens_to_ids)this.vocab[nt]=tt}encode(_){return _}}class Normalizer extends Callable{constructor(_){super(),this.config=_}static fromConfig(_){if(_===null)return null;switch(_.type){case"BertNormalizer":return new BertNormalizer(_);case"Precompiled":return new Precompiled(_);case"Sequence":return new NormalizerSequence(_);case"Replace":return new Replace(_);case"NFC":return new NFC(_);case"NFKC":return new NFKC(_);case"NFKD":return new NFKD(_);case"Strip":return new StripNormalizer(_);case"StripAccents":return new StripAccents(_);case"Lowercase":return new Lowercase(_);case"Prepend":return new Prepend(_);default:throw new Error(`Unknown Normalizer type: ${_.type}`)}}normalize(_){throw Error("normalize should be implemented in subclass.")}_call(_){return this.normalize(_)}}class Replace extends Normalizer{normalize(_){const _e=createPattern(this.config.pattern);return _e===null?_:_.replaceAll(_e,this.config.content)}}class NFC extends Normalizer{normalize(_){return _=_.normalize("NFC"),_}}class NFKC extends Normalizer{normalize(_){return _=_.normalize("NFKC"),_}}class NFKD extends Normalizer{normalize(_){return _=_.normalize("NFKD"),_}}class StripNormalizer extends Normalizer{normalize(_){return this.config.strip_left&&this.config.strip_right?_=_.trim():(this.config.strip_left&&(_=_.trimStart()),this.config.strip_right&&(_=_.trimEnd())),_}}class StripAccents extends Normalizer{normalize(_){return _=remove_accents(_),_}}class Lowercase extends Normalizer{normalize(_){return _=_.toLowerCase(),_}}class Prepend extends Normalizer{normalize(_){return _=this.config.prepend+_,_}}class NormalizerSequence extends Normalizer{constructor(_){super(_),this.normalizers=_.normalizers.map(_e=>Normalizer.fromConfig(_e))}normalize(_){return this.normalizers.reduce((_e,tt)=>tt.normalize(_e),_)}}class BertNormalizer extends Normalizer{_tokenize_chinese_chars(_){const _e=[];for(let tt=0;tt<_.length;++tt){const nt=_[tt],rt=nt.charCodeAt(0);this._is_chinese_char(rt)?(_e.push(" "),_e.push(nt),_e.push(" ")):_e.push(nt)}return _e.join("")}_is_chinese_char(_){return _>=19968&&_<=40959||_>=13312&&_<=19903||_>=131072&&_<=173791||_>=173824&&_<=177983||_>=177984&&_<=178207||_>=178208&&_<=183983||_>=63744&&_<=64255||_>=194560&&_<=195103}stripAccents(_){return _.normalize("NFD").replace(/[\u0300-\u036f]/g,"")}_is_control(_){switch(_){case"	":case`
`:case"\r":return!1;default:return new RegExp("^\\p{Cc}|\\p{Cf}|\\p{Co}|\\p{Cs}$","u").test(_)}}_clean_text(_){const _e=[];for(const tt of _){const nt=tt.charCodeAt(0);nt===0||nt===65533||this._is_control(tt)||(/^\s$/.test(tt)?_e.push(" "):_e.push(tt))}return _e.join("")}normalize(_){return this.config.clean_text&&(_=this._clean_text(_)),this.config.handle_chinese_chars&&(_=this._tokenize_chinese_chars(_)),this.config.lowercase?(_=_.toLowerCase(),this.config.strip_accents!==!1&&(_=this.stripAccents(_))):this.config.strip_accents&&(_=this.stripAccents(_)),_}}class PreTokenizer extends Callable{static fromConfig(_){if(_===null)return null;switch(_.type){case"BertPreTokenizer":return new BertPreTokenizer(_);case"Sequence":return new PreTokenizerSequence(_);case"Whitespace":return new WhitespacePreTokenizer(_);case"WhitespaceSplit":return new WhitespaceSplit(_);case"Metaspace":return new MetaspacePreTokenizer(_);case"ByteLevel":return new ByteLevelPreTokenizer(_);case"Split":return new SplitPreTokenizer(_);case"Punctuation":return new PunctuationPreTokenizer(_);case"Digits":return new DigitsPreTokenizer(_);case"Replace":return new ReplacePreTokenizer(_);default:throw new Error(`Unknown PreTokenizer type: ${_.type}`)}}pre_tokenize_text(_,_e){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(_,_e){return(Array.isArray(_)?_.map(tt=>this.pre_tokenize_text(tt,_e)):this.pre_tokenize_text(_,_e)).flat()}_call(_,_e){return this.pre_tokenize(_,_e)}}class BertPreTokenizer extends PreTokenizer{constructor(_){super(),this.pattern=new RegExp(`[^\\s${PUNCTUATION_REGEX}]+|[${PUNCTUATION_REGEX}]`,"gu")}pre_tokenize_text(_,_e){return _.trim().match(this.pattern)||[]}}class ByteLevelPreTokenizer extends PreTokenizer{constructor(_){super(),this.config=_,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=new RegExp("'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+","gu"),this.byte_encoder=BYTES_TO_UNICODE,this.text_encoder=new TextEncoder}pre_tokenize_text(_,_e){return this.add_prefix_space&&!_.startsWith(" ")&&(_=" "+_),(this.use_regex?_.match(this.pattern)||[]:[_]).map(nt=>Array.from(this.text_encoder.encode(nt),rt=>this.byte_encoder[rt]).join(""))}}class SplitPreTokenizer extends PreTokenizer{constructor(_){super(),this.config=_,this.pattern=createPattern(this.config.pattern,this.config.invert)}pre_tokenize_text(_,_e){return this.pattern===null?[]:this.config.invert?_.match(this.pattern)||[]:regexSplit(_,this.pattern)}}class PunctuationPreTokenizer extends PreTokenizer{constructor(_){super(),this.config=_,this.pattern=new RegExp(`[^${PUNCTUATION_REGEX}]+|[${PUNCTUATION_REGEX}]+`,"gu")}pre_tokenize_text(_,_e){return _.match(this.pattern)||[]}}class DigitsPreTokenizer extends PreTokenizer{constructor(_){super(),this.config=_;const _e=`[^\\d]+|\\d${this.config.individual_digits?"":"+"}`;this.pattern=new RegExp(_e,"gu")}pre_tokenize_text(_,_e){return _.match(this.pattern)||[]}}class PostProcessor extends Callable{constructor(_){super(),this.config=_}static fromConfig(_){if(_===null)return null;switch(_.type){case"TemplateProcessing":return new TemplateProcessing(_);case"ByteLevel":return new ByteLevelPostProcessor(_);case"RobertaProcessing":return new RobertaProcessing(_);case"BertProcessing":return new BertProcessing(_);case"Sequence":return new PostProcessorSequence(_);default:throw new Error(`Unknown PostProcessor type: ${_.type}`)}}post_process(_,..._e){throw Error("post_process should be implemented in subclass.")}_call(_,..._e){return this.post_process(_,..._e)}}class BertProcessing extends PostProcessor{constructor(_){super(_),this.cls=_.cls[0],this.sep=_.sep[0]}post_process(_,_e=null,{add_special_tokens:tt=!0}={}){tt&&(_=mergeArrays([this.cls],_,[this.sep]));let nt=new Array(_.length).fill(0);if(_e!==null){const rt=tt&&this instanceof RobertaProcessing?[this.sep]:[],ot=tt?[this.sep]:[];_=mergeArrays(_,rt,_e,ot),nt=mergeArrays(nt,new Array(_e.length+rt.length+ot.length).fill(1))}return{tokens:_,token_type_ids:nt}}}class RobertaProcessing extends BertProcessing{}class TemplateProcessing extends PostProcessor{constructor(_){super(_),this.single=_.single,this.pair=_.pair}post_process(_,_e=null,{add_special_tokens:tt=!0}={}){const nt=_e===null?this.single:this.pair;let rt=[],ot=[];for(const at of nt)"SpecialToken"in at?tt&&(rt.push(at.SpecialToken.id),ot.push(at.SpecialToken.type_id)):"Sequence"in at&&(at.Sequence.id==="A"?(rt=mergeArrays(rt,_),ot=mergeArrays(ot,new Array(_.length).fill(at.Sequence.type_id))):at.Sequence.id==="B"&&(rt=mergeArrays(rt,_e),ot=mergeArrays(ot,new Array(_e.length).fill(at.Sequence.type_id))));return{tokens:rt,token_type_ids:ot}}}class ByteLevelPostProcessor extends PostProcessor{post_process(_,_e=null){return _e&&(_=mergeArrays(_,_e)),{tokens:_}}}class PostProcessorSequence extends PostProcessor{constructor(_){super(_),this.processors=_.processors.map(_e=>PostProcessor.fromConfig(_e))}post_process(_,_e=null,tt={}){let nt;for(const rt of this.processors)if(rt instanceof ByteLevelPostProcessor)_=rt.post_process(_).tokens,_e&&(_e=rt.post_process(_e).tokens);else{const ot=rt.post_process(_,_e,tt);_=ot.tokens,nt=ot.token_type_ids}return{tokens:_,token_type_ids:nt}}}class Decoder extends Callable{constructor(_){super(),this.config=_,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=_.trim_offsets}static fromConfig(_){if(_===null)return null;switch(_.type){case"WordPiece":return new WordPieceDecoder(_);case"Metaspace":return new MetaspaceDecoder(_);case"ByteLevel":return new ByteLevelDecoder(_);case"Replace":return new ReplaceDecoder(_);case"ByteFallback":return new ByteFallback(_);case"Fuse":return new FuseDecoder(_);case"Strip":return new StripDecoder(_);case"Sequence":return new DecoderSequence(_);case"CTC":return new CTCDecoder(_);case"BPEDecoder":return new BPEDecoder(_);default:throw new Error(`Unknown Decoder type: ${_.type}`)}}_call(_){return this.decode(_)}decode(_){return this.decode_chain(_).join("")}decode_chain(_){throw Error("`decode_chain` should be implemented in subclass.")}}class ReplaceDecoder extends Decoder{decode_chain(_){const _e=createPattern(this.config.pattern);return _e===null?_:_.map(tt=>tt.replaceAll(_e,this.config.content))}}class ByteFallback extends Decoder{constructor(_){super(_),this.text_decoder=new TextDecoder}decode_chain(_){const _e=[];let tt=[];for(const nt of _){let rt=null;if(nt.length===6&&nt.startsWith("<0x")&&nt.endsWith(">")){const ot=parseInt(nt.slice(3,5),16);isNaN(ot)||(rt=ot)}if(rt!==null)tt.push(rt);else{if(tt.length>0){const ot=this.text_decoder.decode(Uint8Array.from(tt));_e.push(ot),tt=[]}_e.push(nt)}}if(tt.length>0){const nt=this.text_decoder.decode(Uint8Array.from(tt));_e.push(nt),tt=[]}return _e}}class FuseDecoder extends Decoder{decode_chain(_){return[_.join("")]}}class StripDecoder extends Decoder{constructor(_){super(_),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(_){return _.map(_e=>{let tt=0;for(let rt=0;rt<this.start&&_e[rt]===this.content;++rt){tt=rt+1;continue}let nt=_e.length;for(let rt=0;rt<this.stop;++rt){const ot=_e.length-rt-1;if(_e[ot]===this.content){nt=ot;continue}else break}return _e.slice(tt,nt)})}}class WordPieceDecoder extends Decoder{constructor(_){super(_),this.cleanup=_.cleanup}decode_chain(_){return _.map((_e,tt)=>(tt!==0&&(_e.startsWith(this.config.prefix)?_e=_e.replace(this.config.prefix,""):_e=" "+_e),this.cleanup&&(_e=clean_up_tokenization(_e)),_e))}}class ByteLevelDecoder extends Decoder{constructor(_){super(_),this.byte_decoder=UNICODE_TO_BYTES,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(_){const _e=_.join(""),tt=new Uint8Array([..._e].map(rt=>this.byte_decoder[rt]));return this.text_decoder.decode(tt)}decode_chain(_){const _e=[];let tt=[];for(const nt of _)this.added_tokens.find(rt=>rt.content===nt)!==void 0?(tt.length>0&&(_e.push(this.convert_tokens_to_string(tt)),tt=[]),_e.push(nt)):tt.push(nt);return tt.length>0&&_e.push(this.convert_tokens_to_string(tt)),_e}}class CTCDecoder extends Decoder{constructor(_){super(_),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(_){if(_.length===0)return"";const _e=[_[0]];for(let rt=1;rt<_.length;++rt)_[rt]!==_e.at(-1)&&_e.push(_[rt]);let nt=_e.filter(rt=>rt!==this.pad_token).join("");return this.cleanup&&(nt=clean_up_tokenization(nt).replaceAll(this.word_delimiter_token," ").trim()),nt}decode_chain(_){return[this.convert_tokens_to_string(_)]}}class DecoderSequence extends Decoder{constructor(_){super(_),this.decoders=_.decoders.map(_e=>Decoder.fromConfig(_e))}decode_chain(_){return this.decoders.reduce((_e,tt)=>tt.decode_chain(_e),_)}}class BPEDecoder extends Decoder{constructor(_){super(_),this.suffix=this.config.suffix}decode_chain(_){return _.map((_e,tt)=>_e.replaceAll(this.suffix,tt===_.length-1?"":" "))}}class VitsDecoder extends Decoder{decode_chain(_){let _e="";for(let tt=1;tt<_.length;tt+=2)_e+=_[tt];return[_e]}}class MetaspacePreTokenizer extends PreTokenizer{constructor(_){super(),this.addPrefixSpace=_.add_prefix_space,this.replacement=_.replacement,this.strRep=_.str_rep||this.replacement,this.prepend_scheme=_.prepend_scheme??"always"}pre_tokenize_text(_,{section_index:_e=void 0}={}){let tt=_.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!tt.startsWith(this.replacement)&&(this.prepend_scheme==="always"||this.prepend_scheme==="first"&&_e===0)&&(tt=this.strRep+tt),[tt]}}class MetaspaceDecoder extends Decoder{constructor(_){super(_),this.addPrefixSpace=_.add_prefix_space,this.replacement=_.replacement}decode_chain(_){const _e=[];for(let tt=0;tt<_.length;++tt){let nt=_[tt].replaceAll(this.replacement," ");this.addPrefixSpace&&tt==0&&nt.startsWith(" ")&&(nt=nt.substring(1)),_e.push(nt)}return _e}}class Precompiled extends Normalizer{constructor(_){super(_),this.charsmap=_.precompiled_charsmap}normalize(_){return _=_.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,""),_=_.replace(/[\u0009\u000A\u000C\u000D\u1680\u200B\u200C\u200E\u200F\u2028\u2029\u2581\uFEFF\uFFFD]/gm," "),_.includes("")?_=_.split("").map(tt=>tt.normalize("NFKC")).join(""):_=_.normalize("NFKC"),_}}class PreTokenizerSequence extends PreTokenizer{constructor(_){super(),this.tokenizers=_.pretokenizers.map(_e=>PreTokenizer.fromConfig(_e))}pre_tokenize_text(_,_e){return this.tokenizers.reduce((tt,nt)=>nt.pre_tokenize(tt,_e),[_])}}class WhitespacePreTokenizer extends PreTokenizer{constructor(_){super()}pre_tokenize_text(_,_e){return _.match(/\w+|[^\w\s]+/g)||[]}}class WhitespaceSplit extends PreTokenizer{constructor(_){super()}pre_tokenize_text(_,_e){return whitespace_split(_)}}class ReplacePreTokenizer extends PreTokenizer{constructor(_){super(),this.config=_,this.pattern=createPattern(this.config.pattern),this.content=this.config.content}pre_tokenize_text(_,_e){return this.pattern===null?[_]:[_.replaceAll(this.pattern,this.config.content)]}}const SPECIAL_TOKEN_ATTRIBUTES=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function padHelper(et,_,_e,tt){for(const nt of Object.keys(et)){const rt=_-et[nt].length,ot=_e(nt),at=new Array(rt).fill(ot);et[nt]=tt==="right"?mergeArrays(et[nt],at):mergeArrays(at,et[nt])}}function truncateHelper(et,_){for(const _e of Object.keys(et))et[_e].length=_}class PreTrainedTokenizer extends Callable{constructor(_e,tt){super();jn(this,"return_token_type_ids",!1);jn(this,"_default_chat_template",`{% for message in messages %}{{'<|im_start|>' + message['role'] + '
' + message['content'] + '<|im_end|>' + '
'}}{% endfor %}{% if add_generation_prompt %}{{ '<|im_start|>assistant
' }}{% endif %}`);this._tokenizer_config=tt,this.normalizer=Normalizer.fromConfig(_e.normalizer),this.pre_tokenizer=PreTokenizer.fromConfig(_e.pre_tokenizer),this.model=TokenizerModel.fromConfig(_e.model,tt),this.post_processor=PostProcessor.fromConfig(_e.post_processor),this.decoder=Decoder.fromConfig(_e.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const nt of _e.added_tokens){const rt=new AddedToken(nt);this.added_tokens.push(rt),this.model.tokens_to_ids.set(rt.content,rt.id),this.model.vocab[rt.id]=rt.content,rt.special&&(this.special_tokens.push(rt.content),this.all_special_ids.push(rt.id))}if(this.additional_special_tokens=tt.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_regex=this.added_tokens.length>0?new RegExp(this.added_tokens.map(nt=>`${nt.lstrip?"\\s*":""}(${escapeRegExp(nt.content)})${nt.rstrip?"\\s*":""}`).join("|")):null,this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.model_max_length=tt.model_max_length,this.remove_space=tt.remove_space,this.clean_up_tokenization_spaces=tt.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=tt.do_lowercase_and_remove_accent??!1,this.padding_side="right",this.legacy=!1,this.chat_template=tt.chat_template??null,Array.isArray(this.chat_template)){const nt=Object.create(null);for(const{name:rt,template:ot}of this.chat_template){if(typeof rt!="string"||typeof ot!="string")throw new Error('Chat template must be a list of objects with "name" and "template" properties');nt[rt]=ot}this.chat_template=nt}this._compiled_template_cache=new Map}getToken(..._e){for(const tt of _e){const nt=this._tokenizer_config[tt];if(nt)if(typeof nt=="object"){if(nt.__type==="AddedToken")return nt.content;throw Error(`Unknown token: ${nt}`)}else return nt}return null}static async from_pretrained(_e,{progress_callback:tt=null,config:nt=null,cache_dir:rt=null,local_files_only:ot=!1,revision:at="main",legacy:lt=null}={}){const ut=await loadTokenizer(_e,{progress_callback:tt,config:nt,cache_dir:rt,local_files_only:ot,revision:at,legacy:lt});return new this(...ut)}_call(_e,{text_pair:tt=null,add_special_tokens:nt=!0,padding:rt=!1,truncation:ot=null,max_length:at=null,return_tensor:lt=!0,return_token_type_ids:ut=null}={}){const dt=Array.isArray(_e);let st;if(dt){if(_e.length===0)throw Error("text array must be non-empty");if(tt!==null){if(Array.isArray(tt)){if(_e.length!==tt.length)throw Error("text and text_pair must have the same length")}else throw Error("text_pair must also be an array");st=_e.map((ct,ft)=>this._encode_plus(ct,tt[ft],{add_special_tokens:nt,return_token_type_ids:ut}))}else st=_e.map(ct=>this._encode_plus(ct,null,{add_special_tokens:nt,return_token_type_ids:ut}))}else{if(_e==null)throw Error("text may not be null or undefined");if(Array.isArray(tt))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");st=[this._encode_plus(_e,tt,{add_special_tokens:nt,return_token_type_ids:ut})]}if(at===null?rt==="max_length"?at=this.model_max_length:at=max$1(st.map(ct=>ct.input_ids.length))[0]:ot||console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=true` to explicitly truncate examples to max length."),at=Math.min(at,this.model_max_length),rt||ot)for(let ct=0;ct<st.length;++ct)st[ct].input_ids.length!==at&&(st[ct].input_ids.length>at?ot&&truncateHelper(st[ct],at):rt&&padHelper(st[ct],at,ft=>ft==="input_ids"?this.pad_token_id:0,this.padding_side));const it={};if(lt){if(!(rt&&ot)&&st.some(ft=>{var ht;for(const mt of Object.keys(ft))if(ft[mt].length!==((ht=st[0][mt])==null?void 0:ht.length))return!0;return!1}))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const ct=[st.length,st[0].input_ids.length];for(const ft of Object.keys(st[0]))it[ft]=new Tensor("int64",BigInt64Array.from(st.flatMap(ht=>ht[ft]).map(BigInt)),ct)}else{for(const ct of Object.keys(st[0]))it[ct]=st.map(ft=>ft[ct]);if(!dt)for(const ct of Object.keys(it))it[ct]=it[ct][0]}return it}_encode_text(_e){return _e===null?null:(this.added_tokens_regex?_e.split(this.added_tokens_regex).filter(rt=>rt):[_e]).map((rt,ot)=>{if(this.added_tokens.find(lt=>lt.content===rt)!==void 0)return rt;{if(this.remove_space===!0&&(rt=rt.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(rt=lowercase_and_remove_accent(rt)),this.normalizer!==null&&(rt=this.normalizer(rt)),rt.length===0)return[];const lt=this.pre_tokenizer!==null?this.pre_tokenizer(rt,{section_index:ot}):[rt];return this.model(lt)}}).flat()}_encode_plus(_e,tt=null,{add_special_tokens:nt=!0,return_token_type_ids:rt=null}={}){const ot=this._encode_text(_e),at=this._encode_text(tt),lt=this.post_processor?this.post_processor(ot,at,{add_special_tokens:nt}):{tokens:mergeArrays(ot??[],at??[])},ut=this.model.convert_tokens_to_ids(lt.tokens),dt={input_ids:ut,attention_mask:new Array(ut.length).fill(1)};return(rt??this.return_token_type_ids)&&lt.token_type_ids&&(dt.token_type_ids=lt.token_type_ids),dt}encode(_e,tt=null,{add_special_tokens:nt=!0,return_token_type_ids:rt=null}={}){const{input_ids:ot}=this._encode_plus(_e,tt,{add_special_tokens:nt,return_token_type_ids:rt});return ot}batch_decode(_e,tt={}){return _e instanceof Tensor&&(_e=_e.tolist()),_e.map(nt=>this.decode(nt,tt))}decode(_e,tt={}){if(_e instanceof Tensor&&(_e=prepareTensorForDecode(_e)),!Array.isArray(_e)||_e.length===0||!isIntegralNumber(_e[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(_e,tt)}decode_single(_e,{skip_special_tokens:tt=!1,clean_up_tokenization_spaces:nt=null}){let rt=this.model.convert_ids_to_tokens(_e);tt&&(rt=rt.filter(at=>!this.special_tokens.includes(at)));let ot=this.decoder?this.decoder(rt):rt.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(ot=ot.replaceAll(this.decoder.end_of_word_suffix," "),tt&&(ot=ot.trim())),(nt??this.clean_up_tokenization_spaces)&&(ot=clean_up_tokenization(ot)),ot}get default_chat_template(){return this._warned_about_chat_template||(console.warn("No chat template is defined for this tokenizer - using a default chat template that implements the ChatML format. If the default is not appropriate for your model, please set `tokenizer.chat_template` to an appropriate template. See https://huggingface.co/docs/transformers/main/chat_templating for more information."),this._warned_about_chat_template=!0),this._default_chat_template}apply_chat_template(_e,{chat_template:tt=null,add_generation_prompt:nt=!1,tokenize:rt=!0,padding:ot=!1,truncation:at=!1,max_length:lt=null,return_tensor:ut=!0,tokenizer_kwargs:dt={},...st}={}){if(this.chat_template&&typeof this.chat_template=="object"||this.chat_template===null&&this.default_chat_template&&typeof this.default_chat_template=="object"){const ht=this.chat_template??this.default_chat_template;if(tt!==null&&Object.hasOwn(ht,tt))tt=ht[tt];else if(tt===null&&"default"in ht)tt=ht.default;else if(tt===null)throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(ht).sort()}.`)}else tt??(tt=this.chat_template??this.default_chat_template);if(typeof tt!="string")throw Error(`chat_template must be a string, but got ${typeof tt}`);let it=this._compiled_template_cache.get(tt);it===void 0&&(it=new Template(tt),this._compiled_template_cache.set(tt,it));const ct=Object.create(null);for(const ht of SPECIAL_TOKEN_ATTRIBUTES){const mt=this.getToken(ht);mt&&(ct[ht]=mt)}const ft=it.render({messages:_e,add_generation_prompt:nt,...ct,...st});return rt?this._call(ft,{add_special_tokens:!1,padding:ot,truncation:at,max_length:lt,return_tensor:ut,...dt}).input_ids:ft}}class BertTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);jn(this,"return_token_type_ids",!0)}}class AlbertTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);jn(this,"return_token_type_ids",!0)}}class MobileBertTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);jn(this,"return_token_type_ids",!0)}}class SqueezeBertTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);jn(this,"return_token_type_ids",!0)}}class DebertaTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);jn(this,"return_token_type_ids",!0)}}class DebertaV2Tokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);jn(this,"return_token_type_ids",!0)}}class HerbertTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);jn(this,"return_token_type_ids",!0)}}class ConvBertTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);jn(this,"return_token_type_ids",!0)}}class RoFormerTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);jn(this,"return_token_type_ids",!0)}}class DistilBertTokenizer extends PreTrainedTokenizer{}class CamembertTokenizer extends PreTrainedTokenizer{}class XLMTokenizer extends PreTrainedTokenizer{constructor(_e,tt){super(_e,tt);jn(this,"return_token_type_ids",!0);console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class ElectraTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);jn(this,"return_token_type_ids",!0)}}class T5Tokenizer extends PreTrainedTokenizer{}class GPT2Tokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);jn(this,"_default_chat_template",'{% for message in messages %}" "{{ message.content }}{{ eos_token }}" "{% endfor %}')}}class BartTokenizer extends PreTrainedTokenizer{}class MBartTokenizer extends PreTrainedTokenizer{constructor(_,_e){super(_,_e),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter(tt=>this.languageRegex.test(tt)),this.lang_to_token=tt=>tt}_build_translation_inputs(_,_e,tt){return _build_translation_inputs(this,_,_e,tt)}}class MBart50Tokenizer extends MBartTokenizer{}class RobertaTokenizer extends PreTrainedTokenizer{}class BloomTokenizer extends GPT2Tokenizer{constructor(_,_e){var rt,ot;const tt=".,!?",nt=(ot=(rt=_.pre_tokenizer)==null?void 0:rt.pretokenizers[0])==null?void 0:ot.pattern;nt&&nt.Regex===` ?[^(\\s|[${tt}])]+`&&(nt.Regex=` ?[^\\s${tt}]+`),super(_,_e)}}const SPIECE_UNDERLINE="";class LlamaTokenizer extends PreTrainedTokenizer{constructor(_e,tt){super(_e,tt);jn(this,"_default_chat_template",`{% if messages[0]['role'] == 'system' %}{% set loop_messages = messages[1:] %}{% set system_message = messages[0]['content'] %}{% elif USE_DEFAULT_PROMPT == true and not '<<SYS>>' in messages[0]['content'] %}{% set loop_messages = messages %}{% set system_message = 'DEFAULT_SYSTEM_MESSAGE' %}{% else %}{% set loop_messages = messages %}{% set system_message = false %}{% endif %}{% for message in loop_messages %}{% if (message['role'] == 'user') != (loop.index0 % 2 == 0) %}{{ raise_exception('Conversation roles must alternate user/assistant/user/assistant/...') }}{% endif %}{% if loop.index0 == 0 and system_message != false %}{% set content = '<<SYS>>
' + system_message + '
<</SYS>>

' + message['content'] %}{% else %}{% set content = message['content'] %}{% endif %}{% if message['role'] == 'user' %}{{ bos_token + '[INST] ' + content.strip() + ' [/INST]' }}{% elif message['role'] == 'system' %}{{ '<<SYS>>
' + content.strip() + '
<</SYS>>

' }}{% elif message['role'] == 'assistant' %}{{ ' '  + content.strip() + ' ' + eos_token }}{% endif %}{% endfor %}`);jn(this,"DEFAULT_SYSTEM_PROMPT",`You are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe. Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature.

If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you don't know the answer to a question, please don't share false information.`);this.use_default_system_prompt=tt.use_default_system_prompt??!1,this.legacy=tt.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new MetaspacePreTokenizer({replacement:SPIECE_UNDERLINE,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(_e){if(_e===null)return null;if(this.legacy||_e.length===0)return super._encode_text(_e);let tt=super._encode_text(SPIECE_UNDERLINE+_e.replaceAll(SPIECE_UNDERLINE," "));return tt.length>1&&tt[0]===SPIECE_UNDERLINE&&this.special_tokens.includes(tt[1])&&(tt=tt.slice(1)),tt}get default_chat_template(){return super.default_chat_template.replaceAll("USE_DEFAULT_PROMPT",this.use_default_system_prompt?"true":"false").replaceAll("DEFAULT_SYSTEM_MESSAGE",this.DEFAULT_SYSTEM_PROMPT.replaceAll(`
`,"\\n").replaceAll("'","\\'"))}}class CodeLlamaTokenizer extends LlamaTokenizer{}class XLMRobertaTokenizer extends PreTrainedTokenizer{}class MPNetTokenizer extends PreTrainedTokenizer{}class FalconTokenizer extends PreTrainedTokenizer{}class GPTNeoXTokenizer extends PreTrainedTokenizer{}class EsmTokenizer extends PreTrainedTokenizer{}class Qwen2Tokenizer extends PreTrainedTokenizer{}class GemmaTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);jn(this,"_default_chat_template",`{% if messages[0]['role'] == 'system' %}{{ raise_exception('System role not supported') }}{% endif %}{% for message in messages %}{% if (message['role'] == 'user') != (loop.index0 % 2 == 0) %}{{ raise_exception('Conversation roles must alternate user/assistant/user/assistant/...') }}{% endif %}{% if (message['role'] == 'assistant') %}{% set role = 'model' %}{% else %}{% set role = message['role'] %}{% endif %}{{ '<start_of_turn>' + role + '
' + message['content'] | trim + '<end_of_turn>
' }}{% endfor %}{% if add_generation_prompt %}{{'<start_of_turn>model
'}}{% endif %}`)}}class Grok1Tokenizer extends PreTrainedTokenizer{}function _build_translation_inputs(et,_,_e,tt){if(!("language_codes"in et)||!Array.isArray(et.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in et)||!(et.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in et)||typeof et.lang_to_token!="function")throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const nt=tt.src_lang,rt=tt.tgt_lang;if(!et.language_codes.includes(rt))throw new Error(`Target language code "${rt}" is not valid. Must be one of: {${et.language_codes.join(", ")}}`);if(nt!==void 0){if(!et.language_codes.includes(nt))throw new Error(`Source language code "${nt}" is not valid. Must be one of: {${et.language_codes.join(", ")}}`);for(const ot of et.post_processor.config.single)if("SpecialToken"in ot&&et.languageRegex.test(ot.SpecialToken.id)){ot.SpecialToken.id=et.lang_to_token(nt);break}}return tt.forced_bos_token_id=et.model.convert_tokens_to_ids([et.lang_to_token(rt)])[0],et._call(_,_e)}class NllbTokenizer extends PreTrainedTokenizer{constructor(_,_e){super(_,_e),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(tt=>this.languageRegex.test(tt)),this.lang_to_token=tt=>tt}_build_translation_inputs(_,_e,tt){return _build_translation_inputs(this,_,_e,tt)}}class M2M100Tokenizer extends PreTrainedTokenizer{constructor(_,_e){super(_,_e),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter(tt=>this.languageRegex.test(tt)).map(tt=>tt.slice(2,-2)),this.lang_to_token=tt=>`__${tt}__`}_build_translation_inputs(_,_e,tt){return _build_translation_inputs(this,_,_e,tt)}}const WHISPER_LANGUAGES=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],WHISPER_LANGUAGE_MAPPING=new Map(WHISPER_LANGUAGES),WHISPER_TO_LANGUAGE_CODE_MAPPING=new Map([...WHISPER_LANGUAGES.map(([et,_])=>[_,et]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);class WhisperTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);jn(this,"_default_chat_template",'{% for message in messages %}" "{{ message.content }}{{ eos_token }}" "{% endfor %}')}_decode_asr(_e,{return_timestamps:tt=!1,return_language:nt=!1,time_precision:rt=null,force_full_sequences:ot=!0}={}){if(rt===null)throw Error("Must specify time_precision");let at=null;const lt=tt==="word";function ut(){return{language:at,timestamp:[null,null],text:""}}const dt=[];let st=ut(),it=0;const ct=this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1;let ft=[],ht=[],mt=!1,pt=null;const _t=new Set(this.all_special_ids);for(const wt of _e){const xt=wt.tokens,Mt=lt?wt.token_timestamps:null;let At=null,St=ct;if("stride"in wt){const[It,$t,Nt]=wt.stride;if(it-=$t,pt=It-Nt,$t&&(St=$t/rt+ct),Nt)for(let Bt=xt.length-1;Bt>=0;--Bt){const Ot=xt[Bt];if(Ot>=ct){if(At!==null&&(Ot-ct)*rt<pt)break;At=Ot}}}let Tt=[],Ct=[];for(let It=0;It<xt.length;++It){const $t=xt[It];if(_t.has($t)){const Nt=this.decode([$t]),Bt=WHISPER_LANGUAGE_MAPPING.get(Nt.slice(2,-2));if(Bt!==void 0){if(at!==null&&Bt!==at&&!tt){ft.push(Tt);const Ot=this.findLongestCommonSequence(ft)[0],Ut=this.decode(Ot);st.text=Ut,dt.push(st),ft=[],Tt=[],st=ut()}at=st.language=Bt}}else if($t>=ct){const Nt=($t-ct)*rt+it,Bt=round$1(Nt,2);if(At!==null&&$t>=At)mt=!0;else if(mt||ft.length>0&&$t<St)mt=!1;else if(st.timestamp[0]===null)st.timestamp[0]=Bt;else if(Bt!==st.timestamp[0]){st.timestamp[1]=Bt,ft.push(Tt),lt&&ht.push(Ct);const[Ot,Ut]=this.findLongestCommonSequence(ft,ht),Lt=this.decode(Ot);st.text=Lt,lt&&(st.words=this.collateWordTimestamps(Ot,Ut,at)),dt.push(st),ft=[],Tt=[],ht=[],Ct=[],st=ut()}}else if(Tt.push($t),lt){let Nt=round$1(Mt[It]+it,2),Bt;It+1<Mt.length?Bt=round$1(Mt[It+1]+it,2):Bt=null,Ct.push([Nt,Bt])}}if("stride"in wt){const[It,$t,Nt]=wt.stride;it+=It-Nt}Tt.length>0?(ft.push(Tt),lt&&ht.push(Ct)):ft.every(It=>It.length===0)&&(st=ut(),ft=[],Tt=[],ht=[],Ct=[])}if(ft.length>0){if(ot&&tt)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[wt,xt]=this.findLongestCommonSequence(ft,ht),Mt=this.decode(wt);st.text=Mt,lt&&(st.words=this.collateWordTimestamps(wt,xt,at)),dt.push(st)}let vt=Object.create(null);const bt=dt.map(wt=>wt.text).join("");if(tt||nt){for(let wt=0;wt<dt.length;++wt){const xt=dt[wt];tt||delete xt.timestamp,nt||delete xt.language}if(lt){const wt=[];for(const xt of dt)for(const Mt of xt.words)wt.push(Mt);vt={chunks:wt}}else vt={chunks:dt}}return[bt,vt]}findLongestCommonSequence(_e,tt=null){let nt=_e[0],rt=nt.length,ot=[];const at=Array.isArray(tt)&&tt.length>0;let lt=at?[]:null,ut=at?tt[0]:null;for(let dt=1;dt<_e.length;++dt){const st=_e[dt];let it=0,ct=[rt,rt,0,0];const ft=st.length;for(let wt=1;wt<rt+ft;++wt){const xt=wt/1e4,Mt=Math.max(0,rt-wt),At=Math.min(rt,rt+ft-wt),St=nt.slice(Mt,At),Tt=Math.max(0,wt-rt),Ct=Math.min(ft,wt),It=st.slice(Tt,Ct);if(St.length!==It.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");const $t=St.filter((Bt,Ot)=>Bt===It[Ot]).length,Nt=$t/wt+xt;$t>1&&Nt>it&&(it=Nt,ct=[Mt,At,Tt,Ct])}const[ht,mt,pt,_t]=ct,vt=Math.floor((mt+ht)/2),bt=Math.floor((_t+pt)/2);ot.push(...nt.slice(0,vt)),nt=st.slice(bt),rt=nt.length,at&&(lt.push(...ut.slice(0,vt)),ut=tt[dt].slice(bt))}return ot.push(...nt),at?(lt.push(...ut),[ot,lt]):[ot,[]]}collateWordTimestamps(_e,tt,nt){const[rt,ot,at]=this.combineTokensIntoWords(_e,nt),lt=[];for(let ut=0;ut<rt.length;++ut){const dt=at[ut];lt.push({text:rt[ut],timestamp:[tt[dt.at(0)][0],tt[dt.at(-1)][1]]})}return lt}combineTokensIntoWords(_e,tt,nt=`"'([{-`,rt=`"'.,!?:)]}`){tt=tt??"english";let ot,at,lt;return["chinese","japanese","thai","lao","myanmar"].includes(tt)?[ot,at,lt]=this.splitTokensOnUnicode(_e):[ot,at,lt]=this.splitTokensOnSpaces(_e),this.mergePunctuations(ot,at,lt,nt,rt)}decode(_e,tt){let nt;return tt&&tt.decode_with_timestamps?(_e instanceof Tensor&&(_e=prepareTensorForDecode(_e)),nt=this.decodeWithTimestamps(_e,tt)):nt=super.decode(_e,tt),nt}decodeWithTimestamps(_e,tt){const nt=(tt==null?void 0:tt.time_precision)??.02,rt=Array.from(this.all_special_ids).at(-1)+1;let ot=[[]];for(const at of _e)if(at>=rt){const lt=round$1((at-rt)*nt,2);ot.push(`<|${lt}|>`),ot.push([])}else ot[ot.length-1].push(at);return ot=ot.map(at=>typeof at=="string"?at:super.decode(at,tt)),ot.join("")}splitTokensOnUnicode(_e){const tt=this.decode(_e,{decode_with_timestamps:!0}),nt="",rt=[],ot=[],at=[];let lt=[],ut=[],dt=0;for(let st=0;st<_e.length;++st){const it=_e[st];lt.push(it),ut.push(st);const ct=this.decode(lt,{decode_with_timestamps:!0});(!ct.includes(nt)||tt[dt+ct.indexOf(nt)]===nt)&&(rt.push(ct),ot.push(lt),at.push(ut),lt=[],ut=[],dt+=ct.length)}return[rt,ot,at]}splitTokensOnSpaces(_e){const[tt,nt,rt]=this.splitTokensOnUnicode(_e),ot=[],at=[],lt=[],ut=new RegExp(`^[${PUNCTUATION_REGEX}]$`,"gu");for(let dt=0;dt<tt.length;++dt){const st=tt[dt],it=nt[dt],ct=rt[dt],ft=it[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),ht=st.startsWith(" "),mt=st.trim(),pt=ut.test(mt);if(ft||ht||pt||ot.length===0)ot.push(st),at.push(it),lt.push(ct);else{const _t=ot.length-1;ot[_t]+=st,at[_t].push(...it),lt[_t].push(...ct)}}return[ot,at,lt]}mergePunctuations(_e,tt,nt,rt,ot){const at=structuredClone(_e),lt=structuredClone(tt),ut=structuredClone(nt);let dt=at.length-2,st=at.length-1;for(;dt>=0;)at[dt].startsWith(" ")&&rt.includes(at[dt].trim())?(at[st]=at[dt]+at[st],lt[st]=mergeArrays(lt[dt],lt[st]),ut[st]=mergeArrays(ut[dt],ut[st]),at[dt]="",lt[dt]=[],ut[dt]=[]):st=dt,--dt;for(dt=0,st=1;st<at.length;)!at[dt].endsWith(" ")&&ot.includes(at[st])?(at[dt]+=at[st],lt[dt]=mergeArrays(lt[dt],lt[st]),ut[dt]=mergeArrays(ut[dt],ut[st]),at[st]="",lt[st]=[],ut[st]=[]):dt=st,++st;return[at.filter(it=>it),lt.filter(it=>it.length>0),ut.filter(it=>it.length>0)]}get_decoder_prompt_ids({language:_e=null,task:tt=null,no_timestamps:nt=!0}={}){const rt=[];if(_e){_e=_e.toLowerCase();let ot=WHISPER_TO_LANGUAGE_CODE_MAPPING.get(_e);if(ot===void 0)if(WHISPER_LANGUAGE_MAPPING.has(_e))ot=_e;else{const ut=_e.length===2?WHISPER_LANGUAGE_MAPPING.keys():WHISPER_LANGUAGE_MAPPING.values();throw new Error(`Language "${_e}" is not supported. Must be one of: ${JSON.stringify(ut)}`)}const at=this.model.tokens_to_ids.get(`<|${ot}|>`);if(at===void 0)throw new Error(`Unable to find language "${ot}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`);rt.push(at)}else rt.push(null);if(tt){if(tt=tt.toLowerCase(),tt!=="transcribe"&&tt!=="translate")throw new Error(`Task "${tt}" is not supported. Must be one of: ["transcribe", "translate"]`);const ot=this.model.tokens_to_ids.get(`<|${tt}|>`);if(ot===void 0)throw new Error(`Unable to find task "${tt}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`);rt.push(ot)}else rt.push(null);if(nt){const ot=this.model.tokens_to_ids.get("<|notimestamps|>");if(ot===void 0)throw new Error('Unable to find "<|notimestamps|>" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.');rt.push(ot)}return rt.map((ot,at)=>[at+1,ot]).filter(ot=>ot[1]!==null)}}class CodeGenTokenizer extends PreTrainedTokenizer{}class CLIPTokenizer extends PreTrainedTokenizer{}class SiglipTokenizer extends PreTrainedTokenizer{}class MarianTokenizer extends PreTrainedTokenizer{constructor(_,_e){super(_,_e),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(tt=>this.languageRegex.test(tt)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(_){if(_===null)return null;const[_e,...tt]=_.trim().split(this.languageRegex);if(tt.length===0)return super._encode_text(_e);if(tt.length===2){const[nt,rt]=tt;return this.supported_language_codes.includes(nt)||console.warn(`Unsupported language code "${nt}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),mergeArrays([nt],super._encode_text(rt))}}}class Wav2Vec2CTCTokenizer extends PreTrainedTokenizer{}class BlenderbotTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);jn(this,"_default_chat_template","{% for message in messages %}{% if message['role'] == 'user' %}{{ ' ' }}{% endif %}{{ message['content'] }}{% if not loop.last %}{{ '  ' }}{% endif %}{% endfor %}{{ eos_token }}")}}class BlenderbotSmallTokenizer extends BlenderbotTokenizer{}class SpeechT5Tokenizer extends PreTrainedTokenizer{}class NougatTokenizer extends PreTrainedTokenizer{}class VitsTokenizer extends PreTrainedTokenizer{constructor(_,_e){super(_,_e),this.decoder=new VitsDecoder({})}}class CohereTokenizer extends PreTrainedTokenizer{}class AutoTokenizer{static async from_pretrained(_,{quantized:_e=!0,progress_callback:tt=null,config:nt=null,cache_dir:rt=null,local_files_only:ot=!1,revision:at="main",legacy:lt=null}={}){var ct;const[ut,dt]=await loadTokenizer(_,{quantized:_e,progress_callback:tt,config:nt,cache_dir:rt,local_files_only:ot,revision:at,legacy:lt}),st=((ct=dt.tokenizer_class)==null?void 0:ct.replace(/Fast$/,""))??"PreTrainedTokenizer";let it=this.TOKENIZER_CLASS_MAPPING[st];return it||(console.warn(`Unknown tokenizer class "${st}", attempting to construct from base class.`),it=PreTrainedTokenizer),new it(ut,dt)}}jn(AutoTokenizer,"TOKENIZER_CLASS_MAPPING",{T5Tokenizer,DistilBertTokenizer,CamembertTokenizer,DebertaTokenizer,DebertaV2Tokenizer,BertTokenizer,HerbertTokenizer,ConvBertTokenizer,RoFormerTokenizer,XLMTokenizer,ElectraTokenizer,MobileBertTokenizer,SqueezeBertTokenizer,AlbertTokenizer,GPT2Tokenizer,BartTokenizer,MBartTokenizer,MBart50Tokenizer,RobertaTokenizer,WhisperTokenizer,CodeGenTokenizer,CLIPTokenizer,SiglipTokenizer,MarianTokenizer,BloomTokenizer,NllbTokenizer,M2M100Tokenizer,LlamaTokenizer,CodeLlamaTokenizer,XLMRobertaTokenizer,MPNetTokenizer,FalconTokenizer,GPTNeoXTokenizer,EsmTokenizer,Wav2Vec2CTCTokenizer,BlenderbotTokenizer,BlenderbotSmallTokenizer,SpeechT5Tokenizer,NougatTokenizer,VitsTokenizer,Qwen2Tokenizer,GemmaTokenizer,Grok1Tokenizer,CohereTokenizer,PreTrainedTokenizer});async function loadConfig(et,_){return await getModelJSON(et,"config.json",!0,_)}class PretrainedConfig{constructor(_){this.model_type=null,this.is_encoder_decoder=!1,Object.assign(this,_)}static async from_pretrained(_,{progress_callback:_e=null,config:tt=null,cache_dir:nt=null,local_files_only:rt=!1,revision:ot="main"}={}){let at=tt??await loadConfig(_,{progress_callback:_e,config:tt,cache_dir:nt,local_files_only:rt,revision:ot});return new this(at)}}class AutoConfig{static async from_pretrained(..._){return PretrainedConfig.from_pretrained(..._)}}class LogitsProcessorList extends Callable{constructor(){super(),this.processors=[]}push(_){this.processors.push(_)}extend(_){this.processors.push(..._)}_call(_,_e){for(let tt of _e)this.processors.forEach(nt=>nt(_,tt))}[Symbol.iterator](){return this.processors.values()}}class LogitsProcessor extends Callable{_call(_,_e){throw Error("`_call` should be implemented in a subclass")}}class ForceTokensLogitsProcessor extends LogitsProcessor{constructor(_){super(),this.force_token_map=Object.fromEntries(_??[])}_call(_,_e){let tt=this.force_token_map[_.length];return exists(tt)&&(_e.data.fill(-1/0),_e.data[tt]=0),_e}}class ForcedBOSTokenLogitsProcessor extends LogitsProcessor{constructor(_){super(),this.bos_token_id=_}_call(_,_e){return _.length===1&&(_e.data.fill(-1/0),_e.data[this.bos_token_id]=0),_e}}class ForcedEOSTokenLogitsProcessor extends LogitsProcessor{constructor(_,_e){super(),this.max_length=_,this.forced_eos_token_id=_e}_call(_,_e){}}class SuppressTokensAtBeginLogitsProcessor extends LogitsProcessor{constructor(_,_e){super(),this.begin_suppress_tokens=_,this.begin_index=_e}_call(_,_e){if(_.length===this.begin_index)for(let tt of this.begin_suppress_tokens)_e.data[tt]=-1/0;return _e}}class WhisperTimeStampLogitsProcessor extends LogitsProcessor{constructor(_){super(),this.eos_token_id=_.eos_token_id,this.no_timestamps_token_id=_.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=(_.forced_decoder_ids||[]).length+2,_.forced_decoder_ids.slice(-1)[0][1]===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=_.max_initial_timestamp_index}_call(_,_e){const tt=_e.data;if(tt[this.no_timestamps_token_id]=-1/0,_.length===this.begin_index-1)return tt.fill(-1/0),tt[this.timestamp_begin]=0,_e;const nt=_.slice(this.begin_index),rt=nt.length>=1&&nt[nt.length-1]>=this.timestamp_begin,ot=nt.length<2||nt[nt.length-2]>=this.timestamp_begin;if(rt&&(ot?tt.subarray(this.timestamp_begin).fill(-1/0):tt.subarray(0,this.eos_token_id).fill(-1/0)),_.length===this.begin_index&&this.max_initial_timestamp_index!==null){const dt=this.timestamp_begin+this.max_initial_timestamp_index;tt.subarray(dt+1).fill(-1/0)}const at=log_softmax(tt),lt=Math.log(at.subarray(this.timestamp_begin).map(Math.exp).reduce((dt,st)=>dt+st)),ut=max$1(at.subarray(0,this.timestamp_begin))[0];return lt>ut&&tt.subarray(0,this.timestamp_begin).fill(-1/0),_e}}class NoRepeatNGramLogitsProcessor extends LogitsProcessor{constructor(_){super(),this.no_repeat_ngram_size=_}getNgrams(_){const _e=_.length,tt=[];for(let rt=0;rt<_e+1-this.no_repeat_ngram_size;++rt){const ot=[];for(let at=0;at<this.no_repeat_ngram_size;++at)ot.push(_[rt+at]);tt.push(ot)}const nt=new Map;for(const rt of tt){const ot=rt.slice(0,rt.length-1),at=JSON.stringify(ot),lt=nt.get(at)??[];lt.push(rt[rt.length-1]),nt.set(at,lt)}return nt}getGeneratedNgrams(_,_e){const tt=_e.slice(_e.length+1-this.no_repeat_ngram_size,_e.length);return _.get(JSON.stringify(tt))??[]}calcBannedNgramTokens(_){const _e=[];if(_.length+1<this.no_repeat_ngram_size)return _e;{const tt=this.getNgrams(_);return this.getGeneratedNgrams(tt,_)}}_call(_,_e){const tt=this.calcBannedNgramTokens(_);for(const nt of tt)_e.data[nt]=-1/0;return _e}}class RepetitionPenaltyLogitsProcessor extends LogitsProcessor{constructor(_){super(),this.penalty=_}_call(_,_e){for(const tt of _)_e.data[tt]<0?_e.data[tt]*=this.penalty:_e.data[tt]/=this.penalty;return _e}}class MinLengthLogitsProcessor extends LogitsProcessor{constructor(_,_e){super(),this.min_length=_,this.eos_token_id=Array.isArray(_e)?_e:[_e]}_call(_,_e){if(_.length<this.min_length)for(const tt of this.eos_token_id)_e.data[tt]=-1/0;return _e}}class MinNewTokensLengthLogitsProcessor extends LogitsProcessor{constructor(_,_e,tt){super(),this.prompt_length_to_skip=_,this.min_new_tokens=_e,this.eos_token_id=Array.isArray(tt)?tt:[tt]}_call(_,_e){if(_.length-this.prompt_length_to_skip<this.min_new_tokens)for(const nt of this.eos_token_id)_e.data[nt]=-1/0;return _e}}class NoBadWordsLogitsProcessor extends LogitsProcessor{constructor(_,_e){super(),this.bad_words_ids=_,this.eos_token_id=Array.isArray(_e)?_e:[_e]}_call(_,_e){for(const tt of this.bad_words_ids){let nt=!0;for(let rt=1;rt<=tt.length-1&&tt.length<_.length;++rt)if(tt.at(-rt-1)!==_.at(-rt)){nt=!1;break}nt&&(_e.data[tt.at(-1)]=-1/0)}return _e}}const GenerationConfig=class{constructor(et={}){this.max_length=et.max_length??20,this.max_new_tokens=et.max_new_tokens??null,this.min_length=et.min_length??0,this.min_new_tokens=et.min_new_tokens??null,this.early_stopping=et.early_stopping??!1,this.max_time=et.max_time??null,this.do_sample=et.do_sample??!1,this.num_beams=et.num_beams??1,this.num_beam_groups=et.num_beam_groups??1,this.penalty_alpha=et.penalty_alpha??null,this.use_cache=et.use_cache??!0,this.temperature=et.temperature??1,this.top_k=et.top_k??50,this.top_p=et.top_p??1,this.typical_p=et.typical_p??1,this.epsilon_cutoff=et.epsilon_cutoff??0,this.eta_cutoff=et.eta_cutoff??0,this.diversity_penalty=et.diversity_penalty??0,this.repetition_penalty=et.repetition_penalty??1,this.encoder_repetition_penalty=et.encoder_repetition_penalty??1,this.length_penalty=et.length_penalty??1,this.no_repeat_ngram_size=et.no_repeat_ngram_size??0,this.bad_words_ids=et.bad_words_ids??null,this.force_words_ids=et.force_words_ids??null,this.renormalize_logits=et.renormalize_logits??!1,this.constraints=et.constraints??null,this.forced_bos_token_id=et.forced_bos_token_id??null,this.forced_eos_token_id=et.forced_eos_token_id??null,this.remove_invalid_values=et.remove_invalid_values??!1,this.exponential_decay_length_penalty=et.exponential_decay_length_penalty??null,this.suppress_tokens=et.suppress_tokens??null,this.begin_suppress_tokens=et.begin_suppress_tokens??null,this.forced_decoder_ids=et.forced_decoder_ids??null,this.num_return_sequences=et.num_return_sequences??1,this.output_attentions=et.output_attentions??!1,this.output_hidden_states=et.output_hidden_states??!1,this.output_scores=et.output_scores??!1,this.return_dict_in_generate=et.return_dict_in_generate??!1,this.pad_token_id=et.pad_token_id??null,this.bos_token_id=et.bos_token_id??null,this.eos_token_id=et.eos_token_id??null,this.encoder_no_repeat_ngram_size=et.encoder_no_repeat_ngram_size??0,this.decoder_start_token_id=et.decoder_start_token_id??null,this.generation_kwargs=et.generation_kwargs??{}}};class Sampler extends Callable{constructor(_){super(),this.generation_config=_}_call(_,_e=-1){return this.sample(_,_e)}sample(_,_e){throw Error("sample should be implemented in subclasses.")}getLogits(_,_e){let tt=_.dims.at(-1),nt=_.data;if(_e===-1)nt=nt.slice(-tt);else{let rt=_e*tt;nt=nt.slice(rt,rt+tt)}return this.generation_config.temperature>0&&(nt=nt.map(rt=>rt/this.generation_config.temperature)),nt}randomSelect(_){let _e=_.reduce((nt,rt)=>nt+rt,0),tt=Math.random()*_e;for(let nt=0;nt<_.length;++nt)if(tt-=_[nt],tt<=0)return nt;return 0}static getSampler(_){if(_.do_sample)return new MultinomialSampler(_);if(_.num_beams>1)return new BeamSearchSampler(_);if(_.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${_.num_return_sequences}.`);return new GreedySampler(_)}}class GreedySampler extends Sampler{sample(_,_e=-1){let tt=this.getLogits(_,_e);return[[max$1(tt)[1],0]]}}class MultinomialSampler extends Sampler{sample(_,_e=-1){let tt=_.dims.at(-1);this.generation_config.top_k>0&&(tt=Math.min(this.generation_config.top_k,tt));const nt=this.getLogits(_,_e),rt=getTopItems(nt,tt),ot=softmax(rt.map(at=>at[1]));return Array.from({length:this.generation_config.num_beams},()=>{const at=this.randomSelect(ot);return[rt[at][0],Math.log(ot[at])]})}}class BeamSearchSampler extends Sampler{sample(_,_e=-1){let tt=_.dims.at(-1);this.generation_config.top_k>0&&(tt=Math.min(this.generation_config.top_k,tt));const nt=this.getLogits(_,_e),rt=getTopItems(nt,tt),ot=softmax(rt.map(at=>at[1]));return Array.from({length:this.generation_config.num_beams},(at,lt)=>[rt[lt][0],Math.log(ot[lt])])}}const{InferenceSession,Tensor:ONNXTensor,env}=ONNX,MODEL_TYPES={EncoderOnly:0,EncoderDecoder:1,Seq2Seq:2,Vision2Seq:3,DecoderOnly:4,MaskGeneration:5},MODEL_TYPE_MAPPING=new Map,MODEL_NAME_TO_CLASS_MAPPING=new Map,MODEL_CLASS_TO_NAME_MAPPING=new Map;async function constructSession(et,_,_e){let tt=`onnx/${_}${_e.quantized?"_quantized":""}.onnx`,nt=await getModelFile(et,tt,!0,_e);try{return await InferenceSession.create(nt,{executionProviders})}catch(rt){if(executionProviders.length===1&&executionProviders[0]==="wasm")throw rt;return console.warn(rt),console.warn("Something went wrong during model construction (most likely a missing operation). Using `wasm` as a fallback. "),await InferenceSession.create(nt,{executionProviders:["wasm"]})}}function validateInputs(et,_){const _e=Object.create(null),tt=[];for(const ot of et.inputNames){const at=_[ot];if(!(at instanceof Tensor)){tt.push(ot);continue}_e[ot]=env.wasm.proxy?at.clone():at}if(tt.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${tt.join(", ")}.`);const nt=Object.keys(_).length,rt=et.inputNames.length;if(nt>rt){let ot=Object.keys(_).filter(at=>!et.inputNames.includes(at));console.warn(`WARNING: Too many inputs were provided (${nt} > ${rt}). The following inputs will be ignored: "${ot.join(", ")}".`)}return _e}async function sessionRun(et,_){const _e=validateInputs(et,_);try{let tt=await et.run(_e);return tt=replaceTensors(tt),tt}catch(tt){throw console.error(`An error occurred during model execution: "${tt}".`),console.error("Inputs given to model:",_e),tt}}function replaceTensors(et){for(let _ in et)et[_]instanceof ONNXTensor?et[_]=new Tensor(et[_]):typeof et[_]=="object"&&replaceTensors(et[_]);return et}function toI64Tensor(et){if(et instanceof Tensor)return et;if(et.length===0)throw Error("items must be non-empty");if(Array.isArray(et[0])){if(et.some(_=>_.length!==et[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new Tensor("int64",BigInt64Array.from(et.flat().map(_=>BigInt(_))),[et.length,et[0].length])}else return new Tensor("int64",BigInt64Array.from(et.map(_=>BigInt(_))),[1,et.length])}function prepareAttentionMask(et,_){let _e=et.config.pad_token_id??null,tt=et.config.eos_token_id??null;isIntegralNumber(tt)&&(tt=[tt]);let nt=_.indexOf(_e)!==-1,rt=tt===null||!tt.includes(_e);if(nt&&rt){let ot=BigInt64Array.from(_.data.map(at=>at!=_e));return new Tensor("int64",ot,_.dims)}else return ones_like(_)}function preparePositionIds(et,_,_e){if(!et.inputNames.includes("position_ids"))return;const tt=new BigInt64Array(_.attention_mask.data.length);for(let nt=0;nt<_.attention_mask.dims[0];++nt){let rt=nt*_.attention_mask.dims[1],ot=BigInt(0);for(let at=0;at<_.attention_mask.dims[1];++at){const lt=rt+at;_.attention_mask.data[lt]===0n?tt[lt]=BigInt(1):(tt[lt]=ot,ot+=_.attention_mask.data[lt])}}_.position_ids=new Tensor("int64",tt,_.attention_mask.dims),_e&&(_.position_ids=_.position_ids.slice(null,-1).unsqueeze_(-1))}function boolTensor(et){return new Tensor("bool",[et],[1])}async function seq2seqForward(et,_){let{encoder_outputs:_e,past_key_values:tt}=_;_e||(_e=(await encoderForward(et,_)).last_hidden_state);let nt={input_ids:_.decoder_input_ids,encoder_hidden_states:_e};const rt=!!tt;et.decoder_merged_session.inputNames.includes("use_cache_branch")&&(nt.use_cache_branch=boolTensor(rt)),et.decoder_merged_session.inputNames.includes("encoder_attention_mask")&&(nt.encoder_attention_mask=_.attention_mask),preparePositionIds(et.decoder_merged_session,nt,rt),et.addPastKeyValues(nt,tt);const ot=await sessionRun(et.decoder_merged_session,nt);let at=ot.logits;tt=et.getPastKeyValues(ot,tt);const lt=et.getAttentions(ot);return new Seq2SeqLMOutput({logits:at,past_key_values:tt,encoder_outputs:_e,...lt})}function seq2seqStartBeams(et,_,_e,tt){let nt=[],rt=0;const ot=et.requires_attention_mask??!0;let at=_e.decoder_input_ids??_e.decoder_start_token_id??_e.bos_token_id??_e.eos_token_id;at instanceof Tensor?at=at.tolist().flat():Array.isArray(at)||(at=[at]);for(let lt of _){lt.dims=[1,...lt.dims];let ut={inputs:lt,encoder_outputs:null,prev_model_outputs:null,output_token_ids:at,done:!1,score:0,id:rt++};ot&&(ut.attention_mask=prepareAttentionMask(et,lt)),nt.push(ut)}return nt}async function seq2seqRunBeam(et,_){var ot;const _e=et.main_input_name;let tt=_.output_token_ids;_.prev_model_outputs&&(tt=tt.slice(-1));let nt={[_e]:_.inputs,decoder_input_ids:toI64Tensor(tt),encoder_outputs:_.encoder_outputs,past_key_values:(ot=_.prev_model_outputs)==null?void 0:ot.past_key_values};_.attention_mask&&(nt.attention_mask=_.attention_mask);let rt=await et.forward(nt);return _.prev_model_outputs=rt,_.encoder_outputs=rt.encoder_outputs,rt}function seq2seqUpdatebeam(et,_){et.output_token_ids=[...et.output_token_ids,_]}async function encoderForward(et,_){const _e=Object.create(null);for(const tt of et.session.inputNames)_e[tt]=_[tt];return et.session.inputNames.includes("token_type_ids")&&!_e.token_type_ids&&(_e.token_type_ids=new Tensor("int64",new BigInt64Array(_e.input_ids.data.length),_e.input_ids.dims)),await sessionRun(et.session,_e)}async function decoderForward(et,_){let{input_ids:_e,past_key_values:tt,attention_mask:nt}=_,rt={input_ids:_e,attention_mask:nt??prepareAttentionMask(et,_e)};const ot=!!tt;et.session.inputNames.includes("use_cache_branch")&&(rt.use_cache_branch=boolTensor(ot)),preparePositionIds(et.session,rt,ot),et.addPastKeyValues(rt,tt);let at=await sessionRun(et.session,rt),lt=at.logits;return tt=et.getPastKeyValues(at,tt),{logits:lt,past_key_values:tt}}function decoderStartBeams(et,_,_e,tt,nt){let rt=[],ot=0;for(let at of _){let lt=at.tolist().map(Number);at.dims=[1,...at.dims];let ut;nt?(ut=nt[ot],ut.dims=[1,...ut.dims]):ut=prepareAttentionMask(et,at);let dt={input:at,model_input_ids:at,attention_mask:ut,prev_model_outputs:null,output_token_ids:lt,num_output_tokens:tt,done:!1,score:0,id:ot++};rt.push(dt)}return rt}async function decoderRunBeam(et,_){var rt;let _e=new BigInt64Array(_.output_token_ids.length).fill(1n),tt={input_ids:_.model_input_ids,attention_mask:new Tensor("int64",_e,[1,_e.length]),past_key_values:(rt=_.prev_model_outputs)==null?void 0:rt.past_key_values},nt=await et.forward(tt);return _.prev_model_outputs=nt,nt}function decoderUpdatebeam(et,_){et.output_token_ids=[...et.output_token_ids,_],et.model_input_ids=new Tensor("int64",[BigInt(_)],[1,1])}class PreTrainedModel extends Callable{constructor(_e,tt){super();jn(this,"main_input_name","input_ids");this.config=_e,this.session=tt;const nt=MODEL_CLASS_TO_NAME_MAPPING.get(this.constructor),rt=MODEL_TYPE_MAPPING.get(nt);this.can_generate=!1,this._runBeam=null,this._getStartBeams=null,this._updateBeam=null,this._forward=null,rt===MODEL_TYPES.DecoderOnly?(this.can_generate=!0,this._runBeam=decoderRunBeam,this._getStartBeams=decoderStartBeams,this._updateBeam=decoderUpdatebeam,this._forward=decoderForward):rt===MODEL_TYPES.Seq2Seq||rt===MODEL_TYPES.Vision2Seq?(this.can_generate=!0,this._runBeam=seq2seqRunBeam,this._getStartBeams=seq2seqStartBeams,this._updateBeam=seq2seqUpdatebeam,this._forward=seq2seqForward):rt===MODEL_TYPES.EncoderDecoder?this._forward=encoderForward:this._forward=encoderForward}async dispose(){const _e=[];for(let tt of Object.keys(this)){const nt=this[tt];nt instanceof InferenceSession&&_e.push(nt.handler.dispose())}return await Promise.all(_e)}static async from_pretrained(_e,{quantized:tt=!0,progress_callback:nt=null,config:rt=null,cache_dir:ot=null,local_files_only:at=!1,revision:lt="main",model_file_name:ut=null}={}){let dt={quantized:tt,progress_callback:nt,config:rt,cache_dir:ot,local_files_only:at,revision:lt,model_file_name:ut};const st=MODEL_CLASS_TO_NAME_MAPPING.get(this),it=MODEL_TYPE_MAPPING.get(st);let ct;return it===MODEL_TYPES.DecoderOnly?ct=await Promise.all([AutoConfig.from_pretrained(_e,dt),constructSession(_e,dt.model_file_name??"decoder_model_merged",dt),getModelJSON(_e,"generation_config.json",!1,dt)]):it===MODEL_TYPES.Seq2Seq||it===MODEL_TYPES.Vision2Seq?ct=await Promise.all([AutoConfig.from_pretrained(_e,dt),constructSession(_e,"encoder_model",dt),constructSession(_e,"decoder_model_merged",dt),getModelJSON(_e,"generation_config.json",!1,dt)]):it===MODEL_TYPES.MaskGeneration?ct=await Promise.all([AutoConfig.from_pretrained(_e,dt),constructSession(_e,"vision_encoder",dt),constructSession(_e,"prompt_encoder_mask_decoder",dt)]):it===MODEL_TYPES.EncoderDecoder?ct=await Promise.all([AutoConfig.from_pretrained(_e,dt),constructSession(_e,"encoder_model",dt),constructSession(_e,"decoder_model_merged",dt)]):(it!==MODEL_TYPES.EncoderOnly&&console.warn(`Model type for '${st??(rt==null?void 0:rt.model_type)}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`),ct=await Promise.all([AutoConfig.from_pretrained(_e,dt),constructSession(_e,dt.model_file_name??"model",dt)])),new this(...ct)}async _call(_e){return await this.forward(_e)}async forward(_e){return await this._forward(this,_e)}_get_logits_processor(_e,tt,nt=null){const rt=new LogitsProcessorList;if(_e.repetition_penalty!==null&&_e.repetition_penalty!==1&&rt.push(new RepetitionPenaltyLogitsProcessor(_e.repetition_penalty)),_e.no_repeat_ngram_size!==null&&_e.no_repeat_ngram_size>0&&rt.push(new NoRepeatNGramLogitsProcessor(_e.no_repeat_ngram_size)),_e.bad_words_ids!==null&&rt.push(new NoBadWordsLogitsProcessor(_e.bad_words_ids,_e.eos_token_id)),_e.min_length!==null&&_e.eos_token_id!==null&&_e.min_length>0&&rt.push(new MinLengthLogitsProcessor(_e.min_length,_e.eos_token_id)),_e.min_new_tokens!==null&&_e.eos_token_id!==null&&_e.min_new_tokens>0&&rt.push(new MinNewTokensLengthLogitsProcessor(tt,_e.min_new_tokens,_e.eos_token_id)),_e.forced_bos_token_id!==null&&rt.push(new ForcedBOSTokenLogitsProcessor(_e.forced_bos_token_id)),_e.forced_eos_token_id!==null&&rt.push(new ForcedEOSTokenLogitsProcessor(_e.max_length,_e.forced_eos_token_id)),_e.begin_suppress_tokens!==null){let ot=tt>1||_e.forced_bos_token_id===null?tt:tt+1;_e.forced_decoder_ids!==null&&(ot+=_e.forced_decoder_ids[_e.forced_decoder_ids.length-1][0]),rt.push(new SuppressTokensAtBeginLogitsProcessor(_e.begin_suppress_tokens,ot))}return _e.forced_decoder_ids!==null&&rt.push(new ForceTokensLogitsProcessor(_e.forced_decoder_ids)),nt!==null&&rt.extend(nt),rt}_get_generation_config(_e){let tt=new GenerationConfig(this.config);return"generation_config"in this&&Object.assign(tt,this.generation_config),_e!==null&&Object.assign(tt,_e),tt}async generate(_e,tt=null,nt=null,{inputs_attention_mask:rt=null}={}){if(!this.can_generate){let pt=`The current model class (${MODEL_CLASS_TO_NAME_MAPPING.get(this.constructor)}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;const _t=this.config.model_type,vt=MODEL_WITH_LM_HEAD_MAPPING_NAMES.get(_t)??MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES.get(_t)??MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES.get(_t)??MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES.get(_t);throw vt&&(pt+=` Please use the following class instead: '${vt[0]}'`),Error(pt)}if(!(_e instanceof Tensor)&&!isTypedArray(_e)&&!Array.isArray(_e))throw Error(`\`inputs\` must be a Tensor, TypedArray, or Array, but is "${_e.constructor.name}".`);let ot;if(this.config.is_encoder_decoder)ot=0;else if(ot=_e instanceof Tensor?_e.dims.at(-1):_e.length,ot===0)throw Error("Must supply a non-empty array of input token ids.");tt=this._get_generation_config(tt),nt=nt??new LogitsProcessorList,nt=this._get_logits_processor(tt,ot,nt);let at=tt.eos_token_id;at!==null&&!Array.isArray(at)&&(at=[at]);let lt=1;const ut=lt+(tt.max_new_tokens??1/0),dt=Number.isInteger(tt.max_length)&&(tt.max_new_tokens??null)===null;let st=Sampler.getSampler(tt),it=this.getStartBeams(_e,tt,lt,rt);for(;it.some(mt=>!mt.done)&&lt<ut;){let mt=[];for(let pt of it){if(pt.done){mt.push(pt);continue}if(dt&&pt.output_token_ids.length>=tt.max_length){pt.done=!0,mt.push(pt);continue}let _t=await this.runBeam(pt);tt.output_attentions&&this.addAttentionsToBeam(pt,_t),tt.output_scores;let vt=_t.logits.slice(null,-1,null);nt(pt.output_token_ids,vt);let bt=st(vt);for(let[wt,xt]of bt){let Mt={...pt};this.updateBeam(Mt,wt),Mt.score+=xt,at&&at.includes(wt)&&(Mt.done=!0),mt.push(Mt)}}++lt,mt=this.groupBeams(mt).map(pt=>pt.sort((_t,vt)=>vt.score-_t.score).slice(0,tt.num_beams)),it=mt.flat(),tt.callback_function&&tt.callback_function(it)}const ct=this.groupBeams(it),ft=mt=>ct.map(pt=>tt.num_return_sequences>1?pt.slice(0,tt.num_return_sequences).map(_t=>_t[mt]):[pt[0][mt]]).flat(),ht=ft("output_token_ids");if(tt.return_dict_in_generate){const mt=ft("decoder_attentions"),pt=ft("cross_attentions");return{sequences:ht,decoder_attentions:mt,cross_attentions:pt}}else return ht}addAttentionsToBeam(_e,tt){if(this.config.is_encoder_decoder){if(!tt.cross_attentions||tt.cross_attentions.length===0)throw Error("`output_attentions` is true, but the model did not produce cross-attentions. This is most likely because the model was not exported with `output_attentions=True`.");_e.cross_attentions||(_e.cross_attentions=[]),_e.cross_attentions.push(tt.cross_attentions)}if(!tt.decoder_attentions||tt.decoder_attentions.length===0)throw Error("`output_attentions` is true, but the model did not produce decoder-attentions. This is most likely because the model was not exported with `output_attentions=True`.");_e.decoder_attentions||(_e.decoder_attentions=[]),_e.decoder_attentions.push(tt.decoder_attentions)}groupBeams(_e){const tt=Object.create(null);for(const nt of _e)tt[nt.id]===void 0?tt[nt.id]=[nt]:tt[nt.id].push(nt);return Object.values(tt)}getPastKeyValues(_e,tt){const nt=Object.create(null);for(const rt in _e)if(rt.startsWith("present")){let ot=rt.replace("present","past_key_values");tt&&rt.includes("encoder")?nt[ot]=tt[ot]:nt[ot]=_e[rt]}return nt}getAttentions(_e){const tt=Object.create(null);for(const nt of["cross_attentions","decoder_attentions"]){const rt=[];for(const ot in _e)if(ot.startsWith(nt)){const at=ot.split(".").pop();rt[at]=_e[ot]}tt[nt]=rt}return tt}addPastKeyValues(_e,tt){if(tt)Object.assign(_e,tt);else if(this.config.is_encoder_decoder&&(this.add_encoder_pkv??!0)){let rt=[1,this.num_encoder_heads,0,this.encoder_dim_kv],ot=[1,this.num_decoder_heads,0,this.decoder_dim_kv];for(let at=0;at<this.num_decoder_layers;++at)_e[`past_key_values.${at}.encoder.key`]=new Tensor("float32",[],rt),_e[`past_key_values.${at}.encoder.value`]=new Tensor("float32",[],rt),_e[`past_key_values.${at}.decoder.key`]=new Tensor("float32",[],ot),_e[`past_key_values.${at}.decoder.value`]=new Tensor("float32",[],ot)}else if(this.config.model_type==="falcon"){let rt=[1*this.num_heads,0,this.dim_kv];for(let ot=0;ot<this.num_layers;++ot)_e[`past_key_values.${ot}.key`]=new Tensor("float32",[],rt),_e[`past_key_values.${ot}.value`]=new Tensor("float32",[],rt)}else if(this.config.multi_query){let rt=[1*this.num_heads,0,2*this.dim_kv];for(let ot=0;ot<this.num_layers;++ot)_e[`past_key_values.${ot}.key_value`]=new Tensor("float32",[],rt)}else if(this.config.model_type==="bloom"){let rt=[1*this.num_heads,this.dim_kv,0],ot=[1*this.num_heads,0,this.dim_kv];for(let at=0;at<this.num_layers;++at)_e[`past_key_values.${at}.key`]=new Tensor("float32",[],rt),_e[`past_key_values.${at}.value`]=new Tensor("float32",[],ot)}else{let rt=[1,this.num_heads,0,this.dim_kv];for(let ot=0;ot<this.num_layers;++ot)_e[`past_key_values.${ot}.key`]=new Tensor("float32",[],rt),_e[`past_key_values.${ot}.value`]=new Tensor("float32",[],rt)}}getStartBeams(_e,tt,nt,rt){return this._getStartBeams(this,_e,tt,nt,rt)}async runBeam(_e){return await this._runBeam(this,_e)}updateBeam(_e,tt){return this._updateBeam(_e,tt)}}class ModelOutput{}class BertPreTrainedModel extends PreTrainedModel{}class BertModel extends BertPreTrainedModel{}class BertForMaskedLM extends BertPreTrainedModel{async _call(_){return new MaskedLMOutput(await super._call(_))}}class BertForSequenceClassification extends BertPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class BertForTokenClassification extends BertPreTrainedModel{async _call(_){return new TokenClassifierOutput(await super._call(_))}}class BertForQuestionAnswering extends BertPreTrainedModel{async _call(_){return new QuestionAnsweringModelOutput(await super._call(_))}}class NomicBertPreTrainedModel extends PreTrainedModel{}class NomicBertModel extends NomicBertPreTrainedModel{}class RoFormerPreTrainedModel extends PreTrainedModel{}class RoFormerModel extends RoFormerPreTrainedModel{}class RoFormerForMaskedLM extends RoFormerPreTrainedModel{async _call(_){return new MaskedLMOutput(await super._call(_))}}class RoFormerForSequenceClassification extends RoFormerPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class RoFormerForTokenClassification extends RoFormerPreTrainedModel{async _call(_){return new TokenClassifierOutput(await super._call(_))}}class RoFormerForQuestionAnswering extends RoFormerPreTrainedModel{async _call(_){return new QuestionAnsweringModelOutput(await super._call(_))}}class ConvBertPreTrainedModel extends PreTrainedModel{}class ConvBertModel extends ConvBertPreTrainedModel{}class ConvBertForMaskedLM extends ConvBertPreTrainedModel{async _call(_){return new MaskedLMOutput(await super._call(_))}}class ConvBertForSequenceClassification extends ConvBertPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class ConvBertForTokenClassification extends ConvBertPreTrainedModel{async _call(_){return new TokenClassifierOutput(await super._call(_))}}class ConvBertForQuestionAnswering extends ConvBertPreTrainedModel{async _call(_){return new QuestionAnsweringModelOutput(await super._call(_))}}class ElectraPreTrainedModel extends PreTrainedModel{}class ElectraModel extends ElectraPreTrainedModel{}class ElectraForMaskedLM extends ElectraPreTrainedModel{async _call(_){return new MaskedLMOutput(await super._call(_))}}class ElectraForSequenceClassification extends ElectraPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class ElectraForTokenClassification extends ElectraPreTrainedModel{async _call(_){return new TokenClassifierOutput(await super._call(_))}}class ElectraForQuestionAnswering extends ElectraPreTrainedModel{async _call(_){return new QuestionAnsweringModelOutput(await super._call(_))}}class CamembertPreTrainedModel extends PreTrainedModel{}class CamembertModel extends CamembertPreTrainedModel{}class CamembertForMaskedLM extends CamembertPreTrainedModel{async _call(_){return new MaskedLMOutput(await super._call(_))}}class CamembertForSequenceClassification extends CamembertPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class CamembertForTokenClassification extends CamembertPreTrainedModel{async _call(_){return new TokenClassifierOutput(await super._call(_))}}class CamembertForQuestionAnswering extends CamembertPreTrainedModel{async _call(_){return new QuestionAnsweringModelOutput(await super._call(_))}}class DebertaPreTrainedModel extends PreTrainedModel{}class DebertaModel extends DebertaPreTrainedModel{}class DebertaForMaskedLM extends DebertaPreTrainedModel{async _call(_){return new MaskedLMOutput(await super._call(_))}}class DebertaForSequenceClassification extends DebertaPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class DebertaForTokenClassification extends DebertaPreTrainedModel{async _call(_){return new TokenClassifierOutput(await super._call(_))}}class DebertaForQuestionAnswering extends DebertaPreTrainedModel{async _call(_){return new QuestionAnsweringModelOutput(await super._call(_))}}class DebertaV2PreTrainedModel extends PreTrainedModel{}class DebertaV2Model extends DebertaV2PreTrainedModel{}class DebertaV2ForMaskedLM extends DebertaV2PreTrainedModel{async _call(_){return new MaskedLMOutput(await super._call(_))}}class DebertaV2ForSequenceClassification extends DebertaV2PreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class DebertaV2ForTokenClassification extends DebertaV2PreTrainedModel{async _call(_){return new TokenClassifierOutput(await super._call(_))}}class DebertaV2ForQuestionAnswering extends DebertaV2PreTrainedModel{async _call(_){return new QuestionAnsweringModelOutput(await super._call(_))}}class DistilBertPreTrainedModel extends PreTrainedModel{}class DistilBertModel extends DistilBertPreTrainedModel{}class DistilBertForSequenceClassification extends DistilBertPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class DistilBertForTokenClassification extends DistilBertPreTrainedModel{async _call(_){return new TokenClassifierOutput(await super._call(_))}}class DistilBertForQuestionAnswering extends DistilBertPreTrainedModel{async _call(_){return new QuestionAnsweringModelOutput(await super._call(_))}}class DistilBertForMaskedLM extends DistilBertPreTrainedModel{async _call(_){return new MaskedLMOutput(await super._call(_))}}class EsmPreTrainedModel extends PreTrainedModel{}class EsmModel extends EsmPreTrainedModel{}class EsmForMaskedLM extends EsmPreTrainedModel{async _call(_){return new MaskedLMOutput(await super._call(_))}}class EsmForSequenceClassification extends EsmPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class EsmForTokenClassification extends EsmPreTrainedModel{async _call(_){return new TokenClassifierOutput(await super._call(_))}}class MobileBertPreTrainedModel extends PreTrainedModel{}class MobileBertModel extends MobileBertPreTrainedModel{}class MobileBertForMaskedLM extends MobileBertPreTrainedModel{async _call(_){return new MaskedLMOutput(await super._call(_))}}class MobileBertForSequenceClassification extends MobileBertPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class MobileBertForQuestionAnswering extends MobileBertPreTrainedModel{async _call(_){return new QuestionAnsweringModelOutput(await super._call(_))}}class MPNetPreTrainedModel extends PreTrainedModel{}class MPNetModel extends MPNetPreTrainedModel{}class MPNetForMaskedLM extends MPNetPreTrainedModel{async _call(_){return new MaskedLMOutput(await super._call(_))}}class MPNetForSequenceClassification extends MPNetPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class MPNetForTokenClassification extends MPNetPreTrainedModel{async _call(_){return new TokenClassifierOutput(await super._call(_))}}class MPNetForQuestionAnswering extends MPNetPreTrainedModel{async _call(_){return new QuestionAnsweringModelOutput(await super._call(_))}}class SqueezeBertPreTrainedModel extends PreTrainedModel{}class SqueezeBertModel extends SqueezeBertPreTrainedModel{}class SqueezeBertForMaskedLM extends SqueezeBertPreTrainedModel{async _call(_){return new MaskedLMOutput(await super._call(_))}}class SqueezeBertForSequenceClassification extends SqueezeBertPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class SqueezeBertForQuestionAnswering extends SqueezeBertPreTrainedModel{async _call(_){return new QuestionAnsweringModelOutput(await super._call(_))}}class AlbertPreTrainedModel extends PreTrainedModel{}class AlbertModel extends AlbertPreTrainedModel{}class AlbertForSequenceClassification extends AlbertPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class AlbertForQuestionAnswering extends AlbertPreTrainedModel{async _call(_){return new QuestionAnsweringModelOutput(await super._call(_))}}class AlbertForMaskedLM extends AlbertPreTrainedModel{async _call(_){return new MaskedLMOutput(await super._call(_))}}class T5PreTrainedModel extends PreTrainedModel{}class T5Model extends T5PreTrainedModel{}class T5ForConditionalGeneration extends T5PreTrainedModel{constructor(_,_e,tt,nt){super(_,_e),this.decoder_merged_session=tt,this.generation_config=nt,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class LongT5PreTrainedModel extends PreTrainedModel{}class LongT5Model extends LongT5PreTrainedModel{}class LongT5ForConditionalGeneration extends LongT5PreTrainedModel{constructor(_,_e,tt,nt){super(_,_e),this.decoder_merged_session=tt,this.generation_config=nt,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class MT5PreTrainedModel extends PreTrainedModel{}class MT5Model extends MT5PreTrainedModel{}class MT5ForConditionalGeneration extends MT5PreTrainedModel{constructor(_,_e,tt,nt){super(_,_e),this.decoder_merged_session=tt,this.generation_config=nt,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class BartPretrainedModel extends PreTrainedModel{}class BartModel extends BartPretrainedModel{}class BartForConditionalGeneration extends BartPretrainedModel{constructor(_,_e,tt,nt){super(_,_e),this.decoder_merged_session=tt,this.generation_config=nt,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class BartForSequenceClassification extends BartPretrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class MBartPreTrainedModel extends PreTrainedModel{}class MBartModel extends MBartPreTrainedModel{}class MBartForConditionalGeneration extends MBartPreTrainedModel{constructor(_,_e,tt,nt){super(_,_e),this.decoder_merged_session=tt,this.generation_config=nt,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class MBartForSequenceClassification extends MBartPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class MBartForCausalLM extends MBartPreTrainedModel{constructor(_,_e,tt){super(_,_e),this.generation_config=tt,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class BlenderbotPreTrainedModel extends PreTrainedModel{}class BlenderbotModel extends BlenderbotPreTrainedModel{}class BlenderbotForConditionalGeneration extends BlenderbotPreTrainedModel{constructor(_,_e,tt,nt){super(_,_e),this.decoder_merged_session=tt,this.generation_config=nt,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class BlenderbotSmallPreTrainedModel extends PreTrainedModel{}class BlenderbotSmallModel extends BlenderbotSmallPreTrainedModel{}class BlenderbotSmallForConditionalGeneration extends BlenderbotSmallPreTrainedModel{constructor(_,_e,tt,nt){super(_,_e),this.decoder_merged_session=tt,this.generation_config=nt,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class RobertaPreTrainedModel extends PreTrainedModel{}class RobertaModel extends RobertaPreTrainedModel{}class RobertaForMaskedLM extends RobertaPreTrainedModel{async _call(_){return new MaskedLMOutput(await super._call(_))}}class RobertaForSequenceClassification extends RobertaPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class RobertaForTokenClassification extends RobertaPreTrainedModel{async _call(_){return new TokenClassifierOutput(await super._call(_))}}class RobertaForQuestionAnswering extends RobertaPreTrainedModel{async _call(_){return new QuestionAnsweringModelOutput(await super._call(_))}}class XLMPreTrainedModel extends PreTrainedModel{}class XLMModel extends XLMPreTrainedModel{}class XLMWithLMHeadModel extends XLMPreTrainedModel{async _call(_){return new MaskedLMOutput(await super._call(_))}}class XLMForSequenceClassification extends XLMPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class XLMForTokenClassification extends XLMPreTrainedModel{async _call(_){return new TokenClassifierOutput(await super._call(_))}}class XLMForQuestionAnswering extends XLMPreTrainedModel{async _call(_){return new QuestionAnsweringModelOutput(await super._call(_))}}class XLMRobertaPreTrainedModel extends PreTrainedModel{}class XLMRobertaModel extends XLMRobertaPreTrainedModel{}class XLMRobertaForMaskedLM extends XLMRobertaPreTrainedModel{async _call(_){return new MaskedLMOutput(await super._call(_))}}class XLMRobertaForSequenceClassification extends XLMRobertaPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class XLMRobertaForTokenClassification extends XLMRobertaPreTrainedModel{async _call(_){return new TokenClassifierOutput(await super._call(_))}}class XLMRobertaForQuestionAnswering extends XLMRobertaPreTrainedModel{async _call(_){return new QuestionAnsweringModelOutput(await super._call(_))}}class ASTPreTrainedModel extends PreTrainedModel{}class ASTModel extends ASTPreTrainedModel{}class ASTForAudioClassification extends ASTPreTrainedModel{}class WhisperPreTrainedModel extends PreTrainedModel{}class WhisperModel extends WhisperPreTrainedModel{}class WhisperForConditionalGeneration extends WhisperPreTrainedModel{constructor(_e,tt,nt,rt){super(_e,tt);jn(this,"requires_attention_mask",!1);jn(this,"main_input_name","input_features");this.decoder_merged_session=nt,this.generation_config=rt,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}async generate(_e,tt=null,nt=null){if(tt=this._get_generation_config(tt),tt.return_timestamps??(tt.return_timestamps=!1),tt.return_timestamps&&(nt=[new WhisperTimeStampLogitsProcessor(tt)]),tt.return_token_timestamps&&(tt.output_attentions=!0,tt.return_dict_in_generate=!0,tt.task==="translate"&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),!tt.alignment_heads))throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");const rt=await super.generate(_e,tt,nt);return tt.return_token_timestamps&&tt.alignment_heads&&(rt.token_timestamps=this._extract_token_timestamps(rt,tt.alignment_heads,tt.num_frames)),rt}_extract_token_timestamps(_e,tt,nt=null,rt=.02){if(!_e.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");let ot=this.config.median_filter_width;ot===void 0&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),ot=7);const at=_e.cross_attentions.map(dt=>{let st=Array.from({length:this.config.decoder_layers},(pt,_t)=>cat(dt.map(vt=>vt[_t]),2)),it=stack(tt.map(([pt,_t])=>nt?st[pt].slice(null,_t,null,[0,nt]):st[pt].slice(null,_t)));it=it.transpose(1,0,2,3);let[ct,ft]=std_mean(it,-2,0,!0),ht=it.clone();for(let pt=0;pt<ht.dims[0];++pt){let _t=ht[pt];for(let vt=0;vt<_t.dims[0];++vt){let bt=_t[vt];const wt=ct[pt][vt][0],xt=ft[pt][vt][0];for(let Mt=0;Mt<bt.dims[0];++Mt){let At=bt[Mt];for(let St=0;St<At.data.length;++St)At.data[St]=(At.data[St]-xt.data[St])/wt.data[St];At.data.set(medianFilter(At.data,ot))}}}return mean(ht,1)}),lt=[_e.sequences.length,_e.sequences[0].length],ut=new Tensor("float32",new Float32Array(lt[0]*lt[1]),lt);for(let dt=0;dt<lt[0];++dt){const st=at[dt].neg().squeeze_(0);let[it,ct]=dynamicTimeWarping(st),ft=Array.from({length:it.length-1},(pt,_t)=>it[_t+1]-it[_t]),ht=mergeArrays([1],ft).map(pt=>!!pt),mt=[];for(let pt=0;pt<ht.length;++pt)ht[pt]&&mt.push(ct[pt]*rt);ut[dt].data.set(mt,1)}return ut}}class VisionEncoderDecoderModel extends PreTrainedModel{constructor(_e,tt,nt,rt){super(_e,tt);jn(this,"main_input_name","pixel_values");this.decoder_merged_session=nt,this.generation_config=rt;const ot=this.config.encoder,at=this.config.decoder,lt=ot.model_type;(MODEL_MAPPING_NAMES_ENCODER_ONLY.get(lt)??MODEL_MAPPING_NAMES_ENCODER_DECODER.get(lt))||console.warn(`Model type for encoder '${lt}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`);const dt=MODEL_WITH_LM_HEAD_MAPPING_NAMES.get(at.model_type);if(!dt)throw new Error(`Unable to construct \`VisionEncoderDecoder\` due to unsupported decoder: "${this.config.decoder.model_type}"`);const st=dt[1],it=new st(at,nt,rt);this.add_encoder_pkv="num_decoder_layers"in it,this.add_encoder_pkv?(this.num_decoder_layers=it.num_decoder_layers,this.num_decoder_heads=it.num_decoder_heads,this.decoder_dim_kv=it.decoder_dim_kv,this.num_encoder_layers=it.num_encoder_layers,this.num_encoder_heads=it.num_encoder_heads,this.encoder_dim_kv=it.encoder_dim_kv):(this.num_layers=it.num_layers,this.num_heads=it.num_heads,this.dim_kv=it.dim_kv)}}class CLIPPreTrainedModel extends PreTrainedModel{}class CLIPModel extends CLIPPreTrainedModel{}class CLIPTextModelWithProjection extends CLIPPreTrainedModel{static async from_pretrained(_,_e={}){return _e.model_file_name??(_e.model_file_name="text_model"),super.from_pretrained(_,_e)}}class CLIPVisionModelWithProjection extends CLIPPreTrainedModel{static async from_pretrained(_,_e={}){return _e.model_file_name??(_e.model_file_name="vision_model"),super.from_pretrained(_,_e)}}class SiglipPreTrainedModel extends PreTrainedModel{}class SiglipModel extends SiglipPreTrainedModel{}class SiglipTextModel extends SiglipPreTrainedModel{static async from_pretrained(_,_e={}){return _e.model_file_name??(_e.model_file_name="text_model"),super.from_pretrained(_,_e)}}class SiglipVisionModel extends CLIPPreTrainedModel{static async from_pretrained(_,_e={}){return _e.model_file_name??(_e.model_file_name="vision_model"),super.from_pretrained(_,_e)}}class ChineseCLIPPreTrainedModel extends PreTrainedModel{}class ChineseCLIPModel extends ChineseCLIPPreTrainedModel{}class CLIPSegPreTrainedModel extends PreTrainedModel{}class CLIPSegModel extends CLIPSegPreTrainedModel{}class CLIPSegForImageSegmentation extends CLIPSegPreTrainedModel{}class GPT2PreTrainedModel extends PreTrainedModel{constructor(_,_e,tt){super(_,_e),this.generation_config=tt,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class GPT2Model extends GPT2PreTrainedModel{}class GPT2LMHeadModel extends GPT2PreTrainedModel{}class GPTNeoPreTrainedModel extends PreTrainedModel{constructor(_,_e,tt){super(_,_e),this.generation_config=tt,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_heads,this.num_layers=this.config.num_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class GPTNeoModel extends GPTNeoPreTrainedModel{}class GPTNeoForCausalLM extends GPTNeoPreTrainedModel{}class GPTNeoXPreTrainedModel extends PreTrainedModel{constructor(_,_e,tt){super(_,_e),this.generation_config=tt,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class GPTNeoXModel extends GPTNeoXPreTrainedModel{}class GPTNeoXForCausalLM extends GPTNeoXPreTrainedModel{}class GPTJPreTrainedModel extends PreTrainedModel{constructor(_,_e,tt){super(_,_e),this.generation_config=tt,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class GPTJModel extends GPTJPreTrainedModel{}class GPTJForCausalLM extends GPTJPreTrainedModel{}class GPTBigCodePreTrainedModel extends PreTrainedModel{constructor(_,_e,tt){super(_,_e),this.generation_config=tt,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class GPTBigCodeModel extends GPTBigCodePreTrainedModel{}class GPTBigCodeForCausalLM extends GPTBigCodePreTrainedModel{}class CodeGenPreTrainedModel extends PreTrainedModel{constructor(_,_e,tt){super(_,_e),this.generation_config=tt,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class CodeGenModel extends CodeGenPreTrainedModel{}class CodeGenForCausalLM extends CodeGenPreTrainedModel{}class LlamaPreTrainedModel extends PreTrainedModel{constructor(_,_e,tt){super(_,_e),this.generation_config=tt,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads??this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class LlamaModel extends LlamaPreTrainedModel{}class LlamaForCausalLM extends LlamaPreTrainedModel{}class Qwen2PreTrainedModel extends PreTrainedModel{constructor(_,_e,tt){super(_,_e),this.generation_config=tt,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads??this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class Qwen2Model extends Qwen2PreTrainedModel{}class Qwen2ForCausalLM extends Qwen2PreTrainedModel{}class PhiPreTrainedModel extends PreTrainedModel{constructor(_,_e,tt){super(_,_e),this.generation_config=tt,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class PhiModel extends PhiPreTrainedModel{}class PhiForCausalLM extends PhiPreTrainedModel{}class BloomPreTrainedModel extends PreTrainedModel{constructor(_,_e,tt){super(_,_e),this.generation_config=tt,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.hidden_size/this.num_heads}}class BloomModel extends BloomPreTrainedModel{}class BloomForCausalLM extends BloomPreTrainedModel{}class MptPreTrainedModel extends PreTrainedModel{constructor(_,_e,tt){super(_,_e),this.generation_config=tt,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_heads,this.num_layers=this.config.n_layers,this.dim_kv=this.config.d_model/this.num_heads}}class MptModel extends MptPreTrainedModel{}class MptForCausalLM extends MptPreTrainedModel{}class OPTPreTrainedModel extends PreTrainedModel{constructor(_,_e,tt){super(_,_e),this.generation_config=tt,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class OPTModel extends OPTPreTrainedModel{}class OPTForCausalLM extends OPTPreTrainedModel{}class ViTPreTrainedModel extends PreTrainedModel{}class ViTModel extends ViTPreTrainedModel{}class ViTForImageClassification extends ViTPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class FastViTPreTrainedModel extends PreTrainedModel{}class FastViTModel extends FastViTPreTrainedModel{}class FastViTForImageClassification extends FastViTPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class VitMattePreTrainedModel extends PreTrainedModel{}class VitMatteForImageMatting extends VitMattePreTrainedModel{async _call(_){return new ImageMattingOutput(await super._call(_))}}class MobileViTPreTrainedModel extends PreTrainedModel{}class MobileViTModel extends MobileViTPreTrainedModel{}class MobileViTForImageClassification extends MobileViTPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class MobileViTV2PreTrainedModel extends PreTrainedModel{}class MobileViTV2Model extends MobileViTV2PreTrainedModel{}class MobileViTV2ForImageClassification extends MobileViTV2PreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class OwlViTPreTrainedModel extends PreTrainedModel{}class OwlViTModel extends OwlViTPreTrainedModel{}class OwlViTForObjectDetection extends OwlViTPreTrainedModel{}class Owlv2PreTrainedModel extends PreTrainedModel{}class Owlv2Model extends Owlv2PreTrainedModel{}class Owlv2ForObjectDetection extends Owlv2PreTrainedModel{}class BeitPreTrainedModel extends PreTrainedModel{}class BeitModel extends BeitPreTrainedModel{}class BeitForImageClassification extends BeitPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class DetrPreTrainedModel extends PreTrainedModel{}class DetrModel extends DetrPreTrainedModel{}class DetrForObjectDetection extends DetrPreTrainedModel{async _call(_){return new DetrObjectDetectionOutput(await super._call(_))}}class DetrForSegmentation extends DetrPreTrainedModel{async _call(_){return new DetrSegmentationOutput(await super._call(_))}}class DetrObjectDetectionOutput extends ModelOutput{constructor({logits:_,pred_boxes:_e}){super(),this.logits=_,this.pred_boxes=_e}}class DetrSegmentationOutput extends ModelOutput{constructor({logits:_,pred_boxes:_e,pred_masks:tt}){super(),this.logits=_,this.pred_boxes=_e,this.pred_masks=tt}}class TableTransformerPreTrainedModel extends PreTrainedModel{}class TableTransformerModel extends TableTransformerPreTrainedModel{}class TableTransformerForObjectDetection extends TableTransformerPreTrainedModel{async _call(_){return new TableTransformerObjectDetectionOutput(await super._call(_))}}class TableTransformerObjectDetectionOutput extends DetrObjectDetectionOutput{}class DeiTPreTrainedModel extends PreTrainedModel{}class DeiTModel extends DeiTPreTrainedModel{}class DeiTForImageClassification extends DeiTPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class ResNetPreTrainedModel extends PreTrainedModel{}class ResNetModel extends ResNetPreTrainedModel{}class ResNetForImageClassification extends ResNetPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class SwinPreTrainedModel extends PreTrainedModel{}class SwinModel extends SwinPreTrainedModel{}class SwinForImageClassification extends SwinPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class Swin2SRPreTrainedModel extends PreTrainedModel{}class Swin2SRModel extends Swin2SRPreTrainedModel{}class Swin2SRForImageSuperResolution extends Swin2SRPreTrainedModel{}class DPTPreTrainedModel extends PreTrainedModel{}class DPTModel extends DPTPreTrainedModel{}class DPTForDepthEstimation extends DPTPreTrainedModel{}class DepthAnythingPreTrainedModel extends PreTrainedModel{}class DepthAnythingForDepthEstimation extends DepthAnythingPreTrainedModel{}class GLPNPreTrainedModel extends PreTrainedModel{}class GLPNModel extends GLPNPreTrainedModel{}class GLPNForDepthEstimation extends GLPNPreTrainedModel{}class DonutSwinPreTrainedModel extends PreTrainedModel{}class DonutSwinModel extends DonutSwinPreTrainedModel{}class ConvNextPreTrainedModel extends PreTrainedModel{}class ConvNextModel extends ConvNextPreTrainedModel{}class ConvNextForImageClassification extends ConvNextPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class ConvNextV2PreTrainedModel extends PreTrainedModel{}class ConvNextV2Model extends ConvNextV2PreTrainedModel{}class ConvNextV2ForImageClassification extends ConvNextV2PreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class Dinov2PreTrainedModel extends PreTrainedModel{}class Dinov2Model extends Dinov2PreTrainedModel{}class Dinov2ForImageClassification extends Dinov2PreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class YolosPreTrainedModel extends PreTrainedModel{}class YolosModel extends YolosPreTrainedModel{}class YolosForObjectDetection extends YolosPreTrainedModel{async _call(_){return new YolosObjectDetectionOutput(await super._call(_))}}class YolosObjectDetectionOutput extends ModelOutput{constructor({logits:_,pred_boxes:_e}){super(),this.logits=_,this.pred_boxes=_e}}class SamPreTrainedModel extends PreTrainedModel{}class SamModel extends SamPreTrainedModel{constructor(_,_e,tt){super(_,_e),this.prompt_encoder_mask_decoder=tt}async get_image_embeddings({pixel_values:_}){return await encoderForward(this,{pixel_values:_})}async forward(_){if((!_.image_embeddings||!_.image_positional_embeddings)&&(_={..._,...await this.get_image_embeddings(_)}),!_.input_labels){const _e=_.input_points.dims.slice(0,-1),tt=_e.reduce((nt,rt)=>nt*rt,1);_.input_labels=new Tensor("int64",new BigInt64Array(tt).fill(1n),_e)}return await sessionRun(this.prompt_encoder_mask_decoder,{input_points:_.input_points,input_labels:_.input_labels,image_embeddings:_.image_embeddings,image_positional_embeddings:_.image_positional_embeddings})}async _call(_){return new SamImageSegmentationOutput(await super._call(_))}}class SamImageSegmentationOutput extends ModelOutput{constructor({iou_scores:_,pred_masks:_e}){super(),this.iou_scores=_,this.pred_masks=_e}}class MarianPreTrainedModel extends PreTrainedModel{}class MarianModel extends MarianPreTrainedModel{}class MarianMTModel extends MarianPreTrainedModel{constructor(_,_e,tt,nt){super(_,_e),this.decoder_merged_session=tt,this.generation_config=nt,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class M2M100PreTrainedModel extends PreTrainedModel{}class M2M100Model extends M2M100PreTrainedModel{}class M2M100ForConditionalGeneration extends M2M100PreTrainedModel{constructor(_,_e,tt,nt){super(_,_e),this.decoder_merged_session=tt,this.generation_config=nt,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class Wav2Vec2PreTrainedModel extends PreTrainedModel{}class Wav2Vec2Model extends Wav2Vec2PreTrainedModel{}class Wav2Vec2ForCTC extends Wav2Vec2PreTrainedModel{async _call(_){return new CausalLMOutput(await super._call(_))}}class Wav2Vec2ForSequenceClassification extends Wav2Vec2PreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class Wav2Vec2ForAudioFrameClassification extends Wav2Vec2PreTrainedModel{async _call(_){return new TokenClassifierOutput(await super._call(_))}}class UniSpeechPreTrainedModel extends PreTrainedModel{}class UniSpeechModel extends UniSpeechPreTrainedModel{}class UniSpeechForCTC extends UniSpeechPreTrainedModel{async _call(_){return new CausalLMOutput(await super._call(_))}}class UniSpeechForSequenceClassification extends UniSpeechPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class UniSpeechSatPreTrainedModel extends PreTrainedModel{}class UniSpeechSatModel extends UniSpeechSatPreTrainedModel{}class UniSpeechSatForCTC extends UniSpeechSatPreTrainedModel{async _call(_){return new CausalLMOutput(await super._call(_))}}class UniSpeechSatForSequenceClassification extends UniSpeechSatPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class UniSpeechSatForAudioFrameClassification extends UniSpeechSatPreTrainedModel{async _call(_){return new TokenClassifierOutput(await super._call(_))}}class Wav2Vec2BertPreTrainedModel extends PreTrainedModel{}class Wav2Vec2BertModel extends Wav2Vec2BertPreTrainedModel{}class Wav2Vec2BertForCTC extends Wav2Vec2BertPreTrainedModel{async _call(_){return new CausalLMOutput(await super._call(_))}}class Wav2Vec2BertForSequenceClassification extends Wav2Vec2BertPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class HubertModel extends Wav2Vec2PreTrainedModel{}class HubertForCTC extends Wav2Vec2PreTrainedModel{async _call(_){return new CausalLMOutput(await super._call(_))}}class HubertForSequenceClassification extends Wav2Vec2PreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class WavLMPreTrainedModel extends PreTrainedModel{}class WavLMModel extends WavLMPreTrainedModel{}class WavLMForCTC extends WavLMPreTrainedModel{async _call(_){return new CausalLMOutput(await super._call(_))}}class WavLMForSequenceClassification extends WavLMPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class WavLMForXVector extends WavLMPreTrainedModel{async _call(_){return new XVectorOutput(await super._call(_))}}class WavLMForAudioFrameClassification extends WavLMPreTrainedModel{async _call(_){return new TokenClassifierOutput(await super._call(_))}}class SpeechT5PreTrainedModel extends PreTrainedModel{}class SpeechT5ForSpeechToText extends SpeechT5PreTrainedModel{}class SpeechT5ForTextToSpeech extends SpeechT5PreTrainedModel{constructor(_,_e,tt,nt){super(_,_e),this.decoder_merged_session=tt,this.generation_config=nt,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.hidden_size/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.hidden_size/this.num_encoder_heads}async generate_speech(_,_e,{threshold:tt=.5,minlenratio:nt=0,maxlenratio:rt=20,vocoder:ot=null}={}){const at={input_ids:_},{encoder_outputs:lt,encoder_attention_mask:ut}=await encoderForward(this,at),dt=lt.dims[1]/this.config.reduction_factor,st=Math.floor(dt*rt),it=Math.floor(dt*nt),ct=this.config.num_mel_bins;let ft=[],ht=null,mt=null,pt=0;for(;;){++pt;const bt=boolTensor(!!mt);let wt;mt?wt=mt.output_sequence_out:wt=new Tensor("float32",new Float32Array(ct),[1,1,ct]);let xt={use_cache_branch:bt,output_sequence:wt,encoder_attention_mask:ut,speaker_embeddings:_e,encoder_hidden_states:lt};this.addPastKeyValues(xt,ht),mt=await sessionRun(this.decoder_merged_session,xt),ht=this.getPastKeyValues(mt,ht);const{prob:Mt,spectrum:At}=mt;if(ft.push(At),pt>=it&&(Array.from(Mt.data).filter(St=>St>=tt).length>0||pt>=st))break}const _t=cat(ft),{waveform:vt}=await sessionRun(ot.session,{spectrogram:_t});return{spectrogram:_t,waveform:vt}}}class SpeechT5HifiGan extends PreTrainedModel{constructor(){super(...arguments);jn(this,"main_input_name","spectrogram")}}class TrOCRPreTrainedModel extends PreTrainedModel{constructor(_,_e,tt){super(_,_e),this.generation_config=tt,this.config.pad_token_id=this.config.eos_token_id,this.num_encoder_layers=this.num_decoder_layers=this.config.decoder_layers,this.num_encoder_heads=this.num_decoder_heads=this.config.decoder_attention_heads,this.encoder_dim_kv=this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads}}class TrOCRForCausalLM extends TrOCRPreTrainedModel{}class MistralPreTrainedModel extends PreTrainedModel{constructor(_,_e,tt){super(_,_e),this.generation_config=tt,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class MistralModel extends MistralPreTrainedModel{}class MistralForCausalLM extends MistralPreTrainedModel{}class Starcoder2PreTrainedModel extends PreTrainedModel{constructor(_,_e,tt){super(_,_e),this.generation_config=tt,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class Starcoder2Model extends Starcoder2PreTrainedModel{}class Starcoder2ForCausalLM extends Starcoder2PreTrainedModel{}class FalconPreTrainedModel extends PreTrainedModel{constructor(_,_e,tt){super(_,_e),this.generation_config=tt,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class FalconModel extends FalconPreTrainedModel{}class FalconForCausalLM extends FalconPreTrainedModel{}class ClapPreTrainedModel extends PreTrainedModel{}class ClapModel extends ClapPreTrainedModel{}class ClapTextModelWithProjection extends ClapPreTrainedModel{static async from_pretrained(_,_e={}){return _e.model_file_name??(_e.model_file_name="text_model"),super.from_pretrained(_,_e)}}class ClapAudioModelWithProjection extends ClapPreTrainedModel{static async from_pretrained(_,_e={}){return _e.model_file_name??(_e.model_file_name="audio_model"),super.from_pretrained(_,_e)}}class VitsPreTrainedModel extends PreTrainedModel{}class VitsModel extends VitsPreTrainedModel{async _call(_){return new VitsModelOutput(await super._call(_))}}class SegformerPreTrainedModel extends PreTrainedModel{}class SegformerForImageClassification extends SegformerPreTrainedModel{}class SegformerForSemanticSegmentation extends SegformerPreTrainedModel{}class StableLmPreTrainedModel extends PreTrainedModel{constructor(_,_e,tt){super(_,_e),this.generation_config=tt,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class StableLmForCausalLM extends StableLmPreTrainedModel{}class EfficientNetPreTrainedModel extends PreTrainedModel{}class EfficientNetModel extends EfficientNetPreTrainedModel{}class EfficientNetForImageClassification extends EfficientNetPreTrainedModel{async _call(_){return new SequenceClassifierOutput(await super._call(_))}}class PretrainedMixin{static async from_pretrained(_,{quantized:_e=!0,progress_callback:tt=null,config:nt=null,cache_dir:rt=null,local_files_only:ot=!1,revision:at="main",model_file_name:lt=null}={}){let ut={quantized:_e,progress_callback:tt,config:nt,cache_dir:rt,local_files_only:ot,revision:at,model_file_name:lt};if(nt=await AutoConfig.from_pretrained(_,ut),ut.config||(ut.config=nt),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);for(let dt of this.MODEL_CLASS_MAPPINGS){const st=dt.get(nt.model_type);if(st)return await st[1].from_pretrained(_,ut)}if(this.BASE_IF_FAIL)return console.warn(`Unknown model class "${nt.model_type}", attempting to construct from base class.`),await PreTrainedModel.from_pretrained(_,ut);throw Error(`Unsupported model type: ${nt.model_type}`)}}jn(PretrainedMixin,"MODEL_CLASS_MAPPINGS",null),jn(PretrainedMixin,"BASE_IF_FAIL",!1);const MODEL_MAPPING_NAMES_ENCODER_ONLY=new Map([["bert",["BertModel",BertModel]],["nomic_bert",["NomicBertModel",NomicBertModel]],["roformer",["RoFormerModel",RoFormerModel]],["electra",["ElectraModel",ElectraModel]],["esm",["EsmModel",EsmModel]],["convbert",["ConvBertModel",ConvBertModel]],["camembert",["CamembertModel",CamembertModel]],["deberta",["DebertaModel",DebertaModel]],["deberta-v2",["DebertaV2Model",DebertaV2Model]],["mpnet",["MPNetModel",MPNetModel]],["albert",["AlbertModel",AlbertModel]],["distilbert",["DistilBertModel",DistilBertModel]],["roberta",["RobertaModel",RobertaModel]],["xlm",["XLMModel",XLMModel]],["xlm-roberta",["XLMRobertaModel",XLMRobertaModel]],["clap",["ClapModel",ClapModel]],["clip",["CLIPModel",CLIPModel]],["clipseg",["CLIPSegModel",CLIPSegModel]],["chinese_clip",["ChineseCLIPModel",ChineseCLIPModel]],["siglip",["SiglipModel",SiglipModel]],["mobilebert",["MobileBertModel",MobileBertModel]],["squeezebert",["SqueezeBertModel",SqueezeBertModel]],["wav2vec2",["Wav2Vec2Model",Wav2Vec2Model]],["wav2vec2-bert",["Wav2Vec2BertModel",Wav2Vec2BertModel]],["unispeech",["UniSpeechModel",UniSpeechModel]],["unispeech-sat",["UniSpeechSatModel",UniSpeechSatModel]],["hubert",["HubertModel",HubertModel]],["wavlm",["WavLMModel",WavLMModel]],["audio-spectrogram-transformer",["ASTModel",ASTModel]],["vits",["VitsModel",VitsModel]],["detr",["DetrModel",DetrModel]],["table-transformer",["TableTransformerModel",TableTransformerModel]],["vit",["ViTModel",ViTModel]],["fastvit",["FastViTModel",FastViTModel]],["mobilevit",["MobileViTModel",MobileViTModel]],["mobilevitv2",["MobileViTV2Model",MobileViTV2Model]],["owlvit",["OwlViTModel",OwlViTModel]],["owlv2",["Owlv2Model",Owlv2Model]],["beit",["BeitModel",BeitModel]],["deit",["DeiTModel",DeiTModel]],["convnext",["ConvNextModel",ConvNextModel]],["convnextv2",["ConvNextV2Model",ConvNextV2Model]],["dinov2",["Dinov2Model",Dinov2Model]],["resnet",["ResNetModel",ResNetModel]],["swin",["SwinModel",SwinModel]],["swin2sr",["Swin2SRModel",Swin2SRModel]],["donut-swin",["DonutSwinModel",DonutSwinModel]],["yolos",["YolosModel",YolosModel]],["dpt",["DPTModel",DPTModel]],["glpn",["GLPNModel",GLPNModel]],["hifigan",["SpeechT5HifiGan",SpeechT5HifiGan]],["efficientnet",["EfficientNetModel",EfficientNetModel]]]),MODEL_MAPPING_NAMES_ENCODER_DECODER=new Map([["t5",["T5Model",T5Model]],["longt5",["LongT5Model",LongT5Model]],["mt5",["MT5Model",MT5Model]],["bart",["BartModel",BartModel]],["mbart",["MBartModel",MBartModel]],["marian",["MarianModel",MarianModel]],["whisper",["WhisperModel",WhisperModel]],["m2m_100",["M2M100Model",M2M100Model]],["blenderbot",["BlenderbotModel",BlenderbotModel]],["blenderbot-small",["BlenderbotSmallModel",BlenderbotSmallModel]]]),MODEL_MAPPING_NAMES_DECODER_ONLY=new Map([["bloom",["BloomModel",BloomModel]],["gpt2",["GPT2Model",GPT2Model]],["gptj",["GPTJModel",GPTJModel]],["gpt_bigcode",["GPTBigCodeModel",GPTBigCodeModel]],["gpt_neo",["GPTNeoModel",GPTNeoModel]],["gpt_neox",["GPTNeoXModel",GPTNeoXModel]],["codegen",["CodeGenModel",CodeGenModel]],["llama",["LlamaModel",LlamaModel]],["qwen2",["Qwen2Model",Qwen2Model]],["phi",["PhiModel",PhiModel]],["mpt",["MptModel",MptModel]],["opt",["OPTModel",OPTModel]],["mistral",["MistralModel",MistralModel]],["starcoder2",["Starcoder2Model",Starcoder2Model]],["falcon",["FalconModel",FalconModel]]]),MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES=new Map([["speecht5",["SpeechT5ForSpeechToText",SpeechT5ForSpeechToText]],["whisper",["WhisperForConditionalGeneration",WhisperForConditionalGeneration]]]),MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES=new Map([["speecht5",["SpeechT5ForTextToSpeech",SpeechT5ForTextToSpeech]]]),MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES=new Map([["vits",["VitsModel",VitsModel]]]),MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES=new Map([["bert",["BertForSequenceClassification",BertForSequenceClassification]],["roformer",["RoFormerForSequenceClassification",RoFormerForSequenceClassification]],["electra",["ElectraForSequenceClassification",ElectraForSequenceClassification]],["esm",["EsmForSequenceClassification",EsmForSequenceClassification]],["convbert",["ConvBertForSequenceClassification",ConvBertForSequenceClassification]],["camembert",["CamembertForSequenceClassification",CamembertForSequenceClassification]],["deberta",["DebertaForSequenceClassification",DebertaForSequenceClassification]],["deberta-v2",["DebertaV2ForSequenceClassification",DebertaV2ForSequenceClassification]],["mpnet",["MPNetForSequenceClassification",MPNetForSequenceClassification]],["albert",["AlbertForSequenceClassification",AlbertForSequenceClassification]],["distilbert",["DistilBertForSequenceClassification",DistilBertForSequenceClassification]],["roberta",["RobertaForSequenceClassification",RobertaForSequenceClassification]],["xlm",["XLMForSequenceClassification",XLMForSequenceClassification]],["xlm-roberta",["XLMRobertaForSequenceClassification",XLMRobertaForSequenceClassification]],["bart",["BartForSequenceClassification",BartForSequenceClassification]],["mbart",["MBartForSequenceClassification",MBartForSequenceClassification]],["mobilebert",["MobileBertForSequenceClassification",MobileBertForSequenceClassification]],["squeezebert",["SqueezeBertForSequenceClassification",SqueezeBertForSequenceClassification]]]),MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES=new Map([["bert",["BertForTokenClassification",BertForTokenClassification]],["roformer",["RoFormerForTokenClassification",RoFormerForTokenClassification]],["electra",["ElectraForTokenClassification",ElectraForTokenClassification]],["esm",["EsmForTokenClassification",EsmForTokenClassification]],["convbert",["ConvBertForTokenClassification",ConvBertForTokenClassification]],["camembert",["CamembertForTokenClassification",CamembertForTokenClassification]],["deberta",["DebertaForTokenClassification",DebertaForTokenClassification]],["deberta-v2",["DebertaV2ForTokenClassification",DebertaV2ForTokenClassification]],["mpnet",["MPNetForTokenClassification",MPNetForTokenClassification]],["distilbert",["DistilBertForTokenClassification",DistilBertForTokenClassification]],["roberta",["RobertaForTokenClassification",RobertaForTokenClassification]],["xlm",["XLMForTokenClassification",XLMForTokenClassification]],["xlm-roberta",["XLMRobertaForTokenClassification",XLMRobertaForTokenClassification]]]),MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES=new Map([["t5",["T5ForConditionalGeneration",T5ForConditionalGeneration]],["longt5",["LongT5ForConditionalGeneration",LongT5ForConditionalGeneration]],["mt5",["MT5ForConditionalGeneration",MT5ForConditionalGeneration]],["bart",["BartForConditionalGeneration",BartForConditionalGeneration]],["mbart",["MBartForConditionalGeneration",MBartForConditionalGeneration]],["marian",["MarianMTModel",MarianMTModel]],["m2m_100",["M2M100ForConditionalGeneration",M2M100ForConditionalGeneration]],["blenderbot",["BlenderbotForConditionalGeneration",BlenderbotForConditionalGeneration]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",BlenderbotSmallForConditionalGeneration]]]),MODEL_WITH_LM_HEAD_MAPPING_NAMES=new Map([["bloom",["BloomForCausalLM",BloomForCausalLM]],["gpt2",["GPT2LMHeadModel",GPT2LMHeadModel]],["gptj",["GPTJForCausalLM",GPTJForCausalLM]],["gpt_bigcode",["GPTBigCodeForCausalLM",GPTBigCodeForCausalLM]],["gpt_neo",["GPTNeoForCausalLM",GPTNeoForCausalLM]],["gpt_neox",["GPTNeoXForCausalLM",GPTNeoXForCausalLM]],["codegen",["CodeGenForCausalLM",CodeGenForCausalLM]],["llama",["LlamaForCausalLM",LlamaForCausalLM]],["qwen2",["Qwen2ForCausalLM",Qwen2ForCausalLM]],["phi",["PhiForCausalLM",PhiForCausalLM]],["mpt",["MptForCausalLM",MptForCausalLM]],["opt",["OPTForCausalLM",OPTForCausalLM]],["mbart",["MBartForCausalLM",MBartForCausalLM]],["mistral",["MistralForCausalLM",MistralForCausalLM]],["starcoder2",["Starcoder2ForCausalLM",Starcoder2ForCausalLM]],["falcon",["FalconForCausalLM",FalconForCausalLM]],["trocr",["TrOCRForCausalLM",TrOCRForCausalLM]],["stablelm",["StableLmForCausalLM",StableLmForCausalLM]]]),MODEL_FOR_MASKED_LM_MAPPING_NAMES=new Map([["bert",["BertForMaskedLM",BertForMaskedLM]],["roformer",["RoFormerForMaskedLM",RoFormerForMaskedLM]],["electra",["ElectraForMaskedLM",ElectraForMaskedLM]],["esm",["EsmForMaskedLM",EsmForMaskedLM]],["convbert",["ConvBertForMaskedLM",ConvBertForMaskedLM]],["camembert",["CamembertForMaskedLM",CamembertForMaskedLM]],["deberta",["DebertaForMaskedLM",DebertaForMaskedLM]],["deberta-v2",["DebertaV2ForMaskedLM",DebertaV2ForMaskedLM]],["mpnet",["MPNetForMaskedLM",MPNetForMaskedLM]],["albert",["AlbertForMaskedLM",AlbertForMaskedLM]],["distilbert",["DistilBertForMaskedLM",DistilBertForMaskedLM]],["roberta",["RobertaForMaskedLM",RobertaForMaskedLM]],["xlm",["XLMWithLMHeadModel",XLMWithLMHeadModel]],["xlm-roberta",["XLMRobertaForMaskedLM",XLMRobertaForMaskedLM]],["mobilebert",["MobileBertForMaskedLM",MobileBertForMaskedLM]],["squeezebert",["SqueezeBertForMaskedLM",SqueezeBertForMaskedLM]]]),MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES=new Map([["bert",["BertForQuestionAnswering",BertForQuestionAnswering]],["roformer",["RoFormerForQuestionAnswering",RoFormerForQuestionAnswering]],["electra",["ElectraForQuestionAnswering",ElectraForQuestionAnswering]],["convbert",["ConvBertForQuestionAnswering",ConvBertForQuestionAnswering]],["camembert",["CamembertForQuestionAnswering",CamembertForQuestionAnswering]],["deberta",["DebertaForQuestionAnswering",DebertaForQuestionAnswering]],["deberta-v2",["DebertaV2ForQuestionAnswering",DebertaV2ForQuestionAnswering]],["mpnet",["MPNetForQuestionAnswering",MPNetForQuestionAnswering]],["albert",["AlbertForQuestionAnswering",AlbertForQuestionAnswering]],["distilbert",["DistilBertForQuestionAnswering",DistilBertForQuestionAnswering]],["roberta",["RobertaForQuestionAnswering",RobertaForQuestionAnswering]],["xlm",["XLMForQuestionAnswering",XLMForQuestionAnswering]],["xlm-roberta",["XLMRobertaForQuestionAnswering",XLMRobertaForQuestionAnswering]],["mobilebert",["MobileBertForQuestionAnswering",MobileBertForQuestionAnswering]],["squeezebert",["SqueezeBertForQuestionAnswering",SqueezeBertForQuestionAnswering]]]),MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",VisionEncoderDecoderModel]]]),MODEL_FOR_DOCUMENT_QUESTION_ANSWERING_MAPPING_NAMES=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",VisionEncoderDecoderModel]]]),MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES=new Map([["vit",["ViTForImageClassification",ViTForImageClassification]],["fastvit",["FastViTForImageClassification",FastViTForImageClassification]],["mobilevit",["MobileViTForImageClassification",MobileViTForImageClassification]],["mobilevitv2",["MobileViTV2ForImageClassification",MobileViTV2ForImageClassification]],["beit",["BeitForImageClassification",BeitForImageClassification]],["deit",["DeiTForImageClassification",DeiTForImageClassification]],["convnext",["ConvNextForImageClassification",ConvNextForImageClassification]],["convnextv2",["ConvNextV2ForImageClassification",ConvNextV2ForImageClassification]],["dinov2",["Dinov2ForImageClassification",Dinov2ForImageClassification]],["resnet",["ResNetForImageClassification",ResNetForImageClassification]],["swin",["SwinForImageClassification",SwinForImageClassification]],["segformer",["SegformerForImageClassification",SegformerForImageClassification]],["efficientnet",["EfficientNetForImageClassification",EfficientNetForImageClassification]]]),MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES=new Map([["detr",["DetrForObjectDetection",DetrForObjectDetection]],["table-transformer",["TableTransformerForObjectDetection",TableTransformerForObjectDetection]],["yolos",["YolosForObjectDetection",YolosForObjectDetection]]]),MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES=new Map([["owlvit",["OwlViTForObjectDetection",OwlViTForObjectDetection]],["owlv2",["Owlv2ForObjectDetection",Owlv2ForObjectDetection]]]),MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES=new Map([["detr",["DetrForSegmentation",DetrForSegmentation]],["clipseg",["CLIPSegForImageSegmentation",CLIPSegForImageSegmentation]]]),MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES=new Map([["segformer",["SegformerForSemanticSegmentation",SegformerForSemanticSegmentation]]]),MODEL_FOR_MASK_GENERATION_MAPPING_NAMES=new Map([["sam",["SamModel",SamModel]]]),MODEL_FOR_CTC_MAPPING_NAMES=new Map([["wav2vec2",["Wav2Vec2ForCTC",Wav2Vec2ForCTC]],["wav2vec2-bert",["Wav2Vec2BertForCTC",Wav2Vec2BertForCTC]],["unispeech",["UniSpeechForCTC",UniSpeechForCTC]],["unispeech-sat",["UniSpeechSatForCTC",UniSpeechSatForCTC]],["wavlm",["WavLMForCTC",WavLMForCTC]],["hubert",["HubertForCTC",HubertForCTC]]]),MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",Wav2Vec2ForSequenceClassification]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",Wav2Vec2BertForSequenceClassification]],["unispeech",["UniSpeechForSequenceClassification",UniSpeechForSequenceClassification]],["unispeech-sat",["UniSpeechSatForSequenceClassification",UniSpeechSatForSequenceClassification]],["wavlm",["WavLMForSequenceClassification",WavLMForSequenceClassification]],["hubert",["HubertForSequenceClassification",HubertForSequenceClassification]],["audio-spectrogram-transformer",["ASTForAudioClassification",ASTForAudioClassification]]]),MODEL_FOR_AUDIO_XVECTOR_MAPPING_NAMES=new Map([["wavlm",["WavLMForXVector",WavLMForXVector]]]),MODEL_FOR_AUDIO_FRAME_CLASSIFICATION_MAPPING_NAMES=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",UniSpeechSatForAudioFrameClassification]],["wavlm",["WavLMForAudioFrameClassification",WavLMForAudioFrameClassification]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",Wav2Vec2ForAudioFrameClassification]]]),MODEL_FOR_IMAGE_MATTING_MAPPING_NAMES=new Map([["vitmatte",["VitMatteForImageMatting",VitMatteForImageMatting]]]),MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES=new Map([["swin2sr",["Swin2SRForImageSuperResolution",Swin2SRForImageSuperResolution]]]),MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES=new Map([["dpt",["DPTForDepthEstimation",DPTForDepthEstimation]],["depth_anything",["DepthAnythingForDepthEstimation",DepthAnythingForDepthEstimation]],["glpn",["GLPNForDepthEstimation",GLPNForDepthEstimation]]]),MODEL_FOR_IMAGE_FEATURE_EXTRACTION_MAPPING_NAMES=new Map([["clip",["CLIPVisionModelWithProjection",CLIPVisionModelWithProjection]],["siglip",["SiglipVisionModel",SiglipVisionModel]]]),MODEL_CLASS_TYPE_MAPPING=[[MODEL_MAPPING_NAMES_ENCODER_ONLY,MODEL_TYPES.EncoderOnly],[MODEL_MAPPING_NAMES_ENCODER_DECODER,MODEL_TYPES.EncoderDecoder],[MODEL_MAPPING_NAMES_DECODER_ONLY,MODEL_TYPES.DecoderOnly],[MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES,MODEL_TYPES.Seq2Seq],[MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES,MODEL_TYPES.Seq2Seq],[MODEL_WITH_LM_HEAD_MAPPING_NAMES,MODEL_TYPES.DecoderOnly],[MODEL_FOR_MASKED_LM_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES,MODEL_TYPES.Vision2Seq],[MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_MATTING_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_MASK_GENERATION_MAPPING_NAMES,MODEL_TYPES.MaskGeneration],[MODEL_FOR_CTC_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES,MODEL_TYPES.Seq2Seq],[MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_AUDIO_XVECTOR_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_AUDIO_FRAME_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_FEATURE_EXTRACTION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly]];for(const[et,_]of MODEL_CLASS_TYPE_MAPPING)for(const[_e,tt]of et.values())MODEL_TYPE_MAPPING.set(_e,_),MODEL_CLASS_TO_NAME_MAPPING.set(tt,_e),MODEL_NAME_TO_CLASS_MAPPING.set(_e,tt);const CUSTOM_MAPPING=[["CLIPTextModelWithProjection",CLIPTextModelWithProjection,MODEL_TYPES.EncoderOnly],["SiglipTextModel",SiglipTextModel,MODEL_TYPES.EncoderOnly],["ClapTextModelWithProjection",ClapTextModelWithProjection,MODEL_TYPES.EncoderOnly],["ClapAudioModelWithProjection",ClapAudioModelWithProjection,MODEL_TYPES.EncoderOnly]];for(const[et,_,_e]of CUSTOM_MAPPING)MODEL_TYPE_MAPPING.set(et,_e),MODEL_CLASS_TO_NAME_MAPPING.set(_,et),MODEL_NAME_TO_CLASS_MAPPING.set(et,_);class AutoModel extends PretrainedMixin{}jn(AutoModel,"MODEL_CLASS_MAPPINGS",MODEL_CLASS_TYPE_MAPPING.map(_=>_[0])),jn(AutoModel,"BASE_IF_FAIL",!0);class AutoModelForSequenceClassification extends PretrainedMixin{}jn(AutoModelForSequenceClassification,"MODEL_CLASS_MAPPINGS",[MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES]);class AutoModelForTokenClassification extends PretrainedMixin{}jn(AutoModelForTokenClassification,"MODEL_CLASS_MAPPINGS",[MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES]);class AutoModelForSeq2SeqLM extends PretrainedMixin{}jn(AutoModelForSeq2SeqLM,"MODEL_CLASS_MAPPINGS",[MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES]);class AutoModelForSpeechSeq2Seq extends PretrainedMixin{}jn(AutoModelForSpeechSeq2Seq,"MODEL_CLASS_MAPPINGS",[MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES]);class AutoModelForTextToSpectrogram extends PretrainedMixin{}jn(AutoModelForTextToSpectrogram,"MODEL_CLASS_MAPPINGS",[MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES]);class AutoModelForTextToWaveform extends PretrainedMixin{}jn(AutoModelForTextToWaveform,"MODEL_CLASS_MAPPINGS",[MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES]);class AutoModelForCausalLM extends PretrainedMixin{}jn(AutoModelForCausalLM,"MODEL_CLASS_MAPPINGS",[MODEL_WITH_LM_HEAD_MAPPING_NAMES]);class AutoModelForMaskedLM extends PretrainedMixin{}jn(AutoModelForMaskedLM,"MODEL_CLASS_MAPPINGS",[MODEL_FOR_MASKED_LM_MAPPING_NAMES]);class AutoModelForQuestionAnswering extends PretrainedMixin{}jn(AutoModelForQuestionAnswering,"MODEL_CLASS_MAPPINGS",[MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES]);class AutoModelForVision2Seq extends PretrainedMixin{}jn(AutoModelForVision2Seq,"MODEL_CLASS_MAPPINGS",[MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES]);class AutoModelForImageClassification extends PretrainedMixin{}jn(AutoModelForImageClassification,"MODEL_CLASS_MAPPINGS",[MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES]);class AutoModelForImageSegmentation extends PretrainedMixin{}jn(AutoModelForImageSegmentation,"MODEL_CLASS_MAPPINGS",[MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES]);class AutoModelForSemanticSegmentation extends PretrainedMixin{}jn(AutoModelForSemanticSegmentation,"MODEL_CLASS_MAPPINGS",[MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES]);class AutoModelForObjectDetection extends PretrainedMixin{}jn(AutoModelForObjectDetection,"MODEL_CLASS_MAPPINGS",[MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES]);class AutoModelForZeroShotObjectDetection extends PretrainedMixin{}jn(AutoModelForZeroShotObjectDetection,"MODEL_CLASS_MAPPINGS",[MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES]);class AutoModelForCTC extends PretrainedMixin{}jn(AutoModelForCTC,"MODEL_CLASS_MAPPINGS",[MODEL_FOR_CTC_MAPPING_NAMES]);class AutoModelForAudioClassification extends PretrainedMixin{}jn(AutoModelForAudioClassification,"MODEL_CLASS_MAPPINGS",[MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES]);class AutoModelForDocumentQuestionAnswering extends PretrainedMixin{}jn(AutoModelForDocumentQuestionAnswering,"MODEL_CLASS_MAPPINGS",[MODEL_FOR_DOCUMENT_QUESTION_ANSWERING_MAPPING_NAMES]);class AutoModelForImageToImage extends PretrainedMixin{}jn(AutoModelForImageToImage,"MODEL_CLASS_MAPPINGS",[MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES]);class AutoModelForDepthEstimation extends PretrainedMixin{}jn(AutoModelForDepthEstimation,"MODEL_CLASS_MAPPINGS",[MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES]);class AutoModelForImageFeatureExtraction extends PretrainedMixin{}jn(AutoModelForImageFeatureExtraction,"MODEL_CLASS_MAPPINGS",[MODEL_FOR_IMAGE_FEATURE_EXTRACTION_MAPPING_NAMES]);class Seq2SeqLMOutput extends ModelOutput{constructor({logits:_,past_key_values:_e,encoder_outputs:tt,decoder_attentions:nt=null,cross_attentions:rt=null}){super(),this.logits=_,this.past_key_values=_e,this.encoder_outputs=tt,this.decoder_attentions=nt,this.cross_attentions=rt}}class SequenceClassifierOutput extends ModelOutput{constructor({logits:_}){super(),this.logits=_}}class XVectorOutput extends ModelOutput{constructor({logits:_,embeddings:_e}){super(),this.logits=_,this.embeddings=_e}}class TokenClassifierOutput extends ModelOutput{constructor({logits:_}){super(),this.logits=_}}class MaskedLMOutput extends ModelOutput{constructor({logits:_}){super(),this.logits=_}}class QuestionAnsweringModelOutput extends ModelOutput{constructor({start_logits:_,end_logits:_e}){super(),this.start_logits=_,this.end_logits=_e}}class CausalLMOutput extends ModelOutput{constructor({logits:_}){super(),this.logits=_}}class ImageMattingOutput extends ModelOutput{constructor({alphas:_}){super(),this.alphas=_}}class VitsModelOutput extends ModelOutput{constructor({waveform:_,spectrogram:_e}){super(),this.waveform=_,this.spectrogram=_e}}const BROWSER_ENV=typeof self<"u",WEBWORKER_ENV=BROWSER_ENV&&self.constructor.name==="DedicatedWorkerGlobalScope";let createCanvasFunction,ImageDataClass,loadImageFunction;if(BROWSER_ENV)createCanvasFunction=(et,_)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(et,_)},loadImageFunction=self.createImageBitmap,ImageDataClass=self.ImageData;else if(sharp)loadImageFunction=async et=>{const _e=(await et.metadata()).channels;let{data:tt,info:nt}=await et.rotate().raw().toBuffer({resolveWithObject:!0});const rt=new RawImage(new Uint8ClampedArray(tt),nt.width,nt.height,nt.channels);return _e!==void 0&&_e!==nt.channels&&rt.convert(_e),rt};else throw new Error("Unable to load image processing library.");const RESAMPLING_MAPPING={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},CONTENT_TYPE_MAP=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class RawImage{constructor(_,_e,tt,nt){this.data=_,this.width=_e,this.height=tt,this.channels=nt}get size(){return[this.width,this.height]}static async read(_){if(_ instanceof RawImage)return _;if(typeof _=="string"||_ instanceof URL)return await this.fromURL(_);throw new Error(`Unsupported input type: ${typeof _}`)}static async fromURL(_){let _e=await getFile(_);if(_e.status!==200)throw new Error(`Unable to read image from "${_}" (${_e.status} ${_e.statusText})`);let tt=await _e.blob();return this.fromBlob(tt)}static async fromBlob(_){if(BROWSER_ENV){let _e=await loadImageFunction(_);const tt=createCanvasFunction(_e.width,_e.height).getContext("2d");return tt.drawImage(_e,0,0),new this(tt.getImageData(0,0,_e.width,_e.height).data,_e.width,_e.height,4)}else{let _e=sharp(await _.arrayBuffer());return await loadImageFunction(_e)}}static fromTensor(_,_e="CHW"){if(_.dims.length!==3)throw new Error(`Tensor should have 3 dimensions, but has ${_.dims.length} dimensions.`);if(_e==="CHW")_=_.transpose(1,2,0);else if(_e!=="HWC")throw new Error(`Unsupported channel format: ${_e}`);if(!(_.data instanceof Uint8ClampedArray||_.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${_.type}`);switch(_.dims[2]){case 1:case 2:case 3:case 4:return new RawImage(_.data,_.dims[1],_.dims[0],_.dims[2]);default:throw new Error(`Unsupported number of channels: ${_.dims[2]}`)}}grayscale(){if(this.channels===1)return this;let _=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let _e=0,tt=0;_e<this.data.length;_e+=this.channels){const nt=this.data[_e],rt=this.data[_e+1],ot=this.data[_e+2];_[tt++]=Math.round(.2989*nt+.587*rt+.114*ot)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(_,this.width,this.height,1)}rgb(){if(this.channels===3)return this;let _=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let _e=0,tt=0;_e<this.data.length;++_e)_[tt++]=this.data[_e],_[tt++]=this.data[_e],_[tt++]=this.data[_e];break;case 4:for(let _e=0,tt=0;_e<this.data.length;_e+=4)_[tt++]=this.data[_e],_[tt++]=this.data[_e+1],_[tt++]=this.data[_e+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(_,this.width,this.height,3)}rgba(){if(this.channels===4)return this;let _=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let _e=0,tt=0;_e<this.data.length;++_e)_[tt++]=this.data[_e],_[tt++]=this.data[_e],_[tt++]=this.data[_e],_[tt++]=255;break;case 3:for(let _e=0,tt=0;_e<this.data.length;_e+=3)_[tt++]=this.data[_e],_[tt++]=this.data[_e+1],_[tt++]=this.data[_e+2],_[tt++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(_,this.width,this.height,4)}async resize(_,_e,{resample:tt=2}={}){let nt=RESAMPLING_MAPPING[tt]??tt;if(BROWSER_ENV){let rt=this.channels,ot=this.toCanvas();const at=createCanvasFunction(_,_e).getContext("2d");return at.drawImage(ot,0,0,_,_e),new RawImage(at.getImageData(0,0,_,_e).data,_,_e,4).convert(rt)}else{let rt=this.toSharp();switch(nt){case"box":case"hamming":(nt==="box"||nt==="hamming")&&(console.warn(`Resampling method ${nt} is not yet supported. Using bilinear instead.`),nt="bilinear");case"nearest":case"bilinear":case"bicubic":rt=rt.affine([_/this.width,0,0,_e/this.height],{interpolator:nt});break;case"lanczos":rt=rt.resize({width:_,height:_e,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${nt} is not supported.`)}return await loadImageFunction(rt)}}async pad([_,_e,tt,nt]){if(_=Math.max(_,0),_e=Math.max(_e,0),tt=Math.max(tt,0),nt=Math.max(nt,0),_===0&&_e===0&&tt===0&&nt===0)return this;if(BROWSER_ENV){let rt=this.channels,ot=this.toCanvas(),at=this.width+_+_e,lt=this.height+tt+nt;const ut=createCanvasFunction(at,lt).getContext("2d");return ut.drawImage(ot,0,0,this.width,this.height,_,tt,at,lt),new RawImage(ut.getImageData(0,0,at,lt).data,at,lt,4).convert(rt)}else{let rt=this.toSharp().extend({left:_,right:_e,top:tt,bottom:nt});return await loadImageFunction(rt)}}async crop([_,_e,tt,nt]){if(_=Math.max(_,0),_e=Math.max(_e,0),tt=Math.min(tt,this.width-1),nt=Math.min(nt,this.height-1),_===0&&_e===0&&tt===this.width-1&&nt===this.height-1)return this;const rt=tt-_+1,ot=nt-_e+1;if(BROWSER_ENV){const at=this.channels,lt=this.toCanvas(),ut=createCanvasFunction(rt,ot).getContext("2d");return ut.drawImage(lt,_,_e,rt,ot,0,0,rt,ot),new RawImage(ut.getImageData(0,0,rt,ot).data,rt,ot,4).convert(at)}else{const at=this.toSharp().extract({left:_,top:_e,width:rt,height:ot});return await loadImageFunction(at)}}async center_crop(_,_e){if(this.width===_&&this.height===_e)return this;let tt=(this.width-_)/2,nt=(this.height-_e)/2;if(BROWSER_ENV){let rt=this.channels,ot=this.toCanvas();const at=createCanvasFunction(_,_e).getContext("2d");let lt=0,ut=0,dt=0,st=0;return tt>=0?lt=tt:dt=-tt,nt>=0?ut=nt:st=-nt,at.drawImage(ot,lt,ut,_,_e,dt,st,_,_e),new RawImage(at.getImageData(0,0,_,_e).data,_,_e,4).convert(rt)}else{let rt=this.toSharp();if(tt>=0&&nt>=0)rt=rt.extract({left:Math.floor(tt),top:Math.floor(nt),width:_,height:_e});else if(tt<=0&&nt<=0){let ot=Math.floor(-nt),at=Math.floor(-tt);rt=rt.extend({top:ot,left:at,right:_-this.width-at,bottom:_e-this.height-ot})}else{let ot=[0,0],at=0;nt<0?(ot[0]=Math.floor(-nt),ot[1]=_e-this.height-ot[0]):at=Math.floor(nt);let lt=[0,0],ut=0;tt<0?(lt[0]=Math.floor(-tt),lt[1]=_-this.width-lt[0]):ut=Math.floor(tt),rt=rt.extend({top:ot[0],bottom:ot[1],left:lt[0],right:lt[1]}).extract({left:ut,top:at,width:_,height:_e})}return await loadImageFunction(rt)}}async toBlob(_="image/png",_e=1){if(!BROWSER_ENV)throw new Error("toBlob() is only supported in browser environments.");return await this.toCanvas().convertToBlob({type:_,quality:_e})}toTensor(_="CHW"){let _e=new Tensor("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if(_!=="HWC")if(_==="CHW")_e=_e.permute(2,0,1);else throw new Error(`Unsupported channel format: ${_}`);return _e}toCanvas(){if(!BROWSER_ENV)throw new Error("toCanvas() is only supported in browser environments.");let _=this.clone().rgba(),_e=createCanvasFunction(_.width,_.height),tt=new ImageDataClass(_.data,_.width,_.height);return _e.getContext("2d").putImageData(tt,0,0),_e}_update(_,_e,tt,nt=null){return this.data=_,this.width=_e,this.height=tt,nt!==null&&(this.channels=nt),this}clone(){return new RawImage(this.data.slice(),this.width,this.height,this.channels)}convert(_){if(this.channels===_)return this;switch(_){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(_){if(BROWSER_ENV){if(WEBWORKER_ENV)throw new Error("Unable to save an image from a Web Worker.");const _e=_.split(".").pop().toLowerCase(),tt=CONTENT_TYPE_MAP.get(_e)??"image/png",nt=await this.toBlob(tt),rt=URL.createObjectURL(nt),ot=document.createElement("a");ot.href=rt,ot.download=_,ot.click(),ot.remove()}else{if(env$1.useFS)return await this.toSharp().toFile(_);throw new Error("Unable to save the image because filesystem is disabled in this environment.")}}toSharp(){if(BROWSER_ENV)throw new Error("toSharp() is only supported in server-side environments.");return sharp(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}async function read_audio(et,_){if(typeof AudioContext>"u")throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const _e=await(await getFile(et)).arrayBuffer(),tt=new AudioContext({sampleRate:_});typeof _>"u"&&console.warn(`No sampling rate provided, using default of ${tt.sampleRate}Hz.`);const nt=await tt.decodeAudioData(_e);let rt;if(nt.numberOfChannels===2){const ot=Math.sqrt(2),at=nt.getChannelData(0),lt=nt.getChannelData(1);rt=new Float32Array(at.length);for(let ut=0;ut<nt.length;++ut)rt[ut]=ot*(at[ut]+lt[ut])/2}else rt=nt.getChannelData(0);return rt}function hanning(et){if(et<1)return new Float64Array;if(et===1)return new Float64Array([1]);const _=et-1,_e=Math.PI/_,tt=new Float64Array(et);for(let nt=0;nt<et;++nt){const rt=2*nt-_;tt[nt]=.5+.5*Math.cos(_e*rt)}return tt}const HERTZ_TO_MEL_MAPPING={htk:et=>2595*Math.log10(1+et/700),kaldi:et=>1127*Math.log(1+et/700),slaney:(et,_=1e3,_e=15,tt=27/Math.log(6.4))=>et>=_?_e+Math.log(et/_)*tt:3*et/200};function hertz_to_mel(et,_="htk"){const _e=HERTZ_TO_MEL_MAPPING[_];if(!_e)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof et=="number"?_e(et):et.map(tt=>_e(tt))}const MEL_TO_HERTZ_MAPPING={htk:et=>700*(10**(et/2595)-1),kaldi:et=>700*(Math.exp(et/1127)-1),slaney:(et,_=1e3,_e=15,tt=Math.log(6.4)/27)=>et>=_e?_*Math.exp(tt*(et-_e)):200*et/3};function mel_to_hertz(et,_="htk"){const _e=MEL_TO_HERTZ_MAPPING[_];if(!_e)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof et=="number"?_e(et):et.map(tt=>_e(tt))}function _create_triangular_filter_bank(et,_){const _e=Float64Array.from({length:_.length-1},(ot,at)=>_[at+1]-_[at]),tt=Array.from({length:et.length},()=>new Array(_.length));for(let ot=0;ot<et.length;++ot){const at=tt[ot];for(let lt=0;lt<_.length;++lt)at[lt]=_[lt]-et[ot]}const nt=_.length-2,rt=Array.from({length:nt},()=>new Array(et.length));for(let ot=0;ot<et.length;++ot){const at=tt[ot];for(let lt=0;lt<nt;++lt){const ut=-at[lt]/_e[lt],dt=at[lt+2]/_e[lt+1];rt[lt][ot]=Math.max(0,Math.min(ut,dt))}}return rt}function linspace(et,_,_e){const tt=(_-et)/(_e-1);return Float64Array.from({length:_e},(nt,rt)=>et+tt*rt)}function mel_filter_bank(et,_,_e,tt,nt,rt=null,ot="htk",at=!1){if(rt!==null&&rt!=="slaney")throw new Error('norm must be one of null or "slaney"');const lt=hertz_to_mel(_e,ot),ut=hertz_to_mel(tt,ot),dt=linspace(lt,ut,_+2);let st=mel_to_hertz(dt,ot),it;if(at){const ft=nt/(et*2);it=hertz_to_mel(Float64Array.from({length:et},(ht,mt)=>mt*ft),ot),st=dt}else it=linspace(0,Math.floor(nt/2),et);const ct=_create_triangular_filter_bank(it,st);if(rt!==null&&rt==="slaney")for(let ft=0;ft<_;++ft){const ht=ct[ft],mt=2/(st[ft+2]-st[ft]);for(let pt=0;pt<et;++pt)ht[pt]*=mt}return ct}function padReflect(et,_,_e){const tt=new et.constructor(et.length+_+_e),nt=et.length-1;for(let rt=0;rt<et.length;++rt)tt[_+rt]=et[rt];for(let rt=1;rt<=_;++rt)tt[_-rt]=et[calculateReflectOffset(rt,nt)];for(let rt=1;rt<=_e;++rt)tt[nt+_+rt]=et[calculateReflectOffset(nt-rt,nt)];return tt}function _db_conversion_helper(et,_,_e,tt,nt){if(_e<=0)throw new Error("reference must be greater than zero");if(tt<=0)throw new Error("min_value must be greater than zero");_e=Math.max(tt,_e);const rt=Math.log10(_e);for(let ot=0;ot<et.length;++ot)et[ot]=_*Math.log10(Math.max(tt,et[ot])-rt);if(nt!==null){if(nt<=0)throw new Error("db_range must be greater than zero");const ot=max$1(et)[0]-nt;for(let at=0;at<et.length;++at)et[at]=Math.max(et[at],ot)}return et}function amplitude_to_db(et,_=1,_e=1e-5,tt=null){return _db_conversion_helper(et,20,_,_e,tt)}function power_to_db(et,_=1,_e=1e-10,tt=null){return _db_conversion_helper(et,10,_,_e,tt)}function spectrogram(et,_,_e,tt,{fft_length:nt=null,power:rt=1,center:ot=!0,pad_mode:at="reflect",onesided:lt=!0,preemphasis:ut=null,mel_filters:dt=null,mel_floor:st=1e-10,log_mel:it=null,reference:ct=1,min_value:ft=1e-10,db_range:ht=null,remove_dc_offset:mt=null,max_num_frames:pt=null,do_pad:_t=!0,transpose:vt=!1}={}){const bt=_.length;if(nt===null&&(nt=_e),_e>nt)throw Error(`frame_length (${_e}) may not be larger than fft_length (${nt})`);if(bt!==_e)throw new Error(`Length of the window (${bt}) must equal frame_length (${_e})`);if(tt<=0)throw new Error("hop_length must be greater than zero");if(rt===null&&dt!==null)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(ot){if(at!=="reflect")throw new Error(`pad_mode="${at}" not implemented yet.`);const Ot=Math.floor((nt-1)/2)+1;et=padReflect(et,Ot,Ot)}const wt=Math.floor(1+Math.floor((et.length-_e)/tt)),xt=lt?Math.floor(nt/2)+1:nt;let Mt=wt,At=wt;pt!==null&&(pt>wt?_t&&(At=pt):At=Mt=pt);const St=new FFT(nt),Tt=new Float64Array(nt),Ct=new Float64Array(St.outputBufferSize),It=new Array(Mt);for(let Ot=0;Ot<Mt;++Ot){const Ut=Ot*tt;for(let zt=0;zt<_e;++zt)Tt[zt]=et[Ut+zt];if(mt){let zt=0;for(let en=0;en<_e;++en)zt+=Tt[en];const Yt=zt/_e;for(let en=0;en<_e;++en)Tt[en]-=Yt}if(ut!==null){for(let zt=_e-1;zt>=1;--zt)Tt[zt]-=ut*Tt[zt-1];Tt[0]*=1-ut}for(let zt=0;zt<_.length;++zt)Tt[zt]*=_[zt];St.realTransform(Ct,Tt);const Lt=new Array(xt);for(let zt=0;zt<Lt.length;++zt){const Yt=zt<<1;Lt[zt]=Ct[Yt]**2+Ct[Yt+1]**2}It[Ot]=Lt}if(rt!==null&&rt!==2){const Ot=2/rt;for(let Ut=0;Ut<It.length;++Ut){const Lt=It[Ut];for(let zt=0;zt<Lt.length;++zt)Lt[zt]**=Ot}}const $t=dt.length,Nt=new Float32Array($t*At),Bt=vt?[At,$t]:[$t,At];for(let Ot=0;Ot<$t;++Ot){const Ut=dt[Ot];for(let Lt=0;Lt<Mt;++Lt){const zt=It[Lt];let Yt=0;for(let en=0;en<xt;++en)Yt+=Ut[en]*zt[en];Nt[vt?Lt*$t+Ot:Ot*Mt+Lt]=Math.max(st,Yt)}}if(rt!==null&&it!==null){const Ot=Math.min(Nt.length,Mt*$t);switch(it){case"log":for(let Ut=0;Ut<Ot;++Ut)Nt[Ut]=Math.log(Nt[Ut]);break;case"log10":for(let Ut=0;Ut<Ot;++Ut)Nt[Ut]=Math.log10(Nt[Ut]);break;case"dB":if(rt===1)amplitude_to_db(Nt,ct,ft,ht);else if(rt===2)power_to_db(Nt,ct,ft,ht);else throw new Error(`Cannot use log_mel option '${it}' with power ${rt}`);break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${it}'`)}}return{data:Nt,dims:Bt}}function window_function(et,_,{periodic:_e=!0,frame_length:tt=null,center:nt=!0}={}){const rt=_e?et+1:et;let ot;switch(_){case"boxcar":ot=new Float64Array(rt).fill(1);break;case"hann":case"hann_window":ot=hanning(rt);break;case"povey":ot=hanning(rt).map(at=>Math.pow(at,.85));break;default:throw new Error(`Unknown window type ${_}.`)}if(_e&&(ot=ot.subarray(0,et)),tt===null)return ot;if(et>tt)throw new Error(`Length of the window (${et}) may not be larger than frame_length (${tt})`);return ot}function center_to_corners_format([et,_,_e,tt]){return[et-_e/2,_-tt/2,et+_e/2,_+tt/2]}function post_process_object_detection(et,_=.5,_e=null,tt=!1){const nt=et.logits,rt=et.pred_boxes,[ot,at,lt]=nt.dims;if(_e!==null&&_e.length!==ot)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let ut=[];for(let dt=0;dt<ot;++dt){let st=_e!==null?_e[dt]:null,it={boxes:[],classes:[],scores:[]},ct=nt[dt],ft=rt[dt];for(let ht=0;ht<at;++ht){let mt=ct[ht],pt=[],_t;if(tt){_t=mt.sigmoid().data;for(let vt=0;vt<_t.length;++vt)_t[vt]>_&&pt.push(vt)}else{let vt=max$1(mt.data)[1];if(vt===lt-1)continue;pt.push(vt),_t=softmax(mt.data)}for(const vt of pt){let bt=ft[ht].data;bt=center_to_corners_format(bt),st!==null&&(bt=bt.map((wt,xt)=>wt*st[(xt+1)%2])),it.boxes.push(bt),it.classes.push(vt),it.scores.push(_t[vt])}}ut.push(it)}return ut}function validate_audio_inputs(et,_){var _e;if(!(et instanceof Float32Array||et instanceof Float64Array))throw new Error(`${_} expects input to be a Float32Array or a Float64Array, but got ${((_e=et==null?void 0:et.constructor)==null?void 0:_e.name)??typeof et} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}function constraint_to_multiple_of(et,_,_e=0,tt=null){const nt=et/_;let rt=bankers_round(nt)*_;return tt!==null&&rt>tt&&(rt=Math.floor(nt)*_),rt<_e&&(rt=Math.ceil(nt)*_),rt}function enforce_size_divisibility([et,_],_e){return[Math.max(Math.floor(et/_e),1)*_e,Math.max(Math.floor(_/_e),1)*_e]}class FeatureExtractor extends Callable{constructor(_){super(),this.config=_}}class ImageFeatureExtractor extends FeatureExtractor{constructor(_){super(_),this.image_mean=this.config.image_mean??this.config.mean,this.image_std=this.config.image_std??this.config.std,this.resample=this.config.resample??2,this.do_rescale=this.config.do_rescale??!0,this.rescale_factor=this.config.rescale_factor??1/255,this.do_normalize=this.config.do_normalize,this.do_resize=this.config.do_resize,this.do_thumbnail=this.config.do_thumbnail,this.size=this.config.size,this.size_divisibility=this.config.size_divisibility??this.config.size_divisor,this.do_center_crop=this.config.do_center_crop,this.crop_size=this.config.crop_size,this.do_convert_rgb=this.config.do_convert_rgb??!0,this.do_crop_margin=this.config.do_crop_margin,this.pad_size=this.config.pad_size,this.do_pad=this.config.do_pad,this.do_pad&&!this.pad_size&&this.size&&this.size.width!==void 0&&this.size.height!==void 0&&(this.pad_size=this.size),this.do_flip_channel_order=this.config.do_flip_channel_order??!1}async thumbnail(_,_e,tt=2){const nt=_.height,rt=_.width,ot=_e.height,at=_e.width;let lt=Math.min(nt,ot),ut=Math.min(rt,at);return lt===nt&&ut===rt?_:(nt>rt?ut=Math.floor(rt*lt/nt):rt>nt&&(lt=Math.floor(nt*ut/rt)),await _.resize(ut,lt,{resample:tt}))}async crop_margin(_,_e=200){const tt=_.clone().grayscale(),nt=min$1(tt.data)[0],ot=max$1(tt.data)[0]-nt;if(ot===0)return _;const at=_e/255;let lt=tt.width,ut=tt.height,dt=0,st=0;for(let it=0;it<tt.height;++it){const ct=it*tt.width;for(let ft=0;ft<tt.width;++ft)(tt.data[ct+ft]-nt)/ot<at&&(lt=Math.min(lt,ft),ut=Math.min(ut,it),dt=Math.max(dt,ft),st=Math.max(st,it))}return _=await _.crop([lt,ut,dt,st]),_}pad_image(_,_e,tt,{mode:nt="constant",center:rt=!1,constant_values:ot=0}={}){const[at,lt,ut]=_e;let dt,st;if(typeof tt=="number"?(dt=tt,st=tt):(dt=tt.width,st=tt.height),dt!==lt||st!==at){const it=new Float32Array(dt*st*ut);if(Array.isArray(ot))for(let ht=0;ht<it.length;++ht)it[ht]=ot[ht%ut];else ot!==0&&it.fill(ot);const[ct,ft]=rt?[Math.floor((dt-lt)/2),Math.floor((st-at)/2)]:[0,0];for(let ht=0;ht<at;++ht){const mt=(ht+ft)*dt,pt=ht*lt;for(let _t=0;_t<lt;++_t){const vt=(mt+_t+ct)*ut,bt=(pt+_t)*ut;for(let wt=0;wt<ut;++wt)it[vt+wt]=_[bt+wt]}}if(nt==="symmetric"){if(rt)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const ht=at-1,mt=lt-1;for(let pt=0;pt<st;++pt){const _t=pt*dt,vt=calculateReflectOffset(pt,ht)*lt;for(let bt=0;bt<dt;++bt){if(pt<at&&bt<lt)continue;const wt=(_t+bt)*ut,xt=(vt+calculateReflectOffset(bt,mt))*ut;for(let Mt=0;Mt<ut;++Mt)it[wt+Mt]=_[xt+Mt]}}}_=it,_e=[st,dt,ut]}return[_,_e]}rescale(_){for(let _e=0;_e<_.length;++_e)_[_e]=this.rescale_factor*_[_e]}get_resize_output_image_size(_,_e){const[tt,nt]=_.size;let rt,ot;if(this.do_thumbnail){const{height:at,width:lt}=_e;rt=Math.min(at,lt)}else Number.isInteger(_e)?(rt=_e,ot=this.config.max_size??rt):_e!==void 0&&(rt=_e.shortest_edge,ot=_e.longest_edge);if(rt!==void 0||ot!==void 0){const at=rt===void 0?1:Math.max(rt/tt,rt/nt),lt=tt*at,ut=nt*at,dt=ot===void 0?1:Math.min(ot/lt,ot/ut);let st=Math.floor(Number((lt*dt).toFixed(2))),it=Math.floor(Number((ut*dt).toFixed(2)));return this.size_divisibility!==void 0&&([st,it]=enforce_size_divisibility([st,it],this.size_divisibility)),[st,it]}else if(_e!==void 0&&_e.width!==void 0&&_e.height!==void 0){let at=_e.width,lt=_e.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let ut=lt/nt,dt=at/tt;Math.abs(1-dt)<Math.abs(1-ut)?ut=dt:dt=ut,lt=constraint_to_multiple_of(ut*nt,this.config.ensure_multiple_of),at=constraint_to_multiple_of(dt*tt,this.config.ensure_multiple_of)}return[at,lt]}else{if(this.size_divisibility!==void 0)return enforce_size_divisibility([tt,nt],this.size_divisibility);throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(_e)}`)}}async resize(_){const[_e,tt]=this.get_resize_output_image_size(_,this.size);return await _.resize(_e,tt,{resample:this.resample})}async preprocess(_,{do_normalize:_e=null,do_pad:tt=null,do_convert_rgb:nt=null,do_convert_grayscale:rt=null,do_flip_channel_order:ot=null}={}){this.do_crop_margin&&(_=await this.crop_margin(_));const[at,lt]=_.size;if(nt??this.do_convert_rgb?_=_.rgb():rt&&(_=_.grayscale()),this.do_resize&&(_=await this.resize(_)),this.do_thumbnail&&(_=await this.thumbnail(_,this.size,this.resample)),this.do_center_crop){let ct,ft;Number.isInteger(this.crop_size)?(ct=this.crop_size,ft=this.crop_size):(ct=this.crop_size.width,ft=this.crop_size.height),_=await _.center_crop(ct,ft)}const ut=[_.height,_.width];let dt=Float32Array.from(_.data),st=[_.height,_.width,_.channels];if(this.do_rescale&&this.rescale(dt),_e??this.do_normalize){let ct=this.image_mean;Array.isArray(this.image_mean)||(ct=new Array(_.channels).fill(ct));let ft=this.image_std;if(Array.isArray(this.image_std)||(ft=new Array(_.channels).fill(ct)),ct.length!==_.channels||ft.length!==_.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${ct.length}) and \`image_std\` (${ft.length}) must match the number of channels in the image (${_.channels}).`);for(let ht=0;ht<dt.length;ht+=_.channels)for(let mt=0;mt<_.channels;++mt)dt[ht+mt]=(dt[ht+mt]-ct[mt])/ft[mt]}if(tt??this.do_pad){if(this.pad_size)[dt,st]=this.pad_image(dt,[_.height,_.width,_.channels],this.pad_size);else if(this.size_divisibility){const[ct,ft]=enforce_size_divisibility([st[1],st[0]],this.size_divisibility);[dt,st]=this.pad_image(dt,st,{width:ct,height:ft})}}if(ot??this.do_flip_channel_order){if(st[2]!==3)throw new Error("Flipping channel order is only supported for RGB images.");for(let ct=0;ct<dt.length;ct+=3){const ft=dt[ct];dt[ct]=dt[ct+2],dt[ct+2]=ft}}const it=new Tensor("float32",dt,st).permute(2,0,1);return{original_size:[lt,at],reshaped_input_size:ut,pixel_values:it}}async _call(_,..._e){Array.isArray(_)||(_=[_]);const tt=await Promise.all(_.map(rt=>this.preprocess(rt)));return{pixel_values:stack(tt.map(rt=>rt.pixel_values),0),original_sizes:tt.map(rt=>rt.original_size),reshaped_input_sizes:tt.map(rt=>rt.reshaped_input_size)}}}class SegformerFeatureExtractor extends ImageFeatureExtractor{post_process_semantic_segmentation(_,_e=null){const tt=_.logits,nt=tt.dims[0];if(_e!==null&&_e.length!==nt)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const rt=[];for(let ot=0;ot<nt;++ot){const at=_e!==null?_e[ot]:null;let lt=tt[ot];at!==null&&(lt=interpolate(lt,at,"bilinear",!1));const[ut,dt]=at??lt.dims.slice(-2),st=new Tensor("int32",new Int32Array(ut*dt),[ut,dt]),it=lt[0].data;for(let mt=1;mt<lt.dims[0];++mt){const pt=lt[mt].data;for(let _t=0;_t<pt.length;++_t)pt[_t]>it[_t]&&(it[_t]=pt[_t],st.data[_t]=mt)}const ct=new Array(lt.dims[0]),ft=st.data;for(let mt=0;mt<ft.length;++mt){const pt=ft[mt];ct[pt]=pt}const ht=ct.filter(mt=>mt!==void 0);rt.push({segmentation:st,labels:ht})}return rt}}class DPTFeatureExtractor extends ImageFeatureExtractor{}class DPTImageProcessor extends DPTFeatureExtractor{}class BitImageProcessor extends ImageFeatureExtractor{}class GLPNFeatureExtractor extends ImageFeatureExtractor{}class CLIPFeatureExtractor extends ImageFeatureExtractor{}class ChineseCLIPFeatureExtractor extends ImageFeatureExtractor{}class SiglipImageProcessor extends ImageFeatureExtractor{}class ConvNextFeatureExtractor extends ImageFeatureExtractor{constructor(_){super(_),this.crop_pct=this.config.crop_pct??224/256}async resize(_){var tt;const _e=(tt=this.size)==null?void 0:tt.shortest_edge;if(_e===void 0)throw new Error("Size dictionary must contain 'shortest_edge' key.");if(_e<384){const nt=Math.floor(_e/this.crop_pct),[rt,ot]=this.get_resize_output_image_size(_,{shortest_edge:nt});_=await _.resize(rt,ot,{resample:this.resample}),_=await _.center_crop(_e,_e)}else _=await _.resize(_e,_e,{resample:this.resample});return _}}class ConvNextImageProcessor extends ConvNextFeatureExtractor{}class ViTFeatureExtractor extends ImageFeatureExtractor{}class ViTImageProcessor extends ImageFeatureExtractor{}class EfficientNetImageProcessor extends ImageFeatureExtractor{constructor(_){super(_),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map(_e=>_e*_e))}}class MobileViTFeatureExtractor extends ImageFeatureExtractor{}class MobileViTImageProcessor extends MobileViTFeatureExtractor{}class OwlViTFeatureExtractor extends ImageFeatureExtractor{post_process_object_detection(..._){return post_process_object_detection(..._)}}class Owlv2ImageProcessor extends OwlViTFeatureExtractor{}class DeiTFeatureExtractor extends ImageFeatureExtractor{}class BeitFeatureExtractor extends ImageFeatureExtractor{}class DonutFeatureExtractor extends ImageFeatureExtractor{pad_image(_,_e,tt,nt={}){const[rt,ot,at]=_e;let lt=this.image_mean;Array.isArray(this.image_mean)||(lt=new Array(at).fill(lt));let ut=this.image_std;Array.isArray(ut)||(ut=new Array(at).fill(lt));const dt=lt.map((st,it)=>-st/ut[it]);return super.pad_image(_,_e,tt,{center:!0,constant_values:dt,...nt})}}class NougatImageProcessor extends DonutFeatureExtractor{}class DetrFeatureExtractor extends ImageFeatureExtractor{async _call(_){const _e=await super._call(_),tt=[_e.pixel_values.dims[0],64,64],nt=new Tensor("int64",new BigInt64Array(tt.reduce((rt,ot)=>rt*ot)).fill(1n),tt);return{..._e,pixel_mask:nt}}post_process_object_detection(..._){return post_process_object_detection(..._)}remove_low_and_no_objects(_,_e,tt,nt){let rt=[],ot=[],at=[];for(let lt=0;lt<_.dims[0];++lt){let ut=_[lt],dt=_e[lt],st=max$1(ut.data)[1];if(st===nt)continue;let ct=softmax(ut.data)[st];ct>tt&&(rt.push(dt),ot.push(ct),at.push(st))}return[rt,ot,at]}check_segment_validity(_,_e,tt,nt=.5,rt=.8){let ot=[],at=0,lt=0;for(let dt=0;dt<_.length;++dt)_[dt]===tt&&(ot.push(dt),++at),_e[tt].data[dt]>=nt&&++lt;let ut=at>0&&lt>0;return ut&&(ut=at/lt>rt),[ut,ot]}compute_segments(_,_e,tt,nt,rt,ot=null,at=null){let[lt,ut]=at??_[0].dims,dt=new Tensor("int32",new Int32Array(lt*ut),[lt,ut]),st=[];if(at!==null)for(let ht=0;ht<_.length;++ht)_[ht]=interpolate(_[ht],at,"bilinear",!1);let it=new Int32Array(_[0].data.length),ct=new Float32Array(_[0].data.length);for(let ht=0;ht<_.length;++ht){let mt=_e[ht];for(let pt=0;pt<_[ht].data.length;++pt)_[ht].data[pt]*=mt,_[ht].data[pt]>ct[pt]&&(it[pt]=ht,ct[pt]=_[ht].data[pt])}let ft=0;for(let ht=0;ht<tt.length;++ht){let mt=tt[ht],[pt,_t]=this.check_segment_validity(it,_,ht,nt,rt);if(pt){++ft;for(let vt of _t)dt.data[vt]=ft;st.push({id:ft,label_id:mt,score:_e[ht]})}}return[dt,st]}post_process_panoptic_segmentation(_,_e=.5,tt=.5,nt=.8,rt=null,ot=null){rt===null&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),rt=new Set);const at=_.logits,ut=_.pred_masks.sigmoid();let[dt,st,it]=at.dims;if(it-=1,ot!==null&&ot.length!==dt)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let ct=[];for(let ft=0;ft<dt;++ft){let ht=ot!==null?ot[ft]:null,mt=at[ft],pt=ut[ft],[_t,vt,bt]=this.remove_low_and_no_objects(mt,pt,_e,it);if(bt.length===0){let[Mt,At]=ht??pt.dims.slice(-2),St=new Tensor("int32",new Int32Array(Mt*At).fill(-1),[Mt,At]);ct.push({segmentation:St,segments_info:[]});continue}let[wt,xt]=this.compute_segments(_t,vt,bt,tt,nt,rt,ht);ct.push({segmentation:wt,segments_info:xt})}return ct}post_process_instance_segmentation(){throw Error("Not implemented yet")}}class YolosFeatureExtractor extends ImageFeatureExtractor{post_process_object_detection(..._){return post_process_object_detection(..._)}}class SamImageProcessor extends ImageFeatureExtractor{reshape_input_points(_,_e,tt){_=structuredClone(_);let nt=calculateDimensions(_);if(nt.length===3)nt=[1,...nt],_=[_];else if(nt.length!==4)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let rt=0;rt<_.length;++rt){let ot=_e[rt],at=tt[rt],lt=[at[0]/ot[0],at[1]/ot[1]];for(let ut=0;ut<_[rt].length;++ut)for(let dt=0;dt<_[rt][ut].length;++dt)for(let st=0;st<_[rt][ut][dt].length;++st)_[rt][ut][dt][st]*=lt[st]}return new Tensor("float32",Float32Array.from(_.flat(1/0)),nt)}add_input_labels(_,_e){let tt=calculateDimensions(_);if(tt.length===2)tt=[1,...tt],_=[_];else if(tt.length!==3)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(tt.some((nt,rt)=>nt!==_e.dims[rt]))throw Error(`The first ${tt.length} dimensions of 'input_points' and 'input_labels' must be the same.`);return new Tensor("int64",_.flat(1/0).map(BigInt),tt)}async _call(_,_e=null,tt=null){const nt=await super._call(_);if(_e&&(nt.input_points=this.reshape_input_points(_e,nt.original_sizes,nt.reshaped_input_sizes)),tt){if(!nt.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");nt.input_labels=this.add_input_labels(tt,nt.input_points)}return nt}post_process_masks(_,_e,tt,{mask_threshold:nt=0,binarize:rt=!0,pad_size:ot=null}={}){const at=[];ot=ot??this.pad_size;const lt=[ot.height,ot.width];for(let ut=0;ut<_e.length;++ut){const dt=_e[ut],st=tt[ut],it=_[ut],ct=[];for(let ft=0;ft<it.dims[0];++ft){const ht=it[ft];let mt=interpolate(ht,lt,"bilinear",!1);if(mt=mt.slice(null,[0,st[0]],[0,st[1]]),mt=interpolate(mt,dt,"bilinear",!1),rt){const pt=new Uint8Array(mt.data.length);for(let _t=0;_t<mt.data.length;++_t)mt.data[_t]>nt&&(pt[_t]=1);mt=new Tensor("bool",pt,mt.dims)}ct.push(mt)}at.push(stack(ct))}return at}}class Swin2SRImageProcessor extends ImageFeatureExtractor{pad_image(_,_e,tt,nt={}){const[rt,ot,at]=_e;return super.pad_image(_,_e,{width:ot+(tt-ot%tt)%tt,height:rt+(tt-rt%tt)%tt},{mode:"symmetric",center:!1,constant_values:-1,...nt})}}class VitMatteImageProcessor extends ImageFeatureExtractor{async _call(_,_e){Array.isArray(_)||(_=[_]),Array.isArray(_e)||(_e=[_e]);const tt=await Promise.all(_.map(ot=>this.preprocess(ot))),nt=await Promise.all(_e.map(ot=>this.preprocess(ot,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0})));return{pixel_values:stack(tt.map((ot,at)=>cat([ot.pixel_values,nt[at].pixel_values],0)),0),original_sizes:tt.map(ot=>ot.original_size),reshaped_input_sizes:tt.map(ot=>ot.reshaped_input_size)}}}class WhisperFeatureExtractor extends FeatureExtractor{constructor(_){var _e;super(_),(_e=this.config).mel_filters??(_e.mel_filters=mel_filter_bank(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney")),this.window=window_function(this.config.n_fft,"hann")}_extract_fbank_features(_){const{data:_e,dims:tt}=spectrogram(_,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:this.config.nb_max_frames}),nt=max$1(_e)[0];for(let rt=0;rt<_e.length;++rt)_e[rt]=(Math.max(_e[rt],nt-8)+4)/4;return{data:_e,dims:tt}}async _call(_){validate_audio_inputs(_,"WhisperFeatureExtractor");let _e;_.length>this.config.n_samples?(console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),_e=_.slice(0,this.config.n_samples)):(_e=new Float32Array(this.config.n_samples),_e.set(_));const{data:tt,dims:nt}=this._extract_fbank_features(_e);return{input_features:new Tensor("float32",tt,[1,...nt])}}}class Wav2Vec2FeatureExtractor extends FeatureExtractor{_zero_mean_unit_var_norm(_){const tt=_.reduce((rt,ot)=>rt+ot,0)/_.length,nt=_.reduce((rt,ot)=>rt+(ot-tt)**2,0)/_.length;return _.map(rt=>(rt-tt)/Math.sqrt(nt+1e-7))}async _call(_){validate_audio_inputs(_,"Wav2Vec2FeatureExtractor"),_ instanceof Float64Array&&(_=new Float32Array(_));let _e=_;this.config.do_normalize&&(_e=this._zero_mean_unit_var_norm(_e));const tt=[1,_e.length];return{input_values:new Tensor("float32",_e,tt),attention_mask:new Tensor("int64",new BigInt64Array(_e.length).fill(1n),tt)}}}class SeamlessM4TFeatureExtractor extends FeatureExtractor{constructor(_){super(_);const _e=this.config.sampling_rate,tt=mel_filter_bank(256,this.config.num_mel_bins,20,Math.floor(_e/2),_e,null,"kaldi",!0);for(let nt=0;nt<tt.length;++nt)tt[nt].push(0);this.mel_filters=tt,this.window=window_function(400,"povey",{periodic:!1})}_extract_fbank_features(_,_e){return _=_.map(tt=>tt*32768),spectrogram(_,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:_e,transpose:!0})}async _call(_,{padding:_e=!0,pad_to_multiple_of:tt=2,do_normalize_per_mel_bins:nt=!0,return_attention_mask:rt=!0}={}){validate_audio_inputs(_,"SeamlessM4TFeatureExtractor");let ot=this._extract_fbank_features(_,this.config.max_length);if(nt){const[ft,ht]=ot.dims;for(let mt=0;mt<ht;++mt){let pt=0;for(let wt=0;wt<ft;++wt)pt+=ot.data[wt*ht+mt];const _t=pt/ft;let vt=0;for(let wt=0;wt<ft;++wt)vt+=(ot.data[wt*ht+mt]-_t)**2;vt/=ft-1;const bt=Math.sqrt(vt+1e-7);for(let wt=0;wt<ft;++wt){const xt=wt*ht+mt;ot.data[xt]=(ot.data[xt]-_t)/bt}}}let at;if(_e){const[ft,ht]=ot.dims,mt=ft%tt;if(mt>0){const pt=new Float32Array(ht*(ft+mt));pt.set(ot.data),pt.fill(this.config.padding_value,ot.data.length);const _t=ft+mt;ot={data:pt,dims:[_t,ht]},rt&&(at=new Tensor("int64",new BigInt64Array(_t),[1,_t]),at.data.fill(1n,0,ft))}}const[lt,ut]=ot.dims,dt=this.config.stride;if(lt%dt!==0)throw new Error(`The number of frames (${lt}) must be a multiple of the stride (${dt}).`);const it=new Tensor("float32",ot.data,ot.dims).view(1,Math.floor(lt/dt),ut*dt),ct={input_features:it};if(rt){const ft=it.dims[1],ht=new Tensor("int64",new BigInt64Array(ft),[1,ft]);if(at)for(let mt=1,pt=0;mt<lt;mt+=dt,++pt)ht.data[pt]=at.data[mt];else ht.data.fill(1n);ct.attention_mask=ht}return ct}}class ASTFeatureExtractor extends FeatureExtractor{constructor(_){super(_);const _e=this.config.sampling_rate,tt=mel_filter_bank(256,this.config.num_mel_bins,20,Math.floor(_e/2),_e,null,"kaldi",!0);for(let nt=0;nt<tt.length;++nt)tt[nt].push(0);this.mel_filters=tt,this.window=window_function(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}_extract_fbank_features(_,_e){return spectrogram(_,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:_e,transpose:!0})}async _call(_){validate_audio_inputs(_,"ASTFeatureExtractor");const _e=this._extract_fbank_features(_,this.config.max_length);if(this.config.do_normalize){const tt=this.std*2;for(let nt=0;nt<_e.data.length;++nt)_e.data[nt]=(_e.data[nt]-this.mean)/tt}return{input_values:new Tensor("float32",_e.data,[1,..._e.dims])}}}class ClapFeatureExtractor extends FeatureExtractor{constructor(_){super(_),this.mel_filters=mel_filter_bank(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=mel_filter_bank(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=window_function(this.config.fft_window_size,"hann")}_get_input_mel(_,_e,tt,nt){let rt,ot=!1;const at=_.length-_e;if(at>0)if(tt==="rand_trunc"){ot=!0;const lt=Math.floor(Math.random()*(at+1));_=_.subarray(lt,lt+_e),rt=this._extract_fbank_features(_,this.mel_filters_slaney,this.config.nb_max_samples),rt.dims=[1,...rt.dims]}else throw new Error(`Truncation strategy "${tt}" not implemented`);else{if(at<0){let lt=new Float64Array(_e);if(lt.set(_),nt==="repeat")for(let ut=_.length;ut<_e;ut+=_.length)lt.set(_.subarray(0,Math.min(_.length,_e-ut)),ut);else if(nt==="repeatpad")for(let ut=_.length;ut<-at;ut+=_.length)lt.set(_,ut);_=lt}if(tt==="fusion")throw new Error(`Truncation strategy "${tt}" not implemented`);rt=this._extract_fbank_features(_,this.mel_filters_slaney,this.config.nb_max_samples),rt.dims=[1,...rt.dims]}return{...rt,longer:ot}}_extract_fbank_features(_,_e,tt=null){return spectrogram(_,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:_e,log_mel:"dB",max_num_frames:tt,do_pad:!1,transpose:!0})}async _call(_,{max_length:_e=null}={}){validate_audio_inputs(_,"ClapFeatureExtractor");const tt=this._get_input_mel(_,_e??this.config.nb_max_samples,this.config.truncation,this.config.padding);return{input_features:new Tensor("float32",tt.data,[1,...tt.dims])}}}class SpeechT5FeatureExtractor extends FeatureExtractor{}class Processor extends Callable{constructor(_){super(),this.feature_extractor=_}async _call(_,..._e){return await this.feature_extractor(_,..._e)}}class SamProcessor extends Processor{async _call(..._){return await this.feature_extractor(..._)}post_process_masks(..._){return this.feature_extractor.post_process_masks(..._)}reshape_input_points(..._){return this.feature_extractor.reshape_input_points(..._)}}class WhisperProcessor extends Processor{async _call(_){return await this.feature_extractor(_)}}class Wav2Vec2ProcessorWithLM extends Processor{async _call(_){return await this.feature_extractor(_)}}class SpeechT5Processor extends Processor{async _call(_){return await this.feature_extractor(_)}}class OwlViTProcessor extends Processor{}class AutoProcessor{static async from_pretrained(_,{progress_callback:_e=null,config:tt=null,cache_dir:nt=null,local_files_only:rt=!1,revision:ot="main"}={}){let at=tt??await getModelJSON(_,"preprocessor_config.json",!0,{progress_callback:_e,config:tt,cache_dir:nt,local_files_only:rt,revision:ot}),lt=at.feature_extractor_type??at.image_processor_type,ut=this.FEATURE_EXTRACTOR_CLASS_MAPPING[lt];if(!ut)if(at.size!==void 0)console.warn(`Feature extractor type "${lt}" not found, assuming ImageFeatureExtractor due to size parameter in config.`),ut=ImageFeatureExtractor;else throw new Error(`Unknown Feature Extractor type: ${lt}`);let dt=this.PROCESSOR_CLASS_MAPPING[at.processor_class]??Processor,st=new ut(at);return new dt(st)}}jn(AutoProcessor,"FEATURE_EXTRACTOR_CLASS_MAPPING",{ImageFeatureExtractor,WhisperFeatureExtractor,ViTFeatureExtractor,MobileViTFeatureExtractor,MobileViTImageProcessor,OwlViTFeatureExtractor,Owlv2ImageProcessor,CLIPFeatureExtractor,ChineseCLIPFeatureExtractor,SiglipImageProcessor,ConvNextFeatureExtractor,ConvNextImageProcessor,SegformerFeatureExtractor,BitImageProcessor,DPTImageProcessor,DPTFeatureExtractor,GLPNFeatureExtractor,BeitFeatureExtractor,DeiTFeatureExtractor,DetrFeatureExtractor,YolosFeatureExtractor,DonutFeatureExtractor,NougatImageProcessor,EfficientNetImageProcessor,ViTImageProcessor,VitMatteImageProcessor,SamImageProcessor,Swin2SRImageProcessor,Wav2Vec2FeatureExtractor,SeamlessM4TFeatureExtractor,SpeechT5FeatureExtractor,ASTFeatureExtractor,ClapFeatureExtractor}),jn(AutoProcessor,"PROCESSOR_CLASS_MAPPING",{WhisperProcessor,Wav2Vec2ProcessorWithLM,SamProcessor,SpeechT5Processor,OwlViTProcessor});async function prepareImages(et){return Array.isArray(et)||(et=[et]),await Promise.all(et.map(_=>RawImage.read(_)))}async function prepareAudios(et,_){return Array.isArray(et)||(et=[et]),await Promise.all(et.map(_e=>typeof _e=="string"||_e instanceof URL?read_audio(_e,_):_e instanceof Float64Array?new Float32Array(_e):_e))}function get_bounding_box(et,_){_&&(et=et.map(ot=>ot|0));const[_e,tt,nt,rt]=et;return{xmin:_e,ymin:tt,xmax:nt,ymax:rt}}class Pipeline extends Callable{constructor({task:_,model:_e,tokenizer:tt=null,processor:nt=null}){super(),this.task=_,this.model=_e,this.tokenizer=tt,this.processor=nt}async dispose(){await this.model.dispose()}}class TextClassificationPipeline extends Pipeline{constructor(_){super(_)}async _call(_,{topk:_e=1}={}){const tt=this.tokenizer(_,{padding:!0,truncation:!0}),nt=await this.model(tt),rt=this.model.config.problem_type==="multi_label_classification"?lt=>lt.sigmoid().data:lt=>softmax(lt.data),ot=this.model.config.id2label,at=[];for(const lt of nt.logits){const ut=rt(lt),st=getTopItems(ut,_e).map(it=>({label:ot[it[0]],score:it[1]}));_e===1?at.push(...st):at.push(st)}return Array.isArray(_)||_e===1?at:at[0]}}class TokenClassificationPipeline extends Pipeline{constructor(_){super(_)}async _call(_,{ignore_labels:_e=["O"]}={}){const tt=Array.isArray(_),nt=this.tokenizer(tt?_:[_],{padding:!0,truncation:!0}),ot=(await this.model(nt)).logits,at=this.model.config.id2label,lt=[];for(let ut=0;ut<ot.dims[0];++ut){const dt=nt.input_ids[ut],st=ot[ut],it=[];for(let ct=0;ct<st.dims[0];++ct){const ft=st[ct],ht=max$1(ft.data)[1],mt=at?at[ht]:`LABEL_${ht}`;if(_e.includes(mt))continue;const pt=this.tokenizer.decode([dt[ct].item()],{skip_special_tokens:!0});if(pt==="")continue;const _t=softmax(ft.data);it.push({entity:mt,score:_t[ht],index:ct,word:pt,start:null,end:null})}lt.push(it)}return tt?lt:lt[0]}}class QuestionAnsweringPipeline extends Pipeline{constructor(_){super(_)}async _call(_,_e,{topk:tt=1}={}){const nt=this.tokenizer(_,{text_pair:_e,padding:!0,truncation:!0}),rt=await this.model(nt),ot=[];for(let at=0;at<rt.start_logits.dims[0];++at){const lt=nt.input_ids[at],ut=lt.indexOf(this.tokenizer.sep_token_id),dt=Array.from(softmax(rt.start_logits[at].data)).map((ct,ft)=>[ct,ft]).filter(ct=>ct[1]>ut),st=Array.from(softmax(rt.end_logits[at].data)).map((ct,ft)=>[ct,ft]).filter(ct=>ct[1]>ut),it=product(dt,st).filter(ct=>ct[0][1]<=ct[1][1]).map(ct=>[ct[0][1],ct[1][1],ct[0][0]*ct[1][0]]).sort((ct,ft)=>ft[2]-ct[2]);for(let ct=0;ct<Math.min(it.length,tt);++ct){const[ft,ht,mt]=it[ct],pt=[...lt].slice(ft,ht+1),_t=this.tokenizer.decode(pt,{skip_special_tokens:!0});ot.push({answer:_t,score:mt})}}return tt===1?ot[0]:ot}}class FillMaskPipeline extends Pipeline{constructor(_){super(_)}async _call(_,{topk:_e=5}={}){const tt=this.tokenizer(_,{padding:!0,truncation:!0}),nt=await this.model(tt),rt=[];for(let ot=0;ot<tt.input_ids.dims[0];++ot){const at=tt.input_ids[ot],lt=at.indexOf(this.tokenizer.mask_token_id);if(lt===-1)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const dt=nt.logits[ot][lt],st=getTopItems(softmax(dt.data),_e);rt.push(st.map(it=>{const ct=[...at];return ct[lt]=it[0],{score:it[1],token:it[0],token_str:this.tokenizer.model.vocab[it[0]],sequence:this.tokenizer.decode(ct,{skip_special_tokens:!0})}}))}return Array.isArray(_)?rt:rt[0]}}class Text2TextGenerationPipeline extends Pipeline{constructor(_e){super(_e);jn(this,"_key","generated_text")}async _call(_e,tt={}){Array.isArray(_e)||(_e=[_e]),this.model.config.prefix&&(_e=_e.map(ut=>this.model.config.prefix+ut));const nt=this.model.config.task_specific_params;nt&&nt[this.task]&&nt[this.task].prefix&&(_e=_e.map(ut=>nt[this.task].prefix+ut));const rt=this.tokenizer,ot={padding:!0,truncation:!0};let at;this instanceof TranslationPipeline&&"_build_translation_inputs"in rt?at=rt._build_translation_inputs(_e,ot,tt).input_ids:at=rt(_e,ot).input_ids;const lt=await this.model.generate(at,tt);return rt.batch_decode(lt,{skip_special_tokens:!0}).map(ut=>({[this._key]:ut}))}}class SummarizationPipeline extends Text2TextGenerationPipeline{constructor(_e){super(_e);jn(this,"_key","summary_text")}}class TranslationPipeline extends Text2TextGenerationPipeline{constructor(_e){super(_e);jn(this,"_key","translation_text")}}function isChat(et){return Array.isArray(et)&&et.every(_=>"role"in _&&"content"in _)}class TextGenerationPipeline extends Pipeline{constructor(_){super(_)}async _call(_,_e={}){let tt=!1,nt=!1,rt;if(typeof _=="string")rt=_=[_];else if(Array.isArray(_)&&_.every(ft=>typeof ft=="string"))tt=!0,rt=_;else{if(isChat(_))_=[_];else if(Array.isArray(_)&&_.every(isChat))tt=!0;else throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");nt=!0,rt=_.map(ft=>this.tokenizer.apply_chat_template(ft,{tokenize:!1,add_generation_prompt:!0}))}const ot=_e.add_special_tokens??!1,at=nt?!1:_e.return_full_text??!0;this.tokenizer.padding_side="left";const{input_ids:lt,attention_mask:ut}=this.tokenizer(rt,{add_special_tokens:ot,padding:!0,truncation:!0}),dt=await this.model.generate(lt,_e,null,{inputs_attention_mask:ut});let st=this.tokenizer.batch_decode(dt,{skip_special_tokens:!0}),it;!at&&lt.dims.at(-1)>0&&(it=this.tokenizer.batch_decode(lt,{skip_special_tokens:!0}).map(ft=>ft.length));const ct=Array.from({length:_.length},ft=>[]);for(let ft=0;ft<st.length;++ft){const ht=Math.floor(ft/dt.length*_.length);it&&(st[ft]=st[ft].slice(it[ht])),ct[ht].push({generated_text:nt?[..._[ht],{role:"assistant",content:st[ft]}]:st[ft]})}return!tt&&ct.length===1?ct[0]:ct}}class ZeroShotClassificationPipeline extends Pipeline{constructor(_){super(_),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map(([_e,tt])=>[_e.toLowerCase(),tt])),this.entailment_id=this.label2id.entailment,this.entailment_id===void 0&&(console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,this.contradiction_id===void 0&&(console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(_,_e,{hypothesis_template:tt="This example is {}.",multi_label:nt=!1}={}){const rt=Array.isArray(_);rt||(_=[_]),Array.isArray(_e)||(_e=[_e]);const ot=_e.map(ut=>tt.replace("{}",ut)),at=nt||_e.length===1,lt=[];for(const ut of _){const dt=[];for(const ct of ot){const ft=this.tokenizer(ut,{text_pair:ct,padding:!0,truncation:!0}),ht=await this.model(ft);at?dt.push([ht.logits.data[this.contradiction_id],ht.logits.data[this.entailment_id]]):dt.push(ht.logits.data[this.entailment_id])}const it=(at?dt.map(ct=>softmax(ct)[1]):softmax(dt)).map((ct,ft)=>[ct,ft]).sort((ct,ft)=>ft[0]-ct[0]);lt.push({sequence:ut,labels:it.map(ct=>_e[ct[1]]),scores:it.map(ct=>ct[0])})}return rt?lt:lt[0]}}class FeatureExtractionPipeline extends Pipeline{constructor(_){super(_)}async _call(_,{pooling:_e="none",normalize:tt=!1,quantize:nt=!1,precision:rt="binary"}={}){const ot=this.tokenizer(_,{padding:!0,truncation:!0}),at=await this.model(ot);let lt=at.last_hidden_state??at.logits??at.token_embeddings;if(_e!=="none")if(_e==="mean")lt=mean_pooling(lt,ot.attention_mask);else if(_e==="cls")lt=lt.slice(null,0);else throw Error(`Pooling method '${_e}' not supported.`);return tt&&(lt=lt.normalize(2,-1)),nt&&(lt=quantize_embeddings(lt,rt)),lt}}class ImageFeatureExtractionPipeline extends Pipeline{constructor(_){super(_)}async _call(_,{pool:_e=null}={}){const tt=await prepareImages(_),{pixel_values:nt}=await this.processor(tt),rt=await this.model({pixel_values:nt});let ot;if(_e){if(!("pooler_output"in rt))throw Error("No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.");ot=rt.pooler_output}else ot=rt.last_hidden_state??rt.logits??rt.image_embeds;return ot}}class AudioClassificationPipeline extends Pipeline{constructor(_){super(_)}async _call(_,{topk:_e=null}={}){const tt=!Array.isArray(_),nt=this.processor.feature_extractor.config.sampling_rate,rt=await prepareAudios(_,nt),ot=this.model.config.id2label,at=[];for(const lt of rt){const ut=await this.processor(lt),st=(await this.model(ut)).logits[0],ct=getTopItems(softmax(st.data),_e).map(ft=>({label:ot[ft[0]],score:ft[1]}));_e===1?at.push(...ct):at.push(ct)}return!tt||_e===1?at:at[0]}}class ZeroShotAudioClassificationPipeline extends Pipeline{constructor(_){super(_)}async _call(_,_e,{hypothesis_template:tt="This is a sound of {}."}={}){const nt=!Array.isArray(_);nt&&(_=[_]);const rt=_e.map(dt=>tt.replace("{}",dt)),ot=this.tokenizer(rt,{padding:!0,truncation:!0}),at=this.processor.feature_extractor.config.sampling_rate,lt=await prepareAudios(_,at),ut=[];for(const dt of lt){const st=await this.processor(dt),it=await this.model({...ot,...st}),ct=softmax(it.logits_per_audio.data);ut.push([...ct].map((ft,ht)=>({score:ft,label:_e[ht]})))}return nt?ut[0]:ut}}class AutomaticSpeechRecognitionPipeline extends Pipeline{constructor(_){super(_)}async _call(_,_e={}){switch(this.model.config.model_type){case"whisper":return this._call_whisper(_,_e);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":return this._call_wav2vec2(_,_e);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`)}}async _call_wav2vec2(_,_e={}){_e.language&&console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'),_e.task&&console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');const tt=!Array.isArray(_);tt&&(_=[_]);const nt=this.processor.feature_extractor.config.sampling_rate,rt=await prepareAudios(_,nt),ot=[];for(const at of rt){const lt=await this.processor(at),dt=(await this.model(lt)).logits[0],st=[];for(const ct of dt)st.push(max$1(ct.data)[1]);const it=this.tokenizer.decode(st);ot.push({text:it})}return tt?ot[0]:ot}async _call_whisper(_,_e={}){const tt=_e.return_timestamps??!1,nt=_e.chunk_length_s??0,rt=_e.chunk_callback??null,ot=_e.force_full_sequences??!1;let at=_e.stride_length_s??null;tt==="word"&&(_e.return_token_timestamps=!0);const lt=pop(_e,"language",null),ut=pop(_e,"task",null);if(lt||ut||tt){if(_e.forced_decoder_ids)throw new Error("Cannot specify `language`/`task`/`return_timestamps` and `forced_decoder_ids` at the same time.");const mt=this.tokenizer.get_decoder_prompt_ids({language:lt,task:ut,no_timestamps:!tt});mt.length>0&&(_e.forced_decoder_ids=mt)}const dt=!Array.isArray(_);dt&&(_=[_]);const st=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,it=this.processor.feature_extractor.config.hop_length,ct=this.processor.feature_extractor.config.sampling_rate,ft=await prepareAudios(_,ct),ht=[];for(const mt of ft){let pt=[];if(nt>0){if(at===null)at=nt/6;else if(nt<=at)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const bt=ct*nt,wt=ct*at,xt=bt-2*wt;let Mt=0;for(;Mt<mt.length;){const At=mt.subarray(Mt,Mt+bt),St=await this.processor(At),Tt=Mt===0,Ct=Mt+xt>=mt.length;pt.push({stride:[At.length,Tt?0:wt,Ct?0:wt],input_features:St.input_features,is_last:Ct}),Mt+=xt}}else pt=[{stride:[mt.length,0,0],input_features:(await this.processor(mt)).input_features,is_last:!0}];for(const bt of pt){_e.num_frames=Math.floor(bt.stride[0]/it);const wt=await this.model.generate(bt.input_features,_e);tt==="word"?(bt.tokens=wt.sequences[0],bt.token_timestamps=wt.token_timestamps.tolist()[0].map(xt=>round$1(xt,2))):bt.tokens=wt[0],bt.stride=bt.stride.map(xt=>xt/ct),rt!==null&&rt(bt)}const[_t,vt]=this.tokenizer._decode_asr(pt,{time_precision:st,return_timestamps:tt,force_full_sequences:ot});ht.push({text:_t,...vt})}return dt?ht[0]:ht}}class ImageToTextPipeline extends Pipeline{constructor(_){super(_)}async _call(_,_e={}){const tt=Array.isArray(_),nt=await prepareImages(_),{pixel_values:rt}=await this.processor(nt),ot=[];for(const at of rt){at.dims=[1,...at.dims];const lt=await this.model.generate(at,_e),ut=this.tokenizer.batch_decode(lt,{skip_special_tokens:!0}).map(dt=>({generated_text:dt.trim()}));ot.push(ut)}return tt?ot:ot[0]}}class ImageClassificationPipeline extends Pipeline{constructor(_){super(_)}async _call(_,{topk:_e=1}={}){const tt=Array.isArray(_),nt=await prepareImages(_),{pixel_values:rt}=await this.processor(nt),ot=await this.model({pixel_values:rt}),at=this.model.config.id2label,lt=[];for(const ut of ot.logits){const st=getTopItems(softmax(ut.data),_e).map(it=>({label:at[it[0]],score:it[1]}));_e===1?lt.push(...st):lt.push(st)}return tt||_e===1?lt:lt[0]}}class ImageSegmentationPipeline extends Pipeline{constructor(_){super(_),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(_,{threshold:_e=.5,mask_threshold:tt=.5,overlap_mask_area_threshold:nt=.8,label_ids_to_fuse:rt=null,target_sizes:ot=null,subtask:at=null}={}){if(Array.isArray(_)&&_.length!==1)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const ut=await prepareImages(_),dt=ut.map(pt=>[pt.height,pt.width]),{pixel_values:st,pixel_mask:it}=await this.processor(ut),ct=await this.model({pixel_values:st,pixel_mask:it});let ft=null;if(at!==null)ft=this.subtasks_mapping[at];else for(let[pt,_t]of Object.entries(this.subtasks_mapping))if(_t in this.processor.feature_extractor){ft=this.processor.feature_extractor[_t].bind(this.processor.feature_extractor),at=pt;break}const ht=this.model.config.id2label,mt=[];if(at==="panoptic"||at==="instance"){const pt=ft(ct,_e,tt,nt,rt,ot??dt)[0],_t=pt.segmentation;for(const vt of pt.segments_info){const bt=new Uint8ClampedArray(_t.data.length);for(let xt=0;xt<_t.data.length;++xt)_t.data[xt]===vt.id&&(bt[xt]=255);const wt=new RawImage(bt,_t.dims[1],_t.dims[0],1);mt.push({score:vt.score,label:ht[vt.label_id],mask:wt})}}else if(at==="semantic"){const{segmentation:pt,labels:_t}=ft(ct,ot??dt)[0];for(const vt of _t){const bt=new Uint8ClampedArray(pt.data.length);for(let xt=0;xt<pt.data.length;++xt)pt.data[xt]===vt&&(bt[xt]=255);const wt=new RawImage(bt,pt.dims[1],pt.dims[0],1);mt.push({score:null,label:ht[vt],mask:wt})}}else throw Error(`Subtask ${at} not supported.`);return mt}}class ZeroShotImageClassificationPipeline extends Pipeline{constructor(_){super(_)}async _call(_,_e,{hypothesis_template:tt="This is a photo of {}"}={}){const nt=Array.isArray(_),rt=await prepareImages(_),ot=_e.map(it=>tt.replace("{}",it)),at=this.tokenizer(ot,{padding:this.model.config.model_type==="siglip"?"max_length":!0,truncation:!0}),{pixel_values:lt}=await this.processor(rt),ut=await this.model({...at,pixel_values:lt}),dt=this.model.config.model_type==="siglip"?it=>it.sigmoid().data:it=>softmax(it.data),st=[];for(const it of ut.logits_per_image){const ft=[...dt(it)].map((ht,mt)=>({score:ht,label:_e[mt]}));ft.sort((ht,mt)=>mt.score-ht.score),st.push(ft)}return nt?st:st[0]}}class ObjectDetectionPipeline extends Pipeline{constructor(_){super(_)}async _call(_,{threshold:_e=.9,percentage:tt=!1}={}){const nt=Array.isArray(_);if(nt&&_.length!==1)throw Error("Object detection pipeline currently only supports a batch size of 1.");const rt=await prepareImages(_),ot=tt?null:rt.map(ct=>[ct.height,ct.width]),{pixel_values:at,pixel_mask:lt}=await this.processor(rt),ut=await this.model({pixel_values:at,pixel_mask:lt}),dt=this.processor.feature_extractor.post_process_object_detection(ut,_e,ot),st=this.model.config.id2label,it=dt.map(ct=>ct.boxes.map((ft,ht)=>({score:ct.scores[ht],label:st[ct.classes[ht]],box:get_bounding_box(ft,!tt)})));return nt?it:it[0]}}class ZeroShotObjectDetectionPipeline extends Pipeline{constructor(_){super(_)}async _call(_,_e,{threshold:tt=.1,topk:nt=null,percentage:rt=!1}={}){const ot=Array.isArray(_),at=await prepareImages(_),lt=this.tokenizer(_e,{padding:!0,truncation:!0}),ut=await this.processor(at),dt=[];for(let st=0;st<at.length;++st){const it=at[st],ct=rt?null:[[it.height,it.width]],ft=ut.pixel_values[st].unsqueeze_(0),ht=await this.model({...lt,pixel_values:ft}),mt=this.processor.feature_extractor.post_process_object_detection(ht,tt,ct,!0)[0];let pt=mt.boxes.map((_t,vt)=>({score:mt.scores[vt],label:_e[mt.classes[vt]],box:get_bounding_box(_t,!rt)})).sort((_t,vt)=>vt.score-_t.score);nt!==null&&(pt=pt.slice(0,nt)),dt.push(pt)}return ot?dt:dt[0]}}class DocumentQuestionAnsweringPipeline extends Pipeline{constructor(_){super(_)}async _call(_,_e,tt={}){const nt=(await prepareImages(_))[0],{pixel_values:rt}=await this.processor(nt),ot=`<s_docvqa><s_question>${_e}</s_question><s_answer>`,at=this.tokenizer(ot,{add_special_tokens:!1,padding:!0,truncation:!0}).input_ids,lt=await this.model.generate(rt,{...tt,decoder_input_ids:at,max_length:this.model.config.decoder.max_position_embeddings}),dt=this.tokenizer.batch_decode(lt)[0].match(/<s_answer>(.*?)<\/s_answer>/);let st=null;return dt&&dt.length>=2&&(st=dt[1].trim()),[{answer:st}]}}class TextToAudioPipeline extends Pipeline{constructor(_e){super(_e);jn(this,"DEFAULT_VOCODER_ID","Xenova/speecht5_hifigan");this.vocoder=_e.vocoder??null}async _call(_e,{speaker_embeddings:tt=null}={}){return this.processor?this._call_text_to_spectrogram(_e,{speaker_embeddings:tt}):this._call_text_to_waveform(_e)}async _call_text_to_waveform(_e){const tt=this.tokenizer(_e,{padding:!0,truncation:!0}),{waveform:nt}=await this.model(tt),rt=this.model.config.sampling_rate;return{audio:nt.data,sampling_rate:rt}}async _call_text_to_spectrogram(_e,{speaker_embeddings:tt}){if(this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID,{quantized:!1})),(typeof tt=="string"||tt instanceof URL)&&(tt=new Float32Array(await(await fetch(tt)).arrayBuffer())),tt instanceof Float32Array)tt=new Tensor("float32",tt,[1,tt.length]);else if(!(tt instanceof Tensor))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");const{input_ids:nt}=this.tokenizer(_e,{padding:!0,truncation:!0}),{waveform:rt}=await this.model.generate_speech(nt,tt,{vocoder:this.vocoder}),ot=this.processor.feature_extractor.config.sampling_rate;return{audio:rt.data,sampling_rate:ot}}}class ImageToImagePipeline extends Pipeline{constructor(_){super(_)}async _call(_){const _e=await prepareImages(_),tt=await this.processor(_e),nt=await this.model(tt),rt=[];for(const ot of nt.reconstruction){const at=ot.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");rt.push(RawImage.fromTensor(at))}return rt.length>1?rt:rt[0]}}class DepthEstimationPipeline extends Pipeline{constructor(_){super(_)}async _call(_){const _e=await prepareImages(_),tt=await this.processor(_e),{predicted_depth:nt}=await this.model(tt),rt=[];for(let ot=0;ot<_e.length;++ot){const at=interpolate(nt[ot],_e[ot].size.reverse(),"bilinear",!1),lt=at.mul_(255/max$1(at.data)[0]).to("uint8");rt.push({predicted_depth:nt[ot],depth:RawImage.fromTensor(lt)})}return rt.length>1?rt:rt[0]}}const SUPPORTED_TASKS=Object.freeze({"text-classification":{tokenizer:AutoTokenizer,pipeline:TextClassificationPipeline,model:AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:AutoTokenizer,pipeline:TokenClassificationPipeline,model:AutoModelForTokenClassification,default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:AutoTokenizer,pipeline:QuestionAnsweringPipeline,model:AutoModelForQuestionAnswering,default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:AutoTokenizer,pipeline:FillMaskPipeline,model:AutoModelForMaskedLM,default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:AutoTokenizer,pipeline:SummarizationPipeline,model:AutoModelForSeq2SeqLM,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:AutoTokenizer,pipeline:TranslationPipeline,model:AutoModelForSeq2SeqLM,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:AutoTokenizer,pipeline:Text2TextGenerationPipeline,model:AutoModelForSeq2SeqLM,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:AutoTokenizer,pipeline:TextGenerationPipeline,model:AutoModelForCausalLM,default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:AutoTokenizer,pipeline:ZeroShotClassificationPipeline,model:AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:AudioClassificationPipeline,model:AutoModelForAudioClassification,processor:AutoProcessor,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:AutoTokenizer,pipeline:ZeroShotAudioClassificationPipeline,model:AutoModel,processor:AutoProcessor,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:AutoTokenizer,pipeline:AutomaticSpeechRecognitionPipeline,model:[AutoModelForSpeechSeq2Seq,AutoModelForCTC],processor:AutoProcessor,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:AutoTokenizer,pipeline:TextToAudioPipeline,model:[AutoModelForTextToWaveform,AutoModelForTextToSpectrogram],processor:[AutoProcessor,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:AutoTokenizer,pipeline:ImageToTextPipeline,model:AutoModelForVision2Seq,processor:AutoProcessor,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:ImageClassificationPipeline,model:AutoModelForImageClassification,processor:AutoProcessor,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:ImageSegmentationPipeline,model:[AutoModelForImageSegmentation,AutoModelForSemanticSegmentation],processor:AutoProcessor,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"zero-shot-image-classification":{tokenizer:AutoTokenizer,pipeline:ZeroShotImageClassificationPipeline,model:AutoModel,processor:AutoProcessor,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:ObjectDetectionPipeline,model:AutoModelForObjectDetection,processor:AutoProcessor,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:AutoTokenizer,pipeline:ZeroShotObjectDetectionPipeline,model:AutoModelForZeroShotObjectDetection,processor:AutoProcessor,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:AutoTokenizer,pipeline:DocumentQuestionAnsweringPipeline,model:AutoModelForDocumentQuestionAnswering,processor:AutoProcessor,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:ImageToImagePipeline,model:AutoModelForImageToImage,processor:AutoProcessor,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:DepthEstimationPipeline,model:AutoModelForDepthEstimation,processor:AutoProcessor,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:AutoTokenizer,pipeline:FeatureExtractionPipeline,model:AutoModel,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:AutoProcessor,pipeline:ImageFeatureExtractionPipeline,model:[AutoModelForImageFeatureExtraction,AutoModel],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),TASK_ALIASES=Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});async function pipeline(et,_=null,{quantized:_e=!0,progress_callback:tt=null,config:nt=null,cache_dir:rt=null,local_files_only:ot=!1,revision:at="main",model_file_name:lt=null}={}){et=TASK_ALIASES[et]??et;const ut=SUPPORTED_TASKS[et.split("_",1)[0]];if(!ut)throw Error(`Unsupported pipeline: ${et}. Must be one of [${Object.keys(SUPPORTED_TASKS)}]`);_||(_=ut.default.model,console.log(`No model specified. Using default model: "${_}".`));const dt={quantized:_e,progress_callback:tt,config:nt,cache_dir:rt,local_files_only:ot,revision:at,model_file_name:lt},st=new Map([["tokenizer",ut.tokenizer],["model",ut.model],["processor",ut.processor]]),it=await loadItems(st,_,dt);it.task=et,dispatchCallback(tt,{status:"ready",task:et,model:_});const ct=ut.pipeline;return new ct(it)}async function loadItems(et,_,_e){const tt=Object.create(null),nt=[];for(let[rt,ot]of et.entries()){if(!ot)continue;let at;Array.isArray(ot)?at=new Promise(async(lt,ut)=>{let dt;for(let st of ot){if(st===null){lt(null);return}try{lt(await st.from_pretrained(_,_e));return}catch(it){dt=it}}ut(dt)}):at=ot.from_pretrained(_,_e),tt[rt]=at,nt.push(at)}await Promise.all(nt);for(let[rt,ot]of Object.entries(tt))tt[rt]=await ot;return tt}env$1.allowLocalModels=!1;env$1.backends.onnx.wasm.proxy=!0;const useDepthEstimator=et=>{const[_,_e]=reactExports.useState(),[tt,nt]=reactExports.useState();return reactExports.useEffect(()=>{async function rt(){const ot=await pipeline("depth-estimation","Xenova/depth-anything-small-hf");_e(()=>ot)}rt()},[]),reactExports.useEffect(()=>{async function rt(){const ot=await RawImage.fromURL(et),{depth:at}=await _(ot);nt(at)}_&&(nt(null),rt())},[_,et]),tt};function setRef(et,_){typeof et=="function"?et(_):et!=null&&(et.current=_)}function composeRefs(...et){return _=>et.forEach(_e=>setRef(_e,_))}function useComposedRefs(...et){return reactExports.useCallback(composeRefs(...et),et)}var Slot=reactExports.forwardRef((et,_)=>{const{children:_e,...tt}=et,nt=reactExports.Children.toArray(_e),rt=nt.find(isSlottable);if(rt){const ot=rt.props.children,at=nt.map(lt=>lt===rt?reactExports.Children.count(ot)>1?reactExports.Children.only(null):reactExports.isValidElement(ot)?ot.props.children:null:lt);return jsxRuntimeExports.jsx(SlotClone,{...tt,ref:_,children:reactExports.isValidElement(ot)?reactExports.cloneElement(ot,void 0,at):null})}return jsxRuntimeExports.jsx(SlotClone,{...tt,ref:_,children:_e})});Slot.displayName="Slot";var SlotClone=reactExports.forwardRef((et,_)=>{const{children:_e,...tt}=et;if(reactExports.isValidElement(_e)){const nt=getElementRef$1(_e);return reactExports.cloneElement(_e,{...mergeProps(tt,_e.props),ref:_?composeRefs(_,nt):nt})}return reactExports.Children.count(_e)>1?reactExports.Children.only(null):null});SlotClone.displayName="SlotClone";var Slottable=({children:et})=>jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment,{children:et});function isSlottable(et){return reactExports.isValidElement(et)&&et.type===Slottable}function mergeProps(et,_){const _e={..._};for(const tt in _){const nt=et[tt],rt=_[tt];/^on[A-Z]/.test(tt)?nt&&rt?_e[tt]=(...at)=>{rt(...at),nt(...at)}:nt&&(_e[tt]=nt):tt==="style"?_e[tt]={...nt,...rt}:tt==="className"&&(_e[tt]=[nt,rt].filter(Boolean).join(" "))}return{...et,..._e}}function getElementRef$1(et){var tt,nt;let _=(tt=Object.getOwnPropertyDescriptor(et.props,"ref"))==null?void 0:tt.get,_e=_&&"isReactWarning"in _&&_.isReactWarning;return _e?et.ref:(_=(nt=Object.getOwnPropertyDescriptor(et,"ref"))==null?void 0:nt.get,_e=_&&"isReactWarning"in _&&_.isReactWarning,_e?et.props.ref:et.props.ref||et.ref)}var NODES=["a","button","div","form","h2","h3","img","input","label","li","nav","ol","p","span","svg","ul"],Primitive=NODES.reduce((et,_)=>{const _e=reactExports.forwardRef((tt,nt)=>{const{asChild:rt,...ot}=tt,at=rt?Slot:_;return typeof window<"u"&&(window[Symbol.for("radix-ui")]=!0),jsxRuntimeExports.jsx(at,{...ot,ref:nt})});return _e.displayName=`Primitive.${_}`,{...et,[_]:_e}},{});function dispatchDiscreteCustomEvent(et,_){et&&reactDomExports.flushSync(()=>et.dispatchEvent(_))}var useLayoutEffect2=globalThis!=null&&globalThis.document?reactExports.useLayoutEffect:()=>{},PORTAL_NAME$1="Portal",Portal$1=reactExports.forwardRef((et,_)=>{var at;const{container:_e,...tt}=et,[nt,rt]=reactExports.useState(!1);useLayoutEffect2(()=>rt(!0),[]);const ot=_e||nt&&((at=globalThis==null?void 0:globalThis.document)==null?void 0:at.body);return ot?ReactDOM.createPortal(jsxRuntimeExports.jsx(Primitive.div,{...tt,ref:_}),ot):null});Portal$1.displayName=PORTAL_NAME$1;var Root$2=Portal$1,has=Object.prototype.hasOwnProperty;function dequal(et,_){var _e,tt;if(et===_)return!0;if(et&&_&&(_e=et.constructor)===_.constructor){if(_e===Date)return et.getTime()===_.getTime();if(_e===RegExp)return et.toString()===_.toString();if(_e===Array){if((tt=et.length)===_.length)for(;tt--&&dequal(et[tt],_[tt]););return tt===-1}if(!_e||typeof et=="object"){tt=0;for(_e in et)if(has.call(et,_e)&&++tt&&!has.call(_,_e)||!(_e in _)||!dequal(et[_e],_[_e]))return!1;return Object.keys(_).length===tt}}return et!==et&&_!==_}var Rule=function et(_,_e,tt,nt){this.name=_,this.fn=_e,this.args=tt,this.modifiers=nt};Rule.prototype._test=function et(_){var _e=this.fn;try{testAux(this.modifiers.slice(),_e,this)(_)}catch{_e=function(){return!1}}try{return testAux(this.modifiers.slice(),_e,this)(_)}catch{return!1}};Rule.prototype._check=function et(_){try{testAux(this.modifiers.slice(),this.fn,this)(_)}catch{if(testAux(this.modifiers.slice(),function(tt){return tt},this)(!1))return}if(!testAux(this.modifiers.slice(),this.fn,this)(_))throw null};Rule.prototype._testAsync=function et(_){var _e=this;return new Promise(function(tt,nt){testAsyncAux(_e.modifiers.slice(),_e.fn,_e)(_).then(function(rt){rt?tt(_):nt(null)}).catch(function(rt){return nt(rt)})})};function pickFn(et,_){return _===void 0&&(_="simple"),typeof et=="object"?et[_]:et}function testAux(et,_,_e){if(et.length){var tt=et.shift(),nt=testAux(et,_,_e);return tt.perform(nt,_e)}else return pickFn(_)}function testAsyncAux(et,_,_e){if(et.length){var tt=et.shift(),nt=testAsyncAux(et,_,_e);return tt.performAsync(nt,_e)}else return function(rt){return Promise.resolve(pickFn(_,"async")(rt))}}var Modifier=function et(_,_e,tt){this.name=_,this.perform=_e,this.performAsync=tt},ValidationError=function(et){function _(_e,tt,nt,rt){for(var ot=[],at=arguments.length-4;at-- >0;)ot[at]=arguments[at+4];et.call(this,ot),et.captureStackTrace&&et.captureStackTrace(this,_),this.rule=_e,this.value=tt,this.cause=nt,this.target=rt}return et&&(_.__proto__=et),_.prototype=Object.create(et&&et.prototype),_.prototype.constructor=_,_}(Error),Context=function et(_,_e){_===void 0&&(_=[]),_e===void 0&&(_e=[]),this.chain=_,this.nextRuleModifiers=_e};Context.prototype._applyRule=function et(_,_e){var tt=this;return function(){for(var nt=[],rt=arguments.length;rt--;)nt[rt]=arguments[rt];return tt.chain.push(new Rule(_e,_.apply(tt,nt),nt,tt.nextRuleModifiers)),tt.nextRuleModifiers=[],tt}};Context.prototype._applyModifier=function et(_,_e){return this.nextRuleModifiers.push(new Modifier(_e,_.simple,_.async)),this};Context.prototype._clone=function et(){return new Context(this.chain.slice(),this.nextRuleModifiers.slice())};Context.prototype.test=function et(_){return this.chain.every(function(_e){return _e._test(_)})};Context.prototype.testAll=function et(_){var _e=[];return this.chain.forEach(function(tt){try{tt._check(_)}catch(nt){_e.push(new ValidationError(tt,_,nt))}}),_e};Context.prototype.check=function et(_){this.chain.forEach(function(_e){try{_e._check(_)}catch(tt){throw new ValidationError(_e,_,tt)}})};Context.prototype.testAsync=function et(_){var _e=this;return new Promise(function(tt,nt){executeAsyncRules(_,_e.chain.slice(),tt,nt)})};function executeAsyncRules(et,_,_e,tt){if(_.length){var nt=_.shift();nt._testAsync(et).then(function(){executeAsyncRules(et,_,_e,tt)},function(rt){tt(new ValidationError(nt,et,rt))})}else _e(et)}var consideredEmpty=function(et,_){return _&&typeof et=="string"&&et.trim().length===0?!0:et==null};function optional(et,_){return _===void 0&&(_=!1),{simple:function(_e){return consideredEmpty(_e,_)||et.check(_e)===void 0},async:function(_e){return consideredEmpty(_e,_)||et.testAsync(_e)}}}function v8n(){return typeof Proxy<"u"?proxyContext(new Context):proxylessContext(new Context)}var customRules={};v8n.extend=function(et){Object.assign(customRules,et)};v8n.clearCustomRules=function(){customRules={}};function proxyContext(et){return new Proxy(et,{get:function(_e,tt){if(tt in _e)return _e[tt];var nt=proxyContext(et._clone());if(tt in availableModifiers)return nt._applyModifier(availableModifiers[tt],tt);if(tt in customRules)return nt._applyRule(customRules[tt],tt);if(tt in availableRules)return nt._applyRule(availableRules[tt],tt)}})}function proxylessContext(et){var _=function(nt,rt){return Object.keys(nt).forEach(function(ot){rt[ot]=function(){for(var at=[],lt=arguments.length;lt--;)at[lt]=arguments[lt];var ut=proxylessContext(rt._clone()),dt=ut._applyRule(nt[ot],ot).apply(void 0,at);return dt}}),rt},_e=_(availableRules,et),tt=_(customRules,_e);return Object.keys(availableModifiers).forEach(function(nt){Object.defineProperty(tt,nt,{get:function(){var rt=proxylessContext(tt._clone());return rt._applyModifier(availableModifiers[nt],nt)}})}),tt}var availableModifiers={not:{simple:function(et){return function(_){return!et(_)}},async:function(et){return function(_){return Promise.resolve(et(_)).then(function(_e){return!_e}).catch(function(){return!0})}}},some:{simple:function(et){return function(_){return split$1(_).some(function(_e){try{return et(_e)}catch{return!1}})}},async:function(et){return function(_){return Promise.all(split$1(_).map(function(_e){try{return et(_e).catch(function(){return!1})}catch{return!1}})).then(function(_e){return _e.some(Boolean)})}}},every:{simple:function(et){return function(_){return _!==!1&&split$1(_).every(et)}},async:function(et){return function(_){return Promise.all(split$1(_).map(et)).then(function(_e){return _e.every(Boolean)})}}},strict:{simple:function(et,_){return function(_e){return isSchemaRule(_)&&_e&&typeof _e=="object"?Object.keys(_.args[0]).length===Object.keys(_e).length&&et(_e):et(_e)}},async:function(et,_){return function(_e){return Promise.resolve(et(_e)).then(function(tt){return isSchemaRule(_)&&_e&&typeof _e=="object"?Object.keys(_.args[0]).length===Object.keys(_e).length&&tt:tt}).catch(function(){return!1})}}}};function isSchemaRule(et){return et&&et.name==="schema"&&et.args.length>0&&typeof et.args[0]=="object"}function split$1(et){return typeof et=="string"?et.split(""):et}var availableRules={equal:function(et){return function(_){return _==et}},exact:function(et){return function(_){return _===et}},number:function(et){return et===void 0&&(et=!0),function(_){return typeof _=="number"&&(et||isFinite(_))}},integer:function(){return function(et){var _=Number.isInteger||isIntegerPolyfill;return _(et)}},numeric:function(){return function(et){return!isNaN(parseFloat(et))&&isFinite(et)}},string:function(){return testType("string")},boolean:function(){return testType("boolean")},undefined:function(){return testType("undefined")},null:function(){return testType("null")},array:function(){return testType("array")},object:function(){return testType("object")},instanceOf:function(et){return function(_){return _ instanceof et}},pattern:function(et){return function(_){return et.test(_)}},lowercase:function(){return function(et){return typeof et=="boolean"||et===et.toLowerCase()&&et.trim()!==""}},uppercase:function(){return function(et){return et===et.toUpperCase()&&et.trim()!==""}},vowel:function(){return function(et){return/^[aeiou]+$/i.test(et)}},consonant:function(){return function(et){return/^(?=[^aeiou])([a-z]+)$/i.test(et)}},first:function(et){return function(_){return _[0]==et}},last:function(et){return function(_){return _[_.length-1]==et}},empty:function(){return function(et){return et.length===0}},length:function(et,_){return function(_e){return _e.length>=et&&_e.length<=(_||et)}},minLength:function(et){return function(_){return _.length>=et}},maxLength:function(et){return function(_){return _.length<=et}},negative:function(){return function(et){return et<0}},positive:function(){return function(et){return et>=0}},between:function(et,_){return function(_e){return _e>=et&&_e<=_}},range:function(et,_){return function(_e){return _e>=et&&_e<=_}},lessThan:function(et){return function(_){return _<et}},lessThanOrEqual:function(et){return function(_){return _<=et}},greaterThan:function(et){return function(_){return _>et}},greaterThanOrEqual:function(et){return function(_){return _>=et}},even:function(){return function(et){return et%2===0}},odd:function(){return function(et){return et%2!==0}},includes:function(et){return function(_){return~_.indexOf(et)}},schema:function(et){return testSchema(et)},passesAnyOf:function(){for(var et=[],_=arguments.length;_--;)et[_]=arguments[_];return function(_e){return et.some(function(tt){return tt.test(_e)})}},optional};function testType(et){return function(_){return Array.isArray(_)&&et==="array"||_===null&&et==="null"||typeof _===et}}function isIntegerPolyfill(et){return typeof et=="number"&&isFinite(et)&&Math.floor(et)===et}function testSchema(et){return{simple:function(_){var _e=[];if(Object.keys(et).forEach(function(tt){var nt=et[tt];try{nt.check((_||{})[tt])}catch(rt){rt.target=tt,_e.push(rt)}}),_e.length>0)throw _e;return!0},async:function(_){var _e=[],tt=Object.keys(et).map(function(nt){var rt=et[nt];return rt.testAsync((_||{})[nt]).catch(function(ot){ot.target=nt,_e.push(ot)})});return Promise.all(tt).then(function(){if(_e.length>0)throw _e;return!0})}}}var e$1="colors",t$1="sizes",r$1="space",n$1={gap:r$1,gridGap:r$1,columnGap:r$1,gridColumnGap:r$1,rowGap:r$1,gridRowGap:r$1,inset:r$1,insetBlock:r$1,insetBlockEnd:r$1,insetBlockStart:r$1,insetInline:r$1,insetInlineEnd:r$1,insetInlineStart:r$1,margin:r$1,marginTop:r$1,marginRight:r$1,marginBottom:r$1,marginLeft:r$1,marginBlock:r$1,marginBlockEnd:r$1,marginBlockStart:r$1,marginInline:r$1,marginInlineEnd:r$1,marginInlineStart:r$1,padding:r$1,paddingTop:r$1,paddingRight:r$1,paddingBottom:r$1,paddingLeft:r$1,paddingBlock:r$1,paddingBlockEnd:r$1,paddingBlockStart:r$1,paddingInline:r$1,paddingInlineEnd:r$1,paddingInlineStart:r$1,top:r$1,right:r$1,bottom:r$1,left:r$1,scrollMargin:r$1,scrollMarginTop:r$1,scrollMarginRight:r$1,scrollMarginBottom:r$1,scrollMarginLeft:r$1,scrollMarginX:r$1,scrollMarginY:r$1,scrollMarginBlock:r$1,scrollMarginBlockEnd:r$1,scrollMarginBlockStart:r$1,scrollMarginInline:r$1,scrollMarginInlineEnd:r$1,scrollMarginInlineStart:r$1,scrollPadding:r$1,scrollPaddingTop:r$1,scrollPaddingRight:r$1,scrollPaddingBottom:r$1,scrollPaddingLeft:r$1,scrollPaddingX:r$1,scrollPaddingY:r$1,scrollPaddingBlock:r$1,scrollPaddingBlockEnd:r$1,scrollPaddingBlockStart:r$1,scrollPaddingInline:r$1,scrollPaddingInlineEnd:r$1,scrollPaddingInlineStart:r$1,fontSize:"fontSizes",background:e$1,backgroundColor:e$1,backgroundImage:e$1,borderImage:e$1,border:e$1,borderBlock:e$1,borderBlockEnd:e$1,borderBlockStart:e$1,borderBottom:e$1,borderBottomColor:e$1,borderColor:e$1,borderInline:e$1,borderInlineEnd:e$1,borderInlineStart:e$1,borderLeft:e$1,borderLeftColor:e$1,borderRight:e$1,borderRightColor:e$1,borderTop:e$1,borderTopColor:e$1,caretColor:e$1,color:e$1,columnRuleColor:e$1,fill:e$1,outline:e$1,outlineColor:e$1,stroke:e$1,textDecorationColor:e$1,fontFamily:"fonts",fontWeight:"fontWeights",lineHeight:"lineHeights",letterSpacing:"letterSpacings",blockSize:t$1,minBlockSize:t$1,maxBlockSize:t$1,inlineSize:t$1,minInlineSize:t$1,maxInlineSize:t$1,width:t$1,minWidth:t$1,maxWidth:t$1,height:t$1,minHeight:t$1,maxHeight:t$1,flexBasis:t$1,gridTemplateColumns:t$1,gridTemplateRows:t$1,borderWidth:"borderWidths",borderTopWidth:"borderWidths",borderRightWidth:"borderWidths",borderBottomWidth:"borderWidths",borderLeftWidth:"borderWidths",borderStyle:"borderStyles",borderTopStyle:"borderStyles",borderRightStyle:"borderStyles",borderBottomStyle:"borderStyles",borderLeftStyle:"borderStyles",borderRadius:"radii",borderTopLeftRadius:"radii",borderTopRightRadius:"radii",borderBottomRightRadius:"radii",borderBottomLeftRadius:"radii",boxShadow:"shadows",textShadow:"shadows",transition:"transitions",zIndex:"zIndices"},i$2=(et,_)=>typeof _=="function"?{"()":Function.prototype.toString.call(_)}:_,o$1=()=>{const et=Object.create(null);return(_,_e,...tt)=>{const nt=(rt=>JSON.stringify(rt,i$2))(_);return nt in et?et[nt]:et[nt]=_e(_,...tt)}},l$1=Symbol.for("sxs.internal"),s$2=(et,_)=>Object.defineProperties(et,Object.getOwnPropertyDescriptors(_)),a$1=et=>{for(const _ in et)return!0;return!1},{hasOwnProperty:c$2}=Object.prototype,d$2=et=>et.includes("-")?et:et.replace(/[A-Z]/g,_=>"-"+_.toLowerCase()),g$2=/\s+(?![^()]*\))/,p$2=et=>_=>et(...typeof _=="string"?String(_).split(g$2):[_]),u$2={appearance:et=>({WebkitAppearance:et,appearance:et}),backfaceVisibility:et=>({WebkitBackfaceVisibility:et,backfaceVisibility:et}),backdropFilter:et=>({WebkitBackdropFilter:et,backdropFilter:et}),backgroundClip:et=>({WebkitBackgroundClip:et,backgroundClip:et}),boxDecorationBreak:et=>({WebkitBoxDecorationBreak:et,boxDecorationBreak:et}),clipPath:et=>({WebkitClipPath:et,clipPath:et}),content:et=>({content:et.includes('"')||et.includes("'")||/^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(et)?et:`"${et}"`}),hyphens:et=>({WebkitHyphens:et,hyphens:et}),maskImage:et=>({WebkitMaskImage:et,maskImage:et}),maskSize:et=>({WebkitMaskSize:et,maskSize:et}),tabSize:et=>({MozTabSize:et,tabSize:et}),textSizeAdjust:et=>({WebkitTextSizeAdjust:et,textSizeAdjust:et}),userSelect:et=>({WebkitUserSelect:et,userSelect:et}),marginBlock:p$2((et,_)=>({marginBlockStart:et,marginBlockEnd:_||et})),marginInline:p$2((et,_)=>({marginInlineStart:et,marginInlineEnd:_||et})),maxSize:p$2((et,_)=>({maxBlockSize:et,maxInlineSize:_||et})),minSize:p$2((et,_)=>({minBlockSize:et,minInlineSize:_||et})),paddingBlock:p$2((et,_)=>({paddingBlockStart:et,paddingBlockEnd:_||et})),paddingInline:p$2((et,_)=>({paddingInlineStart:et,paddingInlineEnd:_||et}))},h$2=/([\d.]+)([^]*)/,f$2=(et,_)=>et.length?et.reduce((_e,tt)=>(_e.push(..._.map(nt=>nt.includes("&")?nt.replace(/&/g,/[ +>|~]/.test(tt)&&/&.*&/.test(nt)?`:is(${tt})`:tt):tt+" "+nt)),_e),[]):_,m$2=(et,_)=>et in b$2&&typeof _=="string"?_.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/,(_e,tt,nt,rt)=>tt+(nt==="stretch"?`-moz-available${rt};${d$2(et)}:${tt}-webkit-fill-available`:`-moz-fit-content${rt};${d$2(et)}:${tt}fit-content`)+rt):String(_),b$2={blockSize:1,height:1,inlineSize:1,maxBlockSize:1,maxHeight:1,maxInlineSize:1,maxWidth:1,minBlockSize:1,minHeight:1,minInlineSize:1,minWidth:1,width:1},S$2=et=>et?et+"-":"",k$2=(et,_,_e)=>et.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g,(tt,nt,rt,ot,at)=>ot=="$"==!!rt?tt:(nt||ot=="--"?"calc(":"")+"var(--"+(ot==="$"?S$2(_)+(at.includes("$")?"":S$2(_e))+at.replace(/\$/g,"-"):at)+")"+(nt||ot=="--"?"*"+(nt||"")+(rt||"1")+")":"")),y$2=/\s*,\s*(?![^()]*\))/,B=Object.prototype.toString,$$2=(et,_,_e,tt,nt)=>{let rt,ot,at;const lt=(ut,dt,st)=>{let it,ct;const ft=ht=>{for(it in ht){const _t=it.charCodeAt(0)===64,vt=_t&&Array.isArray(ht[it])?ht[it]:[ht[it]];for(ct of vt){const bt=/[A-Z]/.test(pt=it)?pt:pt.replace(/-[^]/g,xt=>xt[1].toUpperCase()),wt=typeof ct=="object"&&ct&&ct.toString===B&&(!tt.utils[bt]||!dt.length);if(bt in tt.utils&&!wt){const xt=tt.utils[bt];if(xt!==ot){ot=xt,ft(xt(ct)),ot=null;continue}}else if(bt in u$2){const xt=u$2[bt];if(xt!==at){at=xt,ft(xt(ct)),at=null;continue}}if(_t&&(mt=it.slice(1)in tt.media?"@media "+tt.media[it.slice(1)]:it,it=mt.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g,(xt,Mt,At,St,Tt,Ct)=>{const It=h$2.test(Mt),$t=.0625*(It?-1:1),[Nt,Bt]=It?[St,Mt]:[Mt,St];return"("+(At[0]==="="?"":At[0]===">"===It?"max-":"min-")+Nt+":"+(At[0]!=="="&&At.length===1?Bt.replace(h$2,(Ot,Ut,Lt)=>Number(Ut)+$t*(At===">"?1:-1)+Lt):Bt)+(Tt?") and ("+(Tt[0]===">"?"min-":"max-")+Nt+":"+(Tt.length===1?Ct.replace(h$2,(Ot,Ut,Lt)=>Number(Ut)+$t*(Tt===">"?-1:1)+Lt):Ct):"")+")"})),wt){const xt=_t?st.concat(it):[...st],Mt=_t?[...dt]:f$2(dt,it.split(y$2));rt!==void 0&&nt(x$1(...rt)),rt=void 0,lt(ct,Mt,xt)}else rt===void 0&&(rt=[[],dt,st]),it=_t||it.charCodeAt(0)!==36?it:`--${S$2(tt.prefix)}${it.slice(1).replace(/\$/g,"-")}`,ct=wt?ct:typeof ct=="number"?ct&&bt in I$2?String(ct)+"px":String(ct):k$2(m$2(bt,ct??""),tt.prefix,tt.themeMap[bt]),rt[0].push(`${_t?`${it} `:`${d$2(it)}:`}${ct}`)}}var mt,pt};ft(ut),rt!==void 0&&nt(x$1(...rt)),rt=void 0};lt(et,_,_e)},x$1=(et,_,_e)=>`${_e.map(tt=>`${tt}{`).join("")}${_.length?`${_.join(",")}{`:""}${et.join(";")}${_.length?"}":""}${Array(_e.length?_e.length+1:0).join("}")}`,I$2={animationDelay:1,animationDuration:1,backgroundSize:1,blockSize:1,border:1,borderBlock:1,borderBlockEnd:1,borderBlockEndWidth:1,borderBlockStart:1,borderBlockStartWidth:1,borderBlockWidth:1,borderBottom:1,borderBottomLeftRadius:1,borderBottomRightRadius:1,borderBottomWidth:1,borderEndEndRadius:1,borderEndStartRadius:1,borderInlineEnd:1,borderInlineEndWidth:1,borderInlineStart:1,borderInlineStartWidth:1,borderInlineWidth:1,borderLeft:1,borderLeftWidth:1,borderRadius:1,borderRight:1,borderRightWidth:1,borderSpacing:1,borderStartEndRadius:1,borderStartStartRadius:1,borderTop:1,borderTopLeftRadius:1,borderTopRightRadius:1,borderTopWidth:1,borderWidth:1,bottom:1,columnGap:1,columnRule:1,columnRuleWidth:1,columnWidth:1,containIntrinsicSize:1,flexBasis:1,fontSize:1,gap:1,gridAutoColumns:1,gridAutoRows:1,gridTemplateColumns:1,gridTemplateRows:1,height:1,inlineSize:1,inset:1,insetBlock:1,insetBlockEnd:1,insetBlockStart:1,insetInline:1,insetInlineEnd:1,insetInlineStart:1,left:1,letterSpacing:1,margin:1,marginBlock:1,marginBlockEnd:1,marginBlockStart:1,marginBottom:1,marginInline:1,marginInlineEnd:1,marginInlineStart:1,marginLeft:1,marginRight:1,marginTop:1,maxBlockSize:1,maxHeight:1,maxInlineSize:1,maxWidth:1,minBlockSize:1,minHeight:1,minInlineSize:1,minWidth:1,offsetDistance:1,offsetRotate:1,outline:1,outlineOffset:1,outlineWidth:1,overflowClipMargin:1,padding:1,paddingBlock:1,paddingBlockEnd:1,paddingBlockStart:1,paddingBottom:1,paddingInline:1,paddingInlineEnd:1,paddingInlineStart:1,paddingLeft:1,paddingRight:1,paddingTop:1,perspective:1,right:1,rowGap:1,scrollMargin:1,scrollMarginBlock:1,scrollMarginBlockEnd:1,scrollMarginBlockStart:1,scrollMarginBottom:1,scrollMarginInline:1,scrollMarginInlineEnd:1,scrollMarginInlineStart:1,scrollMarginLeft:1,scrollMarginRight:1,scrollMarginTop:1,scrollPadding:1,scrollPaddingBlock:1,scrollPaddingBlockEnd:1,scrollPaddingBlockStart:1,scrollPaddingBottom:1,scrollPaddingInline:1,scrollPaddingInlineEnd:1,scrollPaddingInlineStart:1,scrollPaddingLeft:1,scrollPaddingRight:1,scrollPaddingTop:1,shapeMargin:1,textDecoration:1,textDecorationThickness:1,textIndent:1,textUnderlineOffset:1,top:1,transitionDelay:1,transitionDuration:1,verticalAlign:1,width:1,wordSpacing:1},R=et=>String.fromCharCode(et+(et>25?39:97)),z=et=>(_=>{let _e,tt="";for(_e=Math.abs(_);_e>52;_e=_e/52|0)tt=R(_e%52)+tt;return R(_e%52)+tt})(((_,_e)=>{let tt=_e.length;for(;tt;)_=33*_^_e.charCodeAt(--tt);return _})(5381,JSON.stringify(et))>>>0),W=["themed","global","styled","onevar","resonevar","allvar","inline"],j$1=et=>{if(et.href&&!et.href.startsWith(location.origin))return!1;try{return!!et.cssRules}catch{return!1}},E=et=>{let _;const _e=()=>{const{cssRules:nt}=_.sheet;return[].map.call(nt,(rt,ot)=>{const{cssText:at}=rt;let lt="";if(at.startsWith("--sxs"))return"";if(nt[ot-1]&&(lt=nt[ot-1].cssText).startsWith("--sxs")){if(!rt.cssRules.length)return"";for(const ut in _.rules)if(_.rules[ut].group===rt)return`--sxs{--sxs:${[..._.rules[ut].cache].join(" ")}}${at}`;return rt.cssRules.length?`${lt}${at}`:""}return at}).join("")},tt=()=>{if(_){const{rules:at,sheet:lt}=_;if(!lt.deleteRule){for(;Object(Object(lt.cssRules)[0]).type===3;)lt.cssRules.splice(0,1);lt.cssRules=[]}for(const ut in at)delete at[ut]}const nt=Object(et).styleSheets||[];for(const at of nt)if(j$1(at)){for(let lt=0,ut=at.cssRules;ut[lt];++lt){const dt=Object(ut[lt]);if(dt.type!==1)continue;const st=Object(ut[lt+1]);if(st.type!==4)continue;++lt;const{cssText:it}=dt;if(!it.startsWith("--sxs"))continue;const ct=it.slice(14,-3).trim().split(/\s+/),ft=W[ct[0]];ft&&(_||(_={sheet:at,reset:tt,rules:{},toString:_e}),_.rules[ft]={group:st,index:lt,cache:new Set(ct)})}if(_)break}if(!_){const at=(lt,ut)=>({type:ut,cssRules:[],insertRule(dt,st){this.cssRules.splice(st,0,at(dt,{import:3,undefined:1}[(dt.toLowerCase().match(/^@([a-z]+)/)||[])[1]]||4))},get cssText(){return lt==="@media{}"?`@media{${[].map.call(this.cssRules,dt=>dt.cssText).join("")}}`:lt}});_={sheet:et?(et.head||et).appendChild(document.createElement("style")).sheet:at("","text/css"),rules:{},reset:tt,toString:_e}}const{sheet:rt,rules:ot}=_;for(let at=W.length-1;at>=0;--at){const lt=W[at];if(!ot[lt]){const ut=W[at+1],dt=ot[ut]?ot[ut].index:rt.cssRules.length;rt.insertRule("@media{}",dt),rt.insertRule(`--sxs{--sxs:${at}}`,dt),ot[lt]={group:rt.cssRules[dt+1],index:dt,cache:new Set([at])}}v$2(ot[lt])}};return tt(),_},v$2=et=>{const _=et.group;let _e=_.cssRules.length;et.apply=tt=>{try{_.insertRule(tt,_e),++_e}catch{}}},T$1=Symbol(),w$1=o$1(),M$1=(et,_)=>w$1(et,()=>(..._e)=>{let tt={type:null,composers:new Set};for(const nt of _e)if(nt!=null)if(nt[l$1]){tt.type==null&&(tt.type=nt[l$1].type);for(const rt of nt[l$1].composers)tt.composers.add(rt)}else nt.constructor!==Object||nt.$$typeof?tt.type==null&&(tt.type=nt):tt.composers.add(C(nt,et));return tt.type==null&&(tt.type="span"),tt.composers.size||tt.composers.add(["PJLV",{},[],[],{},[]]),P(et,tt,_)}),C=({variants:et,compoundVariants:_,defaultVariants:_e,...tt},nt)=>{const rt=`${S$2(nt.prefix)}c-${z(tt)}`,ot=[],at=[],lt=Object.create(null),ut=[];for(const it in _e)lt[it]=String(_e[it]);if(typeof et=="object"&&et)for(const it in et){dt=lt,st=it,c$2.call(dt,st)||(lt[it]="undefined");const ct=et[it];for(const ft in ct){const ht={[it]:String(ft)};String(ft)==="undefined"&&ut.push(it);const mt=ct[ft],pt=[ht,mt,!a$1(mt)];ot.push(pt)}}var dt,st;if(typeof _=="object"&&_)for(const it of _){let{css:ct,...ft}=it;ct=typeof ct=="object"&&ct||{};for(const mt in ft)ft[mt]=String(ft[mt]);const ht=[ft,ct,!a$1(ct)];at.push(ht)}return[rt,tt,ot,at,lt,ut]},P=(et,_,_e)=>{const[tt,nt,rt,ot]=L$1(_.composers),at=typeof _.type=="function"||_.type.$$typeof?(st=>{function it(){for(let ct=0;ct<it[T$1].length;ct++){const[ft,ht]=it[T$1][ct];st.rules[ft].apply(ht)}return it[T$1]=[],null}return it[T$1]=[],it.rules={},W.forEach(ct=>it.rules[ct]={apply:ft=>it[T$1].push([ct,ft])}),it})(_e):null,lt=(at||_e).rules,ut=`.${tt}${nt.length>1?`:where(.${nt.slice(1).join(".")})`:""}`,dt=st=>{st=typeof st=="object"&&st||A;const{css:it,...ct}=st,ft={};for(const pt in rt)if(delete ct[pt],pt in st){let _t=st[pt];typeof _t=="object"&&_t?ft[pt]={"@initial":rt[pt],..._t}:(_t=String(_t),ft[pt]=_t!=="undefined"||ot.has(pt)?_t:rt[pt])}else ft[pt]=rt[pt];const ht=new Set([...nt]);for(const[pt,_t,vt,bt]of _.composers){_e.rules.styled.cache.has(pt)||(_e.rules.styled.cache.add(pt),$$2(_t,[`.${pt}`],[],et,Mt=>{lt.styled.apply(Mt)}));const wt=O(vt,ft,et.media),xt=O(bt,ft,et.media,!0);for(const Mt of wt)if(Mt!==void 0)for(const[At,St,Tt]of Mt){const Ct=`${pt}-${z(St)}-${At}`;ht.add(Ct);const It=(Tt?_e.rules.resonevar:_e.rules.onevar).cache,$t=Tt?lt.resonevar:lt.onevar;It.has(Ct)||(It.add(Ct),$$2(St,[`.${Ct}`],[],et,Nt=>{$t.apply(Nt)}))}for(const Mt of xt)if(Mt!==void 0)for(const[At,St]of Mt){const Tt=`${pt}-${z(St)}-${At}`;ht.add(Tt),_e.rules.allvar.cache.has(Tt)||(_e.rules.allvar.cache.add(Tt),$$2(St,[`.${Tt}`],[],et,Ct=>{lt.allvar.apply(Ct)}))}}if(typeof it=="object"&&it){const pt=`${tt}-i${z(it)}-css`;ht.add(pt),_e.rules.inline.cache.has(pt)||(_e.rules.inline.cache.add(pt),$$2(it,[`.${pt}`],[],et,_t=>{lt.inline.apply(_t)}))}for(const pt of String(st.className||"").trim().split(/\s+/))pt&&ht.add(pt);const mt=ct.className=[...ht].join(" ");return{type:_.type,className:mt,selector:ut,props:ct,toString:()=>mt,deferredInjector:at}};return s$2(dt,{className:tt,selector:ut,[l$1]:_,toString:()=>(_e.rules.styled.cache.has(tt)||dt(),tt)})},L$1=et=>{let _="";const _e=[],tt={},nt=[];for(const[rt,,,,ot,at]of et){_===""&&(_=rt),_e.push(rt),nt.push(...at);for(const lt in ot){const ut=ot[lt];(tt[lt]===void 0||ut!=="undefined"||at.includes(ut))&&(tt[lt]=ut)}}return[_,_e,tt,new Set(nt)]},O=(et,_,_e,tt)=>{const nt=[];e:for(let[rt,ot,at]of et){if(at)continue;let lt,ut=0,dt=!1;for(lt in rt){const st=rt[lt];let it=_[lt];if(it!==st){if(typeof it!="object"||!it)continue e;{let ct,ft,ht=0;for(const mt in it){if(st===String(it[mt])){if(mt!=="@initial"){const pt=mt.slice(1);(ft=ft||[]).push(pt in _e?_e[pt]:mt.replace(/^@media ?/,"")),dt=!0}ut+=ht,ct=!0}++ht}if(ft&&ft.length&&(ot={["@media "+ft.join(", ")]:ot}),!ct)continue e}}}(nt[ut]=nt[ut]||[]).push([tt?"cv":`${lt}-${rt[lt]}`,ot,dt])}return nt},A={},N$1=o$1(),D=(et,_)=>N$1(et,()=>(..._e)=>{const tt=()=>{for(let nt of _e){nt=typeof nt=="object"&&nt||{};let rt=z(nt);if(!_.rules.global.cache.has(rt)){if(_.rules.global.cache.add(rt),"@import"in nt){let ot=[].indexOf.call(_.sheet.cssRules,_.rules.themed.group)-1;for(let at of[].concat(nt["@import"]))at=at.includes('"')||at.includes("'")?at:`"${at}"`,_.sheet.insertRule(`@import ${at};`,ot++);delete nt["@import"]}$$2(nt,[],[],et,ot=>{_.rules.global.apply(ot)})}}return""};return s$2(tt,{toString:tt})}),H$1=o$1(),V$1=(et,_)=>H$1(et,()=>_e=>{const tt=`${S$2(et.prefix)}k-${z(_e)}`,nt=()=>{if(!_.rules.global.cache.has(tt)){_.rules.global.cache.add(tt);const rt=[];$$2(_e,[],[],et,at=>rt.push(at));const ot=`@keyframes ${tt}{${rt.join("")}}`;_.rules.global.apply(ot)}return tt};return s$2(nt,{get name(){return nt()},toString:nt})}),G=class{constructor(et,_,_e,tt){this.token=et==null?"":String(et),this.value=_==null?"":String(_),this.scale=_e==null?"":String(_e),this.prefix=tt==null?"":String(tt)}get computedValue(){return"var("+this.variable+")"}get variable(){return"--"+S$2(this.prefix)+S$2(this.scale)+this.token}toString(){return this.computedValue}},F$1=o$1(),J$1=(et,_)=>F$1(et,()=>(_e,tt)=>{tt=typeof _e=="object"&&_e||Object(tt);const nt=`.${_e=(_e=typeof _e=="string"?_e:"")||`${S$2(et.prefix)}t-${z(tt)}`}`,rt={},ot=[];for(const lt in tt){rt[lt]={};for(const ut in tt[lt]){const dt=`--${S$2(et.prefix)}${lt}-${ut}`,st=k$2(String(tt[lt][ut]),et.prefix,lt);rt[lt][ut]=new G(ut,st,lt,et.prefix),ot.push(`${dt}:${st}`)}}const at=()=>{if(ot.length&&!_.rules.themed.cache.has(_e)){_.rules.themed.cache.add(_e);const lt=`${tt===et.theme?":root,":""}.${_e}{${ot.join(";")}}`;_.rules.themed.apply(lt)}return _e};return{...rt,get className(){return at()},selector:nt,toString:at}}),U$1=o$1(),Y$1=o$1(),q$1=et=>{const _=(_e=>{let tt=!1;const nt=U$1(_e,rt=>{tt=!0;const ot="prefix"in(rt=typeof rt=="object"&&rt||{})?String(rt.prefix):"",at=typeof rt.media=="object"&&rt.media||{},lt=typeof rt.root=="object"?rt.root||null:globalThis.document||null,ut=typeof rt.theme=="object"&&rt.theme||{},dt={prefix:ot,media:at,theme:ut,themeMap:typeof rt.themeMap=="object"&&rt.themeMap||{...n$1},utils:typeof rt.utils=="object"&&rt.utils||{}},st=E(lt),it={css:M$1(dt,st),globalCss:D(dt,st),keyframes:V$1(dt,st),createTheme:J$1(dt,st),reset(){st.reset(),it.theme.toString()},theme:{},sheet:st,config:dt,prefix:ot,getCssText:st.toString,toString:st.toString};return String(it.theme=it.createTheme(ut)),it});return tt||nt.reset(),nt})(et);return _.styled=(({config:_e,sheet:tt})=>Y$1(_e,()=>{const nt=M$1(_e,tt);return(...rt)=>{const ot=nt(...rt),at=ot[l$1].type,lt=React.forwardRef((ut,dt)=>{const st=ut&&ut.as||at,{props:it,deferredInjector:ct}=ot(ut);return delete it.as,it.ref=dt,ct?React.createElement(React.Fragment,null,React.createElement(st,it),React.createElement(ct,null)):React.createElement(st,it)});return lt.className=ot.className,lt.displayName=`Styled.${at.displayName||at.name||at}`,lt.selector=ot.selector,lt.toString=()=>ot.selector,lt[l$1]=ot[l$1],lt}}))(_),_};function composeEventHandlers$1(et,_,{checkForDefaultPrevented:_e=!0}={}){return function(nt){if(et==null||et(nt),_e===!1||!nt.defaultPrevented)return _==null?void 0:_(nt)}}function createContextScope(et,_=[]){let _e=[];function tt(rt,ot){const at=reactExports.createContext(ot),lt=_e.length;_e=[..._e,ot];function ut(st){const{scope:it,children:ct,...ft}=st,ht=(it==null?void 0:it[et][lt])||at,mt=reactExports.useMemo(()=>ft,Object.values(ft));return jsxRuntimeExports.jsx(ht.Provider,{value:mt,children:ct})}function dt(st,it){const ct=(it==null?void 0:it[et][lt])||at,ft=reactExports.useContext(ct);if(ft)return ft;if(ot!==void 0)return ot;throw new Error(`\`${st}\` must be used within \`${rt}\``)}return ut.displayName=rt+"Provider",[ut,dt]}const nt=()=>{const rt=_e.map(ot=>reactExports.createContext(ot));return function(at){const lt=(at==null?void 0:at[et])||rt;return reactExports.useMemo(()=>({[`__scope${et}`]:{...at,[et]:lt}}),[at,lt])}};return nt.scopeName=et,[tt,composeContextScopes(nt,..._)]}function composeContextScopes(...et){const _=et[0];if(et.length===1)return _;const _e=()=>{const tt=et.map(nt=>({useScope:nt(),scopeName:nt.scopeName}));return function(rt){const ot=tt.reduce((at,{useScope:lt,scopeName:ut})=>{const st=lt(rt)[`__scope${ut}`];return{...at,...st}},{});return reactExports.useMemo(()=>({[`__scope${_.scopeName}`]:ot}),[ot])}};return _e.scopeName=_.scopeName,_e}function useCallbackRef(et){const _=reactExports.useRef(et);return reactExports.useEffect(()=>{_.current=et}),reactExports.useMemo(()=>(..._e)=>{var tt;return(tt=_.current)==null?void 0:tt.call(_,..._e)},[])}function useEscapeKeydown(et,_=globalThis==null?void 0:globalThis.document){const _e=useCallbackRef(et);reactExports.useEffect(()=>{const tt=nt=>{nt.key==="Escape"&&_e(nt)};return _.addEventListener("keydown",tt,{capture:!0}),()=>_.removeEventListener("keydown",tt,{capture:!0})},[_e,_])}var DISMISSABLE_LAYER_NAME="DismissableLayer",CONTEXT_UPDATE="dismissableLayer.update",POINTER_DOWN_OUTSIDE="dismissableLayer.pointerDownOutside",FOCUS_OUTSIDE="dismissableLayer.focusOutside",originalBodyPointerEvents,DismissableLayerContext=reactExports.createContext({layers:new Set,layersWithOutsidePointerEventsDisabled:new Set,branches:new Set}),DismissableLayer=reactExports.forwardRef((et,_)=>{const{disableOutsidePointerEvents:_e=!1,onEscapeKeyDown:tt,onPointerDownOutside:nt,onFocusOutside:rt,onInteractOutside:ot,onDismiss:at,...lt}=et,ut=reactExports.useContext(DismissableLayerContext),[dt,st]=reactExports.useState(null),it=(dt==null?void 0:dt.ownerDocument)??(globalThis==null?void 0:globalThis.document),[,ct]=reactExports.useState({}),ft=useComposedRefs(_,Mt=>st(Mt)),ht=Array.from(ut.layers),[mt]=[...ut.layersWithOutsidePointerEventsDisabled].slice(-1),pt=ht.indexOf(mt),_t=dt?ht.indexOf(dt):-1,vt=ut.layersWithOutsidePointerEventsDisabled.size>0,bt=_t>=pt,wt=usePointerDownOutside(Mt=>{const At=Mt.target,St=[...ut.branches].some(Tt=>Tt.contains(At));!bt||St||(nt==null||nt(Mt),ot==null||ot(Mt),Mt.defaultPrevented||at==null||at())},it),xt=useFocusOutside(Mt=>{const At=Mt.target;[...ut.branches].some(Tt=>Tt.contains(At))||(rt==null||rt(Mt),ot==null||ot(Mt),Mt.defaultPrevented||at==null||at())},it);return useEscapeKeydown(Mt=>{_t===ut.layers.size-1&&(tt==null||tt(Mt),!Mt.defaultPrevented&&at&&(Mt.preventDefault(),at()))},it),reactExports.useEffect(()=>{if(dt)return _e&&(ut.layersWithOutsidePointerEventsDisabled.size===0&&(originalBodyPointerEvents=it.body.style.pointerEvents,it.body.style.pointerEvents="none"),ut.layersWithOutsidePointerEventsDisabled.add(dt)),ut.layers.add(dt),dispatchUpdate(),()=>{_e&&ut.layersWithOutsidePointerEventsDisabled.size===1&&(it.body.style.pointerEvents=originalBodyPointerEvents)}},[dt,it,_e,ut]),reactExports.useEffect(()=>()=>{dt&&(ut.layers.delete(dt),ut.layersWithOutsidePointerEventsDisabled.delete(dt),dispatchUpdate())},[dt,ut]),reactExports.useEffect(()=>{const Mt=()=>ct({});return document.addEventListener(CONTEXT_UPDATE,Mt),()=>document.removeEventListener(CONTEXT_UPDATE,Mt)},[]),jsxRuntimeExports.jsx(Primitive.div,{...lt,ref:ft,style:{pointerEvents:vt?bt?"auto":"none":void 0,...et.style},onFocusCapture:composeEventHandlers$1(et.onFocusCapture,xt.onFocusCapture),onBlurCapture:composeEventHandlers$1(et.onBlurCapture,xt.onBlurCapture),onPointerDownCapture:composeEventHandlers$1(et.onPointerDownCapture,wt.onPointerDownCapture)})});DismissableLayer.displayName=DISMISSABLE_LAYER_NAME;var BRANCH_NAME="DismissableLayerBranch",DismissableLayerBranch=reactExports.forwardRef((et,_)=>{const _e=reactExports.useContext(DismissableLayerContext),tt=reactExports.useRef(null),nt=useComposedRefs(_,tt);return reactExports.useEffect(()=>{const rt=tt.current;if(rt)return _e.branches.add(rt),()=>{_e.branches.delete(rt)}},[_e.branches]),jsxRuntimeExports.jsx(Primitive.div,{...et,ref:nt})});DismissableLayerBranch.displayName=BRANCH_NAME;function usePointerDownOutside(et,_=globalThis==null?void 0:globalThis.document){const _e=useCallbackRef(et),tt=reactExports.useRef(!1),nt=reactExports.useRef(()=>{});return reactExports.useEffect(()=>{const rt=at=>{if(at.target&&!tt.current){let lt=function(){handleAndDispatchCustomEvent(POINTER_DOWN_OUTSIDE,_e,ut,{discrete:!0})};const ut={originalEvent:at};at.pointerType==="touch"?(_.removeEventListener("click",nt.current),nt.current=lt,_.addEventListener("click",nt.current,{once:!0})):lt()}else _.removeEventListener("click",nt.current);tt.current=!1},ot=window.setTimeout(()=>{_.addEventListener("pointerdown",rt)},0);return()=>{window.clearTimeout(ot),_.removeEventListener("pointerdown",rt),_.removeEventListener("click",nt.current)}},[_,_e]),{onPointerDownCapture:()=>tt.current=!0}}function useFocusOutside(et,_=globalThis==null?void 0:globalThis.document){const _e=useCallbackRef(et),tt=reactExports.useRef(!1);return reactExports.useEffect(()=>{const nt=rt=>{rt.target&&!tt.current&&handleAndDispatchCustomEvent(FOCUS_OUTSIDE,_e,{originalEvent:rt},{discrete:!1})};return _.addEventListener("focusin",nt),()=>_.removeEventListener("focusin",nt)},[_,_e]),{onFocusCapture:()=>tt.current=!0,onBlurCapture:()=>tt.current=!1}}function dispatchUpdate(){const et=new CustomEvent(CONTEXT_UPDATE);document.dispatchEvent(et)}function handleAndDispatchCustomEvent(et,_,_e,{discrete:tt}){const nt=_e.originalEvent.target,rt=new CustomEvent(et,{bubbles:!1,cancelable:!0,detail:_e});_&&nt.addEventListener(et,_,{once:!0}),tt?dispatchDiscreteCustomEvent(nt,rt):nt.dispatchEvent(rt)}var useReactId=React$1.useId||(()=>{}),count=0;function useId(et){const[_,_e]=reactExports.useState(useReactId());return useLayoutEffect2(()=>{_e(tt=>tt??String(count++))},[et]),_?`radix-${_}`:""}const sides=["top","right","bottom","left"],min=Math.min,max=Math.max,round=Math.round,floor=Math.floor,createCoords=et=>({x:et,y:et}),oppositeSideMap={left:"right",right:"left",bottom:"top",top:"bottom"},oppositeAlignmentMap={start:"end",end:"start"};function clamp$1(et,_,_e){return max(et,min(_,_e))}function evaluate$1(et,_){return typeof et=="function"?et(_):et}function getSide(et){return et.split("-")[0]}function getAlignment(et){return et.split("-")[1]}function getOppositeAxis(et){return et==="x"?"y":"x"}function getAxisLength(et){return et==="y"?"height":"width"}function getSideAxis(et){return["top","bottom"].includes(getSide(et))?"y":"x"}function getAlignmentAxis(et){return getOppositeAxis(getSideAxis(et))}function getAlignmentSides(et,_,_e){_e===void 0&&(_e=!1);const tt=getAlignment(et),nt=getAlignmentAxis(et),rt=getAxisLength(nt);let ot=nt==="x"?tt===(_e?"end":"start")?"right":"left":tt==="start"?"bottom":"top";return _.reference[rt]>_.floating[rt]&&(ot=getOppositePlacement(ot)),[ot,getOppositePlacement(ot)]}function getExpandedPlacements(et){const _=getOppositePlacement(et);return[getOppositeAlignmentPlacement(et),_,getOppositeAlignmentPlacement(_)]}function getOppositeAlignmentPlacement(et){return et.replace(/start|end/g,_=>oppositeAlignmentMap[_])}function getSideList(et,_,_e){const tt=["left","right"],nt=["right","left"],rt=["top","bottom"],ot=["bottom","top"];switch(et){case"top":case"bottom":return _e?_?nt:tt:_?tt:nt;case"left":case"right":return _?rt:ot;default:return[]}}function getOppositeAxisPlacements(et,_,_e,tt){const nt=getAlignment(et);let rt=getSideList(getSide(et),_e==="start",tt);return nt&&(rt=rt.map(ot=>ot+"-"+nt),_&&(rt=rt.concat(rt.map(getOppositeAlignmentPlacement)))),rt}function getOppositePlacement(et){return et.replace(/left|right|bottom|top/g,_=>oppositeSideMap[_])}function expandPaddingObject(et){return{top:0,right:0,bottom:0,left:0,...et}}function getPaddingObject(et){return typeof et!="number"?expandPaddingObject(et):{top:et,right:et,bottom:et,left:et}}function rectToClientRect(et){const{x:_,y:_e,width:tt,height:nt}=et;return{width:tt,height:nt,top:_e,left:_,right:_+tt,bottom:_e+nt,x:_,y:_e}}function computeCoordsFromPlacement(et,_,_e){let{reference:tt,floating:nt}=et;const rt=getSideAxis(_),ot=getAlignmentAxis(_),at=getAxisLength(ot),lt=getSide(_),ut=rt==="y",dt=tt.x+tt.width/2-nt.width/2,st=tt.y+tt.height/2-nt.height/2,it=tt[at]/2-nt[at]/2;let ct;switch(lt){case"top":ct={x:dt,y:tt.y-nt.height};break;case"bottom":ct={x:dt,y:tt.y+tt.height};break;case"right":ct={x:tt.x+tt.width,y:st};break;case"left":ct={x:tt.x-nt.width,y:st};break;default:ct={x:tt.x,y:tt.y}}switch(getAlignment(_)){case"start":ct[ot]-=it*(_e&&ut?-1:1);break;case"end":ct[ot]+=it*(_e&&ut?-1:1);break}return ct}const computePosition$1=async(et,_,_e)=>{const{placement:tt="bottom",strategy:nt="absolute",middleware:rt=[],platform:ot}=_e,at=rt.filter(Boolean),lt=await(ot.isRTL==null?void 0:ot.isRTL(_));let ut=await ot.getElementRects({reference:et,floating:_,strategy:nt}),{x:dt,y:st}=computeCoordsFromPlacement(ut,tt,lt),it=tt,ct={},ft=0;for(let ht=0;ht<at.length;ht++){const{name:mt,fn:pt}=at[ht],{x:_t,y:vt,data:bt,reset:wt}=await pt({x:dt,y:st,initialPlacement:tt,placement:it,strategy:nt,middlewareData:ct,rects:ut,platform:ot,elements:{reference:et,floating:_}});dt=_t??dt,st=vt??st,ct={...ct,[mt]:{...ct[mt],...bt}},wt&&ft<=50&&(ft++,typeof wt=="object"&&(wt.placement&&(it=wt.placement),wt.rects&&(ut=wt.rects===!0?await ot.getElementRects({reference:et,floating:_,strategy:nt}):wt.rects),{x:dt,y:st}=computeCoordsFromPlacement(ut,it,lt)),ht=-1)}return{x:dt,y:st,placement:it,strategy:nt,middlewareData:ct}};async function detectOverflow(et,_){var _e;_===void 0&&(_={});const{x:tt,y:nt,platform:rt,rects:ot,elements:at,strategy:lt}=et,{boundary:ut="clippingAncestors",rootBoundary:dt="viewport",elementContext:st="floating",altBoundary:it=!1,padding:ct=0}=evaluate$1(_,et),ft=getPaddingObject(ct),mt=at[it?st==="floating"?"reference":"floating":st],pt=rectToClientRect(await rt.getClippingRect({element:(_e=await(rt.isElement==null?void 0:rt.isElement(mt)))==null||_e?mt:mt.contextElement||await(rt.getDocumentElement==null?void 0:rt.getDocumentElement(at.floating)),boundary:ut,rootBoundary:dt,strategy:lt})),_t=st==="floating"?{x:tt,y:nt,width:ot.floating.width,height:ot.floating.height}:ot.reference,vt=await(rt.getOffsetParent==null?void 0:rt.getOffsetParent(at.floating)),bt=await(rt.isElement==null?void 0:rt.isElement(vt))?await(rt.getScale==null?void 0:rt.getScale(vt))||{x:1,y:1}:{x:1,y:1},wt=rectToClientRect(rt.convertOffsetParentRelativeRectToViewportRelativeRect?await rt.convertOffsetParentRelativeRectToViewportRelativeRect({elements:at,rect:_t,offsetParent:vt,strategy:lt}):_t);return{top:(pt.top-wt.top+ft.top)/bt.y,bottom:(wt.bottom-pt.bottom+ft.bottom)/bt.y,left:(pt.left-wt.left+ft.left)/bt.x,right:(wt.right-pt.right+ft.right)/bt.x}}const arrow$3=et=>({name:"arrow",options:et,async fn(_){const{x:_e,y:tt,placement:nt,rects:rt,platform:ot,elements:at,middlewareData:lt}=_,{element:ut,padding:dt=0}=evaluate$1(et,_)||{};if(ut==null)return{};const st=getPaddingObject(dt),it={x:_e,y:tt},ct=getAlignmentAxis(nt),ft=getAxisLength(ct),ht=await ot.getDimensions(ut),mt=ct==="y",pt=mt?"top":"left",_t=mt?"bottom":"right",vt=mt?"clientHeight":"clientWidth",bt=rt.reference[ft]+rt.reference[ct]-it[ct]-rt.floating[ft],wt=it[ct]-rt.reference[ct],xt=await(ot.getOffsetParent==null?void 0:ot.getOffsetParent(ut));let Mt=xt?xt[vt]:0;(!Mt||!await(ot.isElement==null?void 0:ot.isElement(xt)))&&(Mt=at.floating[vt]||rt.floating[ft]);const At=bt/2-wt/2,St=Mt/2-ht[ft]/2-1,Tt=min(st[pt],St),Ct=min(st[_t],St),It=Tt,$t=Mt-ht[ft]-Ct,Nt=Mt/2-ht[ft]/2+At,Bt=clamp$1(It,Nt,$t),Ot=!lt.arrow&&getAlignment(nt)!=null&&Nt!==Bt&&rt.reference[ft]/2-(Nt<It?Tt:Ct)-ht[ft]/2<0,Ut=Ot?Nt<It?Nt-It:Nt-$t:0;return{[ct]:it[ct]+Ut,data:{[ct]:Bt,centerOffset:Nt-Bt-Ut,...Ot&&{alignmentOffset:Ut}},reset:Ot}}}),flip$2=function(et){return et===void 0&&(et={}),{name:"flip",options:et,async fn(_){var _e,tt;const{placement:nt,middlewareData:rt,rects:ot,initialPlacement:at,platform:lt,elements:ut}=_,{mainAxis:dt=!0,crossAxis:st=!0,fallbackPlacements:it,fallbackStrategy:ct="bestFit",fallbackAxisSideDirection:ft="none",flipAlignment:ht=!0,...mt}=evaluate$1(et,_);if((_e=rt.arrow)!=null&&_e.alignmentOffset)return{};const pt=getSide(nt),_t=getSideAxis(at),vt=getSide(at)===at,bt=await(lt.isRTL==null?void 0:lt.isRTL(ut.floating)),wt=it||(vt||!ht?[getOppositePlacement(at)]:getExpandedPlacements(at)),xt=ft!=="none";!it&&xt&&wt.push(...getOppositeAxisPlacements(at,ht,ft,bt));const Mt=[at,...wt],At=await detectOverflow(_,mt),St=[];let Tt=((tt=rt.flip)==null?void 0:tt.overflows)||[];if(dt&&St.push(At[pt]),st){const Nt=getAlignmentSides(nt,ot,bt);St.push(At[Nt[0]],At[Nt[1]])}if(Tt=[...Tt,{placement:nt,overflows:St}],!St.every(Nt=>Nt<=0)){var Ct,It;const Nt=(((Ct=rt.flip)==null?void 0:Ct.index)||0)+1,Bt=Mt[Nt];if(Bt)return{data:{index:Nt,overflows:Tt},reset:{placement:Bt}};let Ot=(It=Tt.filter(Ut=>Ut.overflows[0]<=0).sort((Ut,Lt)=>Ut.overflows[1]-Lt.overflows[1])[0])==null?void 0:It.placement;if(!Ot)switch(ct){case"bestFit":{var $t;const Ut=($t=Tt.filter(Lt=>{if(xt){const zt=getSideAxis(Lt.placement);return zt===_t||zt==="y"}return!0}).map(Lt=>[Lt.placement,Lt.overflows.filter(zt=>zt>0).reduce((zt,Yt)=>zt+Yt,0)]).sort((Lt,zt)=>Lt[1]-zt[1])[0])==null?void 0:$t[0];Ut&&(Ot=Ut);break}case"initialPlacement":Ot=at;break}if(nt!==Ot)return{reset:{placement:Ot}}}return{}}}};function getSideOffsets(et,_){return{top:et.top-_.height,right:et.right-_.width,bottom:et.bottom-_.height,left:et.left-_.width}}function isAnySideFullyClipped(et){return sides.some(_=>et[_]>=0)}const hide$2=function(et){return et===void 0&&(et={}),{name:"hide",options:et,async fn(_){const{rects:_e}=_,{strategy:tt="referenceHidden",...nt}=evaluate$1(et,_);switch(tt){case"referenceHidden":{const rt=await detectOverflow(_,{...nt,elementContext:"reference"}),ot=getSideOffsets(rt,_e.reference);return{data:{referenceHiddenOffsets:ot,referenceHidden:isAnySideFullyClipped(ot)}}}case"escaped":{const rt=await detectOverflow(_,{...nt,altBoundary:!0}),ot=getSideOffsets(rt,_e.floating);return{data:{escapedOffsets:ot,escaped:isAnySideFullyClipped(ot)}}}default:return{}}}}};async function convertValueToCoords(et,_){const{placement:_e,platform:tt,elements:nt}=et,rt=await(tt.isRTL==null?void 0:tt.isRTL(nt.floating)),ot=getSide(_e),at=getAlignment(_e),lt=getSideAxis(_e)==="y",ut=["left","top"].includes(ot)?-1:1,dt=rt&&lt?-1:1,st=evaluate$1(_,et);let{mainAxis:it,crossAxis:ct,alignmentAxis:ft}=typeof st=="number"?{mainAxis:st,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...st};return at&&typeof ft=="number"&&(ct=at==="end"?ft*-1:ft),lt?{x:ct*dt,y:it*ut}:{x:it*ut,y:ct*dt}}const offset$2=function(et){return et===void 0&&(et=0),{name:"offset",options:et,async fn(_){var _e,tt;const{x:nt,y:rt,placement:ot,middlewareData:at}=_,lt=await convertValueToCoords(_,et);return ot===((_e=at.offset)==null?void 0:_e.placement)&&(tt=at.arrow)!=null&&tt.alignmentOffset?{}:{x:nt+lt.x,y:rt+lt.y,data:{...lt,placement:ot}}}}},shift$2=function(et){return et===void 0&&(et={}),{name:"shift",options:et,async fn(_){const{x:_e,y:tt,placement:nt}=_,{mainAxis:rt=!0,crossAxis:ot=!1,limiter:at={fn:mt=>{let{x:pt,y:_t}=mt;return{x:pt,y:_t}}},...lt}=evaluate$1(et,_),ut={x:_e,y:tt},dt=await detectOverflow(_,lt),st=getSideAxis(getSide(nt)),it=getOppositeAxis(st);let ct=ut[it],ft=ut[st];if(rt){const mt=it==="y"?"top":"left",pt=it==="y"?"bottom":"right",_t=ct+dt[mt],vt=ct-dt[pt];ct=clamp$1(_t,ct,vt)}if(ot){const mt=st==="y"?"top":"left",pt=st==="y"?"bottom":"right",_t=ft+dt[mt],vt=ft-dt[pt];ft=clamp$1(_t,ft,vt)}const ht=at.fn({..._,[it]:ct,[st]:ft});return{...ht,data:{x:ht.x-_e,y:ht.y-tt}}}}},limitShift$2=function(et){return et===void 0&&(et={}),{options:et,fn(_){const{x:_e,y:tt,placement:nt,rects:rt,middlewareData:ot}=_,{offset:at=0,mainAxis:lt=!0,crossAxis:ut=!0}=evaluate$1(et,_),dt={x:_e,y:tt},st=getSideAxis(nt),it=getOppositeAxis(st);let ct=dt[it],ft=dt[st];const ht=evaluate$1(at,_),mt=typeof ht=="number"?{mainAxis:ht,crossAxis:0}:{mainAxis:0,crossAxis:0,...ht};if(lt){const vt=it==="y"?"height":"width",bt=rt.reference[it]-rt.floating[vt]+mt.mainAxis,wt=rt.reference[it]+rt.reference[vt]-mt.mainAxis;ct<bt?ct=bt:ct>wt&&(ct=wt)}if(ut){var pt,_t;const vt=it==="y"?"width":"height",bt=["top","left"].includes(getSide(nt)),wt=rt.reference[st]-rt.floating[vt]+(bt&&((pt=ot.offset)==null?void 0:pt[st])||0)+(bt?0:mt.crossAxis),xt=rt.reference[st]+rt.reference[vt]+(bt?0:((_t=ot.offset)==null?void 0:_t[st])||0)-(bt?mt.crossAxis:0);ft<wt?ft=wt:ft>xt&&(ft=xt)}return{[it]:ct,[st]:ft}}}},size$2=function(et){return et===void 0&&(et={}),{name:"size",options:et,async fn(_){const{placement:_e,rects:tt,platform:nt,elements:rt}=_,{apply:ot=()=>{},...at}=evaluate$1(et,_),lt=await detectOverflow(_,at),ut=getSide(_e),dt=getAlignment(_e),st=getSideAxis(_e)==="y",{width:it,height:ct}=tt.floating;let ft,ht;ut==="top"||ut==="bottom"?(ft=ut,ht=dt===(await(nt.isRTL==null?void 0:nt.isRTL(rt.floating))?"start":"end")?"left":"right"):(ht=ut,ft=dt==="end"?"top":"bottom");const mt=ct-lt.top-lt.bottom,pt=it-lt.left-lt.right,_t=min(ct-lt[ft],mt),vt=min(it-lt[ht],pt),bt=!_.middlewareData.shift;let wt=_t,xt=vt;if(st?xt=dt||bt?min(vt,pt):pt:wt=dt||bt?min(_t,mt):mt,bt&&!dt){const At=max(lt.left,0),St=max(lt.right,0),Tt=max(lt.top,0),Ct=max(lt.bottom,0);st?xt=it-2*(At!==0||St!==0?At+St:max(lt.left,lt.right)):wt=ct-2*(Tt!==0||Ct!==0?Tt+Ct:max(lt.top,lt.bottom))}await ot({..._,availableWidth:xt,availableHeight:wt});const Mt=await nt.getDimensions(rt.floating);return it!==Mt.width||ct!==Mt.height?{reset:{rects:!0}}:{}}}};function getNodeName(et){return isNode(et)?(et.nodeName||"").toLowerCase():"#document"}function getWindow(et){var _;return(et==null||(_=et.ownerDocument)==null?void 0:_.defaultView)||window}function getDocumentElement(et){var _;return(_=(isNode(et)?et.ownerDocument:et.document)||window.document)==null?void 0:_.documentElement}function isNode(et){return et instanceof Node||et instanceof getWindow(et).Node}function isElement(et){return et instanceof Element||et instanceof getWindow(et).Element}function isHTMLElement(et){return et instanceof HTMLElement||et instanceof getWindow(et).HTMLElement}function isShadowRoot(et){return typeof ShadowRoot>"u"?!1:et instanceof ShadowRoot||et instanceof getWindow(et).ShadowRoot}function isOverflowElement(et){const{overflow:_,overflowX:_e,overflowY:tt,display:nt}=getComputedStyle$1(et);return/auto|scroll|overlay|hidden|clip/.test(_+tt+_e)&&!["inline","contents"].includes(nt)}function isTableElement(et){return["table","td","th"].includes(getNodeName(et))}function isTopLayer(et){return[":popover-open",":modal"].some(_=>{try{return et.matches(_)}catch{return!1}})}function isContainingBlock(et){const _=isWebKit(),_e=isElement(et)?getComputedStyle$1(et):et;return _e.transform!=="none"||_e.perspective!=="none"||(_e.containerType?_e.containerType!=="normal":!1)||!_&&(_e.backdropFilter?_e.backdropFilter!=="none":!1)||!_&&(_e.filter?_e.filter!=="none":!1)||["transform","perspective","filter"].some(tt=>(_e.willChange||"").includes(tt))||["paint","layout","strict","content"].some(tt=>(_e.contain||"").includes(tt))}function getContainingBlock(et){let _=getParentNode(et);for(;isHTMLElement(_)&&!isLastTraversableNode(_);){if(isContainingBlock(_))return _;if(isTopLayer(_))return null;_=getParentNode(_)}return null}function isWebKit(){return typeof CSS>"u"||!CSS.supports?!1:CSS.supports("-webkit-backdrop-filter","none")}function isLastTraversableNode(et){return["html","body","#document"].includes(getNodeName(et))}function getComputedStyle$1(et){return getWindow(et).getComputedStyle(et)}function getNodeScroll(et){return isElement(et)?{scrollLeft:et.scrollLeft,scrollTop:et.scrollTop}:{scrollLeft:et.scrollX,scrollTop:et.scrollY}}function getParentNode(et){if(getNodeName(et)==="html")return et;const _=et.assignedSlot||et.parentNode||isShadowRoot(et)&&et.host||getDocumentElement(et);return isShadowRoot(_)?_.host:_}function getNearestOverflowAncestor(et){const _=getParentNode(et);return isLastTraversableNode(_)?et.ownerDocument?et.ownerDocument.body:et.body:isHTMLElement(_)&&isOverflowElement(_)?_:getNearestOverflowAncestor(_)}function getOverflowAncestors(et,_,_e){var tt;_===void 0&&(_=[]),_e===void 0&&(_e=!0);const nt=getNearestOverflowAncestor(et),rt=nt===((tt=et.ownerDocument)==null?void 0:tt.body),ot=getWindow(nt);return rt?_.concat(ot,ot.visualViewport||[],isOverflowElement(nt)?nt:[],ot.frameElement&&_e?getOverflowAncestors(ot.frameElement):[]):_.concat(nt,getOverflowAncestors(nt,[],_e))}function getCssDimensions(et){const _=getComputedStyle$1(et);let _e=parseFloat(_.width)||0,tt=parseFloat(_.height)||0;const nt=isHTMLElement(et),rt=nt?et.offsetWidth:_e,ot=nt?et.offsetHeight:tt,at=round(_e)!==rt||round(tt)!==ot;return at&&(_e=rt,tt=ot),{width:_e,height:tt,$:at}}function unwrapElement(et){return isElement(et)?et:et.contextElement}function getScale(et){const _=unwrapElement(et);if(!isHTMLElement(_))return createCoords(1);const _e=_.getBoundingClientRect(),{width:tt,height:nt,$:rt}=getCssDimensions(_);let ot=(rt?round(_e.width):_e.width)/tt,at=(rt?round(_e.height):_e.height)/nt;return(!ot||!Number.isFinite(ot))&&(ot=1),(!at||!Number.isFinite(at))&&(at=1),{x:ot,y:at}}const noOffsets=createCoords(0);function getVisualOffsets(et){const _=getWindow(et);return!isWebKit()||!_.visualViewport?noOffsets:{x:_.visualViewport.offsetLeft,y:_.visualViewport.offsetTop}}function shouldAddVisualOffsets(et,_,_e){return _===void 0&&(_=!1),!_e||_&&_e!==getWindow(et)?!1:_}function getBoundingClientRect(et,_,_e,tt){_===void 0&&(_=!1),_e===void 0&&(_e=!1);const nt=et.getBoundingClientRect(),rt=unwrapElement(et);let ot=createCoords(1);_&&(tt?isElement(tt)&&(ot=getScale(tt)):ot=getScale(et));const at=shouldAddVisualOffsets(rt,_e,tt)?getVisualOffsets(rt):createCoords(0);let lt=(nt.left+at.x)/ot.x,ut=(nt.top+at.y)/ot.y,dt=nt.width/ot.x,st=nt.height/ot.y;if(rt){const it=getWindow(rt),ct=tt&&isElement(tt)?getWindow(tt):tt;let ft=it,ht=ft.frameElement;for(;ht&&tt&&ct!==ft;){const mt=getScale(ht),pt=ht.getBoundingClientRect(),_t=getComputedStyle$1(ht),vt=pt.left+(ht.clientLeft+parseFloat(_t.paddingLeft))*mt.x,bt=pt.top+(ht.clientTop+parseFloat(_t.paddingTop))*mt.y;lt*=mt.x,ut*=mt.y,dt*=mt.x,st*=mt.y,lt+=vt,ut+=bt,ft=getWindow(ht),ht=ft.frameElement}}return rectToClientRect({width:dt,height:st,x:lt,y:ut})}function convertOffsetParentRelativeRectToViewportRelativeRect(et){let{elements:_,rect:_e,offsetParent:tt,strategy:nt}=et;const rt=nt==="fixed",ot=getDocumentElement(tt),at=_?isTopLayer(_.floating):!1;if(tt===ot||at&&rt)return _e;let lt={scrollLeft:0,scrollTop:0},ut=createCoords(1);const dt=createCoords(0),st=isHTMLElement(tt);if((st||!st&&!rt)&&((getNodeName(tt)!=="body"||isOverflowElement(ot))&&(lt=getNodeScroll(tt)),isHTMLElement(tt))){const it=getBoundingClientRect(tt);ut=getScale(tt),dt.x=it.x+tt.clientLeft,dt.y=it.y+tt.clientTop}return{width:_e.width*ut.x,height:_e.height*ut.y,x:_e.x*ut.x-lt.scrollLeft*ut.x+dt.x,y:_e.y*ut.y-lt.scrollTop*ut.y+dt.y}}function getClientRects(et){return Array.from(et.getClientRects())}function getWindowScrollBarX(et){return getBoundingClientRect(getDocumentElement(et)).left+getNodeScroll(et).scrollLeft}function getDocumentRect(et){const _=getDocumentElement(et),_e=getNodeScroll(et),tt=et.ownerDocument.body,nt=max(_.scrollWidth,_.clientWidth,tt.scrollWidth,tt.clientWidth),rt=max(_.scrollHeight,_.clientHeight,tt.scrollHeight,tt.clientHeight);let ot=-_e.scrollLeft+getWindowScrollBarX(et);const at=-_e.scrollTop;return getComputedStyle$1(tt).direction==="rtl"&&(ot+=max(_.clientWidth,tt.clientWidth)-nt),{width:nt,height:rt,x:ot,y:at}}function getViewportRect(et,_){const _e=getWindow(et),tt=getDocumentElement(et),nt=_e.visualViewport;let rt=tt.clientWidth,ot=tt.clientHeight,at=0,lt=0;if(nt){rt=nt.width,ot=nt.height;const ut=isWebKit();(!ut||ut&&_==="fixed")&&(at=nt.offsetLeft,lt=nt.offsetTop)}return{width:rt,height:ot,x:at,y:lt}}function getInnerBoundingClientRect(et,_){const _e=getBoundingClientRect(et,!0,_==="fixed"),tt=_e.top+et.clientTop,nt=_e.left+et.clientLeft,rt=isHTMLElement(et)?getScale(et):createCoords(1),ot=et.clientWidth*rt.x,at=et.clientHeight*rt.y,lt=nt*rt.x,ut=tt*rt.y;return{width:ot,height:at,x:lt,y:ut}}function getClientRectFromClippingAncestor(et,_,_e){let tt;if(_==="viewport")tt=getViewportRect(et,_e);else if(_==="document")tt=getDocumentRect(getDocumentElement(et));else if(isElement(_))tt=getInnerBoundingClientRect(_,_e);else{const nt=getVisualOffsets(et);tt={..._,x:_.x-nt.x,y:_.y-nt.y}}return rectToClientRect(tt)}function hasFixedPositionAncestor(et,_){const _e=getParentNode(et);return _e===_||!isElement(_e)||isLastTraversableNode(_e)?!1:getComputedStyle$1(_e).position==="fixed"||hasFixedPositionAncestor(_e,_)}function getClippingElementAncestors(et,_){const _e=_.get(et);if(_e)return _e;let tt=getOverflowAncestors(et,[],!1).filter(at=>isElement(at)&&getNodeName(at)!=="body"),nt=null;const rt=getComputedStyle$1(et).position==="fixed";let ot=rt?getParentNode(et):et;for(;isElement(ot)&&!isLastTraversableNode(ot);){const at=getComputedStyle$1(ot),lt=isContainingBlock(ot);!lt&&at.position==="fixed"&&(nt=null),(rt?!lt&&!nt:!lt&&at.position==="static"&&!!nt&&["absolute","fixed"].includes(nt.position)||isOverflowElement(ot)&&!lt&&hasFixedPositionAncestor(et,ot))?tt=tt.filter(dt=>dt!==ot):nt=at,ot=getParentNode(ot)}return _.set(et,tt),tt}function getClippingRect(et){let{element:_,boundary:_e,rootBoundary:tt,strategy:nt}=et;const ot=[..._e==="clippingAncestors"?isTopLayer(_)?[]:getClippingElementAncestors(_,this._c):[].concat(_e),tt],at=ot[0],lt=ot.reduce((ut,dt)=>{const st=getClientRectFromClippingAncestor(_,dt,nt);return ut.top=max(st.top,ut.top),ut.right=min(st.right,ut.right),ut.bottom=min(st.bottom,ut.bottom),ut.left=max(st.left,ut.left),ut},getClientRectFromClippingAncestor(_,at,nt));return{width:lt.right-lt.left,height:lt.bottom-lt.top,x:lt.left,y:lt.top}}function getDimensions(et){const{width:_,height:_e}=getCssDimensions(et);return{width:_,height:_e}}function getRectRelativeToOffsetParent(et,_,_e){const tt=isHTMLElement(_),nt=getDocumentElement(_),rt=_e==="fixed",ot=getBoundingClientRect(et,!0,rt,_);let at={scrollLeft:0,scrollTop:0};const lt=createCoords(0);if(tt||!tt&&!rt)if((getNodeName(_)!=="body"||isOverflowElement(nt))&&(at=getNodeScroll(_)),tt){const st=getBoundingClientRect(_,!0,rt,_);lt.x=st.x+_.clientLeft,lt.y=st.y+_.clientTop}else nt&&(lt.x=getWindowScrollBarX(nt));const ut=ot.left+at.scrollLeft-lt.x,dt=ot.top+at.scrollTop-lt.y;return{x:ut,y:dt,width:ot.width,height:ot.height}}function isStaticPositioned(et){return getComputedStyle$1(et).position==="static"}function getTrueOffsetParent(et,_){return!isHTMLElement(et)||getComputedStyle$1(et).position==="fixed"?null:_?_(et):et.offsetParent}function getOffsetParent(et,_){const _e=getWindow(et);if(isTopLayer(et))return _e;if(!isHTMLElement(et)){let nt=getParentNode(et);for(;nt&&!isLastTraversableNode(nt);){if(isElement(nt)&&!isStaticPositioned(nt))return nt;nt=getParentNode(nt)}return _e}let tt=getTrueOffsetParent(et,_);for(;tt&&isTableElement(tt)&&isStaticPositioned(tt);)tt=getTrueOffsetParent(tt,_);return tt&&isLastTraversableNode(tt)&&isStaticPositioned(tt)&&!isContainingBlock(tt)?_e:tt||getContainingBlock(et)||_e}const getElementRects=async function(et){const _=this.getOffsetParent||getOffsetParent,_e=this.getDimensions,tt=await _e(et.floating);return{reference:getRectRelativeToOffsetParent(et.reference,await _(et.floating),et.strategy),floating:{x:0,y:0,width:tt.width,height:tt.height}}};function isRTL(et){return getComputedStyle$1(et).direction==="rtl"}const platform={convertOffsetParentRelativeRectToViewportRelativeRect,getDocumentElement,getClippingRect,getOffsetParent,getElementRects,getClientRects,getDimensions,getScale,isElement,isRTL};function observeMove(et,_){let _e=null,tt;const nt=getDocumentElement(et);function rt(){var at;clearTimeout(tt),(at=_e)==null||at.disconnect(),_e=null}function ot(at,lt){at===void 0&&(at=!1),lt===void 0&&(lt=1),rt();const{left:ut,top:dt,width:st,height:it}=et.getBoundingClientRect();if(at||_(),!st||!it)return;const ct=floor(dt),ft=floor(nt.clientWidth-(ut+st)),ht=floor(nt.clientHeight-(dt+it)),mt=floor(ut),_t={rootMargin:-ct+"px "+-ft+"px "+-ht+"px "+-mt+"px",threshold:max(0,min(1,lt))||1};let vt=!0;function bt(wt){const xt=wt[0].intersectionRatio;if(xt!==lt){if(!vt)return ot();xt?ot(!1,xt):tt=setTimeout(()=>{ot(!1,1e-7)},1e3)}vt=!1}try{_e=new IntersectionObserver(bt,{..._t,root:nt.ownerDocument})}catch{_e=new IntersectionObserver(bt,_t)}_e.observe(et)}return ot(!0),rt}function autoUpdate(et,_,_e,tt){tt===void 0&&(tt={});const{ancestorScroll:nt=!0,ancestorResize:rt=!0,elementResize:ot=typeof ResizeObserver=="function",layoutShift:at=typeof IntersectionObserver=="function",animationFrame:lt=!1}=tt,ut=unwrapElement(et),dt=nt||rt?[...ut?getOverflowAncestors(ut):[],...getOverflowAncestors(_)]:[];dt.forEach(pt=>{nt&&pt.addEventListener("scroll",_e,{passive:!0}),rt&&pt.addEventListener("resize",_e)});const st=ut&&at?observeMove(ut,_e):null;let it=-1,ct=null;ot&&(ct=new ResizeObserver(pt=>{let[_t]=pt;_t&&_t.target===ut&&ct&&(ct.unobserve(_),cancelAnimationFrame(it),it=requestAnimationFrame(()=>{var vt;(vt=ct)==null||vt.observe(_)})),_e()}),ut&&!lt&&ct.observe(ut),ct.observe(_));let ft,ht=lt?getBoundingClientRect(et):null;lt&&mt();function mt(){const pt=getBoundingClientRect(et);ht&&(pt.x!==ht.x||pt.y!==ht.y||pt.width!==ht.width||pt.height!==ht.height)&&_e(),ht=pt,ft=requestAnimationFrame(mt)}return _e(),()=>{var pt;dt.forEach(_t=>{nt&&_t.removeEventListener("scroll",_e),rt&&_t.removeEventListener("resize",_e)}),st==null||st(),(pt=ct)==null||pt.disconnect(),ct=null,lt&&cancelAnimationFrame(ft)}}const offset$1=offset$2,shift$1=shift$2,flip$1=flip$2,size$1=size$2,hide$1=hide$2,arrow$2=arrow$3,limitShift$1=limitShift$2,computePosition=(et,_,_e)=>{const tt=new Map,nt={platform,..._e},rt={...nt.platform,_c:tt};return computePosition$1(et,_,{...nt,platform:rt})};var index=typeof document<"u"?reactExports.useLayoutEffect:reactExports.useEffect;function deepEqual(et,_){if(et===_)return!0;if(typeof et!=typeof _)return!1;if(typeof et=="function"&&et.toString()===_.toString())return!0;let _e,tt,nt;if(et&&_&&typeof et=="object"){if(Array.isArray(et)){if(_e=et.length,_e!==_.length)return!1;for(tt=_e;tt--!==0;)if(!deepEqual(et[tt],_[tt]))return!1;return!0}if(nt=Object.keys(et),_e=nt.length,_e!==Object.keys(_).length)return!1;for(tt=_e;tt--!==0;)if(!{}.hasOwnProperty.call(_,nt[tt]))return!1;for(tt=_e;tt--!==0;){const rt=nt[tt];if(!(rt==="_owner"&&et.$$typeof)&&!deepEqual(et[rt],_[rt]))return!1}return!0}return et!==et&&_!==_}function getDPR(et){return typeof window>"u"?1:(et.ownerDocument.defaultView||window).devicePixelRatio||1}function roundByDPR(et,_){const _e=getDPR(et);return Math.round(_*_e)/_e}function useLatestRef(et){const _=reactExports.useRef(et);return index(()=>{_.current=et}),_}function useFloating(et){et===void 0&&(et={});const{placement:_="bottom",strategy:_e="absolute",middleware:tt=[],platform:nt,elements:{reference:rt,floating:ot}={},transform:at=!0,whileElementsMounted:lt,open:ut}=et,[dt,st]=reactExports.useState({x:0,y:0,strategy:_e,placement:_,middlewareData:{},isPositioned:!1}),[it,ct]=reactExports.useState(tt);deepEqual(it,tt)||ct(tt);const[ft,ht]=reactExports.useState(null),[mt,pt]=reactExports.useState(null),_t=reactExports.useCallback(Ut=>{Ut!==xt.current&&(xt.current=Ut,ht(Ut))},[]),vt=reactExports.useCallback(Ut=>{Ut!==Mt.current&&(Mt.current=Ut,pt(Ut))},[]),bt=rt||ft,wt=ot||mt,xt=reactExports.useRef(null),Mt=reactExports.useRef(null),At=reactExports.useRef(dt),St=lt!=null,Tt=useLatestRef(lt),Ct=useLatestRef(nt),It=reactExports.useCallback(()=>{if(!xt.current||!Mt.current)return;const Ut={placement:_,strategy:_e,middleware:it};Ct.current&&(Ut.platform=Ct.current),computePosition(xt.current,Mt.current,Ut).then(Lt=>{const zt={...Lt,isPositioned:!0};$t.current&&!deepEqual(At.current,zt)&&(At.current=zt,reactDomExports.flushSync(()=>{st(zt)}))})},[it,_,_e,Ct]);index(()=>{ut===!1&&At.current.isPositioned&&(At.current.isPositioned=!1,st(Ut=>({...Ut,isPositioned:!1})))},[ut]);const $t=reactExports.useRef(!1);index(()=>($t.current=!0,()=>{$t.current=!1}),[]),index(()=>{if(bt&&(xt.current=bt),wt&&(Mt.current=wt),bt&&wt){if(Tt.current)return Tt.current(bt,wt,It);It()}},[bt,wt,It,Tt,St]);const Nt=reactExports.useMemo(()=>({reference:xt,floating:Mt,setReference:_t,setFloating:vt}),[_t,vt]),Bt=reactExports.useMemo(()=>({reference:bt,floating:wt}),[bt,wt]),Ot=reactExports.useMemo(()=>{const Ut={position:_e,left:0,top:0};if(!Bt.floating)return Ut;const Lt=roundByDPR(Bt.floating,dt.x),zt=roundByDPR(Bt.floating,dt.y);return at?{...Ut,transform:"translate("+Lt+"px, "+zt+"px)",...getDPR(Bt.floating)>=1.5&&{willChange:"transform"}}:{position:_e,left:Lt,top:zt}},[_e,at,Bt.floating,dt.x,dt.y]);return reactExports.useMemo(()=>({...dt,update:It,refs:Nt,elements:Bt,floatingStyles:Ot}),[dt,It,Nt,Bt,Ot])}const arrow$1=et=>{function _(_e){return{}.hasOwnProperty.call(_e,"current")}return{name:"arrow",options:et,fn(_e){const{element:tt,padding:nt}=typeof et=="function"?et(_e):et;return tt&&_(tt)?tt.current!=null?arrow$2({element:tt.current,padding:nt}).fn(_e):{}:tt?arrow$2({element:tt,padding:nt}).fn(_e):{}}}},offset=(et,_)=>({...offset$1(et),options:[et,_]}),shift=(et,_)=>({...shift$1(et),options:[et,_]}),limitShift=(et,_)=>({...limitShift$1(et),options:[et,_]}),flip=(et,_)=>({...flip$1(et),options:[et,_]}),size=(et,_)=>({...size$1(et),options:[et,_]}),hide=(et,_)=>({...hide$1(et),options:[et,_]}),arrow=(et,_)=>({...arrow$1(et),options:[et,_]});var NAME$1="Arrow",Arrow$1=reactExports.forwardRef((et,_)=>{const{children:_e,width:tt=10,height:nt=5,...rt}=et;return jsxRuntimeExports.jsx(Primitive.svg,{...rt,ref:_,width:tt,height:nt,viewBox:"0 0 30 10",preserveAspectRatio:"none",children:et.asChild?_e:jsxRuntimeExports.jsx("polygon",{points:"0,0 30,0 15,10"})})});Arrow$1.displayName=NAME$1;var Root$1=Arrow$1;function useSize(et){const[_,_e]=reactExports.useState(void 0);return useLayoutEffect2(()=>{if(et){_e({width:et.offsetWidth,height:et.offsetHeight});const tt=new ResizeObserver(nt=>{if(!Array.isArray(nt)||!nt.length)return;const rt=nt[0];let ot,at;if("borderBoxSize"in rt){const lt=rt.borderBoxSize,ut=Array.isArray(lt)?lt[0]:lt;ot=ut.inlineSize,at=ut.blockSize}else ot=et.offsetWidth,at=et.offsetHeight;_e({width:ot,height:at})});return tt.observe(et,{box:"border-box"}),()=>tt.unobserve(et)}else _e(void 0)},[et]),_}var POPPER_NAME="Popper",[createPopperContext,createPopperScope]=createContextScope(POPPER_NAME),[PopperProvider,usePopperContext]=createPopperContext(POPPER_NAME),Popper=et=>{const{__scopePopper:_,children:_e}=et,[tt,nt]=reactExports.useState(null);return jsxRuntimeExports.jsx(PopperProvider,{scope:_,anchor:tt,onAnchorChange:nt,children:_e})};Popper.displayName=POPPER_NAME;var ANCHOR_NAME="PopperAnchor",PopperAnchor=reactExports.forwardRef((et,_)=>{const{__scopePopper:_e,virtualRef:tt,...nt}=et,rt=usePopperContext(ANCHOR_NAME,_e),ot=reactExports.useRef(null),at=useComposedRefs(_,ot);return reactExports.useEffect(()=>{rt.onAnchorChange((tt==null?void 0:tt.current)||ot.current)}),tt?null:jsxRuntimeExports.jsx(Primitive.div,{...nt,ref:at})});PopperAnchor.displayName=ANCHOR_NAME;var CONTENT_NAME$1="PopperContent",[PopperContentProvider,useContentContext]=createPopperContext(CONTENT_NAME$1),PopperContent=reactExports.forwardRef((et,_)=>{var Cn,En,jt,Kt,nn,Vt;const{__scopePopper:_e,side:tt="bottom",sideOffset:nt=0,align:rt="center",alignOffset:ot=0,arrowPadding:at=0,avoidCollisions:lt=!0,collisionBoundary:ut=[],collisionPadding:dt=0,sticky:st="partial",hideWhenDetached:it=!1,updatePositionStrategy:ct="optimized",onPlaced:ft,...ht}=et,mt=usePopperContext(CONTENT_NAME$1,_e),[pt,_t]=reactExports.useState(null),vt=useComposedRefs(_,on=>_t(on)),[bt,wt]=reactExports.useState(null),xt=useSize(bt),Mt=(xt==null?void 0:xt.width)??0,At=(xt==null?void 0:xt.height)??0,St=tt+(rt!=="center"?"-"+rt:""),Tt=typeof dt=="number"?dt:{top:0,right:0,bottom:0,left:0,...dt},Ct=Array.isArray(ut)?ut:[ut],It=Ct.length>0,$t={padding:Tt,boundary:Ct.filter(isNotNull),altBoundary:It},{refs:Nt,floatingStyles:Bt,placement:Ot,isPositioned:Ut,middlewareData:Lt}=useFloating({strategy:"fixed",placement:St,whileElementsMounted:(...on)=>autoUpdate(...on,{animationFrame:ct==="always"}),elements:{reference:mt.anchor},middleware:[offset({mainAxis:nt+At,alignmentAxis:ot}),lt&&shift({mainAxis:!0,crossAxis:!1,limiter:st==="partial"?limitShift():void 0,...$t}),lt&&flip({...$t}),size({...$t,apply:({elements:on,rects:dn,availableWidth:Ln,availableHeight:Sn})=>{const{width:Xn,height:Vn}=dn.reference,Hn=on.floating.style;Hn.setProperty("--radix-popper-available-width",`${Ln}px`),Hn.setProperty("--radix-popper-available-height",`${Sn}px`),Hn.setProperty("--radix-popper-anchor-width",`${Xn}px`),Hn.setProperty("--radix-popper-anchor-height",`${Vn}px`)}}),bt&&arrow({element:bt,padding:at}),transformOrigin({arrowWidth:Mt,arrowHeight:At}),it&&hide({strategy:"referenceHidden",...$t})]}),[zt,Yt]=getSideAndAlignFromPlacement(Ot),en=useCallbackRef(ft);useLayoutEffect2(()=>{Ut&&(en==null||en())},[Ut,en]);const bn=(Cn=Lt.arrow)==null?void 0:Cn.x,Un=(En=Lt.arrow)==null?void 0:En.y,mn=((jt=Lt.arrow)==null?void 0:jt.centerOffset)!==0,[vn,In]=reactExports.useState();return useLayoutEffect2(()=>{pt&&In(window.getComputedStyle(pt).zIndex)},[pt]),jsxRuntimeExports.jsx("div",{ref:Nt.setFloating,"data-radix-popper-content-wrapper":"",style:{...Bt,transform:Ut?Bt.transform:"translate(0, -200%)",minWidth:"max-content",zIndex:vn,"--radix-popper-transform-origin":[(Kt=Lt.transformOrigin)==null?void 0:Kt.x,(nn=Lt.transformOrigin)==null?void 0:nn.y].join(" "),...((Vt=Lt.hide)==null?void 0:Vt.referenceHidden)&&{visibility:"hidden",pointerEvents:"none"}},dir:et.dir,children:jsxRuntimeExports.jsx(PopperContentProvider,{scope:_e,placedSide:zt,onArrowChange:wt,arrowX:bn,arrowY:Un,shouldHideArrow:mn,children:jsxRuntimeExports.jsx(Primitive.div,{"data-side":zt,"data-align":Yt,...ht,ref:vt,style:{...ht.style,animation:Ut?void 0:"none"}})})})});PopperContent.displayName=CONTENT_NAME$1;var ARROW_NAME$1="PopperArrow",OPPOSITE_SIDE={top:"bottom",right:"left",bottom:"top",left:"right"},PopperArrow=reactExports.forwardRef(function et(_,_e){const{__scopePopper:tt,...nt}=_,rt=useContentContext(ARROW_NAME$1,tt),ot=OPPOSITE_SIDE[rt.placedSide];return jsxRuntimeExports.jsx("span",{ref:rt.onArrowChange,style:{position:"absolute",left:rt.arrowX,top:rt.arrowY,[ot]:0,transformOrigin:{top:"",right:"0 0",bottom:"center 0",left:"100% 0"}[rt.placedSide],transform:{top:"translateY(100%)",right:"translateY(50%) rotate(90deg) translateX(-50%)",bottom:"rotate(180deg)",left:"translateY(50%) rotate(-90deg) translateX(50%)"}[rt.placedSide],visibility:rt.shouldHideArrow?"hidden":void 0},children:jsxRuntimeExports.jsx(Root$1,{...nt,ref:_e,style:{...nt.style,display:"block"}})})});PopperArrow.displayName=ARROW_NAME$1;function isNotNull(et){return et!==null}var transformOrigin=et=>({name:"transformOrigin",options:et,fn(_){var mt,pt,_t;const{placement:_e,rects:tt,middlewareData:nt}=_,ot=((mt=nt.arrow)==null?void 0:mt.centerOffset)!==0,at=ot?0:et.arrowWidth,lt=ot?0:et.arrowHeight,[ut,dt]=getSideAndAlignFromPlacement(_e),st={start:"0%",center:"50%",end:"100%"}[dt],it=(((pt=nt.arrow)==null?void 0:pt.x)??0)+at/2,ct=(((_t=nt.arrow)==null?void 0:_t.y)??0)+lt/2;let ft="",ht="";return ut==="bottom"?(ft=ot?st:`${it}px`,ht=`${-lt}px`):ut==="top"?(ft=ot?st:`${it}px`,ht=`${tt.floating.height+lt}px`):ut==="right"?(ft=`${-lt}px`,ht=ot?st:`${ct}px`):ut==="left"&&(ft=`${tt.floating.width+lt}px`,ht=ot?st:`${ct}px`),{data:{x:ft,y:ht}}}});function getSideAndAlignFromPlacement(et){const[_,_e="center"]=et.split("-");return[_,_e]}var Root2=Popper,Anchor=PopperAnchor,Content=PopperContent,Arrow=PopperArrow;function useStateMachine(et,_){return reactExports.useReducer((_e,tt)=>_[_e][tt]??_e,et)}var Presence=et=>{const{present:_,children:_e}=et,tt=usePresence(_),nt=typeof _e=="function"?_e({present:tt.isPresent}):reactExports.Children.only(_e),rt=useComposedRefs(tt.ref,getElementRef(nt));return typeof _e=="function"||tt.isPresent?reactExports.cloneElement(nt,{ref:rt}):null};Presence.displayName="Presence";function usePresence(et){const[_,_e]=reactExports.useState(),tt=reactExports.useRef({}),nt=reactExports.useRef(et),rt=reactExports.useRef("none"),ot=et?"mounted":"unmounted",[at,lt]=useStateMachine(ot,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}});return reactExports.useEffect(()=>{const ut=getAnimationName(tt.current);rt.current=at==="mounted"?ut:"none"},[at]),useLayoutEffect2(()=>{const ut=tt.current,dt=nt.current;if(dt!==et){const it=rt.current,ct=getAnimationName(ut);et?lt("MOUNT"):ct==="none"||(ut==null?void 0:ut.display)==="none"?lt("UNMOUNT"):lt(dt&&it!==ct?"ANIMATION_OUT":"UNMOUNT"),nt.current=et}},[et,lt]),useLayoutEffect2(()=>{if(_){const ut=st=>{const ct=getAnimationName(tt.current).includes(st.animationName);st.target===_&&ct&&reactDomExports.flushSync(()=>lt("ANIMATION_END"))},dt=st=>{st.target===_&&(rt.current=getAnimationName(tt.current))};return _.addEventListener("animationstart",dt),_.addEventListener("animationcancel",ut),_.addEventListener("animationend",ut),()=>{_.removeEventListener("animationstart",dt),_.removeEventListener("animationcancel",ut),_.removeEventListener("animationend",ut)}}else lt("ANIMATION_END")},[_,lt]),{isPresent:["mounted","unmountSuspended"].includes(at),ref:reactExports.useCallback(ut=>{ut&&(tt.current=getComputedStyle(ut)),_e(ut)},[])}}function getAnimationName(et){return(et==null?void 0:et.animationName)||"none"}function getElementRef(et){var tt,nt;let _=(tt=Object.getOwnPropertyDescriptor(et.props,"ref"))==null?void 0:tt.get,_e=_&&"isReactWarning"in _&&_.isReactWarning;return _e?et.ref:(_=(nt=Object.getOwnPropertyDescriptor(et,"ref"))==null?void 0:nt.get,_e=_&&"isReactWarning"in _&&_.isReactWarning,_e?et.props.ref:et.props.ref||et.ref)}function useControllableState({prop:et,defaultProp:_,onChange:_e=()=>{}}){const[tt,nt]=useUncontrolledState({defaultProp:_,onChange:_e}),rt=et!==void 0,ot=rt?et:tt,at=useCallbackRef(_e),lt=reactExports.useCallback(ut=>{if(rt){const st=typeof ut=="function"?ut(et):ut;st!==et&&at(st)}else nt(ut)},[rt,et,nt,at]);return[ot,lt]}function useUncontrolledState({defaultProp:et,onChange:_}){const _e=reactExports.useState(et),[tt]=_e,nt=reactExports.useRef(tt),rt=useCallbackRef(_);return reactExports.useEffect(()=>{nt.current!==tt&&(rt(tt),nt.current=tt)},[tt,nt,rt]),_e}var NAME="VisuallyHidden",VisuallyHidden=reactExports.forwardRef((et,_)=>jsxRuntimeExports.jsx(Primitive.span,{...et,ref:_,style:{position:"absolute",border:0,width:1,height:1,padding:0,margin:-1,overflow:"hidden",clip:"rect(0, 0, 0, 0)",whiteSpace:"nowrap",wordWrap:"normal",...et.style}}));VisuallyHidden.displayName=NAME;var Root=VisuallyHidden,[createTooltipContext,createTooltipScope]=createContextScope("Tooltip",[createPopperScope]),usePopperScope=createPopperScope(),PROVIDER_NAME="TooltipProvider",TOOLTIP_OPEN="tooltip.open",[TooltipProviderContextProvider,useTooltipProviderContext]=createTooltipContext(PROVIDER_NAME),TOOLTIP_NAME="Tooltip",[TooltipContextProvider,useTooltipContext]=createTooltipContext(TOOLTIP_NAME),Tooltip=et=>{const{__scopeTooltip:_,children:_e,open:tt,defaultOpen:nt=!1,onOpenChange:rt,disableHoverableContent:ot,delayDuration:at}=et,lt=useTooltipProviderContext(TOOLTIP_NAME,et.__scopeTooltip),ut=usePopperScope(_),[dt,st]=reactExports.useState(null),it=useId(),ct=reactExports.useRef(0),ft=ot??lt.disableHoverableContent,ht=at??lt.delayDuration,mt=reactExports.useRef(!1),[pt=!1,_t]=useControllableState({prop:tt,defaultProp:nt,onChange:Mt=>{Mt?(lt.onOpen(),document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN))):lt.onClose(),rt==null||rt(Mt)}}),vt=reactExports.useMemo(()=>pt?mt.current?"delayed-open":"instant-open":"closed",[pt]),bt=reactExports.useCallback(()=>{window.clearTimeout(ct.current),mt.current=!1,_t(!0)},[_t]),wt=reactExports.useCallback(()=>{window.clearTimeout(ct.current),_t(!1)},[_t]),xt=reactExports.useCallback(()=>{window.clearTimeout(ct.current),ct.current=window.setTimeout(()=>{mt.current=!0,_t(!0)},ht)},[ht,_t]);return reactExports.useEffect(()=>()=>window.clearTimeout(ct.current),[]),jsxRuntimeExports.jsx(Root2,{...ut,children:jsxRuntimeExports.jsx(TooltipContextProvider,{scope:_,contentId:it,open:pt,stateAttribute:vt,trigger:dt,onTriggerChange:st,onTriggerEnter:reactExports.useCallback(()=>{lt.isOpenDelayed?xt():bt()},[lt.isOpenDelayed,xt,bt]),onTriggerLeave:reactExports.useCallback(()=>{ft?wt():window.clearTimeout(ct.current)},[wt,ft]),onOpen:bt,onClose:wt,disableHoverableContent:ft,children:_e})})};Tooltip.displayName=TOOLTIP_NAME;var TRIGGER_NAME="TooltipTrigger",TooltipTrigger=reactExports.forwardRef((et,_)=>{const{__scopeTooltip:_e,...tt}=et,nt=useTooltipContext(TRIGGER_NAME,_e),rt=useTooltipProviderContext(TRIGGER_NAME,_e),ot=usePopperScope(_e),at=reactExports.useRef(null),lt=useComposedRefs(_,at,nt.onTriggerChange),ut=reactExports.useRef(!1),dt=reactExports.useRef(!1),st=reactExports.useCallback(()=>ut.current=!1,[]);return reactExports.useEffect(()=>()=>document.removeEventListener("pointerup",st),[st]),jsxRuntimeExports.jsx(Anchor,{asChild:!0,...ot,children:jsxRuntimeExports.jsx(Primitive.button,{"aria-describedby":nt.open?nt.contentId:void 0,"data-state":nt.stateAttribute,...tt,ref:lt,onPointerMove:composeEventHandlers$1(et.onPointerMove,it=>{it.pointerType!=="touch"&&!dt.current&&!rt.isPointerInTransitRef.current&&(nt.onTriggerEnter(),dt.current=!0)}),onPointerLeave:composeEventHandlers$1(et.onPointerLeave,()=>{nt.onTriggerLeave(),dt.current=!1}),onPointerDown:composeEventHandlers$1(et.onPointerDown,()=>{ut.current=!0,document.addEventListener("pointerup",st,{once:!0})}),onFocus:composeEventHandlers$1(et.onFocus,()=>{ut.current||nt.onOpen()}),onBlur:composeEventHandlers$1(et.onBlur,nt.onClose),onClick:composeEventHandlers$1(et.onClick,nt.onClose)})})});TooltipTrigger.displayName=TRIGGER_NAME;var PORTAL_NAME="TooltipPortal",[PortalProvider,usePortalContext]=createTooltipContext(PORTAL_NAME,{forceMount:void 0}),CONTENT_NAME="TooltipContent",TooltipContent=reactExports.forwardRef((et,_)=>{const _e=usePortalContext(CONTENT_NAME,et.__scopeTooltip),{forceMount:tt=_e.forceMount,side:nt="top",...rt}=et,ot=useTooltipContext(CONTENT_NAME,et.__scopeTooltip);return jsxRuntimeExports.jsx(Presence,{present:tt||ot.open,children:ot.disableHoverableContent?jsxRuntimeExports.jsx(TooltipContentImpl,{side:nt,...rt,ref:_}):jsxRuntimeExports.jsx(TooltipContentHoverable,{side:nt,...rt,ref:_})})}),TooltipContentHoverable=reactExports.forwardRef((et,_)=>{const _e=useTooltipContext(CONTENT_NAME,et.__scopeTooltip),tt=useTooltipProviderContext(CONTENT_NAME,et.__scopeTooltip),nt=reactExports.useRef(null),rt=useComposedRefs(_,nt),[ot,at]=reactExports.useState(null),{trigger:lt,onClose:ut}=_e,dt=nt.current,{onPointerInTransitChange:st}=tt,it=reactExports.useCallback(()=>{at(null),st(!1)},[st]),ct=reactExports.useCallback((ft,ht)=>{const mt=ft.currentTarget,pt={x:ft.clientX,y:ft.clientY},_t=getExitSideFromRect(pt,mt.getBoundingClientRect()),vt=getPaddedExitPoints(pt,_t),bt=getPointsFromRect(ht.getBoundingClientRect()),wt=getHull([...vt,...bt]);at(wt),st(!0)},[st]);return reactExports.useEffect(()=>()=>it(),[it]),reactExports.useEffect(()=>{if(lt&&dt){const ft=mt=>ct(mt,dt),ht=mt=>ct(mt,lt);return lt.addEventListener("pointerleave",ft),dt.addEventListener("pointerleave",ht),()=>{lt.removeEventListener("pointerleave",ft),dt.removeEventListener("pointerleave",ht)}}},[lt,dt,ct,it]),reactExports.useEffect(()=>{if(ot){const ft=ht=>{const mt=ht.target,pt={x:ht.clientX,y:ht.clientY},_t=(lt==null?void 0:lt.contains(mt))||(dt==null?void 0:dt.contains(mt)),vt=!isPointInPolygon(pt,ot);_t?it():vt&&(it(),ut())};return document.addEventListener("pointermove",ft),()=>document.removeEventListener("pointermove",ft)}},[lt,dt,ot,ut,it]),jsxRuntimeExports.jsx(TooltipContentImpl,{...et,ref:rt})}),[VisuallyHiddenContentContextProvider,useVisuallyHiddenContentContext]=createTooltipContext(TOOLTIP_NAME,{isInside:!1}),TooltipContentImpl=reactExports.forwardRef((et,_)=>{const{__scopeTooltip:_e,children:tt,"aria-label":nt,onEscapeKeyDown:rt,onPointerDownOutside:ot,...at}=et,lt=useTooltipContext(CONTENT_NAME,_e),ut=usePopperScope(_e),{onClose:dt}=lt;return reactExports.useEffect(()=>(document.addEventListener(TOOLTIP_OPEN,dt),()=>document.removeEventListener(TOOLTIP_OPEN,dt)),[dt]),reactExports.useEffect(()=>{if(lt.trigger){const st=it=>{const ct=it.target;ct!=null&&ct.contains(lt.trigger)&&dt()};return window.addEventListener("scroll",st,{capture:!0}),()=>window.removeEventListener("scroll",st,{capture:!0})}},[lt.trigger,dt]),jsxRuntimeExports.jsx(DismissableLayer,{asChild:!0,disableOutsidePointerEvents:!1,onEscapeKeyDown:rt,onPointerDownOutside:ot,onFocusOutside:st=>st.preventDefault(),onDismiss:dt,children:jsxRuntimeExports.jsxs(Content,{"data-state":lt.stateAttribute,...ut,...at,ref:_,style:{...at.style,"--radix-tooltip-content-transform-origin":"var(--radix-popper-transform-origin)","--radix-tooltip-content-available-width":"var(--radix-popper-available-width)","--radix-tooltip-content-available-height":"var(--radix-popper-available-height)","--radix-tooltip-trigger-width":"var(--radix-popper-anchor-width)","--radix-tooltip-trigger-height":"var(--radix-popper-anchor-height)"},children:[jsxRuntimeExports.jsx(Slottable,{children:tt}),jsxRuntimeExports.jsx(VisuallyHiddenContentContextProvider,{scope:_e,isInside:!0,children:jsxRuntimeExports.jsx(Root,{id:lt.contentId,role:"tooltip",children:nt||tt})})]})})});TooltipContent.displayName=CONTENT_NAME;var ARROW_NAME="TooltipArrow",TooltipArrow=reactExports.forwardRef((et,_)=>{const{__scopeTooltip:_e,...tt}=et,nt=usePopperScope(_e);return useVisuallyHiddenContentContext(ARROW_NAME,_e).isInside?null:jsxRuntimeExports.jsx(Arrow,{...nt,...tt,ref:_})});TooltipArrow.displayName=ARROW_NAME;function getExitSideFromRect(et,_){const _e=Math.abs(_.top-et.y),tt=Math.abs(_.bottom-et.y),nt=Math.abs(_.right-et.x),rt=Math.abs(_.left-et.x);switch(Math.min(_e,tt,nt,rt)){case rt:return"left";case nt:return"right";case _e:return"top";case tt:return"bottom";default:throw new Error("unreachable")}}function getPaddedExitPoints(et,_,_e=5){const tt=[];switch(_){case"top":tt.push({x:et.x-_e,y:et.y+_e},{x:et.x+_e,y:et.y+_e});break;case"bottom":tt.push({x:et.x-_e,y:et.y-_e},{x:et.x+_e,y:et.y-_e});break;case"left":tt.push({x:et.x+_e,y:et.y-_e},{x:et.x+_e,y:et.y+_e});break;case"right":tt.push({x:et.x-_e,y:et.y-_e},{x:et.x-_e,y:et.y+_e});break}return tt}function getPointsFromRect(et){const{top:_,right:_e,bottom:tt,left:nt}=et;return[{x:nt,y:_},{x:_e,y:_},{x:_e,y:tt},{x:nt,y:tt}]}function isPointInPolygon(et,_){const{x:_e,y:tt}=et;let nt=!1;for(let rt=0,ot=_.length-1;rt<_.length;ot=rt++){const at=_[rt].x,lt=_[rt].y,ut=_[ot].x,dt=_[ot].y;lt>tt!=dt>tt&&_e<(ut-at)*(tt-lt)/(dt-lt)+at&&(nt=!nt)}return nt}function getHull(et){const _=et.slice();return _.sort((_e,tt)=>_e.x<tt.x?-1:_e.x>tt.x?1:_e.y<tt.y?-1:_e.y>tt.y?1:0),getHullPresorted(_)}function getHullPresorted(et){if(et.length<=1)return et.slice();const _=[];for(let tt=0;tt<et.length;tt++){const nt=et[tt];for(;_.length>=2;){const rt=_[_.length-1],ot=_[_.length-2];if((rt.x-ot.x)*(nt.y-ot.y)>=(rt.y-ot.y)*(nt.x-ot.x))_.pop();else break}_.push(nt)}_.pop();const _e=[];for(let tt=et.length-1;tt>=0;tt--){const nt=et[tt];for(;_e.length>=2;){const rt=_e[_e.length-1],ot=_e[_e.length-2];if((rt.x-ot.x)*(nt.y-ot.y)>=(rt.y-ot.y)*(nt.x-ot.x))_e.pop();else break}_e.push(nt)}return _e.pop(),_.length===1&&_e.length===1&&_[0].x===_e[0].x&&_[0].y===_e[0].y?_:_.concat(_e)}var Root3=Tooltip,Trigger=TooltipTrigger,Content2=TooltipContent,Arrow2=TooltipArrow;function _objectWithoutPropertiesLoose$1(et,_){if(et==null)return{};var _e={},tt=Object.keys(et),nt,rt;for(rt=0;rt<tt.length;rt++)nt=tt[rt],!(_.indexOf(nt)>=0)&&(_e[nt]=et[nt]);return _e}function _objectWithoutProperties$1(et,_){if(et==null)return{};var _e=_objectWithoutPropertiesLoose$1(et,_),tt,nt;if(Object.getOwnPropertySymbols){var rt=Object.getOwnPropertySymbols(et);for(nt=0;nt<rt.length;nt++)tt=rt[nt],!(_.indexOf(tt)>=0)&&Object.prototype.propertyIsEnumerable.call(et,tt)&&(_e[tt]=et[tt])}return _e}let LevaErrors;(function(et){et[et.UNSUPPORTED_INPUT=0]="UNSUPPORTED_INPUT",et[et.NO_COMPONENT_FOR_TYPE=1]="NO_COMPONENT_FOR_TYPE",et[et.UNKNOWN_INPUT=2]="UNKNOWN_INPUT",et[et.DUPLICATE_KEYS=3]="DUPLICATE_KEYS",et[et.ALREADY_REGISTERED_TYPE=4]="ALREADY_REGISTERED_TYPE",et[et.CLIPBOARD_ERROR=5]="CLIPBOARD_ERROR",et[et.THEME_ERROR=6]="THEME_ERROR",et[et.PATH_DOESNT_EXIST=7]="PATH_DOESNT_EXIST",et[et.INPUT_TYPE_OVERRIDE=8]="INPUT_TYPE_OVERRIDE",et[et.EMPTY_KEY=9]="EMPTY_KEY"})(LevaErrors||(LevaErrors={}));const ErrorList={[LevaErrors.UNSUPPORTED_INPUT]:(et,_)=>[`An input with type \`${et}\` input was found at path \`${_}\` but it's not supported yet.`],[LevaErrors.NO_COMPONENT_FOR_TYPE]:(et,_)=>[`Type \`${et}\` found at path \`${_}\` can't be displayed in panel because no component supports it yet.`],[LevaErrors.UNKNOWN_INPUT]:(et,_)=>[`input at path \`${et}\` is not recognized.`,_],[LevaErrors.DUPLICATE_KEYS]:(et,_,_e)=>[`Key \`${et}\` of path \`${_}\` already exists at path \`${_e}\`. Even nested keys need to be unique. Rename one of the keys.`],[LevaErrors.ALREADY_REGISTERED_TYPE]:et=>[`Type ${et} has already been registered. You can't register a component with the same type.`],[LevaErrors.CLIPBOARD_ERROR]:et=>["Error copying the value",et],[LevaErrors.THEME_ERROR]:(et,_)=>[`Error accessing the theme \`${et}.${_}\` value.`],[LevaErrors.PATH_DOESNT_EXIST]:et=>[`Error getting the value at path \`${et}\`. There is probably an error in your \`render\` function.`],[LevaErrors.PATH_DOESNT_EXIST]:et=>[`Error accessing the value at path \`${et}\``],[LevaErrors.INPUT_TYPE_OVERRIDE]:(et,_,_e)=>[`Input at path \`${et}\` already exists with type: \`${_}\`. Its type cannot be overridden with type \`${_e}\`.`],[LevaErrors.EMPTY_KEY]:()=>["Keys can not be empty, if you want to hide a label use whitespace."]};function _log(et,_,..._e){const[tt,...nt]=ErrorList[_](..._e);console[et]("LEVA: "+tt,...nt)}const warn=_log.bind(null,"warn"),log=_log.bind(null,"log"),_excluded$a=["value"],_excluded2$4=["schema"],_excluded3$1=["value"],Schemas=[],Plugins={};function getValueType(et){let{value:_}=et,_e=_objectWithoutProperties$1(et,_excluded$a);for(let tt of Schemas){const nt=tt(_,_e);if(nt)return nt}}function register(et,_){let{schema:_e}=_,tt=_objectWithoutProperties$1(_,_excluded2$4);if(et in Plugins){warn(LevaErrors.ALREADY_REGISTERED_TYPE,et);return}Schemas.push((nt,rt)=>_e(nt,rt)&&et),Plugins[et]=tt}function createInternalPlugin(et){return et}function normalize$3$1(et,_,_e,tt){const{normalize:nt}=Plugins[et];if(nt)return nt(_,_e,tt);if(typeof _!="object"||!("value"in _))return{value:_};const{value:rt}=_,ot=_objectWithoutProperties$1(_,_excluded3$1);return{value:rt,settings:ot}}function sanitize$4(et,_,_e,tt,nt,rt){const{sanitize:ot}=Plugins[et];return ot?ot(_,_e,tt,nt,rt):_}function format$2(et,_,_e){const{format:tt}=Plugins[et];return tt?tt(_,_e):_}function _defineProperty$2(et,_,_e){return _ in et?Object.defineProperty(et,_,{value:_e,enumerable:!0,configurable:!0,writable:!0}):et[_]=_e,et}function ownKeys$2(et,_){var _e=Object.keys(et);if(Object.getOwnPropertySymbols){var tt=Object.getOwnPropertySymbols(et);_&&(tt=tt.filter(function(nt){return Object.getOwnPropertyDescriptor(et,nt).enumerable})),_e.push.apply(_e,tt)}return _e}function _objectSpread2(et){for(var _=1;_<arguments.length;_++){var _e=arguments[_]!=null?arguments[_]:{};_%2?ownKeys$2(Object(_e),!0).forEach(function(tt){_defineProperty$2(et,tt,_e[tt])}):Object.getOwnPropertyDescriptors?Object.defineProperties(et,Object.getOwnPropertyDescriptors(_e)):ownKeys$2(Object(_e)).forEach(function(tt){Object.defineProperty(et,tt,Object.getOwnPropertyDescriptor(_e,tt))})}return et}const clamp=(et,_,_e)=>et>_e?_e:et<_?_:et,parseNumber=et=>{if(et===""||typeof et=="number")return et;try{const _=evaluate(et);if(!isNaN(_))return _}catch{}return parseFloat(et)},log10=Math.log(10);function getStep(et){let _=Math.abs(+String(et).replace(".",""));if(_===0)return .01;for(;_!==0&&_%10===0;)_/=10;const _e=Math.floor(Math.log(_)/log10)+1,tt=Math.floor(Math.log10(Math.abs(et))),nt=Math.pow(10,tt-_e);return Math.max(nt,.001)}const range=(et,_,_e)=>_e===_?0:(clamp(et,_,_e)-_)/(_e-_),invertedRange=(et,_,_e)=>et*(_e-_)+_,getUid=()=>"_"+Math.random().toString(36).substr(2,9),parens=/\(([0-9+\-*/^ .]+)\)/,exp=/(\d+(?:\.\d+)?) ?\^ ?(\d+(?:\.\d+)?)/,mul=/(\d+(?:\.\d+)?) ?\* ?(\d+(?:\.\d+)?)/,div=/(\d+(?:\.\d+)?) ?\/ ?(\d+(?:\.\d+)?)/,add=/(\d+(?:\.\d+)?) ?\+ ?(\d+(?:\.\d+)?)/,sub=/(\d+(?:\.\d+)?) ?- ?(\d+(?:\.\d+)?)/;function evaluate(et){if(isNaN(Number(et)))if(parens.test(et)){const _=et.replace(parens,(_e,tt)=>String(evaluate(tt)));return evaluate(_)}else if(exp.test(et)){const _=et.replace(exp,(_e,tt,nt)=>String(Math.pow(Number(tt),Number(nt))));return evaluate(_)}else if(mul.test(et)){const _=et.replace(mul,(_e,tt,nt)=>String(Number(tt)*Number(nt)));return evaluate(_)}else if(div.test(et)){const _=et.replace(div,(_e,tt,nt)=>{if(nt!=0)return String(Number(tt)/Number(nt));throw new Error("Division by zero")});return evaluate(_)}else if(add.test(et)){const _=et.replace(add,(_e,tt,nt)=>String(Number(tt)+Number(nt)));return evaluate(_)}else if(sub.test(et)){const _=et.replace(sub,(_e,tt,nt)=>String(Number(tt)-Number(nt)));return evaluate(_)}else return Number(et);return Number(et)}function pick(et,_){return _.reduce((_e,tt)=>(et&&et.hasOwnProperty(tt)&&(_e[tt]=et[tt]),_e),{})}function omit(et,_){const _e=_objectSpread2({},et);return _.forEach(tt=>tt in et&&delete _e[tt]),_e}function mapArrayToKeys(et,_){return et.reduce((_e,tt,nt)=>Object.assign(_e,{[_[nt]]:tt}),{})}function isObject$8(et){return Object.prototype.toString.call(et)==="[object Object]"}const isEmptyObject=et=>isObject$8(et)&&Object.keys(et).length===0;let SpecialInputs;(function(et){et.BUTTON="BUTTON",et.BUTTON_GROUP="BUTTON_GROUP",et.MONITOR="MONITOR",et.FOLDER="FOLDER"})(SpecialInputs||(SpecialInputs={}));let LevaInputs;(function(et){et.SELECT="SELECT",et.IMAGE="IMAGE",et.NUMBER="NUMBER",et.COLOR="COLOR",et.STRING="STRING",et.BOOLEAN="BOOLEAN",et.INTERVAL="INTERVAL",et.VECTOR3D="VECTOR3D",et.VECTOR2D="VECTOR2D"})(LevaInputs||(LevaInputs={}));const _excluded$9=["type","__customInput"],_excluded2$3=["render","label","optional","order","disabled","hint","onChange","onEditStart","onEditEnd","transient"],_excluded3$2=["type"];function parseOptions(et,_,_e={},tt){var nt,rt;if(typeof et!="object"||Array.isArray(et))return{type:tt,input:et,options:_objectSpread2({key:_,label:_,optional:!1,disabled:!1,order:0},_e)};if("__customInput"in et){const{type:wt,__customInput:xt}=et,Mt=_objectWithoutProperties$1(et,_excluded$9);return parseOptions(xt,_,Mt,wt)}const{render:ot,label:at,optional:lt,order:ut=0,disabled:dt,hint:st,onChange:it,onEditStart:ct,onEditEnd:ft,transient:ht}=et,mt=_objectWithoutProperties$1(et,_excluded2$3),pt=_objectSpread2({render:ot,key:_,label:at??_,hint:st,transient:ht??!!it,onEditStart:ct,onEditEnd:ft,disabled:dt,optional:lt,order:ut},_e);let{type:_t}=mt,vt=_objectWithoutProperties$1(mt,_excluded3$2);if(_t=tt??_t,_t in SpecialInputs)return{type:_t,input:vt,options:pt};let bt;return tt&&isObject$8(vt)&&"value"in vt?bt=vt.value:bt=isEmptyObject(vt)?void 0:vt,{type:_t,input:bt,options:_objectSpread2(_objectSpread2({},pt),{},{onChange:it,optional:(nt=pt.optional)!==null&&nt!==void 0?nt:!1,disabled:(rt=pt.disabled)!==null&&rt!==void 0?rt:!1})}}function normalizeInput(et,_,_e,tt){const nt=parseOptions(et,_),{type:rt,input:ot,options:at}=nt;if(rt)return rt in SpecialInputs?nt:{type:rt,input:normalize$3$1(rt,ot,_e,tt),options:at};let lt=getValueType(ot);return lt?{type:lt,input:normalize$3$1(lt,ot,_e,tt),options:at}:(lt=getValueType({value:ot}),lt?{type:lt,input:normalize$3$1(lt,{value:ot},_e,tt),options:at}:!1)}function updateInput(et,_,_e,tt,nt){const{value:rt,type:ot,settings:at}=et;et.value=sanitizeValue({type:ot,value:rt,settings:at},_,_e,tt),et.fromPanel=nt}const ValueError=function et(_,_e,tt){this.type="LEVA_ERROR",this.message="LEVA: "+_,this.previousValue=_e,this.error=tt};function sanitizeValue({type:et,value:_,settings:_e},tt,nt,rt){const ot=et!=="SELECT"&&typeof tt=="function"?tt(_):tt;let at;try{at=sanitize$4(et,ot,_e,_,nt,rt)}catch(lt){throw new ValueError(`The value \`${tt}\` did not result in a correct value.`,_,lt)}return dequal(at,_)?_:at}const debounce=(et,_,_e=!1)=>{let tt=0;return function(){const nt=arguments,rt=_e&&!tt,ot=()=>et.apply(this,nt);window.clearTimeout(tt),tt=window.setTimeout(ot,_),rt&&ot()}},multiplyStep=et=>et.shiftKey?5:et.altKey?1/5:1;function render(et,_){const _e=console.error;console.error=()=>{},ReactDOM.render(et,_),console.error=_e}const _excluded$8=["value"],_excluded2$2$1=["min","max"],schema$3=et=>{if(typeof et=="number")return!0;if(typeof et=="string"){const _=parseFloat(et);return isNaN(_)?!1:et.substring((""+_).length).trim().length<4}return!1},sanitize$3=(et,{min:_=-1/0,max:_e=1/0,suffix:tt})=>{const nt=parseFloat(et);if(et===""||isNaN(nt))throw Error("Invalid number");const rt=clamp(nt,_,_e);return tt?rt+tt:rt},format$1$1=(et,{pad:_=0,suffix:_e})=>{const tt=parseFloat(et).toFixed(_);return _e?tt+_e:tt},normalize$2$1=et=>{let{value:_}=et,_e=_objectWithoutProperties$1(et,_excluded$8);const{min:tt=-1/0,max:nt=1/0}=_e,rt=_objectWithoutProperties$1(_e,_excluded2$2$1);let ot=parseFloat(_);const at=typeof _=="string"?_.substring((""+ot).length):void 0;ot=clamp(ot,tt,nt);let lt=_e.step;lt||(Number.isFinite(tt)?Number.isFinite(nt)?lt=+(Math.abs(nt-tt)/100).toPrecision(1):lt=+(Math.abs(ot-tt)/100).toPrecision(1):Number.isFinite(nt)&&(lt=+(Math.abs(nt-ot)/100).toPrecision(1)));const ut=lt?getStep(lt)*10:getStep(ot);lt=lt||ut/10;const dt=Math.round(clamp(Math.log10(1/ut),0,2));return{value:at?ot+at:ot,settings:_objectSpread2({initialValue:ot,step:lt,pad:dt,min:tt,max:nt,suffix:at},rt)}},sanitizeStep$1=(et,{step:_,initialValue:_e})=>{const tt=Math.round((et-_e)/_);return _e+tt*_};var props$3=Object.freeze({__proto__:null,schema:schema$3,sanitize:sanitize$3,format:format$1$1,normalize:normalize$2$1,sanitizeStep:sanitizeStep$1});function _extends(){return _extends=Object.assign?Object.assign.bind():function(et){for(var _=1;_<arguments.length;_++){var _e=arguments[_];for(var tt in _e)Object.prototype.hasOwnProperty.call(_e,tt)&&(et[tt]=_e[tt])}return et},_extends.apply(this,arguments)}const InputContext=reactExports.createContext({});function useInputContext(){return reactExports.useContext(InputContext)}const ThemeContext=reactExports.createContext(null),StoreContext=reactExports.createContext(null),PanelSettingsContext=reactExports.createContext(null);function useStoreContext(){return reactExports.useContext(StoreContext)}function usePanelSettingsContext(){return reactExports.useContext(PanelSettingsContext)}const getDefaultTheme=()=>({colors:{elevation1:"#292d39",elevation2:"#181c20",elevation3:"#373c4b",accent1:"#0066dc",accent2:"#007bff",accent3:"#3c93ff",highlight1:"#535760",highlight2:"#8c92a4",highlight3:"#fefefe",vivid1:"#ffcc00",folderWidgetColor:"$highlight2",folderTextColor:"$highlight3",toolTipBackground:"$highlight3",toolTipText:"$elevation2"},radii:{xs:"2px",sm:"3px",lg:"10px"},space:{xs:"3px",sm:"6px",md:"10px",rowGap:"7px",colGap:"7px"},fonts:{mono:"ui-monospace, SFMono-Regular, Menlo, 'Roboto Mono', monospace",sans:"system-ui, sans-serif"},fontSizes:{root:"11px",toolTip:"$root"},sizes:{rootWidth:"280px",controlWidth:"160px",numberInputMinWidth:"38px",scrubberWidth:"8px",scrubberHeight:"16px",rowHeight:"24px",folderTitleHeight:"20px",checkboxSize:"16px",joystickWidth:"100px",joystickHeight:"100px",colorPickerWidth:"$controlWidth",colorPickerHeight:"100px",imagePreviewWidth:"$controlWidth",imagePreviewHeight:"100px",monitorHeight:"60px",titleBarHeight:"39px"},shadows:{level1:"0 0 9px 0 #00000088",level2:"0 4px 14px #00000033"},borderWidths:{root:"0px",input:"1px",focus:"1px",hover:"1px",active:"1px",folder:"1px"},fontWeights:{label:"normal",folder:"normal",button:"normal"}});function createStateClass(et,_){const[_e,tt]=et.split(" "),nt={};return _e!=="none"&&(nt.boxShadow=`${_.inset?"inset ":""}0 0 0 $borderWidths${[_.key]} $colors${_e!=="default"&&_e||_.borderColor}`),tt&&(nt.backgroundColor=tt),nt}const utils={$inputStyle:()=>et=>createStateClass(et,{key:"$input",borderColor:"$highlight1",inset:!0}),$focusStyle:()=>et=>createStateClass(et,{key:"$focus",borderColor:"$accent2"}),$hoverStyle:()=>et=>createStateClass(et,{key:"$hover",borderColor:"$accent1",inset:!0}),$activeStyle:()=>et=>createStateClass(et,{key:"$active",borderColor:"$accent1",inset:!0})},{styled,css,createTheme,globalCss,keyframes}=q$1({prefix:"leva",theme:getDefaultTheme(),utils:_objectSpread2(_objectSpread2({},utils),{},{$flex:()=>({display:"flex",alignItems:"center"}),$flexCenter:()=>({display:"flex",alignItems:"center",justifyContent:"center"}),$reset:()=>({outline:"none",fontSize:"inherit",fontWeight:"inherit",color:"inherit",fontFamily:"inherit",border:"none",backgroundColor:"transparent",appearance:"none"}),$draggable:()=>({touchAction:"none",WebkitUserDrag:"none",userSelect:"none"}),$focus:et=>({"&:focus":utils.$focusStyle()(et)}),$focusWithin:et=>({"&:focus-within":utils.$focusStyle()(et)}),$hover:et=>({"&:hover":utils.$hoverStyle()(et)}),$active:et=>({"&:active":utils.$activeStyle()(et)})})}),globalStyles=globalCss({".leva__panel__dragged":{WebkitUserDrag:"none",userSelect:"none",input:{userSelect:"none"},"*":{cursor:"ew-resize !important"}}});function mergeTheme(et){const _=getDefaultTheme();if(!et)return{theme:_,className:""};Object.keys(et).forEach(tt=>{Object.assign(_[tt],et[tt])});const _e=createTheme(_);return{theme:_,className:_e.className}}function useTh(et,_){const{theme:_e}=reactExports.useContext(ThemeContext);if(!(et in _e)||!(_ in _e[et]))return warn(LevaErrors.THEME_ERROR,et,_),"";let tt=_;for(;;){let nt=_e[et][tt];if(typeof nt=="string"&&nt.charAt(0)==="$")tt=nt.substr(1);else return nt}}const StyledInput=styled("input",{$reset:"",padding:"0 $sm",width:0,minWidth:0,flex:1,height:"100%",variants:{levaType:{number:{textAlign:"right"}},as:{textarea:{padding:"$sm"}}}}),InnerLabel=styled("div",{$draggable:"",height:"100%",$flexCenter:"",position:"relative",padding:"0 $xs",fontSize:"0.8em",opacity:.8,cursor:"default",touchAction:"none",[`& + ${StyledInput}`]:{paddingLeft:0}}),InnerNumberLabel=styled(InnerLabel,{cursor:"ew-resize",marginRight:"-$xs",textTransform:"uppercase",opacity:.3,"&:hover":{opacity:1},variants:{dragging:{true:{backgroundColor:"$accent2",opacity:1}}}}),InputContainer=styled("div",{$flex:"",position:"relative",borderRadius:"$sm",overflow:"hidden",color:"inherit",height:"$rowHeight",backgroundColor:"$elevation3",$inputStyle:"$elevation1",$hover:"",$focusWithin:"",variants:{textArea:{true:{height:"auto"}}}}),_excluded$7$1=["innerLabel","value","onUpdate","onChange","onKeyDown","type","id","inputType","rows"],_excluded2$1$1=["onUpdate"];function ValueInput(et){let{innerLabel:_,value:_e,onUpdate:tt,onChange:nt,onKeyDown:rt,type:ot,id:at,inputType:lt="text",rows:ut=0}=et,dt=_objectWithoutProperties$1(et,_excluded$7$1);const{id:st,emitOnEditStart:it,emitOnEditEnd:ct,disabled:ft}=useInputContext(),ht=at||st,mt=reactExports.useRef(null),pt=ut>0,_t=pt?"textarea":"input",vt=reactExports.useCallback(xt=>Mt=>{const At=Mt.currentTarget.value;xt(At)},[]);React.useEffect(()=>{const xt=mt.current,Mt=vt(At=>{tt(At),ct()});return xt==null||xt.addEventListener("blur",Mt),()=>xt==null?void 0:xt.removeEventListener("blur",Mt)},[vt,tt,ct]);const bt=reactExports.useCallback(xt=>{xt.key==="Enter"&&vt(tt)(xt)},[vt,tt]),wt=Object.assign({as:_t},pt?{rows:ut}:{},dt);return React.createElement(InputContainer,{textArea:pt},_&&typeof _=="string"?React.createElement(InnerLabel,null,_):_,React.createElement(StyledInput,_extends({levaType:ot,ref:mt,id:ht,type:lt,autoComplete:"off",spellCheck:"false",value:_e,onChange:vt(nt),onFocus:()=>it(),onKeyPress:bt,onKeyDown:rt,disabled:ft},wt)))}function NumberInput(et){let{onUpdate:_}=et,_e=_objectWithoutProperties$1(et,_excluded2$1$1);const tt=reactExports.useCallback(rt=>_(parseNumber(rt)),[_]),nt=reactExports.useCallback(rt=>{const ot=rt.key==="ArrowUp"?1:rt.key==="ArrowDown"?-1:0;if(ot){rt.preventDefault();const at=rt.altKey?.1:rt.shiftKey?10:1;_(lt=>parseFloat(lt)+ot*at)}},[_]);return React.createElement(ValueInput,_extends({},_e,{onUpdate:tt,onKeyDown:nt,type:"number"}))}const StyledFolder=styled("div",{}),StyledWrapper=styled("div",{position:"relative",background:"$elevation2",transition:"height 300ms ease",variants:{fill:{true:{},false:{}},flat:{false:{},true:{}},isRoot:{true:{},false:{paddingLeft:"$md","&::after":{content:'""',position:"absolute",left:0,top:0,width:"$borderWidths$folder",height:"100%",backgroundColor:"$folderWidgetColor",opacity:.4,transform:"translateX(-50%)"}}}},compoundVariants:[{isRoot:!0,fill:!1,css:{overflowY:"auto",maxHeight:"calc(100vh - 20px - $$titleBarHeight)"}},{isRoot:!0,flat:!1,css:{borderRadius:"$lg"}}]}),StyledTitle=styled("div",{$flex:"",color:"$folderTextColor",userSelect:"none",cursor:"pointer",height:"$folderTitleHeight",fontWeight:"$folder","> svg":{marginLeft:-4,marginRight:4,cursor:"pointer",fill:"$folderWidgetColor",opacity:.6},"&:hover > svg":{fill:"$folderWidgetColor"},[`&:hover + ${StyledWrapper}::after`]:{opacity:.6},[`${StyledFolder}:hover > & + ${StyledWrapper}::after`]:{opacity:.6},[`${StyledFolder}:hover > & > svg`]:{opacity:1}}),StyledContent=styled("div",{position:"relative",display:"grid",gridTemplateColumns:"100%",rowGap:"$rowGap",transition:"opacity 250ms ease",variants:{toggled:{true:{opacity:1,transitionDelay:"250ms"},false:{opacity:0,transitionDelay:"0ms",pointerEvents:"none"}},isRoot:{true:{"& > div":{paddingLeft:"$md",paddingRight:"$md"},"& > div:first-of-type":{paddingTop:"$sm"},"& > div:last-of-type":{paddingBottom:"$sm"},[`> ${StyledFolder}:not(:first-of-type)`]:{paddingTop:"$sm",marginTop:"$md",borderTop:"$borderWidths$folder solid $colors$elevation1"}}}}}),StyledRow=styled("div",{position:"relative",zIndex:100,display:"grid",rowGap:"$rowGap",gridTemplateRows:"minmax($sizes$rowHeight, max-content)",alignItems:"center",color:"$highlight2",[`${StyledContent} > &`]:{"&:first-of-type":{marginTop:"$rowGap"},"&:last-of-type":{marginBottom:"$rowGap"}},variants:{disabled:{true:{pointerEvents:"none"},false:{"&:hover,&:focus-within":{color:"$highlight3"}}}}}),StyledInputRow=styled(StyledRow,{gridTemplateColumns:"auto $sizes$controlWidth",columnGap:"$colGap"}),CopyLabelContainer=styled("div",{$flex:"",height:"100%",position:"relative",overflow:"hidden","& > div":{marginLeft:"$colGap",padding:"0 $xs",opacity:.4},"& > div:hover":{opacity:.8},"& > div > svg":{display:"none",cursor:"pointer",width:13,minWidth:13,height:13,backgroundColor:"$elevation2"},"&:hover > div > svg":{display:"block"},variants:{align:{top:{height:"100%",alignItems:"flex-start",paddingTop:"$sm"}}}}),StyledOptionalToggle=styled("input",{$reset:"",height:0,width:0,opacity:0,margin:0,"& + label":{position:"relative",$flexCenter:"",height:"100%",userSelect:"none",cursor:"pointer",paddingLeft:2,paddingRight:"$sm",pointerEvents:"auto"},"& + label:after":{content:'""',width:6,height:6,backgroundColor:"$elevation3",borderRadius:"50%",$activeStyle:""},"&:focus + label:after":{$focusStyle:""},"& + label:active:after":{backgroundColor:"$accent1",$focusStyle:""},"&:checked + label:after":{backgroundColor:"$accent1"}}),StyledLabel=styled("label",{fontWeight:"$label",overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap","& > svg":{display:"block"}}),StyledInputWrapper$1=styled("div",{opacity:1,variants:{disabled:{true:{opacity:.6,pointerEvents:"none",[`& ${StyledLabel}`]:{pointerEvents:"auto"}}}}}),Overlay=styled("div",{position:"fixed",top:0,bottom:0,right:0,left:0,zIndex:1e3,userSelect:"none"}),StyledToolTipContent=styled("div",{background:"$toolTipBackground",fontFamily:"$sans",fontSize:"$toolTip",padding:"$xs $sm",color:"$toolTipText",borderRadius:"$xs",boxShadow:"$level2",maxWidth:260}),ToolTipArrow=styled(Arrow2,{fill:"$toolTipBackground"});function Portal({children:et}){const{className:_}=reactExports.useContext(ThemeContext);return React.createElement(Root$2,{className:_},et)}const _excluded$6$1=["align"];function OptionalToggle(){const{id:et,disable:_,disabled:_e}=useInputContext();return React.createElement(React.Fragment,null,React.createElement(StyledOptionalToggle,{id:et+"__disable",type:"checkbox",checked:!_e,onChange:()=>_(!_e)}),React.createElement("label",{htmlFor:et+"__disable"}))}function RawLabel(et){const{id:_,optional:_e,hint:tt}=useInputContext(),nt=et.htmlFor||(_?{htmlFor:_}:null),rt=!tt&&typeof et.children=="string"?{title:et.children}:null;return React.createElement(React.Fragment,null,_e&&React.createElement(OptionalToggle,null),tt!==void 0?React.createElement(Root3,null,React.createElement(Trigger,{asChild:!0},React.createElement(StyledLabel,_extends({},nt,et))),React.createElement(Content2,{side:"top",sideOffset:2},React.createElement(StyledToolTipContent,null,tt,React.createElement(ToolTipArrow,null)))):React.createElement(StyledLabel,_extends({},nt,rt,et)))}function Label(et){let{align:_}=et,_e=_objectWithoutProperties$1(et,_excluded$6$1);const{value:tt,label:nt,key:rt,disabled:ot}=useInputContext(),{hideCopyButton:at}=usePanelSettingsContext(),lt=!at&&rt!==void 0,[ut,dt]=reactExports.useState(!1),st=async()=>{try{await navigator.clipboard.writeText(JSON.stringify({[rt]:tt??""})),dt(!0)}catch{warn(LevaErrors.CLIPBOARD_ERROR,{[rt]:tt})}};return React.createElement(CopyLabelContainer,{align:_,onPointerLeave:()=>dt(!1)},React.createElement(RawLabel,_e),lt&&!ot&&React.createElement("div",{title:`Click to copy ${typeof nt=="string"?nt:rt} value`},ut?React.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor"},React.createElement("path",{d:"M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"}),React.createElement("path",{fillRule:"evenodd",d:"M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm9.707 5.707a1 1 0 00-1.414-1.414L9 12.586l-1.293-1.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z",clipRule:"evenodd"})):React.createElement("svg",{onClick:st,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor"},React.createElement("path",{d:"M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z"}),React.createElement("path",{d:"M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z"}))))}const _excluded$5$1=["toggled"],Svg=styled("svg",{fill:"currentColor",transition:"transform 350ms ease, fill 250ms ease"});function Chevron(et){let{toggled:_}=et,_e=_objectWithoutProperties$1(et,_excluded$5$1);return React.createElement(Svg,_extends({width:"9",height:"5",viewBox:"0 0 9 5",xmlns:"http://www.w3.org/2000/svg",style:{transform:`rotate(${_?0:-90}deg)`}},_e),React.createElement("path",{d:"M3.8 4.4c.4.3 1 .3 1.4 0L8 1.7A1 1 0 007.4 0H1.6a1 1 0 00-.7 1.7l3 2.7z"}))}const _excluded$4$1=["input"];function Row(et){let{input:_}=et,_e=_objectWithoutProperties$1(et,_excluded$4$1);return _?React.createElement(StyledInputRow,_e):React.createElement(StyledRow,_e)}function useInputSetters({value:et,type:_,settings:_e,setValue:tt}){const[nt,rt]=reactExports.useState(format$2(_,et,_e)),ot=reactExports.useRef(et),at=reactExports.useRef(_e);at.current=_e;const lt=reactExports.useCallback(dt=>rt(format$2(_,dt,at.current)),[_]),ut=reactExports.useCallback(dt=>{try{tt(dt)}catch(st){const{type:it,previousValue:ct}=st;if(it!=="LEVA_ERROR")throw st;lt(ct)}},[lt,tt]);return reactExports.useEffect(()=>{dequal(et,ot.current)||lt(et),ot.current=et},[et,lt]),{displayValue:nt,onChange:rt,onUpdate:ut}}function useDrag(et,_){const{emitOnEditStart:_e,emitOnEditEnd:tt}=useInputContext();return useDrag$1(nt=>{nt.first&&(document.body.classList.add("leva__panel__dragged"),_e==null||_e());const rt=et(nt);return nt.last&&(document.body.classList.remove("leva__panel__dragged"),tt==null||tt()),rt},_)}function useCanvas2d(et){const _=reactExports.useRef(null),_e=reactExports.useRef(null),tt=reactExports.useRef(!1);return reactExports.useEffect(()=>{const nt=debounce(()=>{_.current.width=_.current.offsetWidth*window.devicePixelRatio,_.current.height=_.current.offsetHeight*window.devicePixelRatio,et(_.current,_e.current)},250);return window.addEventListener("resize",nt),tt.current||(nt(),tt.current=!0),()=>window.removeEventListener("resize",nt)},[et]),reactExports.useEffect(()=>{_e.current=_.current.getContext("2d")},[]),[_,_e]}function useTransform(){const et=reactExports.useRef(null),_=reactExports.useRef({x:0,y:0}),_e=reactExports.useCallback(tt=>{Object.assign(_.current,tt),et.current&&(et.current.style.transform=`translate3d(${_.current.x}px, ${_.current.y}px, 0)`)},[]);return[et,_e]}const _excluded$3$1=["__refCount"],getInputAtPath=(et,_)=>{if(!et[_])return null;const _e=et[_];return _objectWithoutProperties$1(_e,_excluded$3$1)};function useInput(et){const _=useStoreContext(),[_e,tt]=reactExports.useState(getInputAtPath(_.getData(),et)),nt=reactExports.useCallback(ut=>_.setValueAtPath(et,ut,!0),[et,_]),rt=reactExports.useCallback(ut=>_.setSettingsAtPath(et,ut),[et,_]),ot=reactExports.useCallback(ut=>_.disableInputAtPath(et,ut),[et,_]),at=reactExports.useCallback(()=>_.emitOnEditStart(et),[et,_]),lt=reactExports.useCallback(()=>_.emitOnEditEnd(et),[et,_]);return reactExports.useEffect(()=>{tt(getInputAtPath(_.getData(),et));const ut=_.useStore.subscribe(dt=>getInputAtPath(dt.data,et),tt,{equalityFn:shallow});return()=>ut()},[_,et]),[_e,{set:nt,setSettings:rt,disable:ot,storeId:_.storeId,emitOnEditStart:at,emitOnEditEnd:lt}]}const RangeGrid=styled("div",{variants:{hasRange:{true:{position:"relative",display:"grid",gridTemplateColumns:"auto $sizes$numberInputMinWidth",columnGap:"$colGap",alignItems:"center"}}}}),Range=styled("div",{position:"relative",width:"100%",height:2,borderRadius:"$xs",backgroundColor:"$elevation1"}),Scrubber=styled("div",{position:"absolute",width:"$scrubberWidth",height:"$scrubberHeight",borderRadius:"$xs",boxShadow:"0 0 0 2px $colors$elevation2",backgroundColor:"$accent2",cursor:"pointer",$active:"none $accent1",$hover:"none $accent3",variants:{position:{left:{borderTopRightRadius:0,borderBottomRightRadius:0,transform:"translateX(calc(-0.5 * ($sizes$scrubberWidth + 4px)))"},right:{borderTopLeftRadius:0,borderBottomLeftRadius:0,transform:"translateX(calc(0.5 * ($sizes$scrubberWidth + 4px)))"}}}}),RangeWrapper=styled("div",{position:"relative",$flex:"",height:"100%",cursor:"pointer",touchAction:"none"}),Indicator=styled("div",{position:"absolute",height:"100%",backgroundColor:"$accent2"});function RangeSlider({value:et,min:_,max:_e,onDrag:tt,step:nt,initialValue:rt}){const ot=reactExports.useRef(null),at=reactExports.useRef(null),lt=reactExports.useRef(0),ut=useTh("sizes","scrubberWidth"),dt=useDrag(({event:it,first:ct,xy:[ft],movement:[ht],memo:mt})=>{if(ct){const{width:_t,left:vt}=ot.current.getBoundingClientRect();lt.current=_t-parseFloat(ut),mt=(it==null?void 0:it.target)===at.current?et:invertedRange((ft-vt)/_t,_,_e)}const pt=mt+invertedRange(ht/lt.current,0,_e-_);return tt(sanitizeStep$1(pt,{step:nt,initialValue:rt})),mt}),st=range(et,_,_e);return React.createElement(RangeWrapper,_extends({ref:ot},dt()),React.createElement(Range,null,React.createElement(Indicator,{style:{left:0,right:`${(1-st)*100}%`}})),React.createElement(Scrubber,{ref:at,style:{left:`calc(${st} * (100% - ${ut}))`}}))}const DraggableLabel=React.memo(({label:et,onUpdate:_,step:_e,innerLabelTrim:tt})=>{const[nt,rt]=reactExports.useState(!1),ot=useDrag(({active:at,delta:[lt],event:ut,memo:dt=0})=>(rt(at),dt+=lt/2,Math.abs(dt)>=1&&(_(st=>parseFloat(st)+Math.floor(dt)*_e*multiplyStep(ut)),dt=0),dt));return React.createElement(InnerNumberLabel,_extends({dragging:nt,title:et.length>1?et:""},ot()),et.slice(0,tt))});function Number$1({label:et,id:_,displayValue:_e,onUpdate:tt,onChange:nt,settings:rt,innerLabelTrim:ot=1}){const at=ot>0&&React.createElement(DraggableLabel,{label:et,step:rt.step,onUpdate:tt,innerLabelTrim:ot});return React.createElement(NumberInput,{id:_,value:String(_e),onUpdate:tt,onChange:nt,innerLabel:at})}function NumberComponent(){const et=useInputContext(),{label:_,value:_e,onUpdate:tt,settings:nt,id:rt}=et,{min:ot,max:at}=nt,lt=at!==1/0&&ot!==-1/0;return React.createElement(Row,{input:!0},React.createElement(Label,null,_),React.createElement(RangeGrid,{hasRange:lt},lt&&React.createElement(RangeSlider,_extends({value:parseFloat(_e),onDrag:tt},nt)),React.createElement(Number$1,_extends({},et,{id:rt,label:"value",innerLabelTrim:lt?0:1}))))}const{sanitizeStep}=props$3,rest=_objectWithoutProperties$1(props$3,["sanitizeStep"]);var number$1=_objectSpread2({component:NumberComponent},rest);const schema$2$1=(et,_)=>v8n().schema({options:v8n().passesAnyOf(v8n().object(),v8n().array())}).test(_),sanitize$2$1=(et,{values:_})=>{if(_.indexOf(et)<0)throw Error("Selected value doesn't match Select options");return et},format$3=(et,{values:_})=>_.indexOf(et),normalize$1$1=et=>{let{value:_,options:_e}=et,tt,nt;return Array.isArray(_e)?(nt=_e,tt=_e.map(rt=>String(rt))):(nt=Object.values(_e),tt=Object.keys(_e)),"value"in et?nt.includes(_)||(tt.unshift(String(_)),nt.unshift(_)):_=nt[0],Object.values(_e).includes(_)||(_e[String(_)]=_),{value:_,settings:{keys:tt,values:nt}}};var props$2$1=Object.freeze({__proto__:null,schema:schema$2$1,sanitize:sanitize$2$1,format:format$3,normalize:normalize$1$1});const SelectContainer=styled("div",{$flexCenter:"",position:"relative","> svg":{pointerEvents:"none",position:"absolute",right:"$md"}}),NativeSelect=styled("select",{position:"absolute",top:0,left:0,width:"100%",height:"100%",opacity:0}),PresentationalSelect=styled("div",{display:"flex",alignItems:"center",width:"100%",height:"$rowHeight",backgroundColor:"$elevation3",borderRadius:"$sm",padding:"0 $sm",cursor:"pointer",[`${NativeSelect}:focus + &`]:{$focusStyle:""},[`${NativeSelect}:hover + &`]:{$hoverStyle:""}});function Select({displayValue:et,value:_,onUpdate:_e,id:tt,settings:nt,disabled:rt}){const{keys:ot,values:at}=nt,lt=reactExports.useRef();return _===at[et]&&(lt.current=ot[et]),React.createElement(SelectContainer,null,React.createElement(NativeSelect,{id:tt,value:et,onChange:ut=>_e(at[Number(ut.currentTarget.value)]),disabled:rt},ot.map((ut,dt)=>React.createElement("option",{key:ut,value:dt},ut))),React.createElement(PresentationalSelect,null,lt.current),React.createElement(Chevron,{toggled:!0}))}function SelectComponent(){const{label:et,value:_,displayValue:_e,onUpdate:tt,id:nt,disabled:rt,settings:ot}=useInputContext();return React.createElement(Row,{input:!0},React.createElement(Label,null,et),React.createElement(Select,{id:nt,value:_,displayValue:_e,onUpdate:tt,settings:ot,disabled:rt}))}var select=_objectSpread2({component:SelectComponent},props$2$1);const schema$1$1=et=>v8n().string().test(et),sanitize$1$1=et=>{if(typeof et!="string")throw Error("Invalid string");return et},normalize$4=({value:et,editable:_=!0,rows:_e=!1})=>({value:et,settings:{editable:_,rows:typeof _e=="number"?_e:_e?5:0}});var props$1$1=Object.freeze({__proto__:null,schema:schema$1$1,sanitize:sanitize$1$1,normalize:normalize$4});const _excluded$2$1=["displayValue","onUpdate","onChange","editable"],NonEditableString=styled("div",{whiteSpace:"pre-wrap"});function String$1(et){let{displayValue:_,onUpdate:_e,onChange:tt,editable:nt=!0}=et,rt=_objectWithoutProperties$1(et,_excluded$2$1);return nt?React.createElement(ValueInput,_extends({value:_,onUpdate:_e,onChange:tt},rt)):React.createElement(NonEditableString,null,_)}function StringComponent(){const{label:et,settings:_,displayValue:_e,onUpdate:tt,onChange:nt}=useInputContext();return React.createElement(Row,{input:!0},React.createElement(Label,null,et),React.createElement(String$1,_extends({displayValue:_e,onUpdate:tt,onChange:nt},_)))}var string=_objectSpread2({component:StringComponent},props$1$1);const schema$4=et=>v8n().boolean().test(et),sanitize$5=et=>{if(typeof et!="boolean")throw Error("Invalid boolean");return et};var props$4=Object.freeze({__proto__:null,schema:schema$4,sanitize:sanitize$5});const StyledInputWrapper=styled("div",{position:"relative",$flex:"",height:"$rowHeight",input:{$reset:"",height:0,width:0,opacity:0,margin:0},label:{position:"relative",$flexCenter:"",userSelect:"none",cursor:"pointer",height:"$checkboxSize",width:"$checkboxSize",backgroundColor:"$elevation3",borderRadius:"$sm",$hover:""},"input:focus + label":{$focusStyle:""},"input:focus:checked + label, input:checked + label:hover":{$hoverStyle:"$accent3"},"input + label:active":{backgroundColor:"$accent1"},"input:checked + label:active":{backgroundColor:"$accent1"},"label > svg":{display:"none",width:"90%",height:"90%",stroke:"$highlight3"},"input:checked + label":{backgroundColor:"$accent2"},"input:checked + label > svg":{display:"block"}});function Boolean$1({value:et,onUpdate:_,id:_e,disabled:tt}){return React.createElement(StyledInputWrapper,null,React.createElement("input",{id:_e,type:"checkbox",checked:et,onChange:nt=>_(nt.currentTarget.checked),disabled:tt}),React.createElement("label",{htmlFor:_e},React.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24"},React.createElement("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M5 13l4 4L19 7"}))))}function BooleanComponent(){const{label:et,value:_,onUpdate:_e,disabled:tt,id:nt}=useInputContext();return React.createElement(Row,{input:!0},React.createElement(Label,null,et),React.createElement(Boolean$1,{value:_,onUpdate:_e,id:nt,disabled:tt}))}var boolean=_objectSpread2({component:BooleanComponent},props$4);const _excluded$1$1=["locked"];function Coordinate({value:et,id:_,valueKey:_e,settings:tt,onUpdate:nt,innerLabelTrim:rt}){const ot=reactExports.useRef(et[_e]);ot.current=et[_e];const at=reactExports.useCallback(ut=>nt({[_e]:sanitizeValue({type:"NUMBER",value:ot.current,settings:tt},ut)}),[nt,tt,_e]),lt=useInputSetters({type:"NUMBER",value:et[_e],settings:tt,setValue:at});return React.createElement(Number$1,{id:_,label:_e,value:et[_e],displayValue:lt.displayValue,onUpdate:lt.onUpdate,onChange:lt.onChange,settings:tt,innerLabelTrim:rt})}const Container$2=styled("div",{display:"grid",columnGap:"$colGap",gridAutoFlow:"column dense",alignItems:"center",variants:{withLock:{true:{gridTemplateColumns:"10px auto","> svg":{cursor:"pointer"}}}}});function Lock(et){let{locked:_}=et,_e=_objectWithoutProperties$1(et,_excluded$1$1);return React.createElement("svg",_extends({width:"10",height:"10",viewBox:"0 0 15 15",fill:"none",xmlns:"http://www.w3.org/2000/svg"},_e),_?React.createElement("path",{d:"M5 4.63601C5 3.76031 5.24219 3.1054 5.64323 2.67357C6.03934 2.24705 6.64582 1.9783 7.5014 1.9783C8.35745 1.9783 8.96306 2.24652 9.35823 2.67208C9.75838 3.10299 10 3.75708 10 4.63325V5.99999H5V4.63601ZM4 5.99999V4.63601C4 3.58148 4.29339 2.65754 4.91049 1.99307C5.53252 1.32329 6.42675 0.978302 7.5014 0.978302C8.57583 0.978302 9.46952 1.32233 10.091 1.99162C10.7076 2.65557 11 3.57896 11 4.63325V5.99999H12C12.5523 5.99999 13 6.44771 13 6.99999V13C13 13.5523 12.5523 14 12 14H3C2.44772 14 2 13.5523 2 13V6.99999C2 6.44771 2.44772 5.99999 3 5.99999H4ZM3 6.99999H12V13H3V6.99999Z",fill:"currentColor",fillRule:"evenodd",clipRule:"evenodd"}):React.createElement("path",{d:"M9 3.63601C9 2.76044 9.24207 2.11211 9.64154 1.68623C10.0366 1.26502 10.6432 1 11.5014 1C12.4485 1 13.0839 1.30552 13.4722 1.80636C13.8031 2.23312 14 2.84313 14 3.63325H15C15 2.68242 14.7626 1.83856 14.2625 1.19361C13.6389 0.38943 12.6743 0 11.5014 0C10.4294 0 9.53523 0.337871 8.91218 1.0021C8.29351 1.66167 8 2.58135 8 3.63601V6H1C0.447715 6 0 6.44772 0 7V13C0 13.5523 0.447715 14 1 14H10C10.5523 14 11 13.5523 11 13V7C11 6.44772 10.5523 6 10 6H9V3.63601ZM1 7H10V13H1V7Z",fill:"currentColor",fillRule:"evenodd",clipRule:"evenodd"}))}function Vector({value:et,onUpdate:_,settings:_e,innerLabelTrim:tt}){const{id:nt,setSettings:rt}=useInputContext(),{lock:ot,locked:at}=_e;return React.createElement(Container$2,{withLock:ot},ot&&React.createElement(Lock,{locked:at,onClick:()=>rt({locked:!at})}),Object.keys(et).map((lt,ut)=>React.createElement(Coordinate,{id:ut===0?nt:`${nt}.${lt}`,key:lt,valueKey:lt,value:et,settings:_e[lt],onUpdate:_,innerLabelTrim:tt})))}const normalizeKeyedNumberSettings=(et,_)=>{const _e={};let tt=0,nt=1/0;Object.entries(et).forEach(([rt,ot])=>{_e[rt]=normalize$2$1(_objectSpread2({value:ot},_[rt])).settings,tt=Math.max(tt,_e[rt].step),nt=Math.min(nt,_e[rt].pad)});for(let rt in _e){const{step:ot,min:at,max:lt}=_[rt]||{};!isFinite(ot)&&(!isFinite(at)||!isFinite(lt))&&(_e[rt].step=tt,_e[rt].pad=nt)}return _e},_excluded$b=["lock"],_excluded2$5=["value"];function getVectorSchema(et){const _=v8n().array().length(et).every.number(),_e=tt=>{if(!tt||typeof tt!="object")return!1;const nt=Object.values(tt);return nt.length===et&&nt.every(rt=>isFinite(rt))};return tt=>_.test(tt)||_e(tt)}function getVectorType(et){return Array.isArray(et)?"array":"object"}function convert$1(et,_,_e){return getVectorType(et)===_?et:_==="array"?Object.values(et):mapArrayToKeys(et,_e)}const sanitizeVector=(et,_,_e)=>{const tt=convert$1(et,"object",_.keys);for(let ot in tt)tt[ot]=sanitize$3(tt[ot],_[ot]);const nt=Object.keys(tt);let rt={};if(nt.length===_.keys.length)rt=tt;else{const ot=convert$1(_e,"object",_.keys);if(nt.length===1&&_.locked){const at=nt[0],lt=tt[at],ut=ot[at],dt=ut!==0?lt/ut:1;for(let st in ot)st===at?rt[at]=lt:rt[st]=ot[st]*dt}else rt=_objectSpread2(_objectSpread2({},ot),tt)}return convert$1(rt,_.format,_.keys)},formatVector=(et,_)=>convert$1(et,"object",_.keys),isNumberSettings=et=>!!et&&("step"in et||"min"in et||"max"in et);function normalizeVector(et,_,_e=[]){const{lock:tt=!1}=_,nt=_objectWithoutProperties$1(_,_excluded$b),rt=Array.isArray(et)?"array":"object",ot=rt==="object"?Object.keys(et):_e,at=convert$1(et,"object",ot),lt=isNumberSettings(nt)?ot.reduce((dt,st)=>Object.assign(dt,{[st]:nt}),{}):nt,ut=normalizeKeyedNumberSettings(at,lt);return{value:rt==="array"?et:at,settings:_objectSpread2(_objectSpread2({},ut),{},{format:rt,keys:ot,lock:tt,locked:!1})}}function getVectorPlugin(et){return{schema:getVectorSchema(et.length),normalize:_=>{let{value:_e}=_,tt=_objectWithoutProperties$1(_,_excluded2$5);return normalizeVector(_e,tt,et)},format:(_,_e)=>formatVector(_,_e),sanitize:(_,_e,tt)=>sanitizeVector(_,_e,tt)}}var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(et){return typeof et=="string"?et.length>0:typeof et=="number"},n=function(et,_,_e){return _===void 0&&(_=0),_e===void 0&&(_e=Math.pow(10,_)),Math.round(_e*et)/_e+0},e=function(et,_,_e){return _===void 0&&(_=0),_e===void 0&&(_e=1),et>_e?_e:et>_?et:_},u$1=function(et){return(et=isFinite(et)?et%360:0)>0?et:et+360},a=function(et){return{r:e(et.r,0,255),g:e(et.g,0,255),b:e(et.b,0,255),a:e(et.a)}},o=function(et){return{r:n(et.r),g:n(et.g),b:n(et.b),a:n(et.a,3)}},i$1=/^#([0-9a-f]{3,8})$/i,s$1=function(et){var _=et.toString(16);return _.length<2?"0"+_:_},h$1=function(et){var _=et.r,_e=et.g,tt=et.b,nt=et.a,rt=Math.max(_,_e,tt),ot=rt-Math.min(_,_e,tt),at=ot?rt===_?(_e-tt)/ot:rt===_e?2+(tt-_)/ot:4+(_-_e)/ot:0;return{h:60*(at<0?at+6:at),s:rt?ot/rt*100:0,v:rt/255*100,a:nt}},b$1=function(et){var _=et.h,_e=et.s,tt=et.v,nt=et.a;_=_/360*6,_e/=100,tt/=100;var rt=Math.floor(_),ot=tt*(1-_e),at=tt*(1-(_-rt)*_e),lt=tt*(1-(1-_+rt)*_e),ut=rt%6;return{r:255*[tt,at,ot,ot,lt,tt][ut],g:255*[lt,tt,tt,at,ot,ot][ut],b:255*[ot,ot,lt,tt,tt,at][ut],a:nt}},g$1=function(et){return{h:u$1(et.h),s:e(et.s,0,100),l:e(et.l,0,100),a:e(et.a)}},d$1=function(et){return{h:n(et.h),s:n(et.s),l:n(et.l),a:n(et.a,3)}},f$1=function(et){return b$1((_e=(_=et).s,{h:_.h,s:(_e*=((tt=_.l)<50?tt:100-tt)/100)>0?2*_e/(tt+_e)*100:0,v:tt+_e,a:_.a}));var _,_e,tt},c$1=function(et){return{h:(_=h$1(et)).h,s:(nt=(200-(_e=_.s))*(tt=_.v)/100)>0&&nt<200?_e*tt/100/(nt<=100?nt:200-nt)*100:0,l:nt/2,a:_.a};var _,_e,tt,nt},l=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,p$1=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v$1=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m$1=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y$1={string:[[function(et){var _=i$1.exec(et);return _?(et=_[1]).length<=4?{r:parseInt(et[0]+et[0],16),g:parseInt(et[1]+et[1],16),b:parseInt(et[2]+et[2],16),a:et.length===4?n(parseInt(et[3]+et[3],16)/255,2):1}:et.length===6||et.length===8?{r:parseInt(et.substr(0,2),16),g:parseInt(et.substr(2,2),16),b:parseInt(et.substr(4,2),16),a:et.length===8?n(parseInt(et.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(et){var _=v$1.exec(et)||m$1.exec(et);return _?_[2]!==_[4]||_[4]!==_[6]?null:a({r:Number(_[1])/(_[2]?100/255:1),g:Number(_[3])/(_[4]?100/255:1),b:Number(_[5])/(_[6]?100/255:1),a:_[7]===void 0?1:Number(_[7])/(_[8]?100:1)}):null},"rgb"],[function(et){var _=l.exec(et)||p$1.exec(et);if(!_)return null;var _e,tt,nt=g$1({h:(_e=_[1],tt=_[2],tt===void 0&&(tt="deg"),Number(_e)*(r[tt]||1)),s:Number(_[3]),l:Number(_[4]),a:_[5]===void 0?1:Number(_[5])/(_[6]?100:1)});return f$1(nt)},"hsl"]],object:[[function(et){var _=et.r,_e=et.g,tt=et.b,nt=et.a,rt=nt===void 0?1:nt;return t(_)&&t(_e)&&t(tt)?a({r:Number(_),g:Number(_e),b:Number(tt),a:Number(rt)}):null},"rgb"],[function(et){var _=et.h,_e=et.s,tt=et.l,nt=et.a,rt=nt===void 0?1:nt;if(!t(_)||!t(_e)||!t(tt))return null;var ot=g$1({h:Number(_),s:Number(_e),l:Number(tt),a:Number(rt)});return f$1(ot)},"hsl"],[function(et){var _=et.h,_e=et.s,tt=et.v,nt=et.a,rt=nt===void 0?1:nt;if(!t(_)||!t(_e)||!t(tt))return null;var ot=function(at){return{h:u$1(at.h),s:e(at.s,0,100),v:e(at.v,0,100),a:e(at.a)}}({h:Number(_),s:Number(_e),v:Number(tt),a:Number(rt)});return b$1(ot)},"hsv"]]},N=function(et,_){for(var _e=0;_e<_.length;_e++){var tt=_[_e][0](et);if(tt)return[tt,_[_e][1]]}return[null,void 0]},x=function(et){return typeof et=="string"?N(et.trim(),y$1.string):typeof et=="object"&&et!==null?N(et,y$1.object):[null,void 0]},I$1=function(et){return x(et)[1]},M=function(et,_){var _e=c$1(et);return{h:_e.h,s:e(_e.s+100*_,0,100),l:_e.l,a:_e.a}},H=function(et){return(299*et.r+587*et.g+114*et.b)/1e3/255},$$1=function(et,_){var _e=c$1(et);return{h:_e.h,s:_e.s,l:e(_e.l+100*_,0,100),a:_e.a}},j=function(){function et(_){this.parsed=x(_)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return et.prototype.isValid=function(){return this.parsed!==null},et.prototype.brightness=function(){return n(H(this.rgba),2)},et.prototype.isDark=function(){return H(this.rgba)<.5},et.prototype.isLight=function(){return H(this.rgba)>=.5},et.prototype.toHex=function(){return _=o(this.rgba),_e=_.r,tt=_.g,nt=_.b,ot=(rt=_.a)<1?s$1(n(255*rt)):"","#"+s$1(_e)+s$1(tt)+s$1(nt)+ot;var _,_e,tt,nt,rt,ot},et.prototype.toRgb=function(){return o(this.rgba)},et.prototype.toRgbString=function(){return _=o(this.rgba),_e=_.r,tt=_.g,nt=_.b,(rt=_.a)<1?"rgba("+_e+", "+tt+", "+nt+", "+rt+")":"rgb("+_e+", "+tt+", "+nt+")";var _,_e,tt,nt,rt},et.prototype.toHsl=function(){return d$1(c$1(this.rgba))},et.prototype.toHslString=function(){return _=d$1(c$1(this.rgba)),_e=_.h,tt=_.s,nt=_.l,(rt=_.a)<1?"hsla("+_e+", "+tt+"%, "+nt+"%, "+rt+")":"hsl("+_e+", "+tt+"%, "+nt+"%)";var _,_e,tt,nt,rt},et.prototype.toHsv=function(){return _=h$1(this.rgba),{h:n(_.h),s:n(_.s),v:n(_.v),a:n(_.a,3)};var _},et.prototype.invert=function(){return w({r:255-(_=this.rgba).r,g:255-_.g,b:255-_.b,a:_.a});var _},et.prototype.saturate=function(_){return _===void 0&&(_=.1),w(M(this.rgba,_))},et.prototype.desaturate=function(_){return _===void 0&&(_=.1),w(M(this.rgba,-_))},et.prototype.grayscale=function(){return w(M(this.rgba,-1))},et.prototype.lighten=function(_){return _===void 0&&(_=.1),w($$1(this.rgba,_))},et.prototype.darken=function(_){return _===void 0&&(_=.1),w($$1(this.rgba,-_))},et.prototype.rotate=function(_){return _===void 0&&(_=15),this.hue(this.hue()+_)},et.prototype.alpha=function(_){return typeof _=="number"?w({r:(_e=this.rgba).r,g:_e.g,b:_e.b,a:_}):n(this.rgba.a,3);var _e},et.prototype.hue=function(_){var _e=c$1(this.rgba);return typeof _=="number"?w({h:_,s:_e.s,l:_e.l,a:_e.a}):n(_e.h)},et.prototype.isEqual=function(_){return this.toHex()===w(_).toHex()},et}(),w=function(et){return et instanceof j?et:new j(et)},S$1=[],k$1=function(et){et.forEach(function(_){S$1.indexOf(_)<0&&(_(j,y$1),S$1.push(_))})};function namesPlugin(et,_){var _e={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},tt={};for(var nt in _e)tt[_e[nt]]=nt;var rt={};et.prototype.toName=function(ot){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var at,lt,ut=tt[this.toHex()];if(ut)return ut;if(ot!=null&&ot.closest){var dt=this.toRgb(),st=1/0,it="black";if(!rt.length)for(var ct in _e)rt[ct]=new et(_e[ct]).toRgb();for(var ft in _e){var ht=(at=dt,lt=rt[ft],Math.pow(at.r-lt.r,2)+Math.pow(at.g-lt.g,2)+Math.pow(at.b-lt.b,2));ht<st&&(st=ht,it=ft)}return it}},_.string.push([function(ot){var at=ot.toLowerCase(),lt=at==="transparent"?"#0000":_e[at];return lt?new et(lt).toRgb():null},"name"])}function u(){return(u=Object.assign||function(et){for(var _=1;_<arguments.length;_++){var _e=arguments[_];for(var tt in _e)Object.prototype.hasOwnProperty.call(_e,tt)&&(et[tt]=_e[tt])}return et}).apply(this,arguments)}function c(et,_){if(et==null)return{};var _e,tt,nt={},rt=Object.keys(et);for(tt=0;tt<rt.length;tt++)_.indexOf(_e=rt[tt])>=0||(nt[_e]=et[_e]);return nt}function i(et){var _=reactExports.useRef(et),_e=reactExports.useRef(function(tt){_.current&&_.current(tt)});return _.current=et,_e.current}var s=function(et,_,_e){return _===void 0&&(_=0),_e===void 0&&(_e=1),et>_e?_e:et<_?_:et},f=function(et){return"touches"in et},v=function(et){return et&&et.ownerDocument.defaultView||self},d=function(et,_,_e){var tt=et.getBoundingClientRect(),nt=f(_)?function(rt,ot){for(var at=0;at<rt.length;at++)if(rt[at].identifier===ot)return rt[at];return rt[0]}(_.touches,_e):_;return{left:s((nt.pageX-(tt.left+v(et).pageXOffset))/tt.width),top:s((nt.pageY-(tt.top+v(et).pageYOffset))/tt.height)}},h=function(et){!f(et)&&et.preventDefault()},m=React.memo(function(et){var _=et.onMove,_e=et.onKey,tt=c(et,["onMove","onKey"]),nt=reactExports.useRef(null),rt=i(_),ot=i(_e),at=reactExports.useRef(null),lt=reactExports.useRef(!1),ut=reactExports.useMemo(function(){var ct=function(mt){h(mt),(f(mt)?mt.touches.length>0:mt.buttons>0)&&nt.current?rt(d(nt.current,mt,at.current)):ht(!1)},ft=function(){return ht(!1)};function ht(mt){var pt=lt.current,_t=v(nt.current),vt=mt?_t.addEventListener:_t.removeEventListener;vt(pt?"touchmove":"mousemove",ct),vt(pt?"touchend":"mouseup",ft)}return[function(mt){var pt=mt.nativeEvent,_t=nt.current;if(_t&&(h(pt),!function(bt,wt){return wt&&!f(bt)}(pt,lt.current)&&_t)){if(f(pt)){lt.current=!0;var vt=pt.changedTouches||[];vt.length&&(at.current=vt[0].identifier)}_t.focus(),rt(d(_t,pt,at.current)),ht(!0)}},function(mt){var pt=mt.which||mt.keyCode;pt<37||pt>40||(mt.preventDefault(),ot({left:pt===39?.05:pt===37?-.05:0,top:pt===40?.05:pt===38?-.05:0}))},ht]},[ot,rt]),dt=ut[0],st=ut[1],it=ut[2];return reactExports.useEffect(function(){return it},[it]),React.createElement("div",u({},tt,{onTouchStart:dt,onMouseDown:dt,className:"react-colorful__interactive",ref:nt,onKeyDown:st,tabIndex:0,role:"slider"}))}),g=function(et){return et.filter(Boolean).join(" ")},p=function(et){var _=et.color,_e=et.left,tt=et.top,nt=tt===void 0?.5:tt,rt=g(["react-colorful__pointer",et.className]);return React.createElement("div",{className:rt,style:{top:100*nt+"%",left:100*_e+"%"}},React.createElement("div",{className:"react-colorful__pointer-fill",style:{backgroundColor:_}}))},b=function(et,_,_e){return _===void 0&&(_=0),_e===void 0&&(_e=Math.pow(10,_)),Math.round(_e*et)/_e},y=function(et){var _=et.s,_e=et.v,tt=et.a,nt=(200-_)*_e/100;return{h:b(et.h),s:b(nt>0&&nt<200?_*_e/100/(nt<=100?nt:200-nt)*100:0),l:b(nt/2),a:b(tt,2)}},q=function(et){var _=y(et);return"hsl("+_.h+", "+_.s+"%, "+_.l+"%)"},k=function(et){var _=y(et);return"hsla("+_.h+", "+_.s+"%, "+_.l+"%, "+_.a+")"},I=function(et){var _=et.h,_e=et.s,tt=et.v,nt=et.a;_=_/360*6,_e/=100,tt/=100;var rt=Math.floor(_),ot=tt*(1-_e),at=tt*(1-(_-rt)*_e),lt=tt*(1-(1-_+rt)*_e),ut=rt%6;return{r:b(255*[tt,at,ot,ot,lt,tt][ut]),g:b(255*[lt,tt,tt,at,ot,ot][ut]),b:b(255*[ot,ot,lt,tt,tt,at][ut]),a:b(nt,2)}},L=function(et){var _=et.r,_e=et.g,tt=et.b,nt=et.a,rt=Math.max(_,_e,tt),ot=rt-Math.min(_,_e,tt),at=ot?rt===_?(_e-tt)/ot:rt===_e?2+(tt-_)/ot:4+(_-_e)/ot:0;return{h:b(60*(at<0?at+6:at)),s:b(rt?ot/rt*100:0),v:b(rt/255*100),a:nt}},S=React.memo(function(et){var _=et.hue,_e=et.onChange,tt=g(["react-colorful__hue",et.className]);return React.createElement("div",{className:tt},React.createElement(m,{onMove:function(nt){_e({h:360*nt.left})},onKey:function(nt){_e({h:s(_+360*nt.left,0,360)})},"aria-label":"Hue","aria-valuenow":b(_),"aria-valuemax":"360","aria-valuemin":"0"},React.createElement(p,{className:"react-colorful__hue-pointer",left:_/360,color:q({h:_,s:100,v:100,a:1})})))}),T=React.memo(function(et){var _=et.hsva,_e=et.onChange,tt={backgroundColor:q({h:_.h,s:100,v:100,a:1})};return React.createElement("div",{className:"react-colorful__saturation",style:tt},React.createElement(m,{onMove:function(nt){_e({s:100*nt.left,v:100-100*nt.top})},onKey:function(nt){_e({s:s(_.s+100*nt.left,0,100),v:s(_.v-100*nt.top,0,100)})},"aria-label":"Color","aria-valuetext":"Saturation "+b(_.s)+"%, Brightness "+b(_.v)+"%"},React.createElement(p,{className:"react-colorful__saturation-pointer",top:1-_.v/100,left:_.s/100,color:q(_)})))}),F=function(et,_){if(et===_)return!0;for(var _e in et)if(et[_e]!==_[_e])return!1;return!0};function Y(et,_,_e){var tt=i(_e),nt=reactExports.useState(function(){return et.toHsva(_)}),rt=nt[0],ot=nt[1],at=reactExports.useRef({color:_,hsva:rt});reactExports.useEffect(function(){if(!et.equal(_,at.current.color)){var ut=et.toHsva(_);at.current={hsva:ut,color:_},ot(ut)}},[_,et]),reactExports.useEffect(function(){var ut;F(rt,at.current.hsva)||et.equal(ut=et.fromHsva(rt),at.current.color)||(at.current={hsva:rt,color:ut},tt(ut))},[rt,et,tt]);var lt=reactExports.useCallback(function(ut){ot(function(dt){return Object.assign({},dt,ut)})},[]);return[rt,lt]}var V=typeof window<"u"?reactExports.useLayoutEffect:reactExports.useEffect,$=function(){return typeof __webpack_nonce__<"u"?__webpack_nonce__:void 0},J=new Map,Q=function(et){V(function(){var _=et.current?et.current.ownerDocument:document;if(_!==void 0&&!J.has(_)){var _e=_.createElement("style");_e.innerHTML=`.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}`,J.set(_,_e);var tt=$();tt&&_e.setAttribute("nonce",tt),_.head.appendChild(_e)}},[])},U=function(et){var _=et.className,_e=et.colorModel,tt=et.color,nt=tt===void 0?_e.defaultColor:tt,rt=et.onChange,ot=c(et,["className","colorModel","color","onChange"]),at=reactExports.useRef(null);Q(at);var lt=Y(_e,nt,rt),ut=lt[0],dt=lt[1],st=g(["react-colorful",_]);return React.createElement("div",u({},ot,{ref:at,className:st}),React.createElement(T,{hsva:ut,onChange:dt}),React.createElement(S,{hue:ut.h,onChange:dt,className:"react-colorful__last-control"}))},ee=function(et){var _=et.className,_e=et.hsva,tt=et.onChange,nt={backgroundImage:"linear-gradient(90deg, "+k(Object.assign({},_e,{a:0}))+", "+k(Object.assign({},_e,{a:1}))+")"},rt=g(["react-colorful__alpha",_]),ot=b(100*_e.a);return React.createElement("div",{className:rt},React.createElement("div",{className:"react-colorful__alpha-gradient",style:nt}),React.createElement(m,{onMove:function(at){tt({a:at.left})},onKey:function(at){tt({a:s(_e.a+at.left)})},"aria-label":"Alpha","aria-valuetext":ot+"%","aria-valuenow":ot,"aria-valuemin":"0","aria-valuemax":"100"},React.createElement(p,{className:"react-colorful__alpha-pointer",left:_e.a,color:k(_e)})))},re=function(et){var _=et.className,_e=et.colorModel,tt=et.color,nt=tt===void 0?_e.defaultColor:tt,rt=et.onChange,ot=c(et,["className","colorModel","color","onChange"]),at=reactExports.useRef(null);Q(at);var lt=Y(_e,nt,rt),ut=lt[0],dt=lt[1],st=g(["react-colorful",_]);return React.createElement("div",u({},ot,{ref:at,className:st}),React.createElement(T,{hsva:ut,onChange:dt}),React.createElement(S,{hue:ut.h,onChange:dt}),React.createElement(ee,{hsva:ut,onChange:dt,className:"react-colorful__last-control"}))},xe={defaultColor:{r:0,g:0,b:0,a:1},toHsva:L,fromHsva:I,equal:F},Ce=function(et){return React.createElement(re,u({},et,{colorModel:xe}))},Me={defaultColor:{r:0,g:0,b:0},toHsva:function(et){return L({r:et.r,g:et.g,b:et.b,a:1})},fromHsva:function(et){return{r:(_=I(et)).r,g:_.g,b:_.b};var _},equal:F},Ne=function(et){return React.createElement(U,u({},et,{colorModel:Me}))};function __awaiter(et,_,_e,tt){function nt(rt){return rt instanceof _e?rt:new _e(function(ot){ot(rt)})}return new(_e||(_e=Promise))(function(rt,ot){function at(dt){try{ut(tt.next(dt))}catch(st){ot(st)}}function lt(dt){try{ut(tt.throw(dt))}catch(st){ot(st)}}function ut(dt){dt.done?rt(dt.value):nt(dt.value).then(at,lt)}ut((tt=tt.apply(et,_||[])).next())})}function __generator(et,_){var _e={label:0,sent:function(){if(rt[0]&1)throw rt[1];return rt[1]},trys:[],ops:[]},tt,nt,rt,ot;return ot={next:at(0),throw:at(1),return:at(2)},typeof Symbol=="function"&&(ot[Symbol.iterator]=function(){return this}),ot;function at(ut){return function(dt){return lt([ut,dt])}}function lt(ut){if(tt)throw new TypeError("Generator is already executing.");for(;ot&&(ot=0,ut[0]&&(_e=0)),_e;)try{if(tt=1,nt&&(rt=ut[0]&2?nt.return:ut[0]?nt.throw||((rt=nt.return)&&rt.call(nt),0):nt.next)&&!(rt=rt.call(nt,ut[1])).done)return rt;switch(nt=0,rt&&(ut=[ut[0]&2,rt.value]),ut[0]){case 0:case 1:rt=ut;break;case 4:return _e.label++,{value:ut[1],done:!1};case 5:_e.label++,nt=ut[1],ut=[0];continue;case 7:ut=_e.ops.pop(),_e.trys.pop();continue;default:if(rt=_e.trys,!(rt=rt.length>0&&rt[rt.length-1])&&(ut[0]===6||ut[0]===2)){_e=0;continue}if(ut[0]===3&&(!rt||ut[1]>rt[0]&&ut[1]<rt[3])){_e.label=ut[1];break}if(ut[0]===6&&_e.label<rt[1]){_e.label=rt[1],rt=ut;break}if(rt&&_e.label<rt[2]){_e.label=rt[2],_e.ops.push(ut);break}rt[2]&&_e.ops.pop(),_e.trys.pop();continue}ut=_.call(et,_e)}catch(dt){ut=[6,dt],nt=0}finally{tt=rt=0}if(ut[0]&5)throw ut[1];return{value:ut[0]?ut[1]:void 0,done:!0}}}function __read(et,_){var _e=typeof Symbol=="function"&&et[Symbol.iterator];if(!_e)return et;var tt=_e.call(et),nt,rt=[],ot;try{for(;(_===void 0||_-- >0)&&!(nt=tt.next()).done;)rt.push(nt.value)}catch(at){ot={error:at}}finally{try{nt&&!nt.done&&(_e=tt.return)&&_e.call(tt)}finally{if(ot)throw ot.error}}return rt}function __spread(){for(var et=[],_=0;_<arguments.length;_++)et=et.concat(__read(arguments[_]));return et}typeof SuppressedError=="function"&&SuppressedError;var COMMON_MIME_TYPES=new Map([["aac","audio/aac"],["abw","application/x-abiword"],["arc","application/x-freearc"],["avif","image/avif"],["avi","video/x-msvideo"],["azw","application/vnd.amazon.ebook"],["bin","application/octet-stream"],["bmp","image/bmp"],["bz","application/x-bzip"],["bz2","application/x-bzip2"],["cda","application/x-cdf"],["csh","application/x-csh"],["css","text/css"],["csv","text/csv"],["doc","application/msword"],["docx","application/vnd.openxmlformats-officedocument.wordprocessingml.document"],["eot","application/vnd.ms-fontobject"],["epub","application/epub+zip"],["gz","application/gzip"],["gif","image/gif"],["heic","image/heic"],["heif","image/heif"],["htm","text/html"],["html","text/html"],["ico","image/vnd.microsoft.icon"],["ics","text/calendar"],["jar","application/java-archive"],["jpeg","image/jpeg"],["jpg","image/jpeg"],["js","text/javascript"],["json","application/json"],["jsonld","application/ld+json"],["mid","audio/midi"],["midi","audio/midi"],["mjs","text/javascript"],["mp3","audio/mpeg"],["mp4","video/mp4"],["mpeg","video/mpeg"],["mpkg","application/vnd.apple.installer+xml"],["odp","application/vnd.oasis.opendocument.presentation"],["ods","application/vnd.oasis.opendocument.spreadsheet"],["odt","application/vnd.oasis.opendocument.text"],["oga","audio/ogg"],["ogv","video/ogg"],["ogx","application/ogg"],["opus","audio/opus"],["otf","font/otf"],["png","image/png"],["pdf","application/pdf"],["php","application/x-httpd-php"],["ppt","application/vnd.ms-powerpoint"],["pptx","application/vnd.openxmlformats-officedocument.presentationml.presentation"],["rar","application/vnd.rar"],["rtf","application/rtf"],["sh","application/x-sh"],["svg","image/svg+xml"],["swf","application/x-shockwave-flash"],["tar","application/x-tar"],["tif","image/tiff"],["tiff","image/tiff"],["ts","video/mp2t"],["ttf","font/ttf"],["txt","text/plain"],["vsd","application/vnd.visio"],["wav","audio/wav"],["weba","audio/webm"],["webm","video/webm"],["webp","image/webp"],["woff","font/woff"],["woff2","font/woff2"],["xhtml","application/xhtml+xml"],["xls","application/vnd.ms-excel"],["xlsx","application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],["xml","application/xml"],["xul","application/vnd.mozilla.xul+xml"],["zip","application/zip"],["7z","application/x-7z-compressed"],["mkv","video/x-matroska"],["mov","video/quicktime"],["msg","application/vnd.ms-outlook"]]);function toFileWithPath(et,_){var _e=withMimeType(et);if(typeof _e.path!="string"){var tt=et.webkitRelativePath;Object.defineProperty(_e,"path",{value:typeof _=="string"?_:typeof tt=="string"&&tt.length>0?tt:et.name,writable:!1,configurable:!1,enumerable:!0})}return _e}function withMimeType(et){var _=et.name,_e=_&&_.lastIndexOf(".")!==-1;if(_e&&!et.type){var tt=_.split(".").pop().toLowerCase(),nt=COMMON_MIME_TYPES.get(tt);nt&&Object.defineProperty(et,"type",{value:nt,writable:!1,configurable:!1,enumerable:!0})}return et}var FILES_TO_IGNORE=[".DS_Store","Thumbs.db"];function fromEvent(et){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_){return isObject$7(et)&&isDataTransfer(et)?[2,getDataTransferFiles(et.dataTransfer,et.type)]:isChangeEvt(et)?[2,getInputFiles(et)]:Array.isArray(et)&&et.every(function(_e){return"getFile"in _e&&typeof _e.getFile=="function"})?[2,getFsHandleFiles(et)]:[2,[]]})})}function isDataTransfer(et){return isObject$7(et.dataTransfer)}function isChangeEvt(et){return isObject$7(et)&&isObject$7(et.target)}function isObject$7(et){return typeof et=="object"&&et!==null}function getInputFiles(et){return fromList(et.target.files).map(function(_){return toFileWithPath(_)})}function getFsHandleFiles(et){return __awaiter(this,void 0,void 0,function(){var _;return __generator(this,function(_e){switch(_e.label){case 0:return[4,Promise.all(et.map(function(tt){return tt.getFile()}))];case 1:return _=_e.sent(),[2,_.map(function(tt){return toFileWithPath(tt)})]}})})}function getDataTransferFiles(et,_){return __awaiter(this,void 0,void 0,function(){var _e,tt;return __generator(this,function(nt){switch(nt.label){case 0:return et===null?[2,[]]:et.items?(_e=fromList(et.items).filter(function(rt){return rt.kind==="file"}),_!=="drop"?[2,_e]:[4,Promise.all(_e.map(toFilePromises))]):[3,2];case 1:return tt=nt.sent(),[2,noIgnoredFiles(flatten(tt))];case 2:return[2,noIgnoredFiles(fromList(et.files).map(function(rt){return toFileWithPath(rt)}))]}})})}function noIgnoredFiles(et){return et.filter(function(_){return FILES_TO_IGNORE.indexOf(_.name)===-1})}function fromList(et){if(et===null)return[];for(var _=[],_e=0;_e<et.length;_e++){var tt=et[_e];_.push(tt)}return _}function toFilePromises(et){if(typeof et.webkitGetAsEntry!="function")return fromDataTransferItem(et);var _=et.webkitGetAsEntry();return _&&_.isDirectory?fromDirEntry(_):fromDataTransferItem(et)}function flatten(et){return et.reduce(function(_,_e){return __spread(_,Array.isArray(_e)?flatten(_e):[_e])},[])}function fromDataTransferItem(et){var _=et.getAsFile();if(!_)return Promise.reject(et+" is not a File");var _e=toFileWithPath(_);return Promise.resolve(_e)}function fromEntry(et){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_){return[2,et.isDirectory?fromDirEntry(et):fromFileEntry(et)]})})}function fromDirEntry(et){var _=et.createReader();return new Promise(function(_e,tt){var nt=[];function rt(){var ot=this;_.readEntries(function(at){return __awaiter(ot,void 0,void 0,function(){var lt,ut,dt;return __generator(this,function(st){switch(st.label){case 0:if(at.length)return[3,5];st.label=1;case 1:return st.trys.push([1,3,,4]),[4,Promise.all(nt)];case 2:return lt=st.sent(),_e(lt),[3,4];case 3:return ut=st.sent(),tt(ut),[3,4];case 4:return[3,6];case 5:dt=Promise.all(at.map(fromEntry)),nt.push(dt),rt(),st.label=6;case 6:return[2]}})})},function(at){tt(at)})}rt()})}function fromFileEntry(et){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_){return[2,new Promise(function(_e,tt){et.file(function(nt){var rt=toFileWithPath(nt,et.fullPath);_e(rt)},function(nt){tt(nt)})})]})})}var _default=function(et,_){if(et&&_){var _e=Array.isArray(_)?_:_.split(","),tt=et.name||"",nt=(et.type||"").toLowerCase(),rt=nt.replace(/\/.*$/,"");return _e.some(function(ot){var at=ot.trim().toLowerCase();return at.charAt(0)==="."?tt.toLowerCase().endsWith(at):at.endsWith("/*")?rt===at.replace(/\/.*$/,""):nt===at})}return!0};function ownKeys$1(et,_){var _e=Object.keys(et);if(Object.getOwnPropertySymbols){var tt=Object.getOwnPropertySymbols(et);_&&(tt=tt.filter(function(nt){return Object.getOwnPropertyDescriptor(et,nt).enumerable})),_e.push.apply(_e,tt)}return _e}function _objectSpread$1(et){for(var _=1;_<arguments.length;_++){var _e=arguments[_]!=null?arguments[_]:{};_%2?ownKeys$1(Object(_e),!0).forEach(function(tt){_defineProperty$1(et,tt,_e[tt])}):Object.getOwnPropertyDescriptors?Object.defineProperties(et,Object.getOwnPropertyDescriptors(_e)):ownKeys$1(Object(_e)).forEach(function(tt){Object.defineProperty(et,tt,Object.getOwnPropertyDescriptor(_e,tt))})}return et}function _defineProperty$1(et,_,_e){return _ in et?Object.defineProperty(et,_,{value:_e,enumerable:!0,configurable:!0,writable:!0}):et[_]=_e,et}function _slicedToArray$1(et,_){return _arrayWithHoles$1(et)||_iterableToArrayLimit$1(et,_)||_unsupportedIterableToArray$1(et,_)||_nonIterableRest$1()}function _nonIterableRest$1(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function _unsupportedIterableToArray$1(et,_){if(et){if(typeof et=="string")return _arrayLikeToArray$1(et,_);var _e=Object.prototype.toString.call(et).slice(8,-1);if(_e==="Object"&&et.constructor&&(_e=et.constructor.name),_e==="Map"||_e==="Set")return Array.from(et);if(_e==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(_e))return _arrayLikeToArray$1(et,_)}}function _arrayLikeToArray$1(et,_){(_==null||_>et.length)&&(_=et.length);for(var _e=0,tt=new Array(_);_e<_;_e++)tt[_e]=et[_e];return tt}function _iterableToArrayLimit$1(et,_){var _e=et==null?null:typeof Symbol<"u"&&et[Symbol.iterator]||et["@@iterator"];if(_e!=null){var tt=[],nt=!0,rt=!1,ot,at;try{for(_e=_e.call(et);!(nt=(ot=_e.next()).done)&&(tt.push(ot.value),!(_&&tt.length===_));nt=!0);}catch(lt){rt=!0,at=lt}finally{try{!nt&&_e.return!=null&&_e.return()}finally{if(rt)throw at}}return tt}}function _arrayWithHoles$1(et){if(Array.isArray(et))return et}var FILE_INVALID_TYPE="file-invalid-type",FILE_TOO_LARGE="file-too-large",FILE_TOO_SMALL="file-too-small",TOO_MANY_FILES="too-many-files",getInvalidTypeRejectionErr=function et(_){_=Array.isArray(_)&&_.length===1?_[0]:_;var _e=Array.isArray(_)?"one of ".concat(_.join(", ")):_;return{code:FILE_INVALID_TYPE,message:"File type must be ".concat(_e)}},getTooLargeRejectionErr=function et(_){return{code:FILE_TOO_LARGE,message:"File is larger than ".concat(_," ").concat(_===1?"byte":"bytes")}},getTooSmallRejectionErr=function et(_){return{code:FILE_TOO_SMALL,message:"File is smaller than ".concat(_," ").concat(_===1?"byte":"bytes")}},TOO_MANY_FILES_REJECTION={code:TOO_MANY_FILES,message:"Too many files"};function fileAccepted(et,_){var _e=et.type==="application/x-moz-file"||_default(et,_);return[_e,_e?null:getInvalidTypeRejectionErr(_)]}function fileMatchSize(et,_,_e){if(isDefined(et.size))if(isDefined(_)&&isDefined(_e)){if(et.size>_e)return[!1,getTooLargeRejectionErr(_e)];if(et.size<_)return[!1,getTooSmallRejectionErr(_)]}else{if(isDefined(_)&&et.size<_)return[!1,getTooSmallRejectionErr(_)];if(isDefined(_e)&&et.size>_e)return[!1,getTooLargeRejectionErr(_e)]}return[!0,null]}function isDefined(et){return et!=null}function allFilesAccepted(et){var _=et.files,_e=et.accept,tt=et.minSize,nt=et.maxSize,rt=et.multiple,ot=et.maxFiles;return!rt&&_.length>1||rt&&ot>=1&&_.length>ot?!1:_.every(function(at){var lt=fileAccepted(at,_e),ut=_slicedToArray$1(lt,1),dt=ut[0],st=fileMatchSize(at,tt,nt),it=_slicedToArray$1(st,1),ct=it[0];return dt&&ct})}function isPropagationStopped(et){return typeof et.isPropagationStopped=="function"?et.isPropagationStopped():typeof et.cancelBubble<"u"?et.cancelBubble:!1}function isEvtWithFiles(et){return et.dataTransfer?Array.prototype.some.call(et.dataTransfer.types,function(_){return _==="Files"||_==="application/x-moz-file"}):!!et.target&&!!et.target.files}function onDocumentDragOver(et){et.preventDefault()}function isIe(et){return et.indexOf("MSIE")!==-1||et.indexOf("Trident/")!==-1}function isEdge(et){return et.indexOf("Edge/")!==-1}function isIeOrEdge(){var et=arguments.length>0&&arguments[0]!==void 0?arguments[0]:window.navigator.userAgent;return isIe(et)||isEdge(et)}function composeEventHandlers(){for(var et=arguments.length,_=new Array(et),_e=0;_e<et;_e++)_[_e]=arguments[_e];return function(tt){for(var nt=arguments.length,rt=new Array(nt>1?nt-1:0),ot=1;ot<nt;ot++)rt[ot-1]=arguments[ot];return _.some(function(at){return!isPropagationStopped(tt)&&at&&at.apply(void 0,[tt].concat(rt)),isPropagationStopped(tt)})}}function canUseFileSystemAccessAPI(){return"showOpenFilePicker"in window}function filePickerOptionsTypes(et){return et=typeof et=="string"?et.split(","):et,[{description:"everything",accept:Array.isArray(et)?et.filter(function(_){return _==="audio/*"||_==="video/*"||_==="image/*"||_==="text/*"||/\w+\/[-+.\w]+/g.test(_)}).reduce(function(_,_e){return _objectSpread$1(_objectSpread$1({},_),{},_defineProperty$1({},_e,[]))},{}):{}}]}function isAbort(et){return et instanceof DOMException&&(et.name==="AbortError"||et.code===et.ABORT_ERR)}function isSecurityError(et){return et instanceof DOMException&&(et.name==="SecurityError"||et.code===et.SECURITY_ERR)}var _excluded=["children"],_excluded2$2=["open"],_excluded3=["refKey","role","onKeyDown","onFocus","onBlur","onClick","onDragEnter","onDragOver","onDragLeave","onDrop"],_excluded4=["refKey","onChange","onClick"];function _toConsumableArray(et){return _arrayWithoutHoles(et)||_iterableToArray(et)||_unsupportedIterableToArray(et)||_nonIterableSpread()}function _nonIterableSpread(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function _iterableToArray(et){if(typeof Symbol<"u"&&et[Symbol.iterator]!=null||et["@@iterator"]!=null)return Array.from(et)}function _arrayWithoutHoles(et){if(Array.isArray(et))return _arrayLikeToArray(et)}function _slicedToArray(et,_){return _arrayWithHoles(et)||_iterableToArrayLimit(et,_)||_unsupportedIterableToArray(et,_)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function _unsupportedIterableToArray(et,_){if(et){if(typeof et=="string")return _arrayLikeToArray(et,_);var _e=Object.prototype.toString.call(et).slice(8,-1);if(_e==="Object"&&et.constructor&&(_e=et.constructor.name),_e==="Map"||_e==="Set")return Array.from(et);if(_e==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(_e))return _arrayLikeToArray(et,_)}}function _arrayLikeToArray(et,_){(_==null||_>et.length)&&(_=et.length);for(var _e=0,tt=new Array(_);_e<_;_e++)tt[_e]=et[_e];return tt}function _iterableToArrayLimit(et,_){var _e=et==null?null:typeof Symbol<"u"&&et[Symbol.iterator]||et["@@iterator"];if(_e!=null){var tt=[],nt=!0,rt=!1,ot,at;try{for(_e=_e.call(et);!(nt=(ot=_e.next()).done)&&(tt.push(ot.value),!(_&&tt.length===_));nt=!0);}catch(lt){rt=!0,at=lt}finally{try{!nt&&_e.return!=null&&_e.return()}finally{if(rt)throw at}}return tt}}function _arrayWithHoles(et){if(Array.isArray(et))return et}function ownKeys(et,_){var _e=Object.keys(et);if(Object.getOwnPropertySymbols){var tt=Object.getOwnPropertySymbols(et);_&&(tt=tt.filter(function(nt){return Object.getOwnPropertyDescriptor(et,nt).enumerable})),_e.push.apply(_e,tt)}return _e}function _objectSpread(et){for(var _=1;_<arguments.length;_++){var _e=arguments[_]!=null?arguments[_]:{};_%2?ownKeys(Object(_e),!0).forEach(function(tt){_defineProperty(et,tt,_e[tt])}):Object.getOwnPropertyDescriptors?Object.defineProperties(et,Object.getOwnPropertyDescriptors(_e)):ownKeys(Object(_e)).forEach(function(tt){Object.defineProperty(et,tt,Object.getOwnPropertyDescriptor(_e,tt))})}return et}function _defineProperty(et,_,_e){return _ in et?Object.defineProperty(et,_,{value:_e,enumerable:!0,configurable:!0,writable:!0}):et[_]=_e,et}function _objectWithoutProperties(et,_){if(et==null)return{};var _e=_objectWithoutPropertiesLoose(et,_),tt,nt;if(Object.getOwnPropertySymbols){var rt=Object.getOwnPropertySymbols(et);for(nt=0;nt<rt.length;nt++)tt=rt[nt],!(_.indexOf(tt)>=0)&&Object.prototype.propertyIsEnumerable.call(et,tt)&&(_e[tt]=et[tt])}return _e}function _objectWithoutPropertiesLoose(et,_){if(et==null)return{};var _e={},tt=Object.keys(et),nt,rt;for(rt=0;rt<tt.length;rt++)nt=tt[rt],!(_.indexOf(nt)>=0)&&(_e[nt]=et[nt]);return _e}var Dropzone=reactExports.forwardRef(function(et,_){var _e=et.children,tt=_objectWithoutProperties(et,_excluded),nt=useDropzone(tt),rt=nt.open,ot=_objectWithoutProperties(nt,_excluded2$2);return reactExports.useImperativeHandle(_,function(){return{open:rt}},[rt]),React.createElement(reactExports.Fragment,null,_e(_objectSpread(_objectSpread({},ot),{},{open:rt})))});Dropzone.displayName="Dropzone";var defaultProps={disabled:!1,getFilesFromEvent:fromEvent,maxSize:1/0,minSize:0,multiple:!0,maxFiles:0,preventDropOnDocument:!0,noClick:!1,noKeyboard:!1,noDrag:!1,noDragEventsBubbling:!1,validator:null,useFsAccessApi:!0};Dropzone.defaultProps=defaultProps;Dropzone.propTypes={children:PropTypes.func,accept:PropTypes.oneOfType([PropTypes.string,PropTypes.arrayOf(PropTypes.string)]),multiple:PropTypes.bool,preventDropOnDocument:PropTypes.bool,noClick:PropTypes.bool,noKeyboard:PropTypes.bool,noDrag:PropTypes.bool,noDragEventsBubbling:PropTypes.bool,minSize:PropTypes.number,maxSize:PropTypes.number,maxFiles:PropTypes.number,disabled:PropTypes.bool,getFilesFromEvent:PropTypes.func,onFileDialogCancel:PropTypes.func,onFileDialogOpen:PropTypes.func,useFsAccessApi:PropTypes.bool,onDragEnter:PropTypes.func,onDragLeave:PropTypes.func,onDragOver:PropTypes.func,onDrop:PropTypes.func,onDropAccepted:PropTypes.func,onDropRejected:PropTypes.func,validator:PropTypes.func};var initialState={isFocused:!1,isFileDialogActive:!1,isDragActive:!1,isDragAccept:!1,isDragReject:!1,draggedFiles:[],acceptedFiles:[],fileRejections:[]};function useDropzone(){var et=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},_=_objectSpread(_objectSpread({},defaultProps),et),_e=_.accept,tt=_.disabled,nt=_.getFilesFromEvent,rt=_.maxSize,ot=_.minSize,at=_.multiple,lt=_.maxFiles,ut=_.onDragEnter,dt=_.onDragLeave,st=_.onDragOver,it=_.onDrop,ct=_.onDropAccepted,ft=_.onDropRejected,ht=_.onFileDialogCancel,mt=_.onFileDialogOpen,pt=_.useFsAccessApi,_t=_.preventDropOnDocument,vt=_.noClick,bt=_.noKeyboard,wt=_.noDrag,xt=_.noDragEventsBubbling,Mt=_.validator,At=reactExports.useMemo(function(){return typeof mt=="function"?mt:noop},[mt]),St=reactExports.useMemo(function(){return typeof ht=="function"?ht:noop},[ht]),Tt=reactExports.useRef(null),Ct=reactExports.useRef(null),It=reactExports.useReducer(reducer,initialState),$t=_slicedToArray(It,2),Nt=$t[0],Bt=$t[1],Ot=Nt.isFocused,Ut=Nt.isFileDialogActive,Lt=Nt.draggedFiles,zt=reactExports.useRef(typeof window<"u"&&window.isSecureContext&&pt&&canUseFileSystemAccessAPI()),Yt=function(){!zt.current&&Ut&&setTimeout(function(){if(Ct.current){var xn=Ct.current.files;xn.length||(Bt({type:"closeDialog"}),St())}},300)};reactExports.useEffect(function(){return window.addEventListener("focus",Yt,!1),function(){window.removeEventListener("focus",Yt,!1)}},[Ct,Ut,St,zt]);var en=reactExports.useRef([]),bn=function(xn){Tt.current&&Tt.current.contains(xn.target)||(xn.preventDefault(),en.current=[])};reactExports.useEffect(function(){return _t&&(document.addEventListener("dragover",onDocumentDragOver,!1),document.addEventListener("drop",bn,!1)),function(){_t&&(document.removeEventListener("dragover",onDocumentDragOver),document.removeEventListener("drop",bn))}},[Tt,_t]);var Un=reactExports.useCallback(function(hn){hn.preventDefault(),hn.persist(),Sn(hn),en.current=[].concat(_toConsumableArray(en.current),[hn.target]),isEvtWithFiles(hn)&&Promise.resolve(nt(hn)).then(function(xn){isPropagationStopped(hn)&&!xt||(Bt({draggedFiles:xn,isDragActive:!0,type:"setDraggedFiles"}),ut&&ut(hn))})},[nt,ut,xt]),mn=reactExports.useCallback(function(hn){hn.preventDefault(),hn.persist(),Sn(hn);var xn=isEvtWithFiles(hn);if(xn&&hn.dataTransfer)try{hn.dataTransfer.dropEffect="copy"}catch{}return xn&&st&&st(hn),!1},[st,xt]),vn=reactExports.useCallback(function(hn){hn.preventDefault(),hn.persist(),Sn(hn);var xn=en.current.filter(function(sr){return Tt.current&&Tt.current.contains(sr)}),Tn=xn.indexOf(hn.target);Tn!==-1&&xn.splice(Tn,1),en.current=xn,!(xn.length>0)&&(Bt({isDragActive:!1,type:"setDraggedFiles",draggedFiles:[]}),isEvtWithFiles(hn)&&dt&&dt(hn))},[Tt,dt,xt]),In=reactExports.useCallback(function(hn,xn){var Tn=[],sr=[];hn.forEach(function(Wn){var or=fileAccepted(Wn,_e),fr=_slicedToArray(or,2),Gn=fr[0],nr=fr[1],mr=fileMatchSize(Wn,ot,rt),hr=_slicedToArray(mr,2),Bn=hr[0],cn=hr[1],Fn=Mt?Mt(Wn):null;if(Gn&&Bn&&!Fn)Tn.push(Wn);else{var ir=[nr,cn];Fn&&(ir=ir.concat(Fn)),sr.push({file:Wn,errors:ir.filter(function(ln){return ln})})}}),(!at&&Tn.length>1||at&&lt>=1&&Tn.length>lt)&&(Tn.forEach(function(Wn){sr.push({file:Wn,errors:[TOO_MANY_FILES_REJECTION]})}),Tn.splice(0)),Bt({acceptedFiles:Tn,fileRejections:sr,type:"setFiles"}),it&&it(Tn,sr,xn),sr.length>0&&ft&&ft(sr,xn),Tn.length>0&&ct&&ct(Tn,xn)},[Bt,at,_e,ot,rt,lt,it,ct,ft,Mt]),Cn=reactExports.useCallback(function(hn){hn.preventDefault(),hn.persist(),Sn(hn),en.current=[],isEvtWithFiles(hn)&&Promise.resolve(nt(hn)).then(function(xn){isPropagationStopped(hn)&&!xt||In(xn,hn)}),Bt({type:"reset"})},[nt,In,xt]),En=reactExports.useCallback(function(){if(zt.current){Bt({type:"openDialog"}),At();var hn={multiple:at,types:filePickerOptionsTypes(_e)};window.showOpenFilePicker(hn).then(function(xn){return nt(xn)}).then(function(xn){In(xn,null),Bt({type:"closeDialog"})}).catch(function(xn){isAbort(xn)?(St(xn),Bt({type:"closeDialog"})):isSecurityError(xn)&&(zt.current=!1,Ct.current&&(Ct.current.value=null,Ct.current.click()))});return}Ct.current&&(Bt({type:"openDialog"}),At(),Ct.current.value=null,Ct.current.click())},[Bt,At,St,pt,In,_e,at]),jt=reactExports.useCallback(function(hn){!Tt.current||!Tt.current.isEqualNode(hn.target)||(hn.key===" "||hn.key==="Enter"||hn.keyCode===32||hn.keyCode===13)&&(hn.preventDefault(),En())},[Tt,En]),Kt=reactExports.useCallback(function(){Bt({type:"focus"})},[]),nn=reactExports.useCallback(function(){Bt({type:"blur"})},[]),Vt=reactExports.useCallback(function(){vt||(isIeOrEdge()?setTimeout(En,0):En())},[vt,En]),on=function(xn){return tt?null:xn},dn=function(xn){return bt?null:on(xn)},Ln=function(xn){return wt?null:on(xn)},Sn=function(xn){xt&&xn.stopPropagation()},Xn=reactExports.useMemo(function(){return function(){var hn=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},xn=hn.refKey,Tn=xn===void 0?"ref":xn,sr=hn.role,Wn=hn.onKeyDown,or=hn.onFocus,fr=hn.onBlur,Gn=hn.onClick,nr=hn.onDragEnter,mr=hn.onDragOver,hr=hn.onDragLeave,Bn=hn.onDrop,cn=_objectWithoutProperties(hn,_excluded3);return _objectSpread(_objectSpread(_defineProperty({onKeyDown:dn(composeEventHandlers(Wn,jt)),onFocus:dn(composeEventHandlers(or,Kt)),onBlur:dn(composeEventHandlers(fr,nn)),onClick:on(composeEventHandlers(Gn,Vt)),onDragEnter:Ln(composeEventHandlers(nr,Un)),onDragOver:Ln(composeEventHandlers(mr,mn)),onDragLeave:Ln(composeEventHandlers(hr,vn)),onDrop:Ln(composeEventHandlers(Bn,Cn)),role:typeof sr=="string"&&sr!==""?sr:"button"},Tn,Tt),!tt&&!bt?{tabIndex:0}:{}),cn)}},[Tt,jt,Kt,nn,Vt,Un,mn,vn,Cn,bt,wt,tt]),Vn=reactExports.useCallback(function(hn){hn.stopPropagation()},[]),Hn=reactExports.useMemo(function(){return function(){var hn=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},xn=hn.refKey,Tn=xn===void 0?"ref":xn,sr=hn.onChange,Wn=hn.onClick,or=_objectWithoutProperties(hn,_excluded4),fr=_defineProperty({accept:_e,multiple:at,type:"file",style:{display:"none"},onChange:on(composeEventHandlers(sr,Cn)),onClick:on(composeEventHandlers(Wn,Vn)),tabIndex:-1},Tn,Ct);return _objectSpread(_objectSpread({},fr),or)}},[Ct,_e,at,Cn,tt]),Zt=Lt.length,Gt=Zt>0&&allFilesAccepted({files:Lt,accept:_e,minSize:ot,maxSize:rt,multiple:at,maxFiles:lt}),fn=Zt>0&&!Gt;return _objectSpread(_objectSpread({},Nt),{},{isDragAccept:Gt,isDragReject:fn,isFocused:Ot&&!tt,getRootProps:Xn,getInputProps:Hn,rootRef:Tt,inputRef:Ct,open:on(En)})}function reducer(et,_){switch(_.type){case"focus":return _objectSpread(_objectSpread({},et),{},{isFocused:!0});case"blur":return _objectSpread(_objectSpread({},et),{},{isFocused:!1});case"openDialog":return _objectSpread(_objectSpread({},initialState),{},{isFileDialogActive:!0});case"closeDialog":return _objectSpread(_objectSpread({},et),{},{isFileDialogActive:!1});case"setDraggedFiles":var _e=_.isDragActive,tt=_.draggedFiles;return _objectSpread(_objectSpread({},et),{},{draggedFiles:tt,isDragActive:_e});case"setFiles":return _objectSpread(_objectSpread({},et),{},{acceptedFiles:_.acceptedFiles,fileRejections:_.fileRejections});case"reset":return _objectSpread({},initialState);default:return et}}function noop(){}/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */var isobject=function et(_){return _!=null&&typeof _=="object"&&Array.isArray(_)===!1};/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */var isObject$6=isobject;function isObjectObject(et){return isObject$6(et)===!0&&Object.prototype.toString.call(et)==="[object Object]"}var isPlainObject$2=function et(_){var _e,tt;return!(isObjectObject(_)===!1||(_e=_.constructor,typeof _e!="function")||(tt=_e.prototype,isObjectObject(tt)===!1)||tt.hasOwnProperty("isPrototypeOf")===!1)};/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */var isPlainObject$1=isPlainObject$2,isExtendable$4=function et(_){return isPlainObject$1(_)||typeof _=="function"||Array.isArray(_)};/*!
 * for-in <https://github.com/jonschlinkert/for-in>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */var forIn$1=function et(_,_e,tt){for(var nt in _)if(_e.call(tt,_[nt],nt,_)===!1)break},isExtendable$3=isExtendable$4,forIn=forIn$1;function mixinDeep(et,_){for(var _e=arguments.length,tt=0;++tt<_e;){var nt=arguments[tt];isObject$5(nt)&&forIn(nt,copy,et)}return et}function copy(et,_){if(isValidKey$1(_)){var _e=this[_];isObject$5(et)&&isObject$5(_e)?mixinDeep(_e,et):this[_]=et}}function isObject$5(et){return isExtendable$3(et)&&!Array.isArray(et)}function isValidKey$1(et){return et!=="__proto__"&&et!=="constructor"&&et!=="prototype"}var mixinDeep_1=mixinDeep;/*!
 * get-value <https://github.com/jonschlinkert/get-value>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */var getValue$1=function(et,_,_e,tt,nt){if(!isObject$4(et)||!_)return et;if(_=toString(_),_e&&(_+="."+toString(_e)),tt&&(_+="."+toString(tt)),nt&&(_+="."+toString(nt)),_ in et)return et[_];for(var rt=_.split("."),ot=rt.length,at=-1;et&&++at<ot;){for(var lt=rt[at];lt[lt.length-1]==="\\";)lt=lt.slice(0,-1)+"."+rt[++at];et=et[lt]}return et};function isObject$4(et){return et!==null&&(typeof et=="object"||typeof et=="function")}function toString(et){return et?Array.isArray(et)?et.join("."):et:""}/*!
 * assign-symbols <https://github.com/jonschlinkert/assign-symbols>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */var assignSymbols$1=function(et,_){if(et===null||typeof et>"u")throw new TypeError("expected first argument to be an object.");if(typeof _>"u"||typeof Symbol>"u"||typeof Object.getOwnPropertySymbols!="function")return et;for(var _e=Object.prototype.propertyIsEnumerable,tt=Object(et),nt=arguments.length,rt=0;++rt<nt;)for(var ot=Object(arguments[rt]),at=Object.getOwnPropertySymbols(ot),lt=0;lt<at.length;lt++){var ut=at[lt];_e.call(ot,ut)&&(tt[ut]=ot[ut])}return tt},isExtendable$2=isExtendable$4,assignSymbols=assignSymbols$1,extendShallow$1=Object.assign||function(et){if(et===null||typeof et>"u")throw new TypeError("Cannot convert undefined or null to object");isObject$3(et)||(et={});for(var _=1;_<arguments.length;_++){var _e=arguments[_];isString(_e)&&(_e=toObject(_e)),isObject$3(_e)&&(assign$1(et,_e),assignSymbols(et,_e))}return et};function assign$1(et,_){for(var _e in _)hasOwn$1(_,_e)&&(et[_e]=_[_e])}function isString(et){return et&&typeof et=="string"}function toObject(et){var _={};for(var _e in et)_[_e]=et[_e];return _}function isObject$3(et){return et&&typeof et=="object"||isExtendable$2(et)}function hasOwn$1(et,_){return Object.prototype.hasOwnProperty.call(et,_)}/*!
 * split-string <https://github.com/jonschlinkert/split-string>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */var extend$1=extendShallow$1,splitString=function(et,_,_e){if(typeof et!="string")throw new TypeError("expected a string");typeof _=="function"&&(_e=_,_=null),typeof _=="string"&&(_={sep:_});var tt=extend$1({sep:"."},_),nt=tt.quotes||['"',"'","`"],rt;tt.brackets===!0?rt={"<":">","(":")","[":"]","{":"}"}:tt.brackets&&(rt=tt.brackets);var ot=[],at=[],lt=[""],ut=tt.sep,dt=et.length,st=-1,it;function ct(){if(rt&&at.length)return rt[at[at.length-1]]}for(;++st<dt;){var ft=et[st],ht=et[st+1],mt={val:ft,idx:st,arr:lt,str:et};if(ot.push(mt),ft==="\\"){mt.val=keepEscaping(tt,et,st)===!0?ft+ht:ht,mt.escaped=!0,typeof _e=="function"&&_e(mt),lt[lt.length-1]+=mt.val,st++;continue}if(rt&&rt[ft]){at.push(ft);var pt=ct(),_t=st+1;if(et.indexOf(pt,_t+1)!==-1)for(;at.length&&_t<dt;){var vt=et[++_t];if(vt==="\\"){vt++;continue}if(nt.indexOf(vt)!==-1){_t=getClosingQuote(et,vt,_t+1);continue}if(pt=ct(),at.length&&et.indexOf(pt,_t+1)===-1)break;if(rt[vt]){at.push(vt);continue}pt===vt&&at.pop()}if(it=_t,it===-1){lt[lt.length-1]+=ft;continue}ft=et.slice(st,it+1),mt.val=ft,mt.idx=st=it}if(nt.indexOf(ft)!==-1){if(it=getClosingQuote(et,ft,st+1),it===-1){lt[lt.length-1]+=ft;continue}keepQuotes(ft,tt)===!0?ft=et.slice(st,it+1):ft=et.slice(st+1,it),mt.val=ft,mt.idx=st=it}if(typeof _e=="function"&&(_e(mt,ot),ft=mt.val,st=mt.idx),mt.val===ut&&mt.split!==!1){lt.push("");continue}lt[lt.length-1]+=mt.val}return lt};function getClosingQuote(et,_,_e,tt){var nt=et.indexOf(_,_e);return et.charAt(nt-1)==="\\"?getClosingQuote(et,_,nt+1):nt}function keepQuotes(et,_){return _.keepDoubleQuotes===!0&&et==='"'||_.keepSingleQuotes===!0&&et==="'"?!0:_.keepQuotes}function keepEscaping(et,_,_e){return typeof et.keepEscaping=="function"?et.keepEscaping(_,_e):et.keepEscaping===!0||_[_e+1]==="\\"}/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */var isExtendable$1=function et(_){return typeof _<"u"&&_!==null&&(typeof _=="object"||typeof _=="function")},isObject$2=isExtendable$1,extendShallow=function et(_){isObject$2(_)||(_={});for(var _e=arguments.length,tt=1;tt<_e;tt++){var nt=arguments[tt];isObject$2(nt)&&assign(_,nt)}return _};function assign(et,_){for(var _e in _)hasOwn(_,_e)&&(et[_e]=_[_e])}function hasOwn(et,_){return Object.prototype.hasOwnProperty.call(et,_)}/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */var isExtendable=function et(_){return typeof _<"u"&&_!==null&&(typeof _=="object"||typeof _=="function")};/*!
 * set-value <https://github.com/jonschlinkert/set-value>
 *
 * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */var split=splitString,extend=extendShallow,isPlainObject=isPlainObject$2,isObject$1=isExtendable,setValue=function(et,_,_e){if(!isObject$1(et)||(Array.isArray(_)&&(_=[].concat.apply([],_).join(".")),typeof _!="string"))return et;for(var tt=split(_,{sep:".",brackets:!0}).filter(isValidKey),nt=tt.length,rt=-1,ot=et;++rt<nt;){var at=tt[rt];if(rt!==nt-1){isObject$1(ot[at])||(ot[at]={}),ot=ot[at];continue}isPlainObject(ot[at])&&isPlainObject(_e)?ot[at]=extend({},ot[at],_e):ot[at]=_e}return et};function isValidKey(et){return et!=="__proto__"&&et!=="constructor"&&et!=="prototype"}var isObject=isExtendable$4,merge=mixinDeep_1,get=getValue$1,set=setValue,mergeValue=function et(_,_e,tt){if(!isObject(_))throw new TypeError("expected an object");if(typeof _e!="string"||tt==null)return merge.apply(null,arguments);if(typeof tt=="string")return set(_,_e,tt),_;var nt=get(_,_e);return isObject(tt)&&isObject(nt)&&(tt=merge({},nt,tt)),set(_,_e,tt),_};const merge$1=getDefaultExportFromCjs(mergeValue),join=(...et)=>et.filter(Boolean).join(".");function getKeyPath(et){const _=et.split(".");return[_.pop(),_.join(".")||void 0]}function getValuesForPaths(et,_){return Object.entries(pick(et,_)).reduce((_e,[,{value:tt,disabled:nt,key:rt}])=>(_e[rt]=nt?void 0:tt,_e),{})}function useCompareMemoize(et,_){const _e=reactExports.useRef();return dequal(et,_e.current)||(_e.current=et),_e.current}function useDeepMemo(et,_){return reactExports.useMemo(et,useCompareMemoize(_))}function useToggle(et){const _=reactExports.useRef(null),_e=reactExports.useRef(null),tt=reactExports.useRef(!0);return reactExports.useLayoutEffect(()=>{et||(_.current.style.height="0px",_.current.style.overflow="hidden")},[]),reactExports.useEffect(()=>{if(tt.current){tt.current=!1;return}let nt;const rt=_.current,ot=()=>{et&&(rt.style.removeProperty("height"),rt.style.removeProperty("overflow"),_e.current.scrollIntoView({behavior:"smooth",block:"nearest"}))};rt.addEventListener("transitionend",ot,{once:!0});const{height:at}=_e.current.getBoundingClientRect();return rt.style.height=at+"px",et||(rt.style.overflow="hidden",nt=window.setTimeout(()=>rt.style.height="0px",50)),()=>{rt.removeEventListener("transitionend",ot),clearTimeout(nt)}},[et]),{wrapperRef:_,contentRef:_e}}const useVisiblePaths=et=>{const[_,_e]=reactExports.useState(et.getVisiblePaths());return reactExports.useEffect(()=>{_e(et.getVisiblePaths());const tt=et.useStore.subscribe(et.getVisiblePaths,_e,{equalityFn:shallow});return()=>tt()},[et]),_};function useValuesForPath(et,_,_e){return et.useStore(nt=>{const rt=_objectSpread2(_objectSpread2({},_e),nt.data);return getValuesForPaths(rt,_)},shallow)}function usePopin(et=3){const _=reactExports.useRef(null),_e=reactExports.useRef(null),[tt,nt]=reactExports.useState(!1),rt=reactExports.useCallback(()=>nt(!0),[]),ot=reactExports.useCallback(()=>nt(!1),[]);return reactExports.useLayoutEffect(()=>{if(tt){const{bottom:at,top:lt,left:ut}=_.current.getBoundingClientRect(),{height:dt}=_e.current.getBoundingClientRect(),st=at+dt>window.innerHeight-40?"up":"down";_e.current.style.position="fixed",_e.current.style.zIndex="10000",_e.current.style.left=ut+"px",st==="down"?_e.current.style.top=at+et+"px":_e.current.style.bottom=window.innerHeight-lt+et+"px"}},[et,tt]),{popinRef:_,wrapperRef:_e,shown:tt,show:rt,hide:ot}}k$1([namesPlugin]);const convertMap={rgb:"toRgb",hsl:"toHsl",hsv:"toHsv",hex:"toHex"};v8n.extend({color:()=>et=>w(et).isValid()});const schema$2=et=>v8n().color().test(et);function convert(et,{format:_,hasAlpha:_e,isString:tt}){const nt=convertMap[_]+(tt&&_!=="hex"?"String":""),rt=et[nt]();return typeof rt=="object"&&!_e?omit(rt,["a"]):rt}const sanitize$2=(et,_)=>{const _e=w(et);if(!_e.isValid())throw Error("Invalid color");return convert(_e,_)},format$1=(et,_)=>convert(w(et),_objectSpread2(_objectSpread2({},_),{},{isString:!0,format:"hex"})),normalize$3=({value:et})=>{const _=I$1(et),_e=_==="name"?"hex":_,tt=typeof et=="object"?"a"in et:_==="hex"&&et.length===8||/^(rgba)|(hsla)|(hsva)/.test(et),nt={format:_e,hasAlpha:tt,isString:typeof et=="string"};return{value:sanitize$2(et,nt),settings:nt}};var props$2=Object.freeze({__proto__:null,schema:schema$2,sanitize:sanitize$2,format:format$1,normalize:normalize$3});const ColorPreview=styled("div",{position:"relative",boxSizing:"border-box",borderRadius:"$sm",overflow:"hidden",cursor:"pointer",height:"$rowHeight",width:"$rowHeight",backgroundColor:"#fff",backgroundImage:`url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')`,$inputStyle:"",$hover:"",zIndex:1,variants:{active:{true:{$inputStyle:"$accent1"}}},"&::before":{content:'""',position:"absolute",top:0,bottom:0,right:0,left:0,backgroundColor:"currentColor",zIndex:1}}),PickerContainer=styled("div",{position:"relative",display:"grid",gridTemplateColumns:"$sizes$rowHeight auto",columnGap:"$colGap",alignItems:"center"}),PickerWrapper=styled("div",{width:"$colorPickerWidth",height:"$colorPickerHeight",".react-colorful":{width:"100%",height:"100%",boxShadow:"$level2",cursor:"crosshair"},".react-colorful__saturation":{borderRadius:"$sm $sm 0 0"},".react-colorful__alpha, .react-colorful__hue":{height:10},".react-colorful__last-control":{borderRadius:"0 0 $sm $sm"},".react-colorful__pointer":{height:12,width:12}});function convertToRgb(et,_){return _!=="rgb"?w(et).toRgb():et}function Color({value:et,displayValue:_,settings:_e,onUpdate:tt}){const{emitOnEditStart:nt,emitOnEditEnd:rt}=useInputContext(),{format:ot,hasAlpha:at}=_e,{popinRef:lt,wrapperRef:ut,shown:dt,show:st,hide:it}=usePopin(),ct=reactExports.useRef(0),[ft,ht]=reactExports.useState(()=>convertToRgb(et,ot)),mt=at?Ce:Ne,pt=()=>{ht(convertToRgb(et,ot)),st(),nt()},_t=()=>{it(),rt(),window.clearTimeout(ct.current)},vt=()=>{ct.current=window.setTimeout(_t,500)};return reactExports.useEffect(()=>()=>window.clearTimeout(ct.current),[]),React.createElement(React.Fragment,null,React.createElement(ColorPreview,{ref:lt,active:dt,onClick:()=>pt(),style:{color:_}}),dt&&React.createElement(Portal,null,React.createElement(Overlay,{onPointerUp:_t}),React.createElement(PickerWrapper,{ref:ut,onMouseEnter:()=>window.clearTimeout(ct.current),onMouseLeave:bt=>bt.buttons===0&&vt()},React.createElement(mt,{color:ft,onChange:tt}))))}function ColorComponent(){const{value:et,displayValue:_,label:_e,onChange:tt,onUpdate:nt,settings:rt}=useInputContext();return React.createElement(Row,{input:!0},React.createElement(Label,null,_e),React.createElement(PickerContainer,null,React.createElement(Color,{value:et,displayValue:_,onChange:tt,onUpdate:nt,settings:rt}),React.createElement(ValueInput,{value:_,onChange:tt,onUpdate:nt})))}var color=_objectSpread2({component:ColorComponent},props$2);function Vector3dComponent(){const{label:et,displayValue:_,onUpdate:_e,settings:tt}=useInputContext();return React.createElement(Row,{input:!0},React.createElement(Label,null,et),React.createElement(Vector,{value:_,settings:tt,onUpdate:_e}))}var vector3d=_objectSpread2({component:Vector3dComponent},getVectorPlugin(["x","y","z"]));const JoystickTrigger=styled("div",{$flexCenter:"",position:"relative",backgroundColor:"$elevation3",borderRadius:"$sm",cursor:"pointer",height:"$rowHeight",width:"$rowHeight",touchAction:"none",$draggable:"",$hover:"","&:active":{cursor:"none"},"&::after":{content:'""',backgroundColor:"$accent2",height:4,width:4,borderRadius:2}}),JoystickPlayground=styled("div",{$flexCenter:"",width:"$joystickWidth",height:"$joystickHeight",borderRadius:"$sm",boxShadow:"$level2",position:"fixed",zIndex:1e4,overflow:"hidden",$draggable:"",transform:"translate(-50%, -50%)",variants:{isOutOfBounds:{true:{backgroundColor:"$elevation1"},false:{backgroundColor:"$elevation3"}}},"> div":{position:"absolute",$flexCenter:"",borderStyle:"solid",borderWidth:1,borderColor:"$highlight1",backgroundColor:"$elevation3",width:"80%",height:"80%","&::after,&::before":{content:'""',position:"absolute",zindex:10,backgroundColor:"$highlight1"},"&::before":{width:"100%",height:1},"&::after":{height:"100%",width:1}},"> span":{position:"relative",zindex:100,width:10,height:10,backgroundColor:"$accent2",borderRadius:"50%"}});function Joystick({value:et,settings:_,onUpdate:_e}){const tt=reactExports.useRef(),nt=reactExports.useRef(0),rt=reactExports.useRef(0),ot=reactExports.useRef(1),[at,lt]=reactExports.useState(!1),[ut,dt]=reactExports.useState(!1),[st,it]=useTransform(),ct=reactExports.useRef(null),ft=reactExports.useRef(null);reactExports.useLayoutEffect(()=>{if(at){const{top:It,left:$t,width:Nt,height:Bt}=ct.current.getBoundingClientRect();ft.current.style.left=$t+Nt/2+"px",ft.current.style.top=It+Bt/2+"px"}},[at]);const{keys:[ht,mt],joystick:pt}=_,_t=pt==="invertY"?1:-1,{[ht]:{step:vt},[mt]:{step:bt}}=_,wt=useTh("sizes","joystickWidth"),xt=useTh("sizes","joystickHeight"),Mt=parseFloat(wt)*.8/2,At=parseFloat(xt)*.8/2,St=reactExports.useCallback(()=>{tt.current||(dt(!0),nt.current&&it({x:nt.current*Mt}),rt.current&&it({y:rt.current*-At}),tt.current=window.setInterval(()=>{_e(It=>{const $t=vt*nt.current*ot.current,Nt=_t*bt*rt.current*ot.current;return Array.isArray(It)?{[ht]:It[0]+$t,[mt]:It[1]+Nt}:{[ht]:It[ht]+$t,[mt]:It[mt]+Nt}})},16))},[Mt,At,_e,it,vt,bt,ht,mt,_t]),Tt=reactExports.useCallback(()=>{window.clearTimeout(tt.current),tt.current=void 0,dt(!1)},[]);reactExports.useEffect(()=>{function It($t){ot.current=multiplyStep($t)}return window.addEventListener("keydown",It),window.addEventListener("keyup",It),()=>{window.clearTimeout(tt.current),window.removeEventListener("keydown",It),window.removeEventListener("keyup",It)}},[]);const Ct=useDrag(({first:It,active:$t,delta:[Nt,Bt],movement:[Ot,Ut]})=>{It&&lt(!0);const Lt=clamp(Ot,-Mt,Mt),zt=clamp(Ut,-At,At);nt.current=Math.abs(Ot)>Math.abs(Lt)?Math.sign(Ot-Lt):0,rt.current=Math.abs(Ut)>Math.abs(zt)?Math.sign(zt-Ut):0;let Yt=et[ht],en=et[mt];$t?(nt.current||(Yt+=Nt*vt*ot.current,it({x:Lt})),rt.current||(en-=_t*Bt*bt*ot.current,it({y:zt})),nt.current||rt.current?St():Tt(),_e({[ht]:Yt,[mt]:en})):(lt(!1),nt.current=0,rt.current=0,it({x:0,y:0}),Tt())});return React.createElement(JoystickTrigger,_extends({ref:ct},Ct()),at&&React.createElement(Portal,null,React.createElement(JoystickPlayground,{ref:ft,isOutOfBounds:ut},React.createElement("div",null),React.createElement("span",{ref:st}))))}const Container$1=styled("div",{display:"grid",columnGap:"$colGap",variants:{withJoystick:{true:{gridTemplateColumns:"$sizes$rowHeight auto"},false:{gridTemplateColumns:"auto"}}}});function Vector2dComponent(){const{label:et,displayValue:_,onUpdate:_e,settings:tt}=useInputContext();return React.createElement(Row,{input:!0},React.createElement(Label,null,et),React.createElement(Container$1,{withJoystick:!!tt.joystick},tt.joystick&&React.createElement(Joystick,{value:_,settings:tt,onUpdate:_e}),React.createElement(Vector,{value:_,settings:tt,onUpdate:_e})))}const _excluded$7=["joystick"],plugin=getVectorPlugin(["x","y"]),normalize$2=et=>{let{joystick:_=!0}=et,_e=_objectWithoutProperties$1(et,_excluded$7);const{value:tt,settings:nt}=plugin.normalize(_e);return{value:tt,settings:_objectSpread2(_objectSpread2({},nt),{},{joystick:_})}};var vector2d=_objectSpread2(_objectSpread2({component:Vector2dComponent},plugin),{},{normalize:normalize$2});const sanitize$1=et=>{if(et!==void 0){if(et instanceof File)try{return URL.createObjectURL(et)}catch{return}if(typeof et=="string"&&et.indexOf("blob:")===0)return et;throw Error("Invalid image format [undefined | blob |File].")}},schema$1=(et,_)=>typeof _=="object"&&"image"in _,normalize$1=({image:et})=>({value:et});var props$1=Object.freeze({__proto__:null,sanitize:sanitize$1,schema:schema$1,normalize:normalize$1});const ImageContainer=styled("div",{position:"relative",display:"grid",gridTemplateColumns:"$sizes$rowHeight auto 20px",columnGap:"$colGap",alignItems:"center"}),DropZone=styled("div",{$flexCenter:"",overflow:"hidden",height:"$rowHeight",background:"$elevation3",textAlign:"center",color:"inherit",borderRadius:"$sm",outline:"none",userSelect:"none",cursor:"pointer",$inputStyle:"",$hover:"",$focusWithin:"",$active:"$accent1 $elevation1",variants:{isDragAccept:{true:{$inputStyle:"$accent1",backgroundColor:"$elevation1"}}}}),ImagePreview=styled("div",{boxSizing:"border-box",borderRadius:"$sm",height:"$rowHeight",width:"$rowHeight",$inputStyle:"",backgroundSize:"cover",backgroundPosition:"center",variants:{hasImage:{true:{cursor:"pointer",$hover:"",$active:""}}}}),ImageLargePreview=styled("div",{$flexCenter:"",width:"$imagePreviewWidth",height:"$imagePreviewHeight",borderRadius:"$sm",boxShadow:"$level2",pointerEvents:"none",$inputStyle:"",backgroundSize:"cover",backgroundPosition:"center"}),Instructions=styled("div",{fontSize:"0.8em",height:"100%",padding:"$rowGap $md"}),Remove=styled("div",{$flexCenter:"",top:"0",right:"0",marginRight:"$sm",height:"100%",cursor:"pointer",variants:{disabled:{true:{color:"$elevation3",cursor:"default"}}},"&::after,&::before":{content:'""',position:"absolute",height:2,width:10,borderRadius:1,backgroundColor:"currentColor"},"&::after":{transform:"rotate(45deg)"},"&::before":{transform:"rotate(-45deg)"}});function ImageComponent(){const{label:et,value:_,onUpdate:_e,disabled:tt}=useInputContext(),{popinRef:nt,wrapperRef:rt,shown:ot,show:at,hide:lt}=usePopin(),ut=reactExports.useCallback(ft=>{ft.length&&_e(ft[0])},[_e]),dt=reactExports.useCallback(ft=>{ft.stopPropagation(),_e(void 0)},[_e]),{getRootProps:st,getInputProps:it,isDragAccept:ct}=useDropzone({maxFiles:1,accept:"image/*",onDrop:ut,disabled:tt});return React.createElement(Row,{input:!0},React.createElement(Label,null,et),React.createElement(ImageContainer,null,React.createElement(ImagePreview,{ref:nt,hasImage:!!_,onPointerDown:()=>!!_&&at(),onPointerUp:lt,style:{backgroundImage:_?`url(${_})`:"none"}}),ot&&!!_&&React.createElement(Portal,null,React.createElement(Overlay,{onPointerUp:lt,style:{cursor:"pointer"}}),React.createElement(ImageLargePreview,{ref:rt,style:{backgroundImage:`url(${_})`}})),React.createElement(DropZone,st({isDragAccept:ct}),React.createElement("input",it()),React.createElement(Instructions,null,ct?"drop image":"click or drop")),React.createElement(Remove,{onClick:dt,disabled:!_})))}var image=_objectSpread2({component:ImageComponent},props$1);const number=v8n().number(),schema=(et,_)=>v8n().array().length(2).every.number().test(et)&&v8n().schema({min:number,max:number}).test(_),format=et=>({min:et[0],max:et[1]}),sanitize=(et,{bounds:[_,_e]},tt)=>{const nt=Array.isArray(et)?format(et):et,rt={min:tt[0],max:tt[1]},{min:ot,max:at}=_objectSpread2(_objectSpread2({},rt),nt);return[clamp(Number(ot),_,Math.max(_,at)),clamp(Number(at),Math.min(_e,ot),_e)]},normalize=({value:et,min:_,max:_e})=>{const tt={min:_,max:_e},nt=normalizeKeyedNumberSettings(format(et),{min:tt,max:tt}),rt=[_,_e],ot=_objectSpread2(_objectSpread2({},nt),{},{bounds:rt});return{value:sanitize(format(et),ot,et),settings:ot}};var props=Object.freeze({__proto__:null,schema,format,sanitize,normalize});const _excluded$6=["value","bounds","onDrag"],_excluded2$1=["bounds"],Container=styled("div",{display:"grid",columnGap:"$colGap",gridTemplateColumns:"auto calc($sizes$numberInputMinWidth * 2 + $space$rowGap)"});function IntervalSlider(et){let{value:_,bounds:[_e,tt],onDrag:nt}=et,rt=_objectWithoutProperties$1(et,_excluded$6);const ot=reactExports.useRef(null),at=reactExports.useRef(null),lt=reactExports.useRef(null),ut=reactExports.useRef(0),dt=useTh("sizes","scrubberWidth"),st=useDrag(({event:ft,first:ht,xy:[mt],movement:[pt],memo:_t={}})=>{if(ht){const{width:bt,left:wt}=ot.current.getBoundingClientRect();ut.current=bt-parseFloat(dt);const xt=(ft==null?void 0:ft.target)===at.current||(ft==null?void 0:ft.target)===lt.current;_t.pos=invertedRange((mt-wt)/bt,_e,tt);const Mt=Math.abs(_t.pos-_.min)-Math.abs(_t.pos-_.max);_t.key=Mt<0||Mt===0&&_t.pos<=_.min?"min":"max",xt&&(_t.pos=_[_t.key])}const vt=_t.pos+invertedRange(pt/ut.current,0,tt-_e);return nt({[_t.key]:sanitizeStep(vt,rt[_t.key])}),_t}),it=`calc(${range(_.min,_e,tt)} * (100% - ${dt} - 8px) + 4px)`,ct=`calc(${1-range(_.max,_e,tt)} * (100% - ${dt} - 8px) + 4px)`;return React.createElement(RangeWrapper,_extends({ref:ot},st()),React.createElement(Range,null,React.createElement(Indicator,{style:{left:it,right:ct}})),React.createElement(Scrubber,{position:"left",ref:at,style:{left:it}}),React.createElement(Scrubber,{position:"right",ref:lt,style:{right:ct}}))}function IntervalComponent(){const{label:et,displayValue:_,onUpdate:_e,settings:tt}=useInputContext(),nt=_objectWithoutProperties$1(tt,_excluded2$1);return React.createElement(React.Fragment,null,React.createElement(Row,{input:!0},React.createElement(Label,null,et),React.createElement(Container,null,React.createElement(IntervalSlider,_extends({value:_},tt,{onDrag:_e})),React.createElement(Vector,{value:_,settings:nt,onUpdate:_e,innerLabelTrim:0}))))}var interval=_objectSpread2({component:IntervalComponent},props);const createEventEmitter=()=>{const et=new Map;return{on:(_,_e)=>{let tt=et.get(_);tt===void 0&&(tt=new Set,et.set(_,tt)),tt.add(_e)},off:(_,_e)=>{const tt=et.get(_);tt!==void 0&&(tt.delete(_e),tt.size===0&&et.delete(_))},emit:(_,..._e)=>{const tt=et.get(_);if(tt!==void 0)for(const nt of tt)nt(..._e)}}},_excluded$5=["type","value"],_excluded2=["onChange","transient","onEditStart","onEditEnd"],Store=function et(){const _=create(subscribeWithSelector(()=>({data:{}}))),_e=createEventEmitter();this.storeId=getUid(),this.useStore=_;const tt={},nt=new Set;this.getVisiblePaths=()=>{const ot=this.getData(),at=Object.keys(ot),lt=[];Object.entries(tt).forEach(([dt,st])=>{st.render&&at.some(it=>it.indexOf(dt)===0)&&!st.render(this.get)&&lt.push(dt+".")});const ut=[];return nt.forEach(dt=>{dt in ot&&ot[dt].__refCount>0&&lt.every(st=>dt.indexOf(st)===-1)&&(!ot[dt].render||ot[dt].render(this.get))&&ut.push(dt)}),ut},this.setOrderedPaths=ot=>{ot.forEach(at=>nt.add(at))},this.orderPaths=ot=>(this.setOrderedPaths(ot),ot),this.disposePaths=ot=>{_.setState(at=>{const lt=at.data;return ot.forEach(ut=>{if(ut in lt){const dt=lt[ut];dt.__refCount--,dt.__refCount===0&&dt.type in SpecialInputs&&delete lt[ut]}}),{data:lt}})},this.dispose=()=>{_.setState(()=>({data:{}}))},this.getFolderSettings=ot=>tt[ot]||{},this.getData=()=>_.getState().data,this.addData=(ot,at)=>{_.setState(lt=>{const ut=lt.data;return Object.entries(ot).forEach(([dt,st])=>{let it=ut[dt];if(it){const{type:ct,value:ft}=st,ht=_objectWithoutProperties$1(st,_excluded$5);ct!==it.type?warn(LevaErrors.INPUT_TYPE_OVERRIDE,ct):((it.__refCount===0||at)&&Object.assign(it,ht),it.__refCount++)}else ut[dt]=_objectSpread2(_objectSpread2({},st),{},{__refCount:1})}),{data:ut}})},this.setValueAtPath=(ot,at,lt)=>{_.setState(ut=>{const dt=ut.data;return updateInput(dt[ot],at,ot,this,lt),{data:dt}})},this.setSettingsAtPath=(ot,at)=>{_.setState(lt=>{const ut=lt.data;return ut[ot].settings=_objectSpread2(_objectSpread2({},ut[ot].settings),at),{data:ut}})},this.disableInputAtPath=(ot,at)=>{_.setState(lt=>{const ut=lt.data;return ut[ot].disabled=at,{data:ut}})},this.set=(ot,at)=>{_.setState(lt=>{const ut=lt.data;return Object.entries(ot).forEach(([dt,st])=>{try{updateInput(ut[dt],st,void 0,void 0,at)}catch{}}),{data:ut}})},this.getInput=ot=>{try{return this.getData()[ot]}catch{warn(LevaErrors.PATH_DOESNT_EXIST,ot)}},this.get=ot=>{var at;return(at=this.getInput(ot))===null||at===void 0?void 0:at.value},this.emitOnEditStart=ot=>{_e.emit(`onEditStart:${ot}`,this.get(ot),ot,_objectSpread2(_objectSpread2({},this.getInput(ot)),{},{get:this.get}))},this.emitOnEditEnd=ot=>{_e.emit(`onEditEnd:${ot}`,this.get(ot),ot,_objectSpread2(_objectSpread2({},this.getInput(ot)),{},{get:this.get}))},this.subscribeToEditStart=(ot,at)=>{const lt=`onEditStart:${ot}`;return _e.on(lt,at),()=>_e.off(lt,at)},this.subscribeToEditEnd=(ot,at)=>{const lt=`onEditEnd:${ot}`;return _e.on(lt,at),()=>_e.off(lt,at)};const rt=(ot,at,lt)=>{const ut={};return Object.entries(ot).forEach(([dt,st])=>{if(dt==="")return warn(LevaErrors.EMPTY_KEY);let it=join(at,dt);if(st.type===SpecialInputs.FOLDER){const ct=rt(st.schema,it,lt);Object.assign(ut,ct),it in tt||(tt[it]=st.settings)}else if(dt in lt)warn(LevaErrors.DUPLICATE_KEYS,dt,it,lt[dt].path);else{const ct=normalizeInput(st,dt,it,ut);if(ct){const{type:ft,options:ht,input:mt}=ct,{onChange:pt,transient:_t,onEditStart:vt,onEditEnd:bt}=ht,wt=_objectWithoutProperties$1(ht,_excluded2);ut[it]=_objectSpread2(_objectSpread2(_objectSpread2({type:ft},wt),mt),{},{fromPanel:!0}),lt[dt]={path:it,onChange:pt,transient:_t,onEditStart:vt,onEditEnd:bt}}else warn(LevaErrors.UNKNOWN_INPUT,it,st)}}),ut};this.getDataFromSchema=ot=>{const at={};return[rt(ot,"",at),at]}},levaStore=new Store,defaultSettings$2={collapsed:!1};function folder(et,_){return{type:SpecialInputs.FOLDER,schema:et,settings:_objectSpread2(_objectSpread2({},defaultSettings$2),_)}}const isInput=et=>"__levaInput"in et,buildTree=(et,_)=>{const _e={},tt=_?_.toLowerCase():null;return et.forEach(nt=>{const[rt,ot]=getKeyPath(nt);(!tt||rt.toLowerCase().indexOf(tt)>-1)&&merge$1(_e,ot,{[rt]:{__levaInput:!0,path:nt}})}),_e},_excluded$4=["type","label","path","valueKey","value","settings","setValue","disabled"];function ControlInput(et){let{type:_,label:_e,path:tt,valueKey:nt,value:rt,settings:ot,setValue:at,disabled:lt}=et,ut=_objectWithoutProperties$1(et,_excluded$4);const{displayValue:dt,onChange:st,onUpdate:it}=useInputSetters({type:_,value:rt,settings:ot,setValue:at}),ct=Plugins[_].component;return ct?React.createElement(InputContext.Provider,{value:_objectSpread2({key:nt,path:tt,id:""+tt,label:_e,displayValue:dt,value:rt,onChange:st,onUpdate:it,settings:ot,setValue:at,disabled:lt},ut)},React.createElement(StyledInputWrapper$1,{disabled:lt},React.createElement(ct,null))):(warn(LevaErrors.NO_COMPONENT_FOR_TYPE,_,tt),null)}const StyledButton=styled("button",{display:"block",$reset:"",fontWeight:"$button",height:"$rowHeight",borderStyle:"none",borderRadius:"$sm",backgroundColor:"$elevation1",color:"$highlight1","&:not(:disabled)":{color:"$highlight3",backgroundColor:"$accent2",cursor:"pointer",$hover:"$accent3",$active:"$accent3 $accent1",$focus:""}});function Button({onClick:et,settings:_,label:_e}){const tt=useStoreContext();return React.createElement(Row,null,React.createElement(StyledButton,{disabled:_.disabled,onClick:()=>et(tt.get)},_e))}const StyledButtonGroup=styled("div",{$flex:"",justifyContent:"flex-end",gap:"$colGap"}),StyledButtonGroupButton=styled("button",{$reset:"",cursor:"pointer",borderRadius:"$xs","&:hover":{backgroundColor:"$elevation3"}}),getOpts=({label:et,opts:_})=>{let _e=typeof et=="string"&&et.trim()===""?null:et,tt=_;return typeof _.opts=="object"&&(tt.label!==void 0&&(_e=_.label),tt=_.opts),{label:_e,opts:tt}};function ButtonGroup(et){const{label:_,opts:_e}=getOpts(et),tt=useStoreContext();return React.createElement(Row,{input:!!_},_&&React.createElement(Label,null,_),React.createElement(StyledButtonGroup,null,Object.entries(_e).map(([nt,rt])=>React.createElement(StyledButtonGroupButton,{key:nt,onClick:()=>rt(tt.get)},nt))))}const Canvas=styled("canvas",{height:"$monitorHeight",width:"100%",display:"block",borderRadius:"$sm"}),POINTS=100;function push(et,_){et.push(_),et.length>POINTS&&et.shift()}const MonitorCanvas=reactExports.forwardRef(function({initialValue:et},_){const _e=useTh("colors","highlight3"),tt=useTh("colors","elevation2"),nt=useTh("colors","highlight1"),[rt,ot]=reactExports.useMemo(()=>[w(nt).alpha(.4).toRgbString(),w(nt).alpha(.1).toRgbString()],[nt]),at=reactExports.useRef([et]),lt=reactExports.useRef(et),ut=reactExports.useRef(et),dt=reactExports.useRef(),st=reactExports.useCallback((ft,ht)=>{if(!ft)return;const{width:mt,height:pt}=ft,_t=new Path2D,vt=mt/POINTS,bt=pt*.05;for(let Mt=0;Mt<at.current.length;Mt++){const At=range(at.current[Mt],lt.current,ut.current),St=vt*Mt,Tt=pt-At*(pt-bt*2)-bt;_t.lineTo(St,Tt)}ht.clearRect(0,0,mt,pt);const wt=new Path2D(_t);wt.lineTo(vt*(at.current.length+1),pt),wt.lineTo(0,pt),wt.lineTo(0,0);const xt=ht.createLinearGradient(0,0,0,pt);xt.addColorStop(0,rt),xt.addColorStop(1,ot),ht.fillStyle=xt,ht.fill(wt),ht.strokeStyle=tt,ht.lineJoin="round",ht.lineWidth=14,ht.stroke(_t),ht.strokeStyle=_e,ht.lineWidth=2,ht.stroke(_t)},[_e,tt,rt,ot]),[it,ct]=useCanvas2d(st);return reactExports.useImperativeHandle(_,()=>({frame:ft=>{(lt.current===void 0||ft<lt.current)&&(lt.current=ft),(ut.current===void 0||ft>ut.current)&&(ut.current=ft),push(at.current,ft),dt.current=requestAnimationFrame(()=>st(it.current,ct.current))}}),[it,ct,st]),reactExports.useEffect(()=>()=>cancelAnimationFrame(dt.current),[]),React.createElement(Canvas,{ref:it})}),parse=et=>Number.isFinite(et)?et.toPrecision(2):et.toString(),MonitorLog=reactExports.forwardRef(function({initialValue:et},_){const[_e,tt]=reactExports.useState(parse(et));return reactExports.useImperativeHandle(_,()=>({frame:nt=>tt(parse(nt))}),[]),React.createElement("div",null,_e)});function getValue(et){return typeof et=="function"?et():et.current}function Monitor({label:et,objectOrFn:_,settings:_e}){const tt=reactExports.useRef(),nt=reactExports.useRef(getValue(_));return reactExports.useEffect(()=>{const rt=window.setInterval(()=>{var ot;document.hidden||(ot=tt.current)===null||ot===void 0||ot.frame(getValue(_))},_e.interval);return()=>window.clearInterval(rt)},[_,_e.interval]),React.createElement(Row,{input:!0},React.createElement(Label,{align:"top"},et),_e.graph?React.createElement(MonitorCanvas,{ref:tt,initialValue:nt.current}):React.createElement(MonitorLog,{ref:tt,initialValue:nt.current}))}const _excluded$3=["type","label","key"],specialComponents={[SpecialInputs.BUTTON]:Button,[SpecialInputs.BUTTON_GROUP]:ButtonGroup,[SpecialInputs.MONITOR]:Monitor},Control=React.memo(({path:et})=>{const[_,{set:_e,setSettings:tt,disable:nt,storeId:rt,emitOnEditStart:ot,emitOnEditEnd:at}]=useInput(et);if(!_)return null;const{type:lt,label:ut,key:dt}=_,st=_objectWithoutProperties$1(_,_excluded$3);if(lt in SpecialInputs){const it=specialComponents[lt];return React.createElement(it,_extends({label:ut,path:et},st))}return lt in Plugins?React.createElement(ControlInput,_extends({key:rt+et,type:lt,label:ut,storeId:rt,path:et,valueKey:dt,setValue:_e,setSettings:tt,disable:nt,emitOnEditStart:ot,emitOnEditEnd:at},st)):(log(LevaErrors.UNSUPPORTED_INPUT,lt,et),null)});function FolderTitle({toggle:et,toggled:_,name:_e}){return React.createElement(StyledTitle,{onClick:()=>et()},React.createElement(Chevron,{toggled:_}),React.createElement("div",null,_e))}const Folder=({name:et,path:_,tree:_e})=>{const tt=useStoreContext(),nt=join(_,et),{collapsed:rt,color:ot}=tt.getFolderSettings(nt),[at,lt]=reactExports.useState(!rt),ut=reactExports.useRef(null),dt=useTh("colors","folderWidgetColor"),st=useTh("colors","folderTextColor");return reactExports.useLayoutEffect(()=>{ut.current.style.setProperty("--leva-colors-folderWidgetColor",ot||dt),ut.current.style.setProperty("--leva-colors-folderTextColor",ot||st)},[ot,dt,st]),React.createElement(StyledFolder,{ref:ut},React.createElement(FolderTitle,{name:et,toggled:at,toggle:()=>lt(it=>!it)}),React.createElement(TreeWrapper,{parent:nt,tree:_e,toggled:at}))},TreeWrapper=React.memo(({isRoot:et=!1,fill:_=!1,flat:_e=!1,parent:tt,tree:nt,toggled:rt})=>{const{wrapperRef:ot,contentRef:at}=useToggle(rt),lt=useStoreContext(),ut=([st,it])=>{var ct;return(isInput(it)?(ct=lt.getInput(it.path))===null||ct===void 0?void 0:ct.order:lt.getFolderSettings(join(tt,st)).order)||0},dt=Object.entries(nt).sort((st,it)=>ut(st)-ut(it));return React.createElement(StyledWrapper,{ref:ot,isRoot:et,fill:_,flat:_e},React.createElement(StyledContent,{ref:at,isRoot:et,toggled:rt},dt.map(([st,it])=>isInput(it)?React.createElement(Control,{key:it.path,valueKey:it.valueKey,path:it.path}):React.createElement(Folder,{key:st,name:st,path:tt,tree:it}))))}),StyledRoot=styled("div",{position:"relative",fontFamily:"$mono",fontSize:"$root",color:"$rootText",backgroundColor:"$elevation1",variants:{fill:{false:{position:"fixed",top:"10px",right:"10px",zIndex:1e3,width:"$rootWidth"},true:{position:"relative",width:"100%"}},flat:{false:{borderRadius:"$lg",boxShadow:"$level1"}},oneLineLabels:{true:{[`${StyledInputRow}`]:{gridTemplateColumns:"auto",gridAutoColumns:"minmax(max-content, 1fr)",gridAutoRows:"minmax($sizes$rowHeight), auto)",rowGap:0,columnGap:0,marginTop:"$rowGap"}}},hideTitleBar:{true:{$$titleBarHeight:"0px"},false:{$$titleBarHeight:"$sizes$titleBarHeight"}}},"&,*,*:after,*:before":{boxSizing:"border-box"},"*::selection":{backgroundColor:"$accent2"}}),iconWidth=40,Icon=styled("i",{$flexCenter:"",width:iconWidth,userSelect:"none",cursor:"pointer","> svg":{fill:"$highlight1",transition:"transform 350ms ease, fill 250ms ease"},"&:hover > svg":{fill:"$highlight3"},variants:{active:{true:{"> svg":{fill:"$highlight2"}}}}}),StyledTitleWithFilter=styled("div",{display:"flex",alignItems:"stretch",justifyContent:"space-between",height:"$titleBarHeight",variants:{mode:{drag:{cursor:"grab"}}}}),FilterWrapper=styled("div",{$flex:"",position:"relative",width:"100%",overflow:"hidden",transition:"height 250ms ease",color:"$highlight3",paddingLeft:"$md",[`> ${Icon}`]:{height:30},variants:{toggled:{true:{height:30},false:{height:0}}}}),StyledFilterInput=styled("input",{$reset:"",flex:1,position:"relative",height:30,width:"100%",backgroundColor:"transparent",fontSize:"10px",borderRadius:"$root","&:focus":{},"&::placeholder":{color:"$highlight2"}}),TitleContainer=styled("div",{touchAction:"none",$flexCenter:"",flex:1,"> svg":{fill:"$highlight1"},color:"$highlight1",variants:{drag:{true:{$draggable:"","> svg":{transition:"fill 250ms ease"},"&:hover":{color:"$highlight3"},"&:hover > svg":{fill:"$highlight3"}}},filterEnabled:{false:{paddingRight:iconWidth}}}}),FilterInput=React.forwardRef(({setFilter:et,toggle:_},_e)=>{const[tt,nt]=reactExports.useState(""),rt=reactExports.useMemo(()=>debounce(et,250),[et]),ot=()=>{et(""),nt("")},at=lt=>{const ut=lt.currentTarget.value;_(!0),nt(ut)};return reactExports.useEffect(()=>{rt(tt)},[tt,rt]),React.createElement(React.Fragment,null,React.createElement(StyledFilterInput,{ref:_e,value:tt,placeholder:"[Open filter with CMD+SHIFT+L]",onPointerDown:lt=>lt.stopPropagation(),onChange:at}),React.createElement(Icon,{onClick:()=>ot(),style:{visibility:tt?"visible":"hidden"}},React.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",height:"14",width:"14",viewBox:"0 0 20 20",fill:"currentColor"},React.createElement("path",{fillRule:"evenodd",d:"M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z",clipRule:"evenodd"}))))});function TitleWithFilter({setFilter:et,onDrag:_,onDragStart:_e,onDragEnd:tt,toggle:nt,toggled:rt,title:ot,drag:at,filterEnabled:lt,from:ut}){const[dt,st]=reactExports.useState(!1),it=reactExports.useRef(null);reactExports.useEffect(()=>{var ft,ht;dt?(ft=it.current)===null||ft===void 0||ft.focus():(ht=it.current)===null||ht===void 0||ht.blur()},[dt]);const ct=useDrag(({offset:[ft,ht],first:mt,last:pt})=>{_({x:ft,y:ht}),mt&&_e({x:ft,y:ht}),pt&&tt({x:ft,y:ht})},{filterTaps:!0,from:({offset:[ft,ht]})=>[(ut==null?void 0:ut.x)||ft,(ut==null?void 0:ut.y)||ht]});return reactExports.useEffect(()=>{const ft=ht=>{ht.key==="L"&&ht.shiftKey&&ht.metaKey&&st(mt=>!mt)};return window.addEventListener("keydown",ft),()=>window.removeEventListener("keydown",ft)},[]),React.createElement(React.Fragment,null,React.createElement(StyledTitleWithFilter,{mode:at?"drag":void 0},React.createElement(Icon,{active:!rt,onClick:()=>nt()},React.createElement(Chevron,{toggled:rt,width:12,height:8})),React.createElement(TitleContainer,_extends({},at?ct():{},{drag:at,filterEnabled:lt}),ot===void 0&&at?React.createElement("svg",{width:"20",height:"10",viewBox:"0 0 28 14",xmlns:"http://www.w3.org/2000/svg"},React.createElement("circle",{cx:"2",cy:"2",r:"2"}),React.createElement("circle",{cx:"14",cy:"2",r:"2"}),React.createElement("circle",{cx:"26",cy:"2",r:"2"}),React.createElement("circle",{cx:"2",cy:"12",r:"2"}),React.createElement("circle",{cx:"14",cy:"12",r:"2"}),React.createElement("circle",{cx:"26",cy:"12",r:"2"})):ot),lt&&React.createElement(Icon,{active:dt,onClick:()=>st(ft=>!ft)},React.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",height:"20",viewBox:"0 0 20 20"},React.createElement("path",{d:"M9 9a2 2 0 114 0 2 2 0 01-4 0z"}),React.createElement("path",{fillRule:"evenodd",d:"M10 18a8 8 0 100-16 8 8 0 000 16zm1-13a4 4 0 00-3.446 6.032l-2.261 2.26a1 1 0 101.414 1.415l2.261-2.261A4 4 0 1011 5z",clipRule:"evenodd"})))),React.createElement(FilterWrapper,{toggled:dt},React.createElement(FilterInput,{ref:it,setFilter:et,toggle:nt})))}const _excluded$2=["store","hidden","theme","collapsed"];function LevaRoot(et){let{store:_,hidden:_e=!1,theme:tt,collapsed:nt=!1}=et,rt=_objectWithoutProperties$1(et,_excluded$2);const ot=useDeepMemo(()=>mergeTheme(tt),[tt]),[at,lt]=reactExports.useState(!nt),ut=typeof nt=="object"?!nt.collapsed:at,dt=reactExports.useMemo(()=>typeof nt=="object"?st=>{typeof st=="function"?nt.onChange(!st(!nt.collapsed)):nt.onChange(!st)}:lt,[nt]);return!_||_e?null:React.createElement(ThemeContext.Provider,{value:ot},React.createElement(LevaCore,_extends({store:_},rt,{toggled:ut,setToggle:dt,rootClass:ot.className})))}const LevaCore=React.memo(({store:et,rootClass:_,fill:_e=!1,flat:tt=!1,neverHide:nt=!1,oneLineLabels:rt=!1,titleBar:ot={title:void 0,drag:!0,filter:!0,position:void 0,onDrag:void 0,onDragStart:void 0,onDragEnd:void 0},hideCopyButton:at=!1,toggled:lt,setToggle:ut})=>{var dt,st;const it=useVisiblePaths(et),[ct,ft]=reactExports.useState(""),ht=reactExports.useMemo(()=>buildTree(it,ct),[it,ct]),[mt,pt]=useTransform(),_t=nt||it.length>0,vt=typeof ot=="object"&&ot.title||void 0,bt=typeof ot=="object"&&(dt=ot.drag)!==null&&dt!==void 0?dt:!0,wt=typeof ot=="object"&&(st=ot.filter)!==null&&st!==void 0?st:!0,xt=typeof ot=="object"&&ot.position||void 0,Mt=typeof ot=="object"&&ot.onDrag||void 0,At=typeof ot=="object"&&ot.onDragStart||void 0,St=typeof ot=="object"&&ot.onDragEnd||void 0;return React.useEffect(()=>{pt({x:xt==null?void 0:xt.x,y:xt==null?void 0:xt.y})},[xt,pt]),globalStyles(),React.createElement(PanelSettingsContext.Provider,{value:{hideCopyButton:at}},React.createElement(StyledRoot,{ref:mt,className:_,fill:_e,flat:tt,oneLineLabels:rt,hideTitleBar:!ot,style:{display:_t?"block":"none"}},ot&&React.createElement(TitleWithFilter,{onDrag:Tt=>{pt(Tt),Mt==null||Mt(Tt)},onDragStart:Tt=>At==null?void 0:At(Tt),onDragEnd:Tt=>St==null?void 0:St(Tt),setFilter:ft,toggle:Tt=>ut(Ct=>Tt??!Ct),toggled:lt,title:vt,drag:bt,filterEnabled:wt,from:xt}),_t&&React.createElement(StoreContext.Provider,{value:et},React.createElement(TreeWrapper,{isRoot:!0,fill:_e,flat:tt,tree:ht,toggled:lt}))))}),_excluded$1=["isRoot"];let rootInitialized=!1,rootEl=null;function Leva(et){let{isRoot:_=!1}=et,_e=_objectWithoutProperties$1(et,_excluded$1);return reactExports.useEffect(()=>(rootInitialized=!0,!_&&rootEl&&(rootEl.remove(),rootEl=null),()=>{_||(rootInitialized=!1)}),[_]),React.createElement(LevaRoot,_extends({store:levaStore},_e))}function useRenderRoot(et){reactExports.useEffect(()=>{et&&!rootInitialized&&(rootEl||(rootEl=document.getElementById("leva__root")||Object.assign(document.createElement("div"),{id:"leva__root"}),document.body&&(document.body.appendChild(rootEl),render(React.createElement(Leva,{isRoot:!0}),rootEl))),rootInitialized=!0)},[et])}function parseArgs(et,_,_e,tt,nt){let rt,ot,at,lt,ut;return typeof et=="string"?(ot=et,rt=_,Array.isArray(_e)&&(ut=_e)):(rt=et,Array.isArray(_)?ut=_:(lt=_,ut=_e)),{schema:rt,folderName:ot,folderSettings:at,hookSettings:lt,deps:ut||[]}}function useControls(et,_,_e,tt,nt){const{folderName:rt,schema:ot,folderSettings:at,hookSettings:lt,deps:ut}=parseArgs(et,_,_e),dt=typeof ot=="function",st=reactExports.useRef(!1),it=reactExports.useRef(!0),ct=useDeepMemo(()=>{st.current=!0;const Ct=typeof ot=="function"?ot():ot;return rt?{[rt]:folder(Ct,at)}:Ct},ut),ft=!(lt!=null&&lt.store);useRenderRoot(ft);const[ht]=reactExports.useState(()=>(lt==null?void 0:lt.store)||levaStore),[mt,pt]=reactExports.useMemo(()=>ht.getDataFromSchema(ct),[ht,ct]),[_t,vt,bt,wt,xt]=reactExports.useMemo(()=>{const Ct=[],It=[],$t={},Nt={},Bt={};return Object.values(pt).forEach(({path:Ot,onChange:Ut,onEditStart:Lt,onEditEnd:zt,transient:Yt})=>{Ct.push(Ot),Ut?($t[Ot]=Ut,Yt||It.push(Ot)):It.push(Ot),Lt&&(Nt[Ot]=Lt),zt&&(Bt[Ot]=zt)}),[Ct,It,$t,Nt,Bt]},[pt]),Mt=reactExports.useMemo(()=>ht.orderPaths(_t),[_t,ht]),At=useValuesForPath(ht,vt,mt),St=reactExports.useCallback(Ct=>{const It=Object.entries(Ct).reduce(($t,[Nt,Bt])=>Object.assign($t,{[pt[Nt].path]:Bt}),{});ht.set(It,!1)},[ht,pt]),Tt=reactExports.useCallback(Ct=>ht.get(pt[Ct].path),[ht,pt]);return reactExports.useEffect(()=>{const Ct=!it.current&&st.current;return ht.addData(mt,Ct),it.current=!1,st.current=!1,()=>ht.disposePaths(Mt)},[ht,Mt,mt]),reactExports.useEffect(()=>{const Ct=[];return Object.entries(bt).forEach(([It,$t])=>{$t(ht.get(It),It,_objectSpread2({initial:!0,get:ht.get},ht.getInput(It)));const Nt=ht.useStore.subscribe(Bt=>{const Ot=Bt.data[It];return[Ot.disabled?void 0:Ot.value,Ot]},([Bt,Ot])=>$t(Bt,It,_objectSpread2({initial:!1,get:ht.get},Ot)),{equalityFn:shallow});Ct.push(Nt)}),()=>Ct.forEach(It=>It())},[ht,bt]),reactExports.useEffect(()=>{const Ct=[];return Object.entries(wt).forEach(([It,$t])=>Ct.push(ht.subscribeToEditStart(It,$t))),Object.entries(xt).forEach(([It,$t])=>Ct.push(ht.subscribeToEditEnd(It,$t))),()=>Ct.forEach(It=>It())},[wt,xt,ht]),dt?[At,St,Tt]:At}register(LevaInputs.SELECT,select);register(LevaInputs.IMAGE,image);register(LevaInputs.NUMBER,number$1);register(LevaInputs.COLOR,color);register(LevaInputs.STRING,string);register(LevaInputs.BOOLEAN,boolean);register(LevaInputs.INTERVAL,interval);register(LevaInputs.VECTOR3D,vector3d);register(LevaInputs.VECTOR2D,vector2d);const imgUrl="/watercolor-painting//watercolor_1.jpeg";function App(){const{Image:et}=useControls({Image:{image:imgUrl}}),_=useDepthEstimator(et);return jsxRuntimeExports.jsxs("div",{className:"fixed inset-0",children:[!_&&jsxRuntimeExports.jsx("div",{className:"absolute inset-0 bg-stone-500 animate-pulse"}),jsxRuntimeExports.jsx(Canvas$1,{children:_&&jsxRuntimeExports.jsx(Scene,{img:et,depth:_})})]})}client.createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsx(React.StrictMode,{children:jsxRuntimeExports.jsx(App,{})}));
